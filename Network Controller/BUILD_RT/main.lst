C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\main.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\main\main.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\sr
                    -c\gs2e;..\src\adpter1;..\src\scan;..\src\gsm) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\main.lst) OBJECT(.\main.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: adapter.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: adapter.c,v $
  18           * Revision 1.8  2006/05/23 05:22:39  robin6633
  19           * 1.Removed old command input.
  20           *
  21           * Revision 1.7  2006/05/23 01:53:55  robin6633
  22           * 1.Removed debug information from UART2.
  23           *
  24           * Revision 1.6  2006/05/22 05:45:23  robin6633
  25           * 1.Add DNS handle.
  26           *
  27           * Revision 1.5  2006/05/18 07:29:32  robin6633
  28           * 1.Enabled time counter function.
  29           *
  30           * Revision 1.4  2006/05/18 02:13:35  robin6633
  31           * 1.Changed DHCP initial function.
  32           *
  33           * Revision 1.3  2006/05/17 08:34:17  robin6633
  34           * Disabled DHCP function.
  35           *
  36           * Revision 1.2  2006/05/16 05:03:09  robin6633
  37           * no message
  38           *
  39           * Revision 1.1  2006/05/12 14:23:38  robin6633
  40           * no message
  41           *
  42           * Revision 1.2  2006/02/24 00:31:47  borbin
  43           * no message
  44           *
  45           * Revision 1.1.1.1  2006/02/23 00:55:10  borbin
  46           * no message
  47           *
  48           *=============================================================================
  49           */
  50          
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 2   

  51          /* INCLUDE FILE DECLARATIONS */
  52          #include "reg80390.h"
  53          #include "main.h"
  54          #include "adapter.h"
  55          #include "mstimer.h"
  56          #include "ax11000.h"
  57          #include "interrupt.h"
  58          #include "stoe.h"
  59          #include "dma.h"
  60          #include "tcpip.h"
  61          #include "hsuart.h"
  62          #include "printd.h"
  63          #include "uart.h"
  64          #include "flash.h"
  65          #include <stdio.h>
  66          #include <Intrins.h>
  67          
  68          #include "../i2c/e2prom.h" 
  69          
  70          #include "delay.h"  //lihengning
  71          
  72          #if STOE_TRANSPARENT
              //  #include "uip_arp.h"
              #endif
  75          #if (INCLUDE_DHCP_CLIENT)
  76            #include "dhcpc.h"
  77          #endif
  78          #if (INCLUDE_DNS_CLIENT)
                #include "dnsctab.h"
              #endif
  81          
  82          #include "gconfig.h"
  83          //#include "gconfig1.h"
  84          
  85          #include "gudpbc.h"
  86          #include "temperature.h"
  87          #include "httpd.h"
  88          #include "filesys.h"
  89          #include "sntpc.h"
  90          
  91          #include <string.h>
  92          #include "projdefs.h"
  93          #include "portable.h"
  94          #include "task.h"
  95          #include "queue.h"
  96          #include "8563.h"
  97          
  98          #include "schedule.h"
  99          #include "flash_schedule.h"
 100          #include "../USB/ch375_COM.h"
 101          
 102          #include "../LCD/LCD.h"
 103          #include "../scan/scan.h"
 104          #include "modbusTCP.h"
 105          #include "../gsm/gsm.h"
 106          
 107          /* NAMING CONSTANT DECLARATIONS */
 108          #ifdef DEBUG
              #define DBGMSG(A) {A}
              #else
 111          #define DBGMSG(A) {}
 112          #endif
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 3   

 113          #define TIME_OUT_COUNTER        (250/SWTIMER_INTERVAL)  //250
 114          #define Hardware_Rev22       22
 115          
 116          #define RS485_EN2       0   // if enable new rs485 port
 117          
 118          #define GSM_TASK_ENABLE         0       // if enbale gsm task
 119          
 120          
 121          
 122          extern  GCONFIG_Init1();
 123          
 124          
 125          
 126          volatile char xdata  temco_version[30] _at_ 0x02;
 127          char temco_version[30] = {"model:100 fw:69.11 hw:26"};          //ascii hw:26 bl:14
 128          
 129          extern U8_T bytesN ;
 130          
 131          typedef struct app_buf {
 132                  U32_T ipaddr;
 133                  U8_T buf[100];
 134                  U16_T uip_len;
 135                  U16_T PayLoadOffset;
 136                  U8_T wait;
 137          }APP_BUF;
 138          
 139          APP_BUF XDATA app_arp_buf;
 140          
 141          /* GLOBAL VARIABLES  */
 142          static U16_T ServerBroadcastListenPort;
 143          extern U8_T FlagIsp;
 144          extern U8_T ChangeFlash;
 145          extern U8_T far CRClo;
 146          extern U8_T far CRChi;
 147          extern U8_T far FlagSend;
 148          extern U8_T far Parame[400]; 
 149          extern U8_T far Para[400]; 
 150          enum ledState LED = None;
 151          extern U8_T TsataId;
 152          
 153          #if 1 //lihengning    
 154          extern U8_T  far UartRevNum;  
 155          //extern U16_T far hsurRxCount;
 156          extern U8_T gudpbc_InterAppId;
 157          U8_T TcpSocket_ME;
 158          U8_T Sever_Order = SERVER_NONE;
 159          U8_T Sever_id;
 160          U8_T ChangeIP = 0;
 161          U8_T TcpIp_Scan = 0;
 162          Time_str Time_Server = {0, 0, 0};
 163          U8_T far mac_change_enable = 0;
 164          #endif
 165          
 166          #if (INCLUDE_DNS_CLIENT)
              U8_T XDATA cmdDnsFlag = 0;
              #endif
 169          
 170          static U8_T UpIndex = 0;
 171          U8_T  SYS_FREQUENCY_PERIOD,SYS_FREQUENCY_PERIOD1 ;
 172          
 173          
 174          /* LOCAL SUBPROGRAM DECLARATIONS */
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 4   

 175          //static void UpdateIpSettings(U32_T);
 176          static void CheckArpTable(void);
 177          extern void InitCRC16(void);
 178          extern void CRC16_Tstat(unsigned char ch);
 179          
 180          /* LOCAL VARIABLES DECLARATIONS */
 181          xTaskHandle xHandle1;
 182          xTaskHandle xHandle2;
 183          xTaskHandle xHandle3;
 184          xTaskHandle xHandle4;
 185          xTaskHandle xHandle5;
 186          xTaskHandle xHandle6;
 187          xTaskHandle xHandle7;
 188          xTaskHandle xHandle8;
 189          xTaskHandle xHandle9;   //LHN ADD
 190          xTaskHandle xHandle10;
 191          xTaskHandle xHandle11; 
 192          xTaskHandle xHandle12; 
 193          xTaskHandle xHandle13; 
 194          
 195          
 196             
 197          
 198          char err485=0;
 199          U8_T data LedSta = 0xff;
 200          //U8_T BeatSta=0;
 201          U8_T  far WebText[6][30]={"time.windows.com","time.stdtime.gov.tw","clock.stdtime.gov.tw ",
 202                                     "watch.stdtime.gov.tw", "pool.ntp.org"};
 203          U32_T far IpServer[6]={0x3b7cc454,0xdc829e48,0xda4b0482,0x7ae2c004,0x3b7cc455};
 204          
 205          
 206          
 207          U8_T far test1[5] = {0x54,0x31};
 208          U8_T far test2[2] = {0x45,0x32};
 209          
 210          U8_T  Hardware_Revision;
 211          
 212          
 213          U8_T Read_Hardware_Revision(void)
 214          {
 215   1              return Para[17];
 216   1      }
 217          
 218          
 219          void OSDelay(U8_T x)
 220          {
 221   1              vTaskDelay(x);
 222   1      }
 223          
 224          /*
 225           * ----------------------------------------------------------------------------
 226           * Function Name: UpdateIpSettings
 227           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
 228           * Params:
 229           * Returns:
 230           * Note:
 231           * ----------------------------------------------------------------------------
 232           */
 233          void UpdateIpSettings(U32_T ip)
 234          {
 235   1               U32_T gateWay,subnet;
 236   1      
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 5   

 237   1               if(ip > 0)
 238   1               {
 239   2                      ip = STOE_GetIPAddr();
 240   2                      subnet = STOE_GetSubnetMask();
 241   2                      gateWay = STOE_GetGateway();
 242   2              
 243   2                      Para[215]=(U8_T)(ip>>24);
 244   2                      Para[217]=(U8_T)(ip>>16);
 245   2                      Para[219]=(U8_T)(ip>>8);
 246   2                      Para[221]=(U8_T)(ip);
 247   2              
 248   2                      Para[223]=(U8_T)(subnet>>24);
 249   2                      Para[225]=(U8_T)(subnet>>16);
 250   2                      Para[227]=(U8_T)(subnet>>8);
 251   2                      Para[229]=(U8_T)(subnet);
 252   2              
 253   2                      Para[231]=(U8_T)(gateWay>>24);
 254   2                      Para[233]=(U8_T)(gateWay>>16);
 255   2                      Para[235]=(U8_T)(gateWay>>8);
 256   2                      Para[237]=(U8_T)(gateWay);
 257   2              }
 258   1              else
 259   1              {
 260   2                      ip = (((U32_T)Para[215]) << 24) | ((U32_T)Para[217] << 16) | ((U32_T)Para[219] << 8) | (Para[221]);
 261   2                      subnet = (((U32_T)Para[223]) << 24) | ((U32_T)Para[225] << 16) | ((U32_T)Para[227] << 8) | (Para[229]);
 262   2                      gateWay = (((U32_T)Para[231]) << 24) | ((U32_T)Para[233] << 16) | ((U32_T)Para[235] << 8) | (Para[237]);
 263   2                      
 264   2                      TCPIP_SetIPAddr(ip); 
 265   2                      TCPIP_SetSubnetMask(subnet);
 266   2                      TCPIP_SetGateway(gateWay);
 267   2                              
 268   2                      STOE_SetIPAddr(ip); 
 269   2                  STOE_SetSubnetMask(subnet);
 270   2                      STOE_SetGateway(gateWay);
 271   2              
 272   2              }
 273   1      
 274   1      
 275   1      
 276   1      } /* End of UpdateIpSettings */
 277          
 278          /*
 279           * ----------------------------------------------------------------------------
 280           * Function Name: CheckArpTable
 281           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
 282           * Params:
 283           * Returns:
 284           * Note:
 285           * ----------------------------------------------------------------------------
 286           */
 287          void CheckArpTable(void)
 288          {
 289   1              if (app_arp_buf.wait) 
 290   1              {
 291   2                      U8_T valid = STOE_CHECK_MAC(&app_arp_buf.ipaddr);
 292   2                      if (valid) 
 293   2                      {
 294   3                              DMA_GrantXdata(uip_buf, app_arp_buf.buf, app_arp_buf.uip_len);
 295   3                              PRINTD(DEBUG_MSG ,("send out the packet from arp buffer\n\r"));
 296   3                              uip_len = app_arp_buf.uip_len;
 297   3                              ETH_Send(app_arp_buf.PayLoadOffset);
 298   3                              uip_len = 0;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 6   

 299   3                              app_arp_buf.wait = 0;
 300   3                      }
 301   2              }
 302   1      } /* End of CheckArpTable */
 303          
 304          
 305          
 306          void TCPIP_Task(void)reentrant
 307          {
 308   1         portTickType xDelayPeriod  = ( portTickType ) 200 / portTICK_RATE_MS;  //250
 309   1              
 310   1      
 311   1      #if (BOOTLDR_ISR)
                      ERROR: BOOTLDR_ISR must set to '0' in non-bootloader driver.
              #endif
 314   1      #if (!AX_ETH_INT_ENABLE)
                       ERROR: Must enable ethernet module in this driver.
              #endif
 317   1               U32_T  timeCount,preTimeCount;
 318   1      #if (INCLUDE_DHCP_CLIENT)
 319   1              U8_T    cmdDhcpFlag = 0;
 320   1              U32_T   dhcpTimeStart = 0;
 321   1              U32_T   dhcpTimeStop = 0;
 322   1      #endif
 323   1      
 324   1      //      Uart0_Tx("step1",5);
 325   1      
 326   1      /* Initialize Network adapter */
 327   1              ETH_Init();
 328   1      
 329   1      //      Uart0_Tx("step2",5);
 330   1      
 331   1              DHCP_Init();
 332   1      
 333   1      #if (INCLUDE_DNS_CLIENT)
                      DNSCTAB_Init(); /* include DNS table */
              #endif
 336   1      
 337   1      
 338   1      #if GCONFIG_EEPROM_CONFIG
                      I2C_Init();
              #endif
 341   1      
 342   1      
 343   1      //      Uart0_Tx("step2",5);
 344   1      
 345   1      
 346   1              GCONFIG_Init();
 347   1      
 348   1      
 349   1      
 350   1      
 351   1      #if (INCLUDE_DHCP_CLIENT)       
 352   1              if ( (Para[213] == 1) && ((GCONFIG_GetNetwork() & GCONFIG_NETWORK_DHCP_ENABLE) == GCONFIG_NETWORK_DHCP_EN
             -ABLE) )
 353   1              {
 354   2                      printd("DHCP request... ");
 355   2                      DHCP_Start();
 356   2      #if (!STOE_TRANSPARENT)
 357   2                      STOE_DisableIpFilter();
 358   2      #endif
 359   2                      cmdDhcpFlag = 1;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 7   

 360   2                      dhcpTimeStart = SWTIMER_Tick();
 361   2              }
 362   1              else
 363   1              {
 364   2                      UpdateIpSettings(0);
 365   2              }
 366   1      #else
                      printd("DHCP module is not included. Use static IP address\n\r");
                      GCONFIG_SetServerDynamicIP(GCONFIG_GetServerStaticIP());                                                
                      GCONFIG_WriteConfigData();
                      GUDPBC_Init(ServerBroadcastListenPort);
              #endif
 372   1      
 373   1      //      Uart0_Tx("step3",5);
 374   1      
 375   1      
 376   1              ServerBroadcastListenPort = 1234; 
 377   1              GUDPBC_Init(ServerBroadcastListenPort);
 378   1      
 379   1              HTTP_Init();
 380   1              MODBUSTCP_Init();         // add modbustcp service instead http modbus old and add webpage feature.
 381   1      
 382   1              FSYS_Init();
 383   1              ETH_Start();
 384   1      
 385   1      //      Uart0_Tx("step4",5);
 386   1      
 387   1      
 388   1              while (1)
 389   1              {
 390   2      
 391   2      #if (!STOE_TRANSPARENT)
 392   2                      ETH_SendArpToGateway(ETH_CONTINUE_ARP_REQUEST_TO_GATEWAY_AFTER_REPLY);
 393   2      #endif
 394   2      
 395   2                      CheckArpTable();
 396   2      
 397   2      #if (INCLUDE_DHCP_CLIENT)
 398   2                      if (cmdDhcpFlag == 1)
 399   2                      {                       
 400   3                              if (DHCP_GetState() > DHCP_IDLE_STATE)
 401   3                              {
 402   4                                      DHCP_Send();
 403   4                              }
 404   3                              else
 405   3                              {
 406   4                                      UpdateIpSettings(STOE_GetIPAddr());
 407   4      #if (!STOE_TRANSPARENT)
 408   4                                      STOE_EnableIpFilter();
 409   4      #endif
 410   4                                      cmdDhcpFlag = 0;
 411   4                              }
 412   3                      }
 413   2      #endif
 414   2      
 415   2      #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)    /* interrupt mode */
                              if (STOE_GetInterruptFlag())
                              {
                                      STOE_ProcessInterrupt();
                              }
              #else   /* polling mode */
 421   2                      STOE_ProcessInterrupt();
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 8   

 422   2      #endif
 423   2      
 424   2      #if (!MAC_GET_INTSTATUS_MODE)
 425   2                      if (MAC_GetInterruptFlag())
 426   2                      {
 427   3                              MAC_ProcessInterrupt();
 428   3                      }
 429   2      #else
                              MAC_LinkSpeedChk();
              #endif
 432   2      
 433   2                      timeCount = (U16_T)SWTIMER_Tick();
 434   2                      if ((timeCount- preTimeCount)>= TIME_OUT_COUNTER)
 435   2                      {
 436   3                              preTimeCount = timeCount;
 437   3                              TCPIP_PeriodicCheck();
 438   3                      }
 439   2                      
 440   2             timeCount = (U16_T)SWTIMER_Tick();
 441   2             if(Para[43]==2)
 442   2                 {
 443   3                        SNTPC_GetState();Para[43]=1;
 444   3             }
 445   2      
 446   2      
 447   2      #if (INCLUDE_DNS_CLIENT)
                              if (cmdDnsFlag == 1)
                              {
                                      U8_T state = DNSCTAB_GetState();/* include DNS table */
              
                                      if (state == DNSC_STATE_FREE)
                                      {
                                              cmdDnsFlag = 0;
                                              printf ("Can not find DNS server.\n\r");
                                      }
                                      else if (state == DNSC_STATE_RESPONSED)
                                      {
                                              U32_T   ip;
              
                                              cmdDnsFlag = 0;
              
                                              if ((ip = DNSCTAB_GetIP()) == 0)
                                              {
                                                      printf ("Can not find remote station via DNS server.\n\r");
                                              }
                                              else
                                              {
                                                      printf ("Get IP address from DNS server : %lx\n\r", ip);
                                              }
                                      }
                              }
              #endif
 474   2      
 475   2      //        Uart0_Tx("step5",5);
 476   2      
 477   2              }
 478   1      } /* End of main() */
 479          
 480          
 481          
 482          U8_T BeatSta = 0;
 483          volatile U8_T far LEDS _at_ 0x200000;   //LED Address > 80000, or will compete with SRAM which the range is 
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 9   

             -0-0x80000!!
 484          
 485          void Beat_ON(void)//Set Pin low
 486          {
 487   1      
 488   1              if(Hardware_Revision >= Hardware_Rev22)
 489   1               {      DisPlay1 = 0;
 490   2                      DisPlay2 = 1; }
 491   1              else {
 492   2              DisPlay1 = 1;
 493   2              DisPlay2 = 0;  }
 494   1      
 495   1              LE = 0; 
 496   1              LedSta = 0xfd;
 497   1      //      for(i = 0; i < 100; i++);                          
 498   1              LEDS = LedSta;                                                   
 499   1              LE = 1;  
 500   1      }
 501          
 502          void Beat_OFF(void)  //Set Pin high
 503          {
 504   1              if(Hardware_Revision >= Hardware_Rev22)
 505   1               {      DisPlay1 = 0;
 506   2                      DisPlay2 = 1; }
 507   1              else {
 508   2              DisPlay1 = 1;
 509   2              DisPlay2 = 0;  }
 510   1              
 511   1      
 512   1              LE = 0;
 513   1              LedSta = 0xff;                             
 514   1              LEDS = LedSta;                               
 515   1              LE = 1; 
 516   1      }
 517          
 518          void Led_EthSend(void)//Pin set low
 519          {
 520   1              if(Hardware_Revision >= Hardware_Rev22)
 521   1               {      DisPlay1 = 0;
 522   2                      DisPlay2 = 1; }
 523   1              else {
 524   2              DisPlay1 = 1;
 525   2              DisPlay2 = 0;  }
 526   1              
 527   1              
 528   1              LE = 0;
 529   1              if(BeatSta == 0)
 530   1                      LedSta = 0xf7;                                            
 531   1              else
 532   1                      LedSta = 0xf6;                                    
 533   1              LEDS = LedSta;                               
 534   1              LE = 1;                               
 535   1      }
 536          
 537          
 538          
 539          void Led_EthRxD(void) //Pin set low 
 540          {
 541   1              if(Hardware_Revision >= Hardware_Rev22)
 542   1               {      DisPlay1 = 0;
 543   2                      DisPlay2 = 1; }
 544   1              else {
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 10  

 545   2              DisPlay1 = 1;
 546   2              DisPlay2 = 0;  }
 547   1      
 548   1      
 549   1      
 550   1              LE = 0;
 551   1              if(BeatSta == 0)
 552   1                      LedSta = 0xef;                                            
 553   1              else  
 554   1                      LedSta = 0xee;                            
 555   1              LEDS = LedSta; 
 556   1              LE = 1;
 557   1      }
 558          
 559          void Led_485RxD(void)//Pin set low 
 560          {    
 561   1              if(Hardware_Revision >= Hardware_Rev22)
 562   1               {      DisPlay1 = 1;
 563   2                      DisPlay2 = 0; }
 564   1              else {
 565   2              DisPlay1 = 0;
 566   2              DisPlay2 = 1;  }
 567   1              
 568   1              
 569   1              LE = 0;
 570   1              LedSta = 0x7f;                   
 571   1              LEDS = LedSta; 
 572   1              LE = 1;
 573   1      }
 574          
 575          void Led_485Send(void) //Pin set low 
 576          {      
 577   1              if(Hardware_Revision >= Hardware_Rev22)
 578   1               {      DisPlay1 = 1;
 579   2                      DisPlay2 = 0; }
 580   1              else {
 581   2              DisPlay1 = 0;
 582   2              DisPlay2 = 1;  }
 583   1              
 584   1              
 585   1              LE = 0;
 586   1              LedSta = 0xbf;                                     
 587   1              LEDS = LedSta;
 588   1              LE = 1;
 589   1      }
 590          
 591          void Led_485ERR(void) //Pin set low 
 592          {   
 593   1              if(Hardware_Revision >= Hardware_Rev22)
 594   1               {      DisPlay1 = 0;
 595   2                      DisPlay2 = 1; }
 596   1              else {
 597   2              DisPlay1 = 1;
 598   2              DisPlay2 = 0;  }
 599   1      
 600   1      
 601   1      
 602   1              LE = 0;
 603   1              if(BeatSta == 0)
 604   1                      LedSta = 0xfb;  
 605   1              else
 606   1                      LedSta = 0xf9;                             
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 11  

 607   1              LEDS = LedSta; 
 608   1              LE = 1;
 609   1      }
 610          void Led_ReSet(void)
 611          {
 612   1              if(Hardware_Revision >= Hardware_Rev22)
 613   1               {      DisPlay1 = 0;
 614   2                      DisPlay2 = 1; }
 615   1              else {
 616   2              DisPlay1 = 1;
 617   2              DisPlay2 = 0;  }
 618   1              
 619   1              
 620   1      
 621   1              LE = 0;
 622   1              if(BeatSta == 0)
 623   1                      LedSta = 0xff;  
 624   1              else
 625   1                      LedSta = 0xfd;                             
 626   1              LEDS = LedSta; 
 627   1              LE = 1;
 628   1      }
 629          
 630          /************************************************/
 631          /*  heng addd led feature  */
 632          void Led_zigbee_Tx(void)
 633          {
 634   1              if(Hardware_Revision >= Hardware_Rev22)
 635   1               {      DisPlay1 = 1;
 636   2                      DisPlay2 = 0; }
 637   1              else {
 638   2              DisPlay1 = 0;
 639   2              DisPlay2 = 1;  }
 640   1              
 641   1              
 642   1              LE = 0;
 643   1              LedSta = 0xfe;                                     
 644   1              LEDS = LedSta;
 645   1              LE = 1;
 646   1      }
 647          void Led_zigbee_Rx(void)
 648          {
 649   1              if(Hardware_Revision >= Hardware_Rev22)
 650   1               {      DisPlay1 = 1;
 651   2                      DisPlay2 = 0; }
 652   1              else {
 653   2              DisPlay1 = 0;
 654   2              DisPlay2 = 1;  }
 655   1              
 656   1              LE = 0;
 657   1              LedSta = 0xfd;                                     
 658   1              LEDS = LedSta;
 659   1              LE = 1;
 660   1      }
 661          
 662          void Led_USB_Tx(void)
 663          {
 664   1              if(Hardware_Revision >= Hardware_Rev22)
 665   1               {      DisPlay1 = 1;
 666   2                      DisPlay2 = 0; }
 667   1              else {
 668   2              DisPlay1 = 0;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 12  

 669   2              DisPlay2 = 1;  }
 670   1              
 671   1              
 672   1              LE = 0;
 673   1              LedSta = 0xfb;                                     
 674   1              LEDS = LedSta;
 675   1              LE = 1;
 676   1      }
 677          void Led_USB_Rx(void)
 678          {
 679   1              if(Hardware_Revision >= Hardware_Rev22)
 680   1               {      DisPlay1 = 1;
 681   2                      DisPlay2 = 0; }
 682   1              else {
 683   2              DisPlay1 = 0;
 684   2              DisPlay2 = 1;  }
 685   1              
 686   1              LE = 0;
 687   1              LedSta = 0xf7;                                     
 688   1              LEDS = LedSta;
 689   1              LE = 1;
 690   1      }
 691          
 692          void Led_GSM_Tx(void)
 693          {
 694   1              if(Hardware_Revision >= Hardware_Rev22)
 695   1               {      DisPlay1 = 1;
 696   2                      DisPlay2 = 0; }
 697   1              else {
 698   2              DisPlay1 = 0;
 699   2              DisPlay2 = 1;  }
 700   1              
 701   1              
 702   1              LE = 0;
 703   1              LedSta = 0xef;                                     
 704   1              LEDS = LedSta;
 705   1              LE = 1;
 706   1      }
 707          void Led_GSM_Rx(void)
 708          {
 709   1              if(Hardware_Revision >= Hardware_Rev22)
 710   1               {      DisPlay1 = 1;
 711   2                      DisPlay2 = 0; }
 712   1              else {
 713   2              DisPlay1 = 0;
 714   2              DisPlay2 = 1;  }
 715   1              
 716   1              LE = 0;
 717   1              LedSta = 0xdf;                                     
 718   1              LEDS = LedSta;
 719   1              LE = 1;
 720   1      }
 721          
 722          
 723          
 724          
 725          
 726          void Led_RS232_Tx(void)
 727          {
 728   1              if(Hardware_Revision >= Hardware_Rev22)
 729   1               {      DisPlay1 = 0;
 730   2                      DisPlay2 = 1; }
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 13  

 731   1              else {
 732   2              DisPlay1 = 1;
 733   2              DisPlay2 = 0;  }
 734   1              
 735   1              
 736   1              LE = 0;
 737   1              if(BeatSta == 0)
 738   1                      LedSta = 0xdf;                                            
 739   1              else
 740   1                      LedSta = 0xde;                                    
 741   1              LEDS = LedSta;                               
 742   1              LE = 1;                               
 743   1      }
 744          void Led_RS232_Rx(void)
 745          {
 746   1              if(Hardware_Revision >= Hardware_Rev22)
 747   1               {      DisPlay1 = 0;
 748   2                      DisPlay2 = 1; }
 749   1              else {
 750   2              DisPlay1 = 1;
 751   2              DisPlay2 = 0;  }
 752   1      
 753   1      
 754   1      
 755   1              LE = 0;
 756   1              if(BeatSta == 0)
 757   1                      LedSta = 0xbf;                                            
 758   1              else  
 759   1                      LedSta = 0xbe;                            
 760   1              LEDS = LedSta; 
 761   1              LE = 1;
 762   1      }
 763          
 764          
 765          
 766          
 767          
 768          
 769          /*=================================================*/
 770          
 771          void Led_ispSet(void)
 772          {
 773   1              if(Hardware_Revision >= Hardware_Rev22)                                                                                 
 774   1               {      DisPlay1 = 0;
 775   2                      DisPlay2 = 1; }
 776   1              else {
 777   2              DisPlay1 = 1;
 778   2              DisPlay2 = 0;  }
 779   1              
 780   1              
 781   1              
 782   1              LE = 0;                            
 783   1              LEDS = 0xfe;                                                     
 784   1              LE = 1;  
 785   1      }
 786          
 787          /*****************************************/
 788          /*****************************************/
 789          /*****Uart0 routine***********************/
 790          
 791          void Uart0_Tx(U8_T *buf,U8_T len)
 792          {     
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 14  

 793   1              U8_T i;
 794   1      
 795   1              for(i = 0; i < len; i++)
 796   1              { 
 797   2                      FlagSend = 0;
 798   2                      SBUF0 = buf[i];
 799   2                      while(FlagSend == 0);
 800   2              }
 801   1      
 802   1      }
 803          
 804          void Uart0_Receive(void)
 805          {
 806   1              if(uart0_RxCount > 0)
 807   1              {
 808   2      
 809   2                      LED = RS232_OK;
 810   2                                      
 811   2                      
 812   2                      if((uart0_RxBuf[0] == Para[13]) || (uart0_RxBuf[0] == 0xff))//Address of NetControl 
 813   2                      { 
 814   3                              if(uart0_RxBuf[1] == 0x19) //scan Tsnet
 815   3                              {
 816   4                                      Sever_Order = SERVER_RS232;
 817   4                                      Sever_id = uart0_RxBuf[0]; 
 818   4                                      Tx_To_Tstat(uart0_RxBuf, uart0_RxCount);                                                                                                                        
 819   4                              }                                       
 820   3                              else if(uart0_RxBuf[1] == 0x1a) //scan NC
 821   3                              {
 822   4                                      U8_T i; 
 823   4                                      uart0_TxCount = 0;
 824   4                                      uart0_TxBuf[uart0_TxCount++] = uart0_RxBuf[0];
 825   4                                      uart0_TxBuf[uart0_TxCount++] = 0x19;
 826   4                                      uart0_TxBuf[uart0_TxCount++] = Para[13];                                                 
 827   4                                      uart0_TxBuf[uart0_TxCount++] = Para[1];
 828   4                                      uart0_TxBuf[uart0_TxCount++] = Para[3];
 829   4                                      uart0_TxBuf[uart0_TxCount++] = Para[5];
 830   4                                      uart0_TxBuf[uart0_TxCount++] = Para[7];
 831   4                                      InitCRC16();
 832   4                                      for(i = 0; i < uart0_TxCount; i++)
 833   4                                              CRC16_Tstat(uart0_TxBuf[i]);
 834   4                                      uart0_TxBuf[uart0_TxCount++] = CRChi;
 835   4                                      uart0_TxBuf[uart0_TxCount++] = CRClo;                                    
 836   4                                      Uart0_Tx(uart0_TxBuf, uart0_TxCount);   
 837   4                                      uart0_TxCount = 0;
 838   4                              }
 839   3                              else if(uart0_RxBuf[1] == read) 
 840   3                              {       
 841   4                                      U16_T i;
 842   4                                      U8_T far temp_number;
 843   4                                      U8_T far temp_address;
 844   4                                      U8_T far send_buffer;
 845   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
 846   4      
 847   4                                      uart0_TxBuf[0] = uart0_RxBuf[0];
 848   4                                      uart0_TxBuf[1] = uart0_RxBuf[1];
 849   4                                      uart0_TxBuf[2] = 2 * uart0_RxBuf[5];
 850   4                                      uart0_TxCount = 3 + uart0_TxBuf[2];
 851   4                                      for(i = 0; i < uart0_RxBuf[5]; i++)
 852   4                                      {
 853   5                                              if((StartAdd + i) < MODBUS_TIMER_ADDRESS) //200
 854   5                                              {  
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 15  

 855   6                                                      uart0_TxBuf[3 + 2 * i] = Para[2 * (StartAdd + i)];  
 856   6                                                      uart0_TxBuf[4 + 2 * i] = Para[2 * (StartAdd + i) + 1];
 857   6                                              }
 858   5                                              else if(((StartAdd + i) >= MODBUS_TIMER_ADDRESS) && ((StartAdd + i) < (MODBUS_TIMER_ADDRESS + 8))) 
 859   5                                              {
 860   6                                                      //  YEAR  MONTH  WEEK DATE  HOUR  MINUTE  SECOND 
 861   6                                                      uart0_TxBuf[3 + 2 * i] = 0;
 862   6                                                      switch(StartAdd + i - MODBUS_TIMER_ADDRESS)
 863   6                                                      {
 864   7                                                              case 7:
 865   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.sec;
 866   7                                                                      break;  
 867   7                                                              case 6:
 868   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.min;
 869   7                                                                      break;
 870   7                                                              case 5:
 871   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.hour;
 872   7                                                                      break;
 873   7                                                              case 4:
 874   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.day;
 875   7                                                                      break;
 876   7                                                              case 3:
 877   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.dayofweek;
 878   7                                                                      break;
 879   7                                                              case 2:
 880   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.month;
 881   7                                                                      break;
 882   7                                                              case 1:
 883   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.year;
 884   7                                                                      break;
 885   7                                                              case 0:
 886   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.centary;
 887   7                                                                      break;
 888   7                                                      }               
 889   6                                              }
 890   5                                              else if(((StartAdd + i) >= MODBUS_WR_DESCRIP_FIRST) && ((StartAdd + i) < MODBUS_WR_DESCRIP_LAST))
 891   5                                              {
 892   6                                                      temp_number = (StartAdd + i - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
 893   6                                                      temp_address = (StartAdd + i - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE;
 894   6                                                      send_buffer = WR_Roution[temp_number].UN.all[temp_address];
 895   6                                                  if((temp_address == (WR_DESCRIPTION_SIZE - 1)) && (send_buffer != 0xff))
 896   6                                                      {
 897   7                                                              if((send_buffer & 0x80) == 0)
 898   7                                                              {
 899   8                                                                      if(GetBit(temp_number, wr_state_index))
 900   8                                                                              send_buffer |= 0x40;
 901   8                                                                      else
 902   8                                                                              send_buffer &= 0xbf;
 903   8                                                              }
 904   7      
 905   7                                                              if(GetBit(temp_number, holiday1_state_index))
 906   7                                                                      send_buffer |= 0x20;
 907   7                                                              else
 908   7                                                                      send_buffer &= 0xdf;
 909   7      
 910   7                                                              if(GetBit(temp_number, holiday2_state_index))
 911   7                                                                      send_buffer |= 0x10;
 912   7                                                              else
 913   7                                                                      send_buffer &= 0xef;
 914   7                                                      }
 915   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 916   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 16  

 917   6                                              }
 918   5                                              else if(((StartAdd + i) >= MODBUS_AR_DESCRIP_FIRST) && ((StartAdd + i) < MODBUS_AR_DESCRIP_LAST))
 919   5                                              {
 920   6                                                      temp_number = (StartAdd + i - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;    // line
 921   6                                                      temp_address = (StartAdd + i - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE;
 922   6                                                      send_buffer = AR_Roution[temp_number].UN.all[temp_address];
 923   6      
 924   6                                                      if(temp_address == (AR_DESCRIPTION_SIZE - 1))
 925   6                                                      {
 926   7                                                              if((send_buffer & 0x80) == 0)
 927   7                                                              {
 928   8                                                                      if(GetBit(temp_number, ar_state_index))
 929   8                                                                              send_buffer |= 0x40;
 930   8                                                                      else
 931   8                                                                              send_buffer &= 0xbf;
 932   8                                                              }
 933   7                                                      }
 934   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 935   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
 936   6                                              }
 937   5                                              else if(((StartAdd + i) >= MODBUS_ID_FIRST) && ((StartAdd + i) < MODBUS_ID_LAST))
 938   5                                              {
 939   6                                                      temp_number = (StartAdd + i - MODBUS_ID_FIRST) / ID_SIZE;
 940   6                                                      temp_address = (StartAdd + i - MODBUS_ID_FIRST) % ID_SIZE;
 941   6                                                      send_buffer = ID_Config[temp_number].all[temp_address];
 942   6                      
 943   6                                                      if((temp_address == (ID_SIZE - 1)) && (send_buffer != 0xff))
 944   6                                                      {
 945   7                                                              if((send_buffer & 0x80) == 0)
 946   7                                                              {
 947   8                                                                      if(GetBit(temp_number, output_state_index))
 948   8                                                                              send_buffer |= 0x40;
 949   8                                                                      else
 950   8                                                                              send_buffer &= 0xbf;
 951   8                                                              }
 952   7      
 953   7                                                              if(GetBit(temp_number, schedual1_state_index))
 954   7                                                                      send_buffer |= 0x20;
 955   7                                                              else
 956   7                                                                      send_buffer &= 0xdf;
 957   7      
 958   7                                                              if(GetBit(temp_number, schedual2_state_index))
 959   7                                                                      send_buffer |= 0x10;
 960   7                                                              else
 961   7                                                                      send_buffer &= 0xef;
 962   7                                                      }
 963   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 964   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
 965   6                                              }
 966   5                                              else if(((StartAdd + i) >= MODBUS_AR_TIME_FIRST) && ((StartAdd + i) < MODBUS_WR_ONTIME_FIRST))
 967   5                                              {
 968   6                                                      temp_number = (StartAdd + i - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
 969   6                                                      temp_address = (StartAdd + i - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE;
 970   6                                                      send_buffer = AR_Roution[temp_number].Time[temp_address];
 971   6                      
 972   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 973   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;
 974   6                                              }
 975   5                                              else if(((StartAdd + i) >= MODBUS_WR_ONTIME_FIRST) && ((StartAdd + i) < MODBUS_WR_OFFTIME_FIRST))
 976   5                                              {
 977   6                                                      temp_number = (StartAdd + i - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;           
 978   6                                                      temp_address = (StartAdd + i - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 17  

 979   6                                                      send_buffer = WR_Roution[temp_number].OnTime[temp_address];
 980   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 981   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;
 982   6                                              }
 983   5                                              else if(((StartAdd + i) >= MODBUS_WR_OFFTIME_FIRST) && ((StartAdd + i) < MODBUS_WR_OFFTIME_LAST))
 984   5                                              {
 985   6                                                      temp_number = (StartAdd + i - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
 986   6                                                      temp_address = (StartAdd + i - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE;
 987   6                                                      send_buffer = WR_Roution[temp_number].OffTime[temp_address];
 988   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 989   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;                   
 990   6                                              }
 991   5                                              else
 992   5                                              {
 993   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 994   6                                                      uart0_TxBuf[4 + 2 * i] = 1;
 995   6                                              }                                               
 996   5                                      } 
 997   4      
 998   4                                      EA = 0;
 999   4                                      InitCRC16();
1000   4                                      for(i = 0; i < uart0_TxCount; i++)
1001   4                                              CRC16_Tstat(uart0_TxBuf[i]);
1002   4                                      uart0_TxBuf[uart0_TxCount++] = CRChi;                        
1003   4                                      uart0_TxBuf[uart0_TxCount++] = CRClo;
1004   4                                      EA = 1;
1005   4      
1006   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1009   4      
1010   4                                      Uart0_Tx(uart0_TxBuf, uart0_TxCount);
1011   4      
1012   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1015   4                                                                                                                      
1016   4                              }
1017   3                              else if(uart0_RxBuf[1] == swrite) 
1018   3                              {
1019   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
1020   4                                      if(StartAdd < 200)
1021   4                                      {
1022   5                                              if(StartAdd == 15) // clear flash to zero
1023   5                                              {
1024   6                                                      if(((uart0_RxBuf[4] << 8) | uart0_RxBuf[5]) == 0x55)
1025   6                                                      {
1026   7                                                              memset(WR_Roution, 0, MAX_WR * WR_STRUCT_LENGTH);
1027   7                                                              memset(AR_Roution, 0, MAX_AR * AR_STRUCT_LENGTH);
1028   7                                                              memset(ID_Config, 0, MAX_ID * ID_SIZE);
1029   7                                                              Para[30] = 0;
1030   7                                                              Para[31] = 0;
1031   7                                                              ChangeFlash = 2;
1032   7                                                      }
1033   6                                              }
1034   5                                              else if(StartAdd == 106)
1035   5                                              {
1036   6                                                      if((((Para[212] << 8) | Para[213]) == 0) && (((uart0_RxBuf[4] << 8) | uart0_RxBuf[5]) != 0))
1037   6                                                      {
1038   7                                                              Para[212] = uart0_RxBuf[4];
1039   7                                                              Para[213] = uart0_RxBuf[5];
1040   7                                                              ChangeIP = 1;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 18  

1041   7                                                              ChangeFlash = 2;
1042   7                                                      }
1043   6                                              }
1044   5                                              else if((StartAdd >= 107) && (StartAdd <= 120)) //IP change ,reset cpu
1045   5                                              {
1046   6                                                      if(((Para[212] << 8) | Para[213]) == 0)
1047   6                                                      {
1048   7                                                              Para[2*uart0_RxBuf[3]] = uart0_RxBuf[4];                //write to bufffer array high bit
1049   7                                                              Para[2*uart0_RxBuf[3] + 1] = uart0_RxBuf[5];    //write to bufffer array low bit
1050   7                                                              ChangeFlash = 2;
1051   7                                                              ChangeIP = 1;
1052   7                                                      }
1053   6                                              }
1054   5                                              else
1055   5                                              {
1056   6                                                      Para[2*uart0_RxBuf[3]] = uart0_RxBuf[4];                //write to bufffer array high bit
1057   6                                                      Para[2*uart0_RxBuf[3] + 1] = uart0_RxBuf[5];    //write to bufffer array low bit
1058   6                                                      ChangeFlash = 2;
1059   6                                              }
1060   5                                      }
1061   4                                      else if((StartAdd >= SCHEDUAL_MODBUS_ADDRESS) && (StartAdd < (SCHEDUAL_MODBUS_ADDRESS + 8)))
1062   4                                      {
1063   5                                              switch(StartAdd - SCHEDUAL_MODBUS_ADDRESS)
1064   5                                              {
1065   6                                                      case 0: //century
1066   6                                                              if(uart0_RxBuf[5] == 19)
1067   6                                                              {
1068   7                                                                      Set_Clock(PCF_MON, Time.UN.Current.month | 0x80);
1069   7                                                              }
1070   6                                                              else if(uart0_RxBuf[5] == 20)
1071   6                                                              {
1072   7                                                                      Set_Clock(PCF_MON, Time.UN.Current.month & 0x7f);
1073   7                                                              }
1074   6                                                              break;
1075   6                                                      case 1: //year
1076   6                                                              Set_Clock(PCF_YEAR, uart0_RxBuf[5]);
1077   6                                                              break;
1078   6                                                      case 2: //month
1079   6                                                              if(Time.UN.Current.centary == 19)
1080   6                                                              {
1081   7                                                                      Set_Clock(PCF_MON, uart0_RxBuf[5] | 0x80);
1082   7                                                              }
1083   6                                                              else if(Time.UN.Current.centary == 20)
1084   6                                                              {
1085   7                                                                      Set_Clock(PCF_MON, uart0_RxBuf[5] & 0x7f);
1086   7                                                              }
1087   6                                                              break;
1088   6                                                      case 3:
1089   6                                                              Set_Clock(PCF_WEEK, uart0_RxBuf[5]);
1090   6                                                              break;
1091   6                                                      case 4: //date
1092   6                                                              Set_Clock(PCF_DAY, uart0_RxBuf[5]);
1093   6                                                              break;
1094   6                                                      case 5: //hour
1095   6                                                              Set_Clock(PCF_HOUR, uart0_RxBuf[5]);
1096   6                                                              break;
1097   6                                                      case 6: //minute
1098   6                                                              Set_Clock(PCF_MIN, uart0_RxBuf[5]);
1099   6                                                              break;
1100   6                                                      case 7: //second
1101   6                                                              Set_Clock(PCF_SEC, uart0_RxBuf[5]);
1102   6                                                              break;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 19  

1103   6                                              }
1104   5                                      }
1105   4                                      else
1106   4                                      {
1107   5                                              // spare
1108   5                                      }
1109   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1112   4                                      Uart0_Tx(uart0_RxBuf, uart0_RxCount);
1113   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1116   4                              }
1117   3                              else if(uart0_RxBuf[1] == mwrite) //multi_write
1118   3                              {
1119   4                                      U8_T i;
1120   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
1121   4                                      ChangeFlash = 1;
1122   4                                      if(StartAdd < SCHEDUAL_MODBUS_ADDRESS)
1123   4                                      {
1124   5                                              if((StartAdd == 100) && (uart0_RxBuf[6] == 12))
1125   5                                              {
1126   6                                                      Para[201] = uart0_RxBuf[8];
1127   6                                                      Para[203] = uart0_RxBuf[10];
1128   6                                                      Para[205] = uart0_RxBuf[12];
1129   6                                                      Para[207] = uart0_RxBuf[14];
1130   6                                                      Para[209] = uart0_RxBuf[16];
1131   6                                                      Para[211] = uart0_RxBuf[18];
1132   6                      
1133   6                                                      mac_change_enable = 1;
1134   6                                                      ChangeIP = 1;
1135   6                                              }
1136   5                                          else
1137   5                                              {
1138   6                                                      for(i = 0; i < uart0_RxBuf[6]; i++)
1139   6                                                      {
1140   7                                                              if(((StartAdd + i / 2) < 100) || ((StartAdd + i / 2) > 105))  
1141   7                                                                      Para[2 * StartAdd + i] = uart0_RxBuf[i];
1142   7                                                      } 
1143   6                                              }
1144   5                                      }
1145   4                                      else if(StartAdd == SCHEDUAL_MODBUS_ADDRESS) //200th register ,write time 
1146   4                                      {
1147   5      //                                      if((StartAdd - SCHEDUAL_MODBUS_ADDRESS) % 8 == 0)
1148   5      //                                              memcpy(Time.UN.Setime,&uart0_RxBuf[7], 8);
1149   5                                              if(uart0_RxBuf[5] == 8)
1150   5                                              {
1151   6                                                      if(uart0_RxBuf[5] == uart0_RxBuf[6])
1152   6                                                      {
1153   7                                                              Time.UN.Setime[7] = uart0_RxBuf[14];
1154   7                                                              Time.UN.Setime[6] = uart0_RxBuf[13];
1155   7                                                              Time.UN.Setime[5] = uart0_RxBuf[12];
1156   7                                                              Time.UN.Setime[4] = uart0_RxBuf[11];
1157   7                                                              Time.UN.Setime[3] = uart0_RxBuf[10];
1158   7                                                              if(uart0_RxBuf[7] == 19)
1159   7                                                                      uart0_RxBuf[9] |= 0x80;
1160   7                                                              else
1161   7                                                                      uart0_RxBuf[9] &= 0x7f;
1162   7                                                              Time.UN.Setime[2] = uart0_RxBuf[9];
1163   7                                                              Time.UN.Setime[1] = uart0_RxBuf[8];
1164   7                                                              Time.UN.Setime[0] = uart0_RxBuf[7];
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 20  

1165   7                                                      }
1166   6                                                      else
1167   6                                                      {
1168   7                                                              Time.UN.Setime[7] = uart0_RxBuf[22];
1169   7                                                              Time.UN.Setime[6] = uart0_RxBuf[20];
1170   7                                                              Time.UN.Setime[5] = uart0_RxBuf[18];
1171   7                                                              Time.UN.Setime[4] = uart0_RxBuf[16];
1172   7                                                              Time.UN.Setime[3] = uart0_RxBuf[14];
1173   7                                                              if(uart0_RxBuf[8] == 19)
1174   7                                                                      uart0_RxBuf[12] |= 0x80;
1175   7                                                              else
1176   7                                                                      uart0_RxBuf[12] &= 0x7f;
1177   7                                                              Time.UN.Setime[2] = uart0_RxBuf[12];
1178   7                                                              Time.UN.Setime[1] = uart0_RxBuf[10];
1179   7                                                              Time.UN.Setime[0] = uart0_RxBuf[8];
1180   7                                                      }
1181   6                                                      Initial_Clock();
1182   6                                              }
1183   5                                      }
1184   4                                      else if ((StartAdd >= MODBUS_WR_DESCRIP_FIRST) && (StartAdd < MODBUS_WR_DESCRIP_LAST)) //weekly
1185   4                              {                                                               
1186   5                                              if((StartAdd - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE == 0)
1187   5                                              {
1188   6                                                      i = (StartAdd - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
1189   6                                                      memcpy((U8_T *)&WR_Roution[i].UN.all[0], uart0_RxBuf + 7, WR_DESCRIPTION_SIZE);
1190   6                                              }
1191   5                              }
1192   4                                      else if((StartAdd >= MODBUS_AR_DESCRIP_FIRST) && (StartAdd < MODBUS_AR_DESCRIP_LAST))
1193   4                                      {
1194   5                                              if((StartAdd - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE == 0)
1195   5                                              {
1196   6                                                      i = (StartAdd - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;          
1197   6                                                      memcpy((U8_T *)&AR_Roution[i].UN.all[0], uart0_RxBuf + 7, AR_DESCRIPTION_SIZE);
1198   6                                              }
1199   5                                      }
1200   4                                      else if((StartAdd >= MODBUS_ID_FIRST) && (StartAdd < MODBUS_ID_LAST))
1201   4                                      {
1202   5                                              if((StartAdd - MODBUS_ID_FIRST) % ID_SIZE == 0)
1203   5                                              {
1204   6                                                      i = (StartAdd - MODBUS_ID_FIRST) / ID_SIZE;
1205   6                                                      memcpy((U8_T *)&ID_Config[i].all[0], uart0_RxBuf + 7, ID_SIZE);
1206   6                                              }
1207   5                                      }
1208   4                                      else if((StartAdd >= MODBUS_AR_TIME_FIRST) && (StartAdd < MODBUS_AR_TIME_LAST))
1209   4                                      {
1210   5                                              if((StartAdd - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE == 0)
1211   5                                              {
1212   6                                                      i = (StartAdd - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;                   
1213   6                                                      memcpy((U8_T *)&AR_Roution[i].Time[0], uart0_RxBuf + 7, AR_TIME_SIZE);
1214   6                                              }
1215   5                                      }
1216   4                                      else if((StartAdd >= MODBUS_WR_ONTIME_FIRST) && (StartAdd < MODBUS_WR_ONTIME_LAST))
1217   4                                      {
1218   5                                              if((StartAdd - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE == 0)
1219   5                                              {
1220   6                                                      i = (StartAdd - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;
1221   6                                                      memcpy((U8_T *)&WR_Roution[i].OnTime[0], uart0_RxBuf + 7, WR_TIME_SIZE);
1222   6                                              }
1223   5                                      }
1224   4                                      else if((StartAdd >= MODBUS_WR_OFFTIME_FIRST) && (StartAdd < MODBUS_WR_OFFTIME_LAST))
1225   4                                      {
1226   5                                              if((StartAdd - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE == 0)
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 21  

1227   5                                              {
1228   6                                                      i = (StartAdd - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;                                        
1229   6                                                      memcpy((U8_T *)&WR_Roution[i].OffTime[0], uart0_RxBuf + 7 , WR_TIME_SIZE);
1230   6                                              }
1231   5                                      }
1232   4      
1233   4                                      InitCRC16();
1234   4                                      for(i = 0; i < 6; i++)
1235   4                                      {
1236   5                                              uart0_TxBuf[i] = uart0_RxBuf[i];
1237   5                                              CRC16_Tstat(uart0_TxBuf[i]);
1238   5                                      }
1239   4                                      uart0_TxBuf[6] = CRChi;                        
1240   4                                      uart0_TxBuf[7] = CRClo;
1241   4      
1242   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1245   4                                      Uart0_Tx(uart0_TxBuf, 8);
1246   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1249   4                              }
1250   3                      }
1251   2                      else
1252   2                      {
1253   3                              Sever_Order = SERVER_RS232;
1254   3                              Sever_id = uart0_RxBuf[0];                                
1255   3                              Tx_To_Tstat(uart0_RxBuf, uart0_RxCount);                                                                                                                         
1256   3                      }
1257   2      
1258   2                      uart0_RxCount = 0;    
1259   2              }
1260   1      }
1261          
1262          
1263          /*****************************************/
1264          /*****************************************/
1265          /*****Uart1 routine***********************/
1266          void Uart1_Tx(U8_T *buf,U8_T len)
1267          {     
1268   1              U8_T i;
1269   1              for(i = 0; i < len; i++)
1270   1              { 
1271   2                      FlagSend = 0;
1272   2                      SBUF1 = buf[i];
1273   2                      while(FlagSend == 0);
1274   2              }
1275   1      }
1276          
1277          U8_T forward_buffer[300];
1278          U8_T forward_buffer1[300];
1279          extern U16_T sessonlen;
1280          extern void Set_transaction_ID(U8_T *str, U16_T reg);
1281          
1282          void Uart1_Receive(void)
1283          {
1284   1              U8_T   i;
1285   1              U16_T  uart1_count = 0;                 
1286   1              U16_T  length = 0;
1287   1              U16_T  uart1_cnt;
1288   1      
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 22  

1289   1      
1290   1      //      Uart0_Tx(uart1_RxBuf,uart1_RxCount);
1291   1      
1292   1              EA = 0;
1293   1              if(uart1_RxCount)
1294   1              {
1295   2                      if(Sever_Order == 1)
1296   2                      {
1297   3                              Set_transaction_ID(forward_buffer1, sessonlen);
1298   3                              uart1_count = 6;
1299   3      
1300   3                              uart1_cnt = uart1_RxCount;
1301   3                      }
1302   2      
1303   2                      memcpy(forward_buffer1 + uart1_count, uart1_RxBuf, uart1_RxCount);
1304   2      
1305   2      //              Uart0_Tx(uart1_RxBuf,uart1_RxCount);               // for test !
1306   2                      uart1_count += uart1_RxCount;
1307   2                      uart1_RxCount = 0;
1308   2                      EA = 1;
1309   2              
1310   2              }
1311   1              else
1312   1              {
1313   2                      EA = 1;
1314   2                      return;
1315   2              }
1316   1      
1317   1              i = 0;
1318   1              if(uart1_count)
1319   1              {
1320   2                      LED = Zigbee_OK;
1321   2      
1322   2                      if(Sever_Order == SERVER_TCPIP)  //Sever Order is from TCP/IP
1323   2                      {                   
1324   3                       if((forward_buffer1[6] == 0xff)&&(forward_buffer1[6 + 1] == 0x19))
1325   3                       {
1326   4                              //      length = 15;
1327   4                              for(i = 0;((forward_buffer1[9 * i + 6] == 0xff) && (forward_buffer1[9 * i + 7] == 0x19)); i++)
1328   4                              {        
1329   5                                      if(length > uart1_cnt)
1330   5                                              break;
1331   5                                      else
1332   5                                      length = 9 * i + 15;
1333   5                              }
1334   4                       }
1335   3                       else if((forward_buffer1[6 + 1] == 0x03)&&(TsataId == forward_buffer1[6])) 
1336   3                               length = forward_buffer1[6 + 2] + 9 ;          //6head + 3
1337   3      
1338   3                       else if((forward_buffer1[6 + 1] == 0x06)&&(TsataId == forward_buffer1[6]))             
1339   3                               length = 12;
1340   3      
1341   3                       else if((forward_buffer1[6 + 1] == 0x10)&&(TsataId == forward_buffer1[6]))
1342   3                               length = 12 ;
1343   3      
1344   3                       else
1345   3                               length = 0;
1346   3      
1347   3                              TCPIP_TcpSend(TcpSocket_ME, forward_buffer1, length , TCPIP_SEND_NOT_FINAL);
1348   3      
1349   3              //              Uart0_Tx(forward_buffer,length);
1350   3                      
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 23  

1351   3                      }
1352   2                      else if(Sever_Order == SERVER_RS232)
1353   2                      {
1354   3                              Uart0_Tx(forward_buffer1, uart1_count);
1355   3      
1356   3                       if((uart1_RxBuf[0] == 0xff)&&(uart1_RxBuf[1] == 0x19))
1357   3                               length = 9;
1358   3                       else 
1359   3                               length = uart1_RxBuf[2] + 5 ;
1360   3      
1361   3                              Uart0_Tx(forward_buffer1, length);
1362   3      
1363   3                      }
1364   2                      else if(Sever_Order == SERVER_USB)
1365   2                      {
1366   3                              memcpy(UpBuf, forward_buffer1, uart1_count);
1367   3                              UpCtr = uart1_count;
1368   3                              UpIndex = 0;
1369   3                              ENDP2_NEED_UP_FLAG = 1;
1370   3                      }
1371   2                      else if(Sever_Order == SERVER_SCHEDULE)
1372   2                      {
1373   3                              if(uart1_count == 8)
1374   3                              {
1375   4                                      U8_T i;
1376   4                                      InitCRC16();
1377   4                                      for(i = 0; i < 6; i++)
1378   4                                              CRC16_Tstat(forward_buffer1[i]);
1379   4      
1380   4                                      if((forward_buffer1[6] == CRChi) && (forward_buffer1[7] == CRClo))
1381   4                                      {
1382   5                                              schedule_flag = 1;
1383   5                                      }
1384   4                              }
1385   3                      }
1386   2                      else if(Sever_Order == SERVER_SCAN)
1387   2                      {
1388   3                              switch(scan_state)
1389   3                              {
1390   4                                      case SCAN_BINSEARCH:
1391   4                                              scan_response_state = MULTIPLE_ID;
1392   4                                              if(uart1_count >= 9) // right
1393   4                                              {
1394   5                                                      U8_T i;
1395   5                                                      InitCRC16();
1396   5                                                      for(i = 0; i < 7; i++)
1397   5                                                              CRC16_Tstat(forward_buffer[i]);
1398   5                      
1399   5                                                      if((forward_buffer[7] == CRChi) && (forward_buffer[8] == CRClo))
1400   5                                                      {
1401   6                                                              if((forward_buffer[0] == 0xff) && (forward_buffer[1] == 0x19)) // double check it is the response f
             -or scan command
1402   6                                                              {
1403   7                                                                      current_db.id = forward_buffer[2];
1404   7                                                                      current_db.sn = ((U32_T)forward_buffer[6] << 24) | ((U32_T)forward_buffer[5] << 16) | ((U32_T)forw
             -ard_buffer[4] << 8) | forward_buffer[3];
1405   7                                                                      if(uart1_count == 9)
1406   7                                                                      {
1407   8                                                                              scan_response_state = UNIQUE_ID;
1408   8                                                                      }
1409   7                                                                      else
1410   7                                                                      {
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 24  

1411   8                                                                              scan_response_state = UNIQUE_ID_FROM_MULTIPLE;
1412   8                                                                      }
1413   7                                                              }
1414   6                                                      }
1415   5                                              }
1416   4                                              // and none tstat in the range will wait timeout in the waitrsponse routine
1417   4                                              break;
1418   4                                      case SCAN_ASSIGN_ID_WITH_SN:
1419   4                                              if(uart1_count == 12) //right
1420   4                                              {
1421   5                                                      scan_response_state = ASSIGN_ID;
1422   5                                              }
1423   4                                              break;
1424   4                              }
1425   3                      }
1426   2      
1427   2                      else
1428   2                      {}
1429   2                      
1430   2                      Sever_Order = SERVER_NONE;
1431   2              }
1432   1      
1433   1      }
1434          
1435          
1436          
1437          
1438          void display_ip(void)
1439          {
1440   1              U8_T adr,i;             //num,
1441   1              U32_T sn,a,b,c,d;
1442   1      
1443   1              a =  Para[7];
1444   1              a = a << 24;
1445   1      
1446   1              b =  Para[5];
1447   1              b = b << 16;
1448   1      
1449   1              c =  Para[3];
1450   1              c = c << 8;
1451   1      
1452   1              d =  Para[1];
1453   1      
1454   1              sn = a + b + c + d ;
1455   1      
1456   1      //      Lcd_Show_String(1,1,"    ",1,12);
1457   1              
1458   1              Lcd_Show_String(3,1,"ip = ",1,5);
1459   1              Lcd_Show_Data(3,6,Para[215],0,1);
1460   1              Lcd_Show_String(3,9,".",1,1);
1461   1              Lcd_Show_Data(3,10,Para[217],0,1);
1462   1              Lcd_Show_String(3,13,".",1,1);
1463   1              Lcd_Show_Data(3,14,Para[219],0,1);
1464   1              Lcd_Show_String(3,15,".",1,1);
1465   1              Lcd_Show_Data(3,16,Para[221],0,1);
1466   1      
1467   1      
1468   1              Lcd_Show_String(1,1,"id = ",1,5);
1469   1              Lcd_Show_Data(1,6,Para[13],0,1);
1470   1      
1471   1              Lcd_Show_String(2,1,"sn = ",1,5);
1472   1              Lcd_show_for_32bit(2,6,sn,1);
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 25  

1473   1      
1474   1              
1475   1              adr = Para[9] % 10 ;
1476   1              i = 1;
1477   1              Lcd_Show_String(4,i,"fw:",1,3);
1478   1              Lcd_Show_Data(4,i+3,Para[11],0,1);
1479   1              Lcd_Show_String(4,i+5,".",1,1);
1480   1      //      Lcd_Show_Data(4,7,adr,0,1);
1481   1              Lcd_Show_Data(4,i+6,Para[9],0,1);
1482   1      
1483   1              Lcd_Show_String(4,i+9,"hw:",1,3);
1484   1              Lcd_Show_Data(4,i+12,Para[17],0,1);
1485   1      
1486   1              Lcd_Show_String(4,i+15,"bl:",1,3);
1487   1              Lcd_Show_Data(4,i+18,Para[29],0,1);
1488   1      
1489   1      
1490   1      //      Lcd_Show_Data(4,adr,(U16_T)(sn >> 16),0,1);
1491   1      //      Lcd_Show_Data(4,adr+4,(U16_T)sn,0,1);
1492   1              Lcd_Show_String(0,1,"Network Controller",1,12);
1493   1      }
1494          
1495          void Display_Updating(void)
1496          {
1497   1      
1498   1              Lcd_Show_String(2,5,"Updating...",1,11);
1499   1      }
1500          
1501          
1502          
1503          /*****Uart2 routine***********************/
1504          void Uart2_Receive(void)
1505          {
1506   1              U16_T uart2_count = 0;
1507   1      
1508   1              EA = 0;
1509   1              if(hsurRxCount)
1510   1              {
1511   2                      if(Sever_Order == SERVER_TCPIP)
1512   2                      {
1513   3                              Set_transaction_ID(forward_buffer, sessonlen);
1514   3                              uart2_count = 6;
1515   3                      }
1516   2      
1517   2                      memcpy(forward_buffer + uart2_count, hsurRxBuffer, hsurRxCount);
1518   2                      uart2_count += hsurRxCount;
1519   2                      hsurRxCount = 0;
1520   2                      EA = 1;
1521   2              }
1522   1              else
1523   1              {
1524   2                      EA = 1;
1525   2                      return;
1526   2              }
1527   1      
1528   1              if(uart2_count)
1529   1              {
1530   2                      if(Sever_Order == SERVER_TCPIP)  //Sever Order is from TCPIP
1531   2                      {
1532   3                              if(TcpIp_Scan == 1)
1533   3                              {
1534   4                                      TcpIp_Scan = 0;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 26  

1535   4                                      TCPIP_TcpSend(TcpSocket_ME, forward_buffer, uart2_count, TCPIP_SEND_NOT_FINAL);
1536   4                              }
1537   3                              else
1538   3                              {
1539   4                                      TCPIP_TcpSend(TcpSocket_ME, forward_buffer, uart2_count-2, TCPIP_SEND_NOT_FINAL);
1540   4                              
1541   4                               //   Uart0_Tx(forward_buffer,uart2_count-2);
1542   4                              
1543   4                              }
1544   3                      LED = S485_OK;
1545   3              
1546   3                      }
1547   2                      else if(Sever_Order == SERVER_RS232)
1548   2                      {
1549   3                              Uart0_Tx(forward_buffer, uart2_count);
1550   3                              LED = S485_OK;
1551   3                      }
1552   2                      else if(Sever_Order == SERVER_USB)
1553   2                      {
1554   3                              memcpy(UpBuf, forward_buffer, uart2_count);
1555   3                              UpCtr = uart2_count;
1556   3                              UpIndex = 0;
1557   3                              ENDP2_NEED_UP_FLAG = 1;
1558   3                              LED = S485_OK;
1559   3                      }
1560   2                      else if(Sever_Order == SERVER_SCHEDULE) // schedule commands
1561   2                      {
1562   3                              if(uart2_count == 8)
1563   3                              {
1564   4                                      U8_T i;
1565   4                                      InitCRC16();
1566   4                                      for(i = 0; i < 6; i++)
1567   4                                              CRC16_Tstat(forward_buffer[i]);
1568   4      
1569   4                                      if((forward_buffer[6] == CRChi) && (forward_buffer[7] == CRClo))
1570   4                                      {
1571   5                                              schedule_flag = 1;
1572   5                                      }
1573   4                              }       
1574   3                      }
1575   2                      else if(Sever_Order == SERVER_SCAN)
1576   2                      {
1577   3                              switch(scan_state)
1578   3                              {
1579   4                                      case SCAN_BINSEARCH:
1580   4                                              scan_response_state = MULTIPLE_ID;
1581   4                                              if(uart2_count >= 9) // right
1582   4                                              {
1583   5                                                      U8_T i;
1584   5                                                      InitCRC16();
1585   5                                                      for(i = 0; i < 7; i++)
1586   5                                                              CRC16_Tstat(forward_buffer[i]);
1587   5                      
1588   5                                                      if((forward_buffer[7] == CRChi) && (forward_buffer[8] == CRClo))
1589   5                                                      {
1590   6                                                              if((forward_buffer[0] == 0xff) && (forward_buffer[1] == 0x19)) // double check it is the response f
             -or scan command
1591   6                                                              {
1592   7                                                                      current_db.id = forward_buffer[2];
1593   7                                                                      current_db.sn = ((U32_T)forward_buffer[6] << 24) | ((U32_T)forward_buffer[5] << 16) | ((U32_T)forw
             -ard_buffer[4] << 8) | forward_buffer[3];
1594   7                                                                      if(uart2_count == 9)
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 27  

1595   7                                                                      {
1596   8                                                                              scan_response_state = UNIQUE_ID;
1597   8                                                                      }
1598   7                                                                      else
1599   7                                                                      {
1600   8                                                                              scan_response_state = UNIQUE_ID_FROM_MULTIPLE;
1601   8                                                                      }
1602   7                                                              }
1603   6                                                      }
1604   5                                              }
1605   4                                              // and none tstat in the range will wait timeout in the waitrsponse routine
1606   4                                              break;
1607   4                                      case SCAN_ASSIGN_ID_WITH_SN:
1608   4                                              if(uart2_count == 12) //right
1609   4                                              {
1610   5                                                      scan_response_state = ASSIGN_ID;
1611   5                                              }
1612   4                                              break;
1613   4                              }
1614   3                      }
1615   2      
1616   2                      else
1617   2                      {
1618   3                              
1619   3                      }
1620   2                      Sever_Order = SERVER_NONE;
1621   2      
1622   2                      
1623   2              }
1624   1      }
1625          
1626          /********** transmit order to tstat ******************/
1627          void Tx_To_Tstat(U8_T *buf, U8_T len)
1628          {
1629   1              U8_T i;
1630   1      
1631   1              Rs485_EN = 1;
1632   1      
1633   1              Uart1_Tx(buf, len);
1634   1      
1635   1      
1636   1              for(i = 0; i < len; i++)  
1637   1                      HSUR_PutChar(buf[i]);
1638   1      
1639   1              if(len < 10)
1640   1                      DELAY_Ms(1);
1641   1              else
1642   1                      DELAY_Ms((len + 1) / 8);
1643   1      
1644   1              Rs485_EN = 0;
1645   1              
1646   1      }
1647          
1648          void LedBeat_task(void) reentrant
1649          {   U16_T i;
1650   1        
1651   1              portTickType xDelayPeriod = ( portTickType ) 500 / portTICK_RATE_MS;  //2000
1652   1          portTickType xDelayPeriod1 = ( portTickType ) 100 / portTICK_RATE_MS;
1653   1      
1654   1              for (;;)                                
1655   1              {       
1656   2                      if(err485)
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 28  

1657   2                      {
1658   3                              Led_485ERR();
1659   3                              for(i = 0; i < 20000;i++);
1660   3                                      err485 = 0;
1661   3      
1662   3                              vTaskDelay(xDelayPeriod1);
1663   3                      } 
1664   2      //              BeatSta=1;
1665   2                      Beat_ON();
1666   2                      vTaskDelay(xDelayPeriod);
1667   2      //              BeatSta=0;
1668   2                      Beat_OFF() ;
1669   2                      vTaskDelay(xDelayPeriod);                                
1670   2              }
1671   1      }
1672          
1673          void Realtimer_task(void) reentrant
1674          {
1675   1      
1676   1              portTickType xDelayPeriod = ( portTickType ) 1000 / portTICK_RATE_MS;//2 minutes writting flash.
1677   1              
1678   1              for (;;)
1679   1              {   
1680   2                           vTaskDelay(xDelayPeriod);
1681   2                  /* if(SetimeFlag)
1682   2                     { SetimeFlag=0;
1683   2                       Initial_Clock();
1684   2                     }*/
1685   2      
1686   2                              // Uart0_Tx(Data,48);
1687   2                   Read_Clock(2);
1688   2              }
1689   1      
1690   1      }
1691          
1692          
1693          void Timer_task(void) reentrant
1694          {
1695   1              unsigned portLONG       count = 0;
1696   1              portTickType xDelayPeriod = ( portTickType ) 3000 / portTICK_RATE_MS;//3000
1697   1          U16_T i=0;
1698   1              
1699   1              for (;;)
1700   1              {     
1701   2              
1702   2                      if(ChangeFlash == 1)
1703   2                   {  
1704   3                              Flash_Write_Schedule();
1705   3                              ChangeFlash=0;                  
1706   3               }
1707   2                       else if(ChangeFlash == 2)
1708   2                   {  
1709   3                              ChangeFlash=0;          
1710   3                              Flash_Write_Schedule(); 
1711   3                        //  IntFlashErase(ERA_RUN,0x070000);          //erase                             
1712   3                        //  MassFlashWrite(0,Para,400);           //write to flash
1713   3                              
1714   3               }
1715   2      
1716   2                       if(ChangeIP > 0)  //LHN add
1717   2                       {
1718   3                              ChangeIP++;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 29  

1719   3                              if(ChangeIP >= 4)
1720   3                              {
1721   4                                      ChangeIP = 0;
1722   4      
1723   4                                      if(mac_change_enable == 1)
1724   4                                      {
1725   5                                              E2prom_Write_Byte_To_Absolute_Address(0x0b, Para[201]);
1726   5                                              E2prom_Write_Byte_To_Absolute_Address(0x0a, Para[203]);
1727   5                                              E2prom_Write_Byte_To_Absolute_Address(0x09, Para[205]);
1728   5                                              E2prom_Write_Byte_To_Absolute_Address(0x08, Para[207]);
1729   5                                              E2prom_Write_Byte_To_Absolute_Address(0x07, Para[209]);
1730   5                                              E2prom_Write_Byte_To_Absolute_Address(0x06, Para[211]);
1731   5      
1732   5                                              mac_change_enable = 0;
1733   5                                      }
1734   4      
1735   4                                      lcdreset();
1736   4                                      Lcd_Initial();
1737   4                                      Display_reboot();
1738   4                                      AX11000_SoftReboot();
1739   4                              }
1740   3                      }
1741   2      
1742   2                      Read_Clock(2);
1743   2                      vTaskDelay(xDelayPeriod);
1744   2              }
1745   1      }
1746          
1747          
1748          void Ledflash_task(void) reentrant
1749          {
1750   1              portTickType    xDelayPeriod = ( portTickType ) SYS_FREQUENCY_PERIOD / portTICK_RATE_MS;//200
1751   1              portTickType    xDelayPeriod1 = ( portTickType ) SYS_FREQUENCY_PERIOD1 / portTICK_RATE_MS;//100
1752   1      
1753   1              for (;;)
1754   1              {  
1755   2                if(LED==Ethnet_OK){ Led_EthSend(); vTaskDelay(xDelayPeriod1);Led_EthRxD(); vTaskDelay(xDelayPeri
             -od1);
1756   3                                                        LED= None;Led_ReSet();        }
1757   2      
1758   2      
1759   2                        if(LED==RS232_OK) {   Led_RS232_Tx(); vTaskDelay(xDelayPeriod1); Led_RS232_Rx();      vTaskDelay(xDelayPer
             -iod1);        
1760   3                                                                       LED= None;Led_ReSet(); }
1761   2      
1762   2      
1763   2                if(LED==Zigbee_OK) { Led_zigbee_Tx();  vTaskDelay(xDelayPeriod1);     Led_zigbee_Rx(); vTaskDelay(xD
             -elayPeriod1);
1764   3                                                                 LED= None;Led_ReSet();       
1765   3                                                               }
1766   2      
1767   2      
1768   2                        if(LED==Usb_OK) {     Led_USB_Tx(); vTaskDelay(xDelayPeriod1); Led_USB_Rx();vTaskDelay(xDelayPeriod1);
1769   3                                                                 LED= None;Led_ReSet();       }
1770   2      
1771   2      
1772   2                        if(LED==Gsm_OK) {     }
1773   2                 
1774   2      
1775   2                        if(LED==S485_OK){  
1776   3                                            Led_485Send();vTaskDelay(xDelayPeriod1);Led_485RxD();vTaskDelay(xDelayPeriod1);
1777   3                                                    LED=None;Led_ReSet();         }
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 30  

1778   2                          
1779   2      
1780   2                if(LED==S485_ERR){ Led_485ERR(); vTaskDelay(xDelayPeriod1); vTaskDelay(xDelayPeriod1);
1781   3                                                        LED= None;Led_ReSet();        }
1782   2               
1783   2      
1784   2                     vTaskDelay(xDelayPeriod);
1785   2              }
1786   1      }
1787          
1788          
1789          void Scan_task(void)
1790          {
1791   1              portTickType xDelayPeriod = (portTickType)10000 / portTICK_RATE_MS;
1792   1              init_scan();
1793   1              while(1)
1794   1              {
1795   2                      vTaskDelay(xDelayPeriod);
1796   2                      scan_tstat();
1797   2              }
1798   1      }
1799          
1800          
1801          void Uart0_task(void) reentrant
1802          {
1803   1              portTickType xDelayPeriod  = ( portTickType ) 300 / portTICK_RATE_MS;//1000
1804   1              
1805   1              for (;;)
1806   1          {
1807   2              #if 1
1808   2                      Uart0_Receive();
1809   2                      vTaskDelay(xDelayPeriod);
1810   2              #endif   
1811   2          }           
1812   1        
1813   1      }
1814          
1815          void Uart1_task(void) reentrant
1816          {
1817   1              portTickType xDelayPeriod = ( portTickType ) 40 / portTICK_RATE_MS;//50
1818   1              
1819   1              for (;;)
1820   1          { 
1821   2                      vTaskDelay(xDelayPeriod);
1822   2                      if(uart1_timeout == 0)
1823   2                      {
1824   3                              Uart1_Receive();
1825   3                      }
1826   2              }
1827   1      }
1828          
1829          
1830          void Uart2_task(void) reentrant
1831          {
1832   1              portTickType xDelayPeriod = ( portTickType ) 50 / portTICK_RATE_MS;//1000
1833   1      
1834   1              for (;;)
1835   1          { 
1836   2                      vTaskDelay(xDelayPeriod);
1837   2                      if(uart2_timeout == 0)
1838   2                      {
1839   3                              Uart2_Receive();
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 31  

1840   3                      }
1841   2              }
1842   1      }
1843          
1844          
1845          void Schedule_task(void) reentrant
1846          {
1847   1              static U8_T     count = 0;
1848   1              portTickType xDelayPeriod = ( portTickType ) 500 / portTICK_RATE_MS;//500
1849   1              for (;;)
1850   1              { 
1851   2      #if 1
1852   2      /* implement CaculateTime rution  per 500ms */
1853   2                      CaculateTime();
1854   2      /* implement CheckWeeklyRoutines rution  per 1s */
1855   2                      if(count % 2 == 0)  // 1s
1856   2                      {
1857   3                              //Para[1]++;
1858   3                              CheckWeeklyRoutines();
1859   3                      }
1860   2      /* implement CheckAnnualRoutines rution  per 3s */
1861   2      /* implement CheckIdRoutines rution  per 3s */  
1862   2                      if(count % 6 == 0)  // 3s
1863   2                      {
1864   3                              //Para[3]++;
1865   3                              CheckAnnualRoutines();
1866   3                              CheckIdRoutines();
1867   3                      }
1868   2      
1869   2      #endif          
1870   2                      if(count < 6) count++;
1871   2                      else count = 0;
1872   2      
1873   2                      vTaskDelay(xDelayPeriod);
1874   2              }
1875   1      }
1876          
1877          void TimeServer_task(void) reentrant
1878          {
1879   1              portTickType xDelayPeriod = ( portTickType ) 1000 / portTICK_RATE_MS;  //2000
1880   1          U8_T i;
1881   1              U32_T ip;//ntp.fudan.edu.cn=0x3D812A2C; 0xc0a800c7;192.168.0.199 0x4137150f;time.windows.com
1882   1              U8_T Data[48]={0xd9,0x00,0x0a,0xfa,0x00,0x00,0x00,0x00,0x00,0x01,0x04}; //{0x65,0,0x0b,0};
1883   1              for (;;)
1884   1              { 
1885   2                              Time_Server.Leng++;
1886   2                              if( (Time_Server.Leng == 50000) || (Para[355] == 6))                                                                 
1887   2                              {       
1888   3                                      Para[355] = 0;
1889   3                                      Para[399] = 0;
1890   3      
1891   3                                      ip = ((U32_T)Para[357]) << 24 | ((U32_T)Para[359]) << 16 | ((U32_T)Para[361]) << 8 | (U32_T)Para[363];
1892   3                                      Time_Server.UdpSocket = TCPIP_UdpNew(gudpbc_InterAppId, 0, ip, 1234,123);
1893   3                                      if(Time_Server.UdpSocket != TCPIP_NO_NEW_CONN)
1894   3                                      {
1895   4                                              for(i = 11; i < 40; i++)
1896   4                                                      Data[i] = 0;
1897   4                                              Data[40] = 0xd2;Data[41] = 0x3c;Data[42] = 0xde;Data[43] = 0xd6;
1898   4                                              Data[44] = 0xe8;Data[45] = 0;Data[46] = 0;Data[47] = 0;                         
1899   4                                      //      Uart0_Tx(Data,48);
1900   4                                      //      DELAY_Ms(5);
1901   4                                              TCPIP_UdpSend(Time_Server.UdpSocket, 0, 0, Data,48);
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 32  

1902   4                                      }
1903   3                              }
1904   2      
1905   2                              if (Time_Server.Leng >= 50110) 
1906   2                                      Time_Server.Leng = 0;
1907   2                                                              
1908   2                              vTaskDelay(xDelayPeriod);
1909   2                      }
1910   1      }
1911          
1912          void UdpBroadcast_task(void)
1913          {
1914   1              portTickType xDelayPeriod = ( portTickType ) 2000 / portTICK_RATE_MS;
1915   1              while(1)
1916   1              {
1917   2                      vTaskDelay(xDelayPeriod);
1918   2              }
1919   1      }
1920          
1921          
1922          
1923          void USB_task(void)
1924          {
1925   1              U8_T len, length;
1926   1              U16_T StartAdd;
1927   1              portTickType xDelayPeriod = (portTickType)20 / portTICK_RATE_MS;
1928   1      
1929   1              CH375_Init();
1930   1      
1931   1              while(1)
1932   1              {   
1933   2                      vTaskDelay(xDelayPeriod);
1934   2                      if(usb_poll() == TRUE)
1935   2                      {
1936   3                              mCH375Interrupt();
1937   3                      }
1938   2                      else
1939   2                      {
1940   3                              if(USB_timeout == 0)
1941   3                              {
1942   4                                      if(DownCtr > 0)
1943   4                                      {
1944   5                                         LED = Usb_OK;
1945   5      
1946   5                                              if((DownBuf[0] == Para[13]) || (DownBuf[0] == 0xff))    // Address of NetControl 
1947   5                                              { 
1948   6                                                      if(DownBuf[1] == 0x19)          //scan Tsnet
1949   6                                                      {
1950   7                                                              Sever_Order = SERVER_USB;               //USB
1951   7                                                              Sever_id = DownBuf[0];
1952   7                                                              Tx_To_Tstat(DownBuf, DownCtr);                                                                                                                  
1953   7                                                      }                                       
1954   6                                                      else if(DownBuf[1] == 0x1a)     //scan NC
1955   6                                                      { 
1956   7                                                              UpCtr = 0;
1957   7                                                              UpBuf[UpCtr++] = DownBuf[0];
1958   7                                                              UpBuf[UpCtr++] = 0x19;
1959   7                                                              UpBuf[UpCtr++] = Para[13];                                               
1960   7                                                              UpBuf[UpCtr++] = Para[1];
1961   7                                                              UpBuf[UpCtr++] = Para[3];
1962   7                                                              UpBuf[UpCtr++] = Para[5];
1963   7                                                              UpBuf[UpCtr++] = Para[7];
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 33  

1964   7                                                              InitCRC16();
1965   7                                                              for(len = 0; len < UpCtr; len++)
1966   7                                                                      CRC16_Tstat(UpBuf[len]);
1967   7                                                              UpBuf[UpCtr++] = CRChi;
1968   7                                                              UpBuf[UpCtr++] = CRClo;
1969   7                                                              UpIndex = 0;
1970   7                                                              ENDP2_NEED_UP_FLAG = 1;                                  
1971   7                                                      }
1972   6                                                      else if(DownBuf[1] == read) 
1973   6                                                      {
1974   7                                                              UpBuf[0] = DownBuf[0];
1975   7                                                              UpBuf[1] = DownBuf[1];
1976   7                                                              length = (DownBuf[4] << 8) | DownBuf[5];
1977   7                                                              UpBuf[2] = 2 * length;
1978   7                                                              UpCtr = 3 + UpBuf[2];
1979   7                                                              StartAdd = (DownBuf[2] << 8) | DownBuf[3];                                                                           
1980   7                                                              for(len = 0; len < length; len++)
1981   7                                                              {
1982   8                                                                      if(StartAdd < 200)
1983   8                                                                      {
1984   9                                                                              UpBuf[3 + 2 * len] = Para[2 * (StartAdd + len)];  
1985   9                                                                              UpBuf[4 + 2 * len] = Para[2 * (StartAdd + len) + 1];
1986   9                                                                      }
1987   8                                                                      else if((StartAdd + len) >= MODBUS_TIMER_ADDRESS) 
1988   8                                                                      {
1989   9                                                                              if(StartAdd + len < MODBUS_TIMER_ADDRESS + 8)
1990   9                                                                              {        
1991  10                                                                              //  YEAR  MONTH  WEEK DATE  HOUR  MINUTE  SECOND 
1992  10                                                                                      UpBuf[3 + 2 * len] = 0;
1993  10                                                                                      switch(StartAdd + len - MODBUS_TIMER_ADDRESS)
1994  10                                                                                      {
1995  11                                                                                              case 7:
1996  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.sec;
1997  11                                                                                                      break;  
1998  11                                                                                              case 6:
1999  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.min;
2000  11                                                                                                      break;
2001  11                                                                                              case 5:
2002  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.hour;
2003  11                                                                                                      break;
2004  11                                                                                              case 4:
2005  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.day;
2006  11                                                                                                      break;
2007  11                                                                                              case 3:
2008  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.dayofweek;
2009  11                                                                                                      break;
2010  11                                                                                              case 2:
2011  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.month;
2012  11                                                                                                      break;
2013  11                                                                                              case 1:
2014  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.year;
2015  11                                                                                                      break;
2016  11                                                                                              case 0:
2017  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.centary;
2018  11                                                                                                      break;
2019  11                                                                                      }               
2020  10                                                                              }
2021   9                                                                              else if(StartAdd + len >= MODBUS_WR_DESCRIP_FIRST && StartAdd + len < MODBUS_WR_DESCRIP_LAST)
2022   9                                                                              {
2023  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
2024  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE;
2025  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].UN.all[temp_address];
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 34  

2026  10                                                                                  if((temp_address == (WR_DESCRIPTION_SIZE - 1)) && (send_buffer != 0xff))
2027  10                                                                                      {
2028  11                                                                                              if((send_buffer & 0x80) == 0)
2029  11                                                                                              {
2030  12                                                                                                      if(GetBit(temp_number, wr_state_index))
2031  12                                                                                                              send_buffer |= 0x40;
2032  12                                                                                                      else
2033  12                                                                                                              send_buffer &= 0xbf;
2034  12                                                                                              }
2035  11      
2036  11                                                                                              if(GetBit(temp_number, holiday1_state_index))
2037  11                                                                                                      send_buffer |= 0x20;
2038  11                                                                                              else
2039  11                                                                                                      send_buffer &= 0xdf;
2040  11      
2041  11                                                                                              if(GetBit(temp_number, holiday2_state_index))
2042  11                                                                                                      send_buffer |= 0x10;
2043  11                                                                                              else
2044  11                                                                                                      send_buffer &= 0xef;
2045  11                                                                                      }
2046  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2047  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2048  10                                                                              }
2049   9                                                                              else if(StartAdd + len >= MODBUS_AR_DESCRIP_FIRST && StartAdd + len < MODBUS_AR_DESCRIP_LAST)
2050   9                                                                              {
2051  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;    // line
2052  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE;
2053  10                                                                                      U8_T send_buffer = AR_Roution[temp_number].UN.all[temp_address];
2054  10                                      
2055  10                                                                                      if(temp_address == (AR_DESCRIPTION_SIZE - 1))
2056  10                                                                                      {
2057  11                                                                                              if((send_buffer & 0x80) == 0)
2058  11                                                                                              {
2059  12                                                                                                      if(GetBit(temp_number, ar_state_index))
2060  12                                                                                                              send_buffer |= 0x40;
2061  12                                                                                                      else
2062  12                                                                                                              send_buffer &= 0xbf;
2063  12                                                                                              }
2064  11                                                                                      }
2065  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2066  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2067  10                                                                              }
2068   9                                                                              else if(StartAdd + len >= MODBUS_ID_FIRST && StartAdd + len < MODBUS_ID_LAST)
2069   9                                                                              {
2070  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_ID_FIRST) / ID_SIZE;
2071  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_ID_FIRST) % ID_SIZE;
2072  10                                                                                      U8_T send_buffer = ID_Config[temp_number].all[temp_address];
2073  10                                                      
2074  10                                                                                      if((temp_address == (ID_SIZE - 1)) && (send_buffer != 0xff))
2075  10                                                                                      {
2076  11                                                                                              if((send_buffer & 0x80) == 0)
2077  11                                                                                              {
2078  12                                                                                                      if(GetBit(temp_number, output_state_index))
2079  12                                                                                                              send_buffer |= 0x40;
2080  12                                                                                                      else
2081  12                                                                                                              send_buffer &= 0xbf;
2082  12                                                                                              }
2083  11      
2084  11                                                                                              if(GetBit(temp_number, schedual1_state_index))
2085  11                                                                                                      send_buffer |= 0x20;
2086  11                                                                                              else
2087  11                                                                                                      send_buffer &= 0xdf;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 35  

2088  11      
2089  11                                                                                              if(GetBit(temp_number, schedual2_state_index))
2090  11                                                                                                      send_buffer |= 0x10;
2091  11                                                                                              else
2092  11                                                                                                      send_buffer &= 0xef;
2093  11                                                                                      }
2094  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2095  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2096  10                                                                              }
2097   9                                                                              else if(StartAdd + len >= MODBUS_AR_TIME_FIRST && StartAdd + len < MODBUS_WR_ONTIME_FIRST)
2098   9                                                                              {
2099  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
2100  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE;
2101  10                                                                                      U8_T send_buffer = AR_Roution[temp_number].Time[temp_address];
2102  10                                                      
2103  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2104  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;
2105  10                                                                              }
2106   9                                                                              else if(StartAdd + len >= MODBUS_WR_ONTIME_FIRST && StartAdd + len < MODBUS_WR_OFFTIME_FIRST)
2107   9                                                                              {
2108  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;            
2109  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE;
2110  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].OnTime[temp_address];
2111  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2112  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;
2113  10                                                                              }
2114   9                                                                              else if(StartAdd + len >= MODBUS_WR_OFFTIME_FIRST && StartAdd + len < MODBUS_TOTAL_PARAMETERS)
2115   9                                                                              {
2116  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
2117  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE;
2118  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].OffTime[temp_address];
2119  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2120  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;                       
2121  10                                                                              }
2122   9      //                                                                      else if(StartAdd==0xee10) //for ISP read address of 0xee10
2123   9      //                                                                      {  
2124   9      //                                                                              RealNum = 2;
2125   9      //                                                                              send_tcp[UIP_HEAD] = uip_appdata[UIP_HEAD];//
2126   9      //                                                                              send_tcp[UIP_HEAD+1] = READ_VARIABLES;//
2127   9      //                                                                              send_tcp[UIP_HEAD+2] = RealNum;
2128   9      //                                                                              send_tcp[UIP_HEAD+3] = send_tcp[UIP_HEAD+4]=0;//00                              
2129   9      //                                                                      }
2130   9                                                                              else
2131   9                                                                              {
2132  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2133  10                                                                                      UpBuf[4 + 2 * len] = 1;
2134  10                                                                              }                                               
2135   9                                                                      } 
2136   8                                                              }
2137   7      
2138   7                                                              InitCRC16();
2139   7                                                              for(len = 0; len < UpCtr; len++)
2140   7                                                                      CRC16_Tstat(UpBuf[len]);
2141   7      
2142   7                                                              UpBuf[UpCtr++] = CRChi;                        
2143   7                                                              UpBuf[UpCtr++] = CRClo;
2144   7      
2145   7                                                              UpIndex = 0;
2146   7                                                              ENDP2_NEED_UP_FLAG = 1;                                                                                         
2147   7                                                      }
2148   6                                                      else if(DownBuf[1] == swrite) 
2149   6                                                      {
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 36  

2150   7                                                              if(((DownBuf[2] << 8) | DownBuf[3]) < 200)
2151   7                                                              {
2152   8                                                                      if(((DownBuf[2] << 8) | DownBuf[3]) == 106)
2153   8                                                                      {
2154   9                                                                              if((((Para[212] << 8) | Para[213]) == 0) && (((DownBuf[4] << 8) | DownBuf[5]) != 0))
2155   9                                                                              {
2156  10                                                                                      Para[212] = DownBuf[4];
2157  10                                                                                      Para[213] = DownBuf[5];
2158  10                                                                                      ChangeIP = 1;
2159  10                                                                                      ChangeFlash = 2;
2160  10                                                                              }
2161   9                                                                      }
2162   8                                                                      else if((((DownBuf[2] << 8) | DownBuf[3]) >= 107) && (((DownBuf[2] << 8) | DownBuf[3]) <= 120)) //
             -IP change ,reset cpu
2163   8                                                                      {
2164   9                                                                              if(((Para[212] << 8) | Para[213]) == 0)
2165   9                                                                              {
2166  10                                                                                      Para[2*DownBuf[3]] = DownBuf[4];                //write to bufffer array high bit
2167  10                                                                                      Para[2*DownBuf[3] + 1] = DownBuf[5];    //write to bufffer array low bit
2168  10                                                                                      ChangeFlash = 2;
2169  10                                                                                      ChangeIP = 1;
2170  10                                                                              }
2171   9                                                                      }
2172   8                                                                      else
2173   8                                                                      {
2174   9                                                                              Para[2*DownBuf[3]] = DownBuf[4];                        //write to bufffer array high bit
2175   9                                                                              Para[2*DownBuf[3] + 1] = DownBuf[5];            //write to bufffer array low bit
2176   9                                                                              ChangeFlash = 2;
2177   9                                                                      }
2178   8                                                              }
2179   7      
2180   7                                                              for(len = 0; len < DownCtr; len++)
2181   7                                                                      UpBuf[len] = DownBuf[len];
2182   7      
2183   7                                                              UpCtr = len;
2184   7                                                              UpIndex = 0;
2185   7                                                              ENDP2_NEED_UP_FLAG = 1;
2186   7                                                      }
2187   6                                              }
2188   5                                              else
2189   5                                              {
2190   6                                                      Sever_Order = SERVER_USB;               //USB
2191   6                                                      Sever_id = DownBuf[0];                            
2192   6                                                      Tx_To_Tstat(DownBuf, DownCtr);                                                                                                                   
2193   6                                              } 
2194   5                                              
2195   5                                              DownCtr = 0;
2196   5                                      }
2197   4                              }
2198   3      
2199   3                              if((ENDP2_NEED_UP_FLAG == 1) && (ENDP2_UP_SUC_FLAG == 1) && UpCtr)
2200   3                              {
2201   4                                      ENDP2_UP_SUC_FLAG = 0;
2202   4                                      if(UpCtr > BULK_IN_ENDP_MAX_SIZE)
2203   4                                      {
2204   5                                              length = BULK_IN_ENDP_MAX_SIZE;
2205   5                                              UpCtr -= BULK_IN_ENDP_MAX_SIZE;
2206   5                                      }
2207   4                                      else
2208   4                                      {
2209   5                                              length = UpCtr;
2210   5                                              UpCtr = 0;
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 37  

2211   5                                              ENDP2_NEED_UP_FLAG = 0;
2212   5                                      }
2213   4      
2214   4                                      CH375_WR_CMD_PORT(CMD_WR_USB_DATA7);                    // 2
2215   4                                      CH375_WR_DAT_PORT(length);
2216   4                                      for(len = 0; len < length; len++)
2217   4                                              CH375_WR_DAT_PORT(UpBuf[UpIndex++]);
2218   4                              }
2219   3                      }
2220   2              }
2221   1      }
2222          
2223          
2224          BOOL send_out = TRUE;
2225          U8_T test_setpoint[] = { 0xfe, 0x06, 0x01, 0x5b, 0x00, 0x19, 0x2c, 0x20}; 
2226          U8_T rev_cnt = 0;
2227          
2228          void gsm_task(void) reentrant                                           // LJ
2229          {
2230   1              U8_T end_ch = 0x1a;
2231   1              char temp_gsm[100];
2232   1              portTickType xDelayPeriod = ( portTickType)     1000 / portTICK_RATE_MS;
2233   1      
2234   1              gsm_init();                     // LJ
2235   1          
2236   1              for (;;)
2237   1              {
2238   2                      vTaskDelay(xDelayPeriod);
2239   2      
2240   2      //         GSM_SWITCH = ~GSM_SWITCH;
2241   2      
2242   2                      switch ( g_state)
2243   2                      {
2244   3                              case GSM_INITING:
2245   3                                      gsm_module_init();
2246   3                                      break;
2247   3                              case GSM_ERROR:
2248   3      //                              gsm_debug( "RETURN ERROR");
2249   3                                      break;
2250   3                              case GSM_INIT_DONE:
2251   3                                      if(0)          // wait for temperature register
2252   3                                      {
2253   4                                              if(send_out)
2254   4                                              {
2255   5                                                      sprintf( temp_gsm, "AT+CMGS=\"%s\"", &phoneNumber[3]);
2256   5                                                      send_at_cmd( temp_gsm);
2257   5                                                      MicroWait(65000);
2258   5                                                      send_at_cmd( "NetworkController");
2259   5                                                                      simulate_write_byte(0x1a);
2260   5                                              //      Uart1_Tx( &end_ch, 1);
2261   5                                                      //g_state = SMS_SENDING;
2262   5                                                      send_out = FALSE;
2263   5                                              }
2264   4                                      }
2265   3                                      break;                          
2266   3                              case SMS_READY:
2267   3                                      send_at_cmd( "Test GSM module first time");
2268   3                              //      Uart1_Tx( &end_ch, 1);
2269   3                              simulate_write_byte(0x1a);
2270   3                                      g_state = GSM_INIT_DONE;
2271   3                                      break;
2272   3                              case SMS_SEND_SUCCESS:
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 38  

2273   3                                      g_state = GSM_INIT_DONE;
2274   3                                      break;
2275   3                              case GET_MSG:
2276   3      //                              gsm_debug( "send cmgr");
2277   3                                      send_at_cmd( "AT+CMGR=1");
2278   3                                      rev_cnt++;
2279   3                                      g_state = GSM_INIT_DONE;
2280   3                                      if( rev_cnt > 9)
2281   3                                      {
2282   4                                              g_state = GSM_INIT_DONE;
2283   4                                              rev_cnt = 0;
2284   4                                              send_at_cmd( "AT+CMGD=1");                         // 10
2285   4                                      }
2286   3                                      break;
2287   3                              case SET_POINT:
2288   3                                      Tx_To_Tstat( test_setpoint, 8);
2289   3                                      g_state = GSM_INIT_DONE;
2290   3                                      break;
2291   3                              default:
2292   3                                      break;
2293   3                      }
2294   2                      if( gsm_RxBuf.size > 1)
2295   2                      {
2296   3                              gsm_msg_process (gsm_RxBuf.buf); 
2297   3                      }
2298   2              }
2299   1      }
2300          
2301          
2302          
2303          
2304          /*
2305           * ----------------------------------------------------------------------------
2306           * Function Name: main
2307           * Purpose:
2308           * Params:
2309           * Returns:
2310           * Note:
2311           * ----------------------------------------------------------------------------*/
2312          
2313          void main(void )
2314          { 
2315   1              U16_T i;
2316   1          U8_T FlashFlag=0; //flash 
2317   1          U8_T dat[100];
2318   1          U16_T baudRateDiv=0;
2319   1              U8_T flag_store_schedule;
2320   1              ExecuteRuntimeFlag = 1;
2321   1      
2322   1         #if  RS485_EN2
                      Rs485_2_EN = 0;
                 #endif
2325   1      
2326   1              AX11000_Init();
2327   1              UART_Init(0);
2328   1              UART_Init(1);
2329   1              Lcd_Initial();
2330   1      
2331   1          HSUR_InitValue();
2332   1              switch (CSREPR & (BIT6|BIT7))
2333   1                      {
2334   2                  case SCS_25M:
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 39  

2335   2                              baudRateDiv = UR2_BR25_19200;
2336   2                              break;
2337   2                      case SCS_50M:
2338   2                              baudRateDiv = UR2_BR50_19200;
2339   2                              break;
2340   2                      case SCS_100M:
2341   2                              baudRateDiv = UR2_BR100_19200;
2342   2                              break;
2343   2                      }
2344   1      
2345   1              HSUR_Setup(baudRateDiv, (UR2_CHAR_8|UR2_STOP_10), (UR2_RDI_ENB|UR2_RLSI_ENB),
2346   1              (UR2_FIFO_MODE|UR2_RXFIFO_RST|UR2_TXFIFO_RST|UR2_TRIG_08), UR2_RTS);
2347   1              
2348   1          I2C_Init();
2349   1      
2350   1      
2351   1              for(i = 0; i < 100; i++)
2352   1          { 
2353   2                      IntFlashReadByte(0x70000 + i, &dat[i]);
2354   2                      if(dat[i] == 0xff) FlashFlag++;
2355   2          }
2356   1      
2357   1              if(FlashFlag > 90) //if its the time to program
2358   1              {   
2359   2                      IntFlashReadByte(0x6FFFF, &Parame[29]);
2360   2      
2361   2                      E2prom_Read_Byte_From_Absolute_Address(0x0b, Parame + 201);
2362   2                      E2prom_Read_Byte_From_Absolute_Address(0x0a, Parame + 203);
2363   2                      E2prom_Read_Byte_From_Absolute_Address(0x09, Parame + 205);
2364   2                      E2prom_Read_Byte_From_Absolute_Address(0x08, Parame + 207);
2365   2                      E2prom_Read_Byte_From_Absolute_Address(0x07, Parame + 209);
2366   2                      E2prom_Read_Byte_From_Absolute_Address(0x06, Parame + 211);
2367   2      
2368   2                      MassFlashWrite(0, Parame, 400);   //write datas to address 0,length 400 
2369   2              }
2370   1              
2371   1              for(i = 0; i < 400; i++)   //read 
2372   1                      IntFlashReadByte(0x70000 + i, &Para[i]);   //the first para means location,last means array
2373   1      
2374   1              E2prom_Read_Byte_From_Absolute_Address(0x0b, Para + 201);
2375   1              E2prom_Read_Byte_From_Absolute_Address(0x0a, Para + 203);
2376   1              E2prom_Read_Byte_From_Absolute_Address(0x09, Para + 205);
2377   1              E2prom_Read_Byte_From_Absolute_Address(0x08, Para + 207);
2378   1              E2prom_Read_Byte_From_Absolute_Address(0x07, Para + 209);
2379   1              E2prom_Read_Byte_From_Absolute_Address(0x06, Para + 211);
2380   1      
2381   1              Flash_Inital(); 
2382   1              IntFlashReadByte(0x7fff0, &flag_store_schedule);
2383   1              if(flag_store_schedule == 0x55) 
2384   1              {
2385   2                      Flash_Read_Schedule();    // read scheduel data from flash
2386   2              }
2387   1              if(Para[29] != Parame[29])    //botload is changed,user configure can't erase.so if software revision nee
             -d to change
2388   1              {                                                         //there must a mistake on this.//
2389   2                      Para[29] = Parame[29];    //Para[9] is fireware low byte not bootloader version ,alreafy modify.//
2390   2                      Flash_Write_Schedule();   //para[29] is bootloader version. heng@temcocontrols.com//
2391   2              }
2392   1              if(Para[33]==0x1f)                        //if update is not completed,flashing led shows this statement.
2393   1              FlagIsp=1; 
2394   1      
2395   1              display_ip();
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 40  

2396   1              Hardware_Revision = Read_Hardware_Revision();
2397   1      
2398   1      
2399   1      
2400   1       // MAC_SetMacAddr(add_mac);
2401   1      
2402   1        sTaskCreate(TCPIP_Task, (const signed portCHAR * const)"TCPIP_task",
2403   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, (xTaskHandle *)&xHandle1); //0 2
2404   1      
2405   1        sTaskCreate(LedBeat_task, (const signed portCHAR * const)"LedBeat_task",
2406   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle3);  //3
2407   1      
2408   1        sTaskCreate(Timer_task, (const signed portCHAR * const)"Timer_task",
2409   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, (xTaskHandle *)&xHandle2);  //!!!
2410   1      
2411   1         sTaskCreate(Ledflash_task, (const signed portCHAR * const)"Ledflash_task",
2412   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 5, (xTaskHandle *)&xHandle4);  //!!!!
2413   1      
2414   1         sTaskCreate(Uart0_task, (const signed portCHAR * const)"Uart0_task",
2415   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 8, (xTaskHandle *)&xHandle5); //!!!!
2416   1      
2417   1         sTaskCreate(Uart1_task, (const signed portCHAR * const)"Uart1_task",
2418   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 9, (xTaskHandle *)&xHandle6);
2419   1      
2420   1         sTaskCreate(Uart2_task, (const signed portCHAR * const)"Uart2_task",
2421   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 9, (xTaskHandle *)&xHandle9);//!!!!
2422   1      
2423   1         sTaskCreate(Scan_task, (const signed portCHAR * const)"Scan_task",
2424   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 6, (xTaskHandle *)&xHandle12);//8
2425   1      
2426   1         sTaskCreate(Schedule_task, (const signed portCHAR * const)"Schedule_task",
2427   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 6, (xTaskHandle *)&xHandle8);//!!!
2428   1      
2429   1         sTaskCreate(TimeServer_task, (const signed portCHAR * const)"TimeServer_task",
2430   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 7, (xTaskHandle *)&xHandle7);// no 
2431   1      
2432   1         sTaskCreate(UdpBroadcast_task, (const signed portCHAR * const)"UdpBroadcast_task",
2433   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle10);// no 
2434   1      
2435   1          sTaskCreate(USB_task, (const signed portCHAR * const)"USB_task",
2436   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 10, (xTaskHandle *)&xHandle11);//8
2437   1      
2438   1      #if GSM_TASK_ENABLE
                      sTaskCreate(gsm_task, (const signed portCHAR * const)"gsm_task",
                              portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle13);           
              #endif
2442   1                 /*GSM task has a issue that may cause TCPIP task very lag */
2443   1      
2444   1        /* Finally kick off the scheduler.  This function should never return. */
2445   1              vTaskStartScheduler( portUSE_PREEMPTION );
2446   1      }
2447          
2448          
2449          
2450          
2451          
2452          /* End of adapter.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16652    ----
   CONSTANT SIZE    =    393    ----
C51 COMPILER V9.06   MAIN                                                                  05/22/2013 13:52:24 PAGE 41  

   XDATA SIZE       =    778     185
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    215    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
