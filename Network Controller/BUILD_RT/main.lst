C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\main.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\main\main.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\sr
                    -c\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\main.lst) OBJE
                    -CT(.\main.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: adapter.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: adapter.c,v $
  18           * Revision 1.8  2006/05/23 05:22:39  robin6633
  19           * 1.Removed old command input.
  20           *
  21           * Revision 1.7  2006/05/23 01:53:55  robin6633
  22           * 1.Removed debug information from UART2.
  23           *
  24           * Revision 1.6  2006/05/22 05:45:23  robin6633
  25           * 1.Add DNS handle.
  26           *
  27           * Revision 1.5  2006/05/18 07:29:32  robin6633
  28           * 1.Enabled time counter function.
  29           *
  30           * Revision 1.4  2006/05/18 02:13:35  robin6633
  31           * 1.Changed DHCP initial function.
  32           *
  33           * Revision 1.3  2006/05/17 08:34:17  robin6633
  34           * Disabled DHCP function.
  35           *
  36           * Revision 1.2  2006/05/16 05:03:09  robin6633
  37           * no message
  38           *
  39           * Revision 1.1  2006/05/12 14:23:38  robin6633
  40           * no message
  41           *
  42           * Revision 1.2  2006/02/24 00:31:47  borbin
  43           * no message
  44           *
  45           * Revision 1.1.1.1  2006/02/23 00:55:10  borbin
  46           * no message
  47           *
  48           *=============================================================================
  49           */
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 2   

  50          
  51          /* INCLUDE FILE DECLARATIONS */
  52          #include "reg80390.h"
  53          #include "main.h"
  54          #include "adapter.h"
  55          #include "mstimer.h"
  56          #include "ax11000.h"
  57          #include "interrupt.h"
  58          #include "stoe.h"
  59          #include "dma.h"
  60          #include "tcpip.h"
  61          #include "hsuart.h"
  62          #include "printd.h"
  63          #include "uart.h"
  64          #include "flash.h"
  65          #include <stdio.h>
  66          #include <Intrins.h>
  67          
  68          #include "../i2c/e2prom.h" 
  69          
  70          #include "delay.h"  //lihengning
  71          
  72          #if STOE_TRANSPARENT
              //  #include "uip_arp.h"
              #endif
  75          #if (INCLUDE_DHCP_CLIENT)
  76            #include "dhcpc.h"
  77          #endif
  78          #if (INCLUDE_DNS_CLIENT)
                #include "dnsctab.h"
              #endif
  81          
  82          #include "gconfig.h"
  83          //#include "gconfig1.h"
  84          
  85          #include "gudpbc.h"
  86          #include "temperature.h"
  87          #include "httpd.h"
  88          #include "filesys.h"
  89          #include "sntpc.h"
  90          
  91          #include <string.h>
  92          #include "projdefs.h"
  93          #include "portable.h"
  94          #include "task.h"
  95          #include "queue.h"
  96          #include "8563.h"
  97          
  98          #include "schedule.h"
  99          #include "flash_schedule.h"
 100          #include "../USB/ch375_COM.h"
 101          
 102          #include "../LCD/LCD.h"
 103          #include "../scan/scan.h"
 104          #include "modbusTCP.h"
 105          #include "../gsm/gsm.h"
 106          #include "dyndns_app.h"
 107          
 108          /* NAMING CONSTANT DECLARATIONS */
 109          #ifdef DEBUG
              #define DBGMSG(A) {A}
              #else
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 3   

 112          #define DBGMSG(A) {}
 113          #endif
 114          #define TIME_OUT_COUNTER        (250/SWTIMER_INTERVAL)  //250
 115          #define Hardware_Rev22       22
 116          
 117          #define RS485_EN2       0   // if enable new rs485 port
 118          
 119          #define GSM_TASK_ENABLE         0       // if enbale gsm task
 120          
 121          
 122          
 123          extern  GCONFIG_Init1();
 124          
 125          
 126          
 127          volatile char xdata  temco_version[30] _at_ 0x02;
 128          char temco_version[30] = {"model:100 fw:69.11 hw:26"};          //ascii hw:26 bl:14
 129          
 130          extern U8_T bytesN ;
 131          
 132          typedef struct app_buf {
 133                  U32_T ipaddr;
 134                  U8_T buf[100];
 135                  U16_T uip_len;
 136                  U16_T PayLoadOffset;
 137                  U8_T wait;
 138          }APP_BUF;
 139          
 140          APP_BUF XDATA app_arp_buf;
 141          
 142          /* GLOBAL VARIABLES  */
 143          static U16_T ServerBroadcastListenPort;
 144          extern U8_T FlagIsp;
 145          extern U8_T ChangeFlash;
 146          extern U8_T far CRClo;
 147          extern U8_T far CRChi;
 148          extern U8_T far FlagSend;
 149          extern U8_T far Parame[400]; 
 150          extern U8_T far Para[400]; 
 151          enum ledState LED = None;
 152          extern U8_T TsataId;
 153          
 154          #if 1 //lihengning    
 155          extern U8_T  far UartRevNum;  
 156          //extern U16_T far hsurRxCount;
 157          extern U8_T gudpbc_InterAppId;
 158          U8_T TcpSocket_ME;
 159          U8_T Sever_Order = SERVER_NONE;
 160          U8_T Sever_id;
 161          U8_T ChangeIP = 0;
 162          U8_T TcpIp_Scan = 0;
 163          Time_str Time_Server = {0, 0, 0};
 164          U8_T far mac_change_enable = 0;
 165          #endif
 166          
 167          #if (INCLUDE_DNS_CLIENT)
              U8_T XDATA cmdDnsFlag = 0;
              #endif
 170          
 171          static U8_T UpIndex = 0;
 172          U8_T  SYS_FREQUENCY_PERIOD,SYS_FREQUENCY_PERIOD1 ;
 173          
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 4   

 174          
 175          /* LOCAL SUBPROGRAM DECLARATIONS */
 176          //static void UpdateIpSettings(U32_T);
 177          static void CheckArpTable(void);
 178          extern void InitCRC16(void);
 179          extern void CRC16_Tstat(unsigned char ch);
 180          
 181          /* LOCAL VARIABLES DECLARATIONS */
 182          xTaskHandle xHandle1;
 183          xTaskHandle xHandle2;
 184          xTaskHandle xHandle3;
 185          xTaskHandle xHandle4;
 186          xTaskHandle xHandle5;
 187          xTaskHandle xHandle6;
 188          xTaskHandle xHandle7;
 189          xTaskHandle xHandle8;
 190          xTaskHandle xHandle9;   //LHN ADD
 191          xTaskHandle xHandle10;
 192          xTaskHandle xHandle11; 
 193          xTaskHandle xHandle12; 
 194          xTaskHandle xHandle13; 
 195          
 196          
 197             
 198          
 199          char err485=0;
 200          U8_T data LedSta = 0xff;
 201          //U8_T BeatSta=0;
 202          U8_T  far WebText[6][30]={"time.windows.com","time.stdtime.gov.tw","clock.stdtime.gov.tw ",
 203                                     "watch.stdtime.gov.tw", "pool.ntp.org"};
 204          U32_T far IpServer[6]={0x3b7cc454,0xdc829e48,0xda4b0482,0x7ae2c004,0x3b7cc455};
 205          
 206          
 207          
 208          U8_T far test1[5] = {0x54,0x31};
 209          U8_T far test2[2] = {0x45,0x32};
 210          
 211          U8_T  Hardware_Revision;
 212          
 213          
 214          U8_T Read_Hardware_Revision(void)
 215          {
 216   1              return Para[17];
 217   1      }
 218          
 219          
 220          void OSDelay(U8_T x)
 221          {
 222   1              vTaskDelay(x);
 223   1      }
 224          
 225          /*
 226           * ----------------------------------------------------------------------------
 227           * Function Name: UpdateIpSettings
 228           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
 229           * Params:
 230           * Returns:
 231           * Note:
 232           * ----------------------------------------------------------------------------
 233           */
 234          void UpdateIpSettings(U32_T ip)
 235          {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 5   

 236   1               U32_T gateWay,subnet;
 237   1      
 238   1               if(ip > 0)
 239   1               {
 240   2                      ip = STOE_GetIPAddr();
 241   2                      subnet = STOE_GetSubnetMask();
 242   2                      gateWay = STOE_GetGateway();
 243   2              
 244   2                      Para[215]=(U8_T)(ip>>24);
 245   2                      Para[217]=(U8_T)(ip>>16);
 246   2                      Para[219]=(U8_T)(ip>>8);
 247   2                      Para[221]=(U8_T)(ip);
 248   2              
 249   2                      Para[223]=(U8_T)(subnet>>24);
 250   2                      Para[225]=(U8_T)(subnet>>16);
 251   2                      Para[227]=(U8_T)(subnet>>8);
 252   2                      Para[229]=(U8_T)(subnet);
 253   2              
 254   2                      Para[231]=(U8_T)(gateWay>>24);
 255   2                      Para[233]=(U8_T)(gateWay>>16);
 256   2                      Para[235]=(U8_T)(gateWay>>8);
 257   2                      Para[237]=(U8_T)(gateWay);
 258   2              }
 259   1              else
 260   1              {
 261   2                      ip = (((U32_T)Para[215]) << 24) | ((U32_T)Para[217] << 16) | ((U32_T)Para[219] << 8) | (Para[221]);
 262   2                      subnet = (((U32_T)Para[223]) << 24) | ((U32_T)Para[225] << 16) | ((U32_T)Para[227] << 8) | (Para[229]);
 263   2                      gateWay = (((U32_T)Para[231]) << 24) | ((U32_T)Para[233] << 16) | ((U32_T)Para[235] << 8) | (Para[237]);
 264   2                      
 265   2                      TCPIP_SetIPAddr(ip); 
 266   2                      TCPIP_SetSubnetMask(subnet);
 267   2                      TCPIP_SetGateway(gateWay);
 268   2                              
 269   2                      STOE_SetIPAddr(ip); 
 270   2                  STOE_SetSubnetMask(subnet);
 271   2                      STOE_SetGateway(gateWay);
 272   2              
 273   2              }
 274   1      
 275   1      
 276   1      
 277   1      } /* End of UpdateIpSettings */
 278          
 279          /*
 280           * ----------------------------------------------------------------------------
 281           * Function Name: CheckArpTable
 282           * Purpose: Update IP address, subnet mak, gateway IP address and DNS IP address 
 283           * Params:
 284           * Returns:
 285           * Note:
 286           * ----------------------------------------------------------------------------
 287           */
 288          void CheckArpTable(void)
 289          {
 290   1              if (app_arp_buf.wait) 
 291   1              {
 292   2                      U8_T valid = STOE_CHECK_MAC(&app_arp_buf.ipaddr);
 293   2                      if (valid) 
 294   2                      {
 295   3                              DMA_GrantXdata(uip_buf, app_arp_buf.buf, app_arp_buf.uip_len);
 296   3                              PRINTD(DEBUG_MSG ,("send out the packet from arp buffer\n\r"));
 297   3                              uip_len = app_arp_buf.uip_len;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 6   

 298   3                              ETH_Send(app_arp_buf.PayLoadOffset);
 299   3                              uip_len = 0;
 300   3                              app_arp_buf.wait = 0;
 301   3                      }
 302   2              }
 303   1      } /* End of CheckArpTable */
 304          
 305          
 306          
 307          void TCPIP_Task(void)reentrant
 308          {
 309   1         portTickType xDelayPeriod  = ( portTickType ) 200 / portTICK_RATE_MS;  //250
 310   1              
 311   1      
 312   1      #if (BOOTLDR_ISR)
                      ERROR: BOOTLDR_ISR must set to '0' in non-bootloader driver.
              #endif
 315   1      #if (!AX_ETH_INT_ENABLE)
                       ERROR: Must enable ethernet module in this driver.
              #endif
 318   1               U32_T  timeCount,preTimeCount;
 319   1      #if (INCLUDE_DHCP_CLIENT)
 320   1              U8_T    cmdDhcpFlag = 0;
 321   1              U32_T   dhcpTimeStart = 0;
 322   1              U32_T   dhcpTimeStop = 0;
 323   1      #endif
 324   1      
 325   1      //      Uart0_Tx("step1",5);
 326   1      
 327   1      /* Initialize Network adapter */
 328   1              ETH_Init();
 329   1      
 330   1      //      Uart0_Tx("step2",5);
 331   1      
 332   1              DHCP_Init();
 333   1      
 334   1      #if (INCLUDE_DNS_CLIENT)
                      DNSCTAB_Init(); /* include DNS table */
              #endif
 337   1      
 338   1      
 339   1      #if GCONFIG_EEPROM_CONFIG
                      I2C_Init();
              #endif
 342   1      
 343   1      
 344   1      //      Uart0_Tx("step2",5);
 345   1      
 346   1      
 347   1              GCONFIG_Init();
 348   1      
 349   1      
 350   1      
 351   1      
 352   1      #if (INCLUDE_DHCP_CLIENT)       
 353   1              if ( (Para[213] == 1) && ((GCONFIG_GetNetwork() & GCONFIG_NETWORK_DHCP_ENABLE) == GCONFIG_NETWORK_DHCP_EN
             -ABLE) )
 354   1              {
 355   2                      printd("DHCP request... ");
 356   2                      DHCP_Start();
 357   2      #if (!STOE_TRANSPARENT)
 358   2                      STOE_DisableIpFilter();
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 7   

 359   2      #endif
 360   2                      cmdDhcpFlag = 1;
 361   2                      dhcpTimeStart = SWTIMER_Tick();
 362   2              }
 363   1              else
 364   1              {
 365   2                      UpdateIpSettings(0);
 366   2              }
 367   1      #else
                      printd("DHCP module is not included. Use static IP address\n\r");
                      GCONFIG_SetServerDynamicIP(GCONFIG_GetServerStaticIP());                                                
                      GCONFIG_WriteConfigData();
                      GUDPBC_Init(ServerBroadcastListenPort);
              #endif
 373   1      
 374   1      //      Uart0_Tx("step3",5);
 375   1      
 376   1      
 377   1              ServerBroadcastListenPort = 1234; 
 378   1              GUDPBC_Init(ServerBroadcastListenPort);
 379   1      
 380   1              HTTP_Init();
 381   1              MODBUSTCP_Init();         // add modbustcp service instead http modbus old and add webpage feature.
 382   1      
 383   1              FSYS_Init();
 384   1              ETH_Start();
 385   1      
 386   1      //      Uart0_Tx("step4",5);
 387   1      
 388   1              init_dyndns();
 389   1      
 390   1      
 391   1              while (1)
 392   1              {
 393   2      
 394   2      #if (!STOE_TRANSPARENT)
 395   2                      ETH_SendArpToGateway(ETH_CONTINUE_ARP_REQUEST_TO_GATEWAY_AFTER_REPLY);
 396   2      #endif
 397   2      
 398   2                      CheckArpTable();
 399   2      
 400   2      #if (INCLUDE_DHCP_CLIENT)
 401   2                      if (cmdDhcpFlag == 1)
 402   2                      {                       
 403   3                              if (DHCP_GetState() > DHCP_IDLE_STATE)
 404   3                              {
 405   4                                      DHCP_Send();
 406   4                              }
 407   3                              else
 408   3                              {
 409   4                                      UpdateIpSettings(STOE_GetIPAddr());
 410   4      #if (!STOE_TRANSPARENT)
 411   4                                      STOE_EnableIpFilter();
 412   4      #endif
 413   4                                      cmdDhcpFlag = 0;
 414   4                              }
 415   3                      }
 416   2      #endif
 417   2      
 418   2      #if (STOE_GET_INTSTATUS_MODE == STOE_INTERRUPT_MODE)    /* interrupt mode */
                              if (STOE_GetInterruptFlag())
                              {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 8   

                                      STOE_ProcessInterrupt();
                              }
              #else   /* polling mode */
 424   2                      STOE_ProcessInterrupt();
 425   2      #endif
 426   2      
 427   2      #if (!MAC_GET_INTSTATUS_MODE)
 428   2                      if (MAC_GetInterruptFlag())
 429   2                      {
 430   3                              MAC_ProcessInterrupt();
 431   3                      }
 432   2      #else
                              MAC_LinkSpeedChk();
              #endif
 435   2      
 436   2                      timeCount = (U16_T)SWTIMER_Tick();
 437   2                      if ((timeCount- preTimeCount)>= TIME_OUT_COUNTER)
 438   2                      {
 439   3                              preTimeCount = timeCount;
 440   3                              TCPIP_PeriodicCheck();
 441   3                      }
 442   2                      
 443   2             timeCount = (U16_T)SWTIMER_Tick();
 444   2             if(Para[43]==2)
 445   2                 {
 446   3                        SNTPC_GetState();Para[43]=1;
 447   3             }
 448   2      
 449   2      
 450   2      #if (INCLUDE_DNS_CLIENT)
                              if (cmdDnsFlag == 1)
                              {
                                      U8_T state = DNSCTAB_GetState();/* include DNS table */
              
                                      if (state == DNSC_STATE_FREE)
                                      {
                                              cmdDnsFlag = 0;
                                              printf ("Can not find DNS server.\n\r");
                                      }
                                      else if (state == DNSC_STATE_RESPONSED)
                                      {
                                              U32_T   ip;
              
                                              cmdDnsFlag = 0;
              
                                              if ((ip = DNSCTAB_GetIP()) == 0)
                                              {
                                                      printf ("Can not find remote station via DNS server.\n\r");
                                              }
                                              else
                                              {
                                                      printf ("Get IP address from DNS server : %lx\n\r", ip);
                                              }
                                      }
                              }
              #endif
 477   2      
 478   2                 do_dyndns();
 479   2      //        Uart0_Tx("step5",5);
 480   2      
 481   2              }
 482   1      } /* End of main() */
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 9   

 483          
 484          
 485          
 486          U8_T BeatSta = 0;
 487          volatile U8_T far LEDS _at_ 0x200000;   //LED Address > 80000, or will compete with SRAM which the range is 
             -0-0x80000!!
 488          
 489          void Beat_ON(void)//Set Pin low
 490          {
 491   1      
 492   1              if(Hardware_Revision >= Hardware_Rev22)
 493   1               {      DisPlay1 = 0;
 494   2                      DisPlay2 = 1; }
 495   1              else {
 496   2              DisPlay1 = 1;
 497   2              DisPlay2 = 0;  }
 498   1      
 499   1              LE = 0; 
 500   1              LedSta = 0xfd;
 501   1      //      for(i = 0; i < 100; i++);                          
 502   1              LEDS = LedSta;                                                   
 503   1              LE = 1;  
 504   1      }
 505          
 506          void Beat_OFF(void)  //Set Pin high
 507          {
 508   1              if(Hardware_Revision >= Hardware_Rev22)
 509   1               {      DisPlay1 = 0;
 510   2                      DisPlay2 = 1; }
 511   1              else {
 512   2              DisPlay1 = 1;
 513   2              DisPlay2 = 0;  }
 514   1              
 515   1      
 516   1              LE = 0;
 517   1              LedSta = 0xff;                             
 518   1              LEDS = LedSta;                               
 519   1              LE = 1; 
 520   1      }
 521          
 522          void Led_EthSend(void)//Pin set low
 523          {
 524   1              if(Hardware_Revision >= Hardware_Rev22)
 525   1               {      DisPlay1 = 0;
 526   2                      DisPlay2 = 1; }
 527   1              else {
 528   2              DisPlay1 = 1;
 529   2              DisPlay2 = 0;  }
 530   1              
 531   1              
 532   1              LE = 0;
 533   1              if(BeatSta == 0)
 534   1                      LedSta = 0xf7;                                            
 535   1              else
 536   1                      LedSta = 0xf6;                                    
 537   1              LEDS = LedSta;                               
 538   1              LE = 1;                               
 539   1      }
 540          
 541          
 542          
 543          void Led_EthRxD(void) //Pin set low 
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 10  

 544          {
 545   1              if(Hardware_Revision >= Hardware_Rev22)
 546   1               {      DisPlay1 = 0;
 547   2                      DisPlay2 = 1; }
 548   1              else {
 549   2              DisPlay1 = 1;
 550   2              DisPlay2 = 0;  }
 551   1      
 552   1      
 553   1      
 554   1              LE = 0;
 555   1              if(BeatSta == 0)
 556   1                      LedSta = 0xef;                                            
 557   1              else  
 558   1                      LedSta = 0xee;                            
 559   1              LEDS = LedSta; 
 560   1              LE = 1;
 561   1      }
 562          
 563          void Led_485RxD(void)//Pin set low 
 564          {    
 565   1              if(Hardware_Revision >= Hardware_Rev22)
 566   1               {      DisPlay1 = 1;
 567   2                      DisPlay2 = 0; }
 568   1              else {
 569   2              DisPlay1 = 0;
 570   2              DisPlay2 = 1;  }
 571   1              
 572   1              
 573   1              LE = 0;
 574   1              LedSta = 0x7f;                   
 575   1              LEDS = LedSta; 
 576   1              LE = 1;
 577   1      }
 578          
 579          void Led_485Send(void) //Pin set low 
 580          {      
 581   1              if(Hardware_Revision >= Hardware_Rev22)
 582   1               {      DisPlay1 = 1;
 583   2                      DisPlay2 = 0; }
 584   1              else {
 585   2              DisPlay1 = 0;
 586   2              DisPlay2 = 1;  }
 587   1              
 588   1              
 589   1              LE = 0;
 590   1              LedSta = 0xbf;                                     
 591   1              LEDS = LedSta;
 592   1              LE = 1;
 593   1      }
 594          
 595          void Led_485ERR(void) //Pin set low 
 596          {   
 597   1              if(Hardware_Revision >= Hardware_Rev22)
 598   1               {      DisPlay1 = 0;
 599   2                      DisPlay2 = 1; }
 600   1              else {
 601   2              DisPlay1 = 1;
 602   2              DisPlay2 = 0;  }
 603   1      
 604   1      
 605   1      
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 11  

 606   1              LE = 0;
 607   1              if(BeatSta == 0)
 608   1                      LedSta = 0xfb;  
 609   1              else
 610   1                      LedSta = 0xf9;                             
 611   1              LEDS = LedSta; 
 612   1              LE = 1;
 613   1      }
 614          void Led_ReSet(void)
 615          {
 616   1              if(Hardware_Revision >= Hardware_Rev22)
 617   1               {      DisPlay1 = 0;
 618   2                      DisPlay2 = 1; }
 619   1              else {
 620   2              DisPlay1 = 1;
 621   2              DisPlay2 = 0;  }
 622   1              
 623   1              
 624   1      
 625   1              LE = 0;
 626   1              if(BeatSta == 0)
 627   1                      LedSta = 0xff;  
 628   1              else
 629   1                      LedSta = 0xfd;                             
 630   1              LEDS = LedSta; 
 631   1              LE = 1;
 632   1      }
 633          
 634          /************************************************/
 635          /*  heng addd led feature  */
 636          void Led_zigbee_Tx(void)
 637          {
 638   1              if(Hardware_Revision >= Hardware_Rev22)
 639   1               {      DisPlay1 = 1;
 640   2                      DisPlay2 = 0; }
 641   1              else {
 642   2              DisPlay1 = 0;
 643   2              DisPlay2 = 1;  }
 644   1              
 645   1              
 646   1              LE = 0;
 647   1              LedSta = 0xfe;                                     
 648   1              LEDS = LedSta;
 649   1              LE = 1;
 650   1      }
 651          void Led_zigbee_Rx(void)
 652          {
 653   1              if(Hardware_Revision >= Hardware_Rev22)
 654   1               {      DisPlay1 = 1;
 655   2                      DisPlay2 = 0; }
 656   1              else {
 657   2              DisPlay1 = 0;
 658   2              DisPlay2 = 1;  }
 659   1              
 660   1              LE = 0;
 661   1              LedSta = 0xfd;                                     
 662   1              LEDS = LedSta;
 663   1              LE = 1;
 664   1      }
 665          
 666          void Led_USB_Tx(void)
 667          {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 12  

 668   1              if(Hardware_Revision >= Hardware_Rev22)
 669   1               {      DisPlay1 = 1;
 670   2                      DisPlay2 = 0; }
 671   1              else {
 672   2              DisPlay1 = 0;
 673   2              DisPlay2 = 1;  }
 674   1              
 675   1              
 676   1              LE = 0;
 677   1              LedSta = 0xfb;                                     
 678   1              LEDS = LedSta;
 679   1              LE = 1;
 680   1      }
 681          void Led_USB_Rx(void)
 682          {
 683   1              if(Hardware_Revision >= Hardware_Rev22)
 684   1               {      DisPlay1 = 1;
 685   2                      DisPlay2 = 0; }
 686   1              else {
 687   2              DisPlay1 = 0;
 688   2              DisPlay2 = 1;  }
 689   1              
 690   1              LE = 0;
 691   1              LedSta = 0xf7;                                     
 692   1              LEDS = LedSta;
 693   1              LE = 1;
 694   1      }
 695          
 696          void Led_GSM_Tx(void)
 697          {
 698   1              if(Hardware_Revision >= Hardware_Rev22)
 699   1               {      DisPlay1 = 1;
 700   2                      DisPlay2 = 0; }
 701   1              else {
 702   2              DisPlay1 = 0;
 703   2              DisPlay2 = 1;  }
 704   1              
 705   1              
 706   1              LE = 0;
 707   1              LedSta = 0xef;                                     
 708   1              LEDS = LedSta;
 709   1              LE = 1;
 710   1      }
 711          void Led_GSM_Rx(void)
 712          {
 713   1              if(Hardware_Revision >= Hardware_Rev22)
 714   1               {      DisPlay1 = 1;
 715   2                      DisPlay2 = 0; }
 716   1              else {
 717   2              DisPlay1 = 0;
 718   2              DisPlay2 = 1;  }
 719   1              
 720   1              LE = 0;
 721   1              LedSta = 0xdf;                                     
 722   1              LEDS = LedSta;
 723   1              LE = 1;
 724   1      }
 725          
 726          
 727          
 728          
 729          
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 13  

 730          void Led_RS232_Tx(void)
 731          {
 732   1              if(Hardware_Revision >= Hardware_Rev22)
 733   1               {      DisPlay1 = 0;
 734   2                      DisPlay2 = 1; }
 735   1              else {
 736   2              DisPlay1 = 1;
 737   2              DisPlay2 = 0;  }
 738   1              
 739   1              
 740   1              LE = 0;
 741   1              if(BeatSta == 0)
 742   1                      LedSta = 0xdf;                                            
 743   1              else
 744   1                      LedSta = 0xde;                                    
 745   1              LEDS = LedSta;                               
 746   1              LE = 1;                               
 747   1      }
 748          void Led_RS232_Rx(void)
 749          {
 750   1              if(Hardware_Revision >= Hardware_Rev22)
 751   1               {      DisPlay1 = 0;
 752   2                      DisPlay2 = 1; }
 753   1              else {
 754   2              DisPlay1 = 1;
 755   2              DisPlay2 = 0;  }
 756   1      
 757   1      
 758   1      
 759   1              LE = 0;
 760   1              if(BeatSta == 0)
 761   1                      LedSta = 0xbf;                                            
 762   1              else  
 763   1                      LedSta = 0xbe;                            
 764   1              LEDS = LedSta; 
 765   1              LE = 1;
 766   1      }
 767          
 768          
 769          
 770          
 771          
 772          
 773          /*=================================================*/
 774          
 775          void Led_ispSet(void)
 776          {
 777   1              if(Hardware_Revision >= Hardware_Rev22)                                                                                 
 778   1               {      DisPlay1 = 0;
 779   2                      DisPlay2 = 1; }
 780   1              else {
 781   2              DisPlay1 = 1;
 782   2              DisPlay2 = 0;  }
 783   1              
 784   1              
 785   1              
 786   1              LE = 0;                            
 787   1              LEDS = 0xfe;                                                     
 788   1              LE = 1;  
 789   1      }
 790          
 791          /*****************************************/
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 14  

 792          /*****************************************/
 793          /*****Uart0 routine***********************/
 794          
 795          void Uart0_Tx(U8_T *buf,U8_T len)
 796          {     
 797   1              U8_T i;
 798   1      
 799   1              for(i = 0; i < len; i++)
 800   1              { 
 801   2                      FlagSend = 0;
 802   2                      SBUF0 = buf[i];
 803   2                      while(FlagSend == 0);
 804   2              }
 805   1      
 806   1      }
 807          
 808          void Uart0_Receive(void)
 809          {
 810   1              if(uart0_RxCount > 0)
 811   1              {
 812   2      
 813   2                      LED = RS232_OK;
 814   2                                      
 815   2                      
 816   2                      if((uart0_RxBuf[0] == Para[13]) || (uart0_RxBuf[0] == 0xff))//Address of NetControl 
 817   2                      { 
 818   3                              if(uart0_RxBuf[1] == 0x19) //scan Tsnet
 819   3                              {
 820   4                                      Sever_Order = SERVER_RS232;
 821   4                                      Sever_id = uart0_RxBuf[0]; 
 822   4                                      Tx_To_Tstat(uart0_RxBuf, uart0_RxCount);                                                                                                                        
 823   4                              }                                       
 824   3                              else if(uart0_RxBuf[1] == 0x1a) //scan NC
 825   3                              {
 826   4                                      U8_T i; 
 827   4                                      uart0_TxCount = 0;
 828   4                                      uart0_TxBuf[uart0_TxCount++] = uart0_RxBuf[0];
 829   4                                      uart0_TxBuf[uart0_TxCount++] = 0x19;
 830   4                                      uart0_TxBuf[uart0_TxCount++] = Para[13];                                                 
 831   4                                      uart0_TxBuf[uart0_TxCount++] = Para[1];
 832   4                                      uart0_TxBuf[uart0_TxCount++] = Para[3];
 833   4                                      uart0_TxBuf[uart0_TxCount++] = Para[5];
 834   4                                      uart0_TxBuf[uart0_TxCount++] = Para[7];
 835   4                                      InitCRC16();
 836   4                                      for(i = 0; i < uart0_TxCount; i++)
 837   4                                              CRC16_Tstat(uart0_TxBuf[i]);
 838   4                                      uart0_TxBuf[uart0_TxCount++] = CRChi;
 839   4                                      uart0_TxBuf[uart0_TxCount++] = CRClo;                                    
 840   4                                      Uart0_Tx(uart0_TxBuf, uart0_TxCount);   
 841   4                                      uart0_TxCount = 0;
 842   4                              }
 843   3                              else if(uart0_RxBuf[1] == read) 
 844   3                              {       
 845   4                                      U16_T i;
 846   4                                      U8_T far temp_number;
 847   4                                      U8_T far temp_address;
 848   4                                      U8_T far send_buffer;
 849   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
 850   4      
 851   4                                      uart0_TxBuf[0] = uart0_RxBuf[0];
 852   4                                      uart0_TxBuf[1] = uart0_RxBuf[1];
 853   4                                      uart0_TxBuf[2] = 2 * uart0_RxBuf[5];
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 15  

 854   4                                      uart0_TxCount = 3 + uart0_TxBuf[2];
 855   4                                      for(i = 0; i < uart0_RxBuf[5]; i++)
 856   4                                      {
 857   5                                              if((StartAdd + i) < MODBUS_TIMER_ADDRESS) //200
 858   5                                              {  
 859   6                                                      uart0_TxBuf[3 + 2 * i] = Para[2 * (StartAdd + i)];  
 860   6                                                      uart0_TxBuf[4 + 2 * i] = Para[2 * (StartAdd + i) + 1];
 861   6                                              }
 862   5                                              else if(((StartAdd + i) >= MODBUS_TIMER_ADDRESS) && ((StartAdd + i) < (MODBUS_TIMER_ADDRESS + 8))) 
 863   5                                              {
 864   6                                                      //  YEAR  MONTH  WEEK DATE  HOUR  MINUTE  SECOND 
 865   6                                                      uart0_TxBuf[3 + 2 * i] = 0;
 866   6                                                      switch(StartAdd + i - MODBUS_TIMER_ADDRESS)
 867   6                                                      {
 868   7                                                              case 7:
 869   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.sec;
 870   7                                                                      break;  
 871   7                                                              case 6:
 872   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.min;
 873   7                                                                      break;
 874   7                                                              case 5:
 875   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.hour;
 876   7                                                                      break;
 877   7                                                              case 4:
 878   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.day;
 879   7                                                                      break;
 880   7                                                              case 3:
 881   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.dayofweek;
 882   7                                                                      break;
 883   7                                                              case 2:
 884   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.month;
 885   7                                                                      break;
 886   7                                                              case 1:
 887   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.year;
 888   7                                                                      break;
 889   7                                                              case 0:
 890   7                                                                      uart0_TxBuf[4 + 2 * i] = Time.UN.Current.centary;
 891   7                                                                      break;
 892   7                                                      }               
 893   6                                              }
 894   5                                              else if(((StartAdd + i) >= MODBUS_WR_DESCRIP_FIRST) && ((StartAdd + i) < MODBUS_WR_DESCRIP_LAST))
 895   5                                              {
 896   6                                                      temp_number = (StartAdd + i - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
 897   6                                                      temp_address = (StartAdd + i - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE;
 898   6                                                      send_buffer = WR_Roution[temp_number].UN.all[temp_address];
 899   6                                                  if((temp_address == (WR_DESCRIPTION_SIZE - 1)) && (send_buffer != 0xff))
 900   6                                                      {
 901   7                                                              if((send_buffer & 0x80) == 0)
 902   7                                                              {
 903   8                                                                      if(GetBit(temp_number, wr_state_index))
 904   8                                                                              send_buffer |= 0x40;
 905   8                                                                      else
 906   8                                                                              send_buffer &= 0xbf;
 907   8                                                              }
 908   7      
 909   7                                                              if(GetBit(temp_number, holiday1_state_index))
 910   7                                                                      send_buffer |= 0x20;
 911   7                                                              else
 912   7                                                                      send_buffer &= 0xdf;
 913   7      
 914   7                                                              if(GetBit(temp_number, holiday2_state_index))
 915   7                                                                      send_buffer |= 0x10;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 16  

 916   7                                                              else
 917   7                                                                      send_buffer &= 0xef;
 918   7                                                      }
 919   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 920   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
 921   6                                              }
 922   5                                              else if(((StartAdd + i) >= MODBUS_AR_DESCRIP_FIRST) && ((StartAdd + i) < MODBUS_AR_DESCRIP_LAST))
 923   5                                              {
 924   6                                                      temp_number = (StartAdd + i - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;    // line
 925   6                                                      temp_address = (StartAdd + i - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE;
 926   6                                                      send_buffer = AR_Roution[temp_number].UN.all[temp_address];
 927   6      
 928   6                                                      if(temp_address == (AR_DESCRIPTION_SIZE - 1))
 929   6                                                      {
 930   7                                                              if((send_buffer & 0x80) == 0)
 931   7                                                              {
 932   8                                                                      if(GetBit(temp_number, ar_state_index))
 933   8                                                                              send_buffer |= 0x40;
 934   8                                                                      else
 935   8                                                                              send_buffer &= 0xbf;
 936   8                                                              }
 937   7                                                      }
 938   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 939   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
 940   6                                              }
 941   5                                              else if(((StartAdd + i) >= MODBUS_ID_FIRST) && ((StartAdd + i) < MODBUS_ID_LAST))
 942   5                                              {
 943   6                                                      temp_number = (StartAdd + i - MODBUS_ID_FIRST) / ID_SIZE;
 944   6                                                      temp_address = (StartAdd + i - MODBUS_ID_FIRST) % ID_SIZE;
 945   6                                                      send_buffer = ID_Config[temp_number].all[temp_address];
 946   6                      
 947   6                                                      if((temp_address == (ID_SIZE - 1)) && (send_buffer != 0xff))
 948   6                                                      {
 949   7                                                              if((send_buffer & 0x80) == 0)
 950   7                                                              {
 951   8                                                                      if(GetBit(temp_number, output_state_index))
 952   8                                                                              send_buffer |= 0x40;
 953   8                                                                      else
 954   8                                                                              send_buffer &= 0xbf;
 955   8                                                              }
 956   7      
 957   7                                                              if(GetBit(temp_number, schedual1_state_index))
 958   7                                                                      send_buffer |= 0x20;
 959   7                                                              else
 960   7                                                                      send_buffer &= 0xdf;
 961   7      
 962   7                                                              if(GetBit(temp_number, schedual2_state_index))
 963   7                                                                      send_buffer |= 0x10;
 964   7                                                              else
 965   7                                                                      send_buffer &= 0xef;
 966   7                                                      }
 967   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 968   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;   
 969   6                                              }
 970   5                                              else if(((StartAdd + i) >= MODBUS_AR_TIME_FIRST) && ((StartAdd + i) < MODBUS_WR_ONTIME_FIRST))
 971   5                                              {
 972   6                                                      temp_number = (StartAdd + i - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
 973   6                                                      temp_address = (StartAdd + i - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE;
 974   6                                                      send_buffer = AR_Roution[temp_number].Time[temp_address];
 975   6                      
 976   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 977   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 17  

 978   6                                              }
 979   5                                              else if(((StartAdd + i) >= MODBUS_WR_ONTIME_FIRST) && ((StartAdd + i) < MODBUS_WR_OFFTIME_FIRST))
 980   5                                              {
 981   6                                                      temp_number = (StartAdd + i - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;           
 982   6                                                      temp_address = (StartAdd + i - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE;
 983   6                                                      send_buffer = WR_Roution[temp_number].OnTime[temp_address];
 984   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 985   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;
 986   6                                              }
 987   5                                              else if(((StartAdd + i) >= MODBUS_WR_OFFTIME_FIRST) && ((StartAdd + i) < MODBUS_WR_OFFTIME_LAST))
 988   5                                              {
 989   6                                                      temp_number = (StartAdd + i - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
 990   6                                                      temp_address = (StartAdd + i - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE;
 991   6                                                      send_buffer = WR_Roution[temp_number].OffTime[temp_address];
 992   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 993   6                                                      uart0_TxBuf[4 + 2 * i] = send_buffer;                   
 994   6                                              }
 995   5                                              else
 996   5                                              {
 997   6                                                      uart0_TxBuf[3 + 2 * i] = 0;     
 998   6                                                      uart0_TxBuf[4 + 2 * i] = 1;
 999   6                                              }                                               
1000   5                                      } 
1001   4      
1002   4                                      EA = 0;
1003   4                                      InitCRC16();
1004   4                                      for(i = 0; i < uart0_TxCount; i++)
1005   4                                              CRC16_Tstat(uart0_TxBuf[i]);
1006   4                                      uart0_TxBuf[uart0_TxCount++] = CRChi;                        
1007   4                                      uart0_TxBuf[uart0_TxCount++] = CRClo;
1008   4                                      EA = 1;
1009   4      
1010   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1013   4      
1014   4                                      Uart0_Tx(uart0_TxBuf, uart0_TxCount);
1015   4      
1016   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1019   4                                                                                                                      
1020   4                              }
1021   3                              else if(uart0_RxBuf[1] == swrite) 
1022   3                              {
1023   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
1024   4                                      if(StartAdd < 200)
1025   4                                      {
1026   5                                              if(StartAdd == 15) // clear flash to zero
1027   5                                              {
1028   6                                                      if(((uart0_RxBuf[4] << 8) | uart0_RxBuf[5]) == 0x55)
1029   6                                                      {
1030   7                                                              memset(WR_Roution, 0, MAX_WR * WR_STRUCT_LENGTH);
1031   7                                                              memset(AR_Roution, 0, MAX_AR * AR_STRUCT_LENGTH);
1032   7                                                              memset(ID_Config, 0, MAX_ID * ID_SIZE);
1033   7                                                              Para[30] = 0;
1034   7                                                              Para[31] = 0;
1035   7                                                              ChangeFlash = 2;
1036   7                                                      }
1037   6                                              }
1038   5                                              else if(StartAdd == 106)
1039   5                                              {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 18  

1040   6                                                      if((((Para[212] << 8) | Para[213]) == 0) && (((uart0_RxBuf[4] << 8) | uart0_RxBuf[5]) != 0))
1041   6                                                      {
1042   7                                                              Para[212] = uart0_RxBuf[4];
1043   7                                                              Para[213] = uart0_RxBuf[5];
1044   7                                                              ChangeIP = 1;
1045   7                                                              ChangeFlash = 2;
1046   7                                                      }
1047   6                                              }
1048   5                                              else if((StartAdd >= 107) && (StartAdd <= 120)) //IP change ,reset cpu
1049   5                                              {
1050   6                                                      if(((Para[212] << 8) | Para[213]) == 0)
1051   6                                                      {
1052   7                                                              Para[2*uart0_RxBuf[3]] = uart0_RxBuf[4];                //write to bufffer array high bit
1053   7                                                              Para[2*uart0_RxBuf[3] + 1] = uart0_RxBuf[5];    //write to bufffer array low bit
1054   7                                                              ChangeFlash = 2;
1055   7                                                              ChangeIP = 1;
1056   7                                                      }
1057   6                                              }
1058   5                                              else
1059   5                                              {
1060   6                                                      Para[2*uart0_RxBuf[3]] = uart0_RxBuf[4];                //write to bufffer array high bit
1061   6                                                      Para[2*uart0_RxBuf[3] + 1] = uart0_RxBuf[5];    //write to bufffer array low bit
1062   6                                                      ChangeFlash = 2;
1063   6                                              }
1064   5                                      }
1065   4                                      else if((StartAdd >= SCHEDUAL_MODBUS_ADDRESS) && (StartAdd < (SCHEDUAL_MODBUS_ADDRESS + 8)))
1066   4                                      {
1067   5                                              switch(StartAdd - SCHEDUAL_MODBUS_ADDRESS)
1068   5                                              {
1069   6                                                      case 0: //century
1070   6                                                              if(uart0_RxBuf[5] == 19)
1071   6                                                              {
1072   7                                                                      Set_Clock(PCF_MON, Time.UN.Current.month | 0x80);
1073   7                                                              }
1074   6                                                              else if(uart0_RxBuf[5] == 20)
1075   6                                                              {
1076   7                                                                      Set_Clock(PCF_MON, Time.UN.Current.month & 0x7f);
1077   7                                                              }
1078   6                                                              break;
1079   6                                                      case 1: //year
1080   6                                                              Set_Clock(PCF_YEAR, uart0_RxBuf[5]);
1081   6                                                              break;
1082   6                                                      case 2: //month
1083   6                                                              if(Time.UN.Current.centary == 19)
1084   6                                                              {
1085   7                                                                      Set_Clock(PCF_MON, uart0_RxBuf[5] | 0x80);
1086   7                                                              }
1087   6                                                              else if(Time.UN.Current.centary == 20)
1088   6                                                              {
1089   7                                                                      Set_Clock(PCF_MON, uart0_RxBuf[5] & 0x7f);
1090   7                                                              }
1091   6                                                              break;
1092   6                                                      case 3:
1093   6                                                              Set_Clock(PCF_WEEK, uart0_RxBuf[5]);
1094   6                                                              break;
1095   6                                                      case 4: //date
1096   6                                                              Set_Clock(PCF_DAY, uart0_RxBuf[5]);
1097   6                                                              break;
1098   6                                                      case 5: //hour
1099   6                                                              Set_Clock(PCF_HOUR, uart0_RxBuf[5]);
1100   6                                                              break;
1101   6                                                      case 6: //minute
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 19  

1102   6                                                              Set_Clock(PCF_MIN, uart0_RxBuf[5]);
1103   6                                                              break;
1104   6                                                      case 7: //second
1105   6                                                              Set_Clock(PCF_SEC, uart0_RxBuf[5]);
1106   6                                                              break;
1107   6                                              }
1108   5                                      }
1109   4                                      else
1110   4                                      {
1111   5                                              // spare
1112   5                                      }
1113   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1116   4                                      Uart0_Tx(uart0_RxBuf, uart0_RxCount);
1117   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1120   4                              }
1121   3                              else if(uart0_RxBuf[1] == mwrite) //multi_write
1122   3                              {
1123   4                                      U8_T i;
1124   4                                      U16_T StartAdd = (uart0_RxBuf[2] << 8) | uart0_RxBuf[3];
1125   4                                      ChangeFlash = 1;
1126   4                                      if(StartAdd < SCHEDUAL_MODBUS_ADDRESS)
1127   4                                      {
1128   5                                              if((StartAdd == 100) && (uart0_RxBuf[6] == 12))
1129   5                                              {
1130   6                                                      Para[201] = uart0_RxBuf[8];
1131   6                                                      Para[203] = uart0_RxBuf[10];
1132   6                                                      Para[205] = uart0_RxBuf[12];
1133   6                                                      Para[207] = uart0_RxBuf[14];
1134   6                                                      Para[209] = uart0_RxBuf[16];
1135   6                                                      Para[211] = uart0_RxBuf[18];
1136   6                      
1137   6                                                      mac_change_enable = 1;
1138   6                                                      ChangeIP = 1;
1139   6                                              }
1140   5                                          else
1141   5                                              {
1142   6                                                      for(i = 0; i < uart0_RxBuf[6]; i++)
1143   6                                                      {
1144   7                                                              if(((StartAdd + i / 2) < 100) || ((StartAdd + i / 2) > 105))  
1145   7                                                                      Para[2 * StartAdd + i] = uart0_RxBuf[i];
1146   7                                                      } 
1147   6                                              }
1148   5                                      }
1149   4                                      else if(StartAdd == SCHEDUAL_MODBUS_ADDRESS) //200th register ,write time 
1150   4                                      {
1151   5      //                                      if((StartAdd - SCHEDUAL_MODBUS_ADDRESS) % 8 == 0)
1152   5      //                                              memcpy(Time.UN.Setime,&uart0_RxBuf[7], 8);
1153   5                                              if(uart0_RxBuf[5] == 8)
1154   5                                              {
1155   6                                                      if(uart0_RxBuf[5] == uart0_RxBuf[6])
1156   6                                                      {
1157   7                                                              Time.UN.Setime[7] = uart0_RxBuf[14];
1158   7                                                              Time.UN.Setime[6] = uart0_RxBuf[13];
1159   7                                                              Time.UN.Setime[5] = uart0_RxBuf[12];
1160   7                                                              Time.UN.Setime[4] = uart0_RxBuf[11];
1161   7                                                              Time.UN.Setime[3] = uart0_RxBuf[10];
1162   7                                                              if(uart0_RxBuf[7] == 19)
1163   7                                                                      uart0_RxBuf[9] |= 0x80;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 20  

1164   7                                                              else
1165   7                                                                      uart0_RxBuf[9] &= 0x7f;
1166   7                                                              Time.UN.Setime[2] = uart0_RxBuf[9];
1167   7                                                              Time.UN.Setime[1] = uart0_RxBuf[8];
1168   7                                                              Time.UN.Setime[0] = uart0_RxBuf[7];
1169   7                                                      }
1170   6                                                      else
1171   6                                                      {
1172   7                                                              Time.UN.Setime[7] = uart0_RxBuf[22];
1173   7                                                              Time.UN.Setime[6] = uart0_RxBuf[20];
1174   7                                                              Time.UN.Setime[5] = uart0_RxBuf[18];
1175   7                                                              Time.UN.Setime[4] = uart0_RxBuf[16];
1176   7                                                              Time.UN.Setime[3] = uart0_RxBuf[14];
1177   7                                                              if(uart0_RxBuf[8] == 19)
1178   7                                                                      uart0_RxBuf[12] |= 0x80;
1179   7                                                              else
1180   7                                                                      uart0_RxBuf[12] &= 0x7f;
1181   7                                                              Time.UN.Setime[2] = uart0_RxBuf[12];
1182   7                                                              Time.UN.Setime[1] = uart0_RxBuf[10];
1183   7                                                              Time.UN.Setime[0] = uart0_RxBuf[8];
1184   7                                                      }
1185   6                                                      Initial_Clock();
1186   6                                              }
1187   5                                      }
1188   4                                      else if ((StartAdd >= MODBUS_WR_DESCRIP_FIRST) && (StartAdd < MODBUS_WR_DESCRIP_LAST)) //weekly
1189   4                              {                                                               
1190   5                                              if((StartAdd - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE == 0)
1191   5                                              {
1192   6                                                      i = (StartAdd - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
1193   6                                                      memcpy((U8_T *)&WR_Roution[i].UN.all[0], uart0_RxBuf + 7, WR_DESCRIPTION_SIZE);
1194   6                                              }
1195   5                              }
1196   4                                      else if((StartAdd >= MODBUS_AR_DESCRIP_FIRST) && (StartAdd < MODBUS_AR_DESCRIP_LAST))
1197   4                                      {
1198   5                                              if((StartAdd - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE == 0)
1199   5                                              {
1200   6                                                      i = (StartAdd - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;          
1201   6                                                      memcpy((U8_T *)&AR_Roution[i].UN.all[0], uart0_RxBuf + 7, AR_DESCRIPTION_SIZE);
1202   6                                              }
1203   5                                      }
1204   4                                      else if((StartAdd >= MODBUS_ID_FIRST) && (StartAdd < MODBUS_ID_LAST))
1205   4                                      {
1206   5                                              if((StartAdd - MODBUS_ID_FIRST) % ID_SIZE == 0)
1207   5                                              {
1208   6                                                      i = (StartAdd - MODBUS_ID_FIRST) / ID_SIZE;
1209   6                                                      memcpy((U8_T *)&ID_Config[i].all[0], uart0_RxBuf + 7, ID_SIZE);
1210   6                                              }
1211   5                                      }
1212   4                                      else if((StartAdd >= MODBUS_AR_TIME_FIRST) && (StartAdd < MODBUS_AR_TIME_LAST))
1213   4                                      {
1214   5                                              if((StartAdd - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE == 0)
1215   5                                              {
1216   6                                                      i = (StartAdd - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;                   
1217   6                                                      memcpy((U8_T *)&AR_Roution[i].Time[0], uart0_RxBuf + 7, AR_TIME_SIZE);
1218   6                                              }
1219   5                                      }
1220   4                                      else if((StartAdd >= MODBUS_WR_ONTIME_FIRST) && (StartAdd < MODBUS_WR_ONTIME_LAST))
1221   4                                      {
1222   5                                              if((StartAdd - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE == 0)
1223   5                                              {
1224   6                                                      i = (StartAdd - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;
1225   6                                                      memcpy((U8_T *)&WR_Roution[i].OnTime[0], uart0_RxBuf + 7, WR_TIME_SIZE);
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 21  

1226   6                                              }
1227   5                                      }
1228   4                                      else if((StartAdd >= MODBUS_WR_OFFTIME_FIRST) && (StartAdd < MODBUS_WR_OFFTIME_LAST))
1229   4                                      {
1230   5                                              if((StartAdd - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE == 0)
1231   5                                              {
1232   6                                                      i = (StartAdd - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;                                        
1233   6                                                      memcpy((U8_T *)&WR_Roution[i].OffTime[0], uart0_RxBuf + 7 , WR_TIME_SIZE);
1234   6                                              }
1235   5                                      }
1236   4      
1237   4                                      InitCRC16();
1238   4                                      for(i = 0; i < 6; i++)
1239   4                                      {
1240   5                                              uart0_TxBuf[i] = uart0_RxBuf[i];
1241   5                                              CRC16_Tstat(uart0_TxBuf[i]);
1242   5                                      }
1243   4                                      uart0_TxBuf[6] = CRChi;                        
1244   4                                      uart0_TxBuf[7] = CRClo;
1245   4      
1246   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 1;
                                         #endif
1249   4                                      Uart0_Tx(uart0_TxBuf, 8);
1250   4                                 #if  RS485_EN2
                                              Rs485_2_EN = 0;
                                         #endif
1253   4                              }
1254   3                      }
1255   2                      else
1256   2                      {
1257   3                              Sever_Order = SERVER_RS232;
1258   3                              Sever_id = uart0_RxBuf[0];                                
1259   3                              Tx_To_Tstat(uart0_RxBuf, uart0_RxCount);                                                                                                                         
1260   3                      }
1261   2      
1262   2                      uart0_RxCount = 0;    
1263   2              }
1264   1      }
1265          
1266          
1267          /*****************************************/
1268          /*****************************************/
1269          /*****Uart1 routine***********************/
1270          void Uart1_Tx(U8_T *buf,U8_T len)
1271          {     
1272   1              U8_T i;
1273   1              for(i = 0; i < len; i++)
1274   1              { 
1275   2                      FlagSend = 0;
1276   2                      SBUF1 = buf[i];
1277   2                      while(FlagSend == 0);
1278   2              }
1279   1      }
1280          
1281          U8_T forward_buffer[300];
1282          U8_T forward_buffer1[300];
1283          extern U16_T sessonlen;
1284          extern void Set_transaction_ID(U8_T *str, U16_T reg);
1285          
1286          void Uart1_Receive(void)
1287          {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 22  

1288   1              U8_T   i;
1289   1              U16_T  uart1_count = 0;                 
1290   1              U16_T  length = 0;
1291   1              U16_T  uart1_cnt;
1292   1      
1293   1      
1294   1      //      Uart0_Tx(uart1_RxBuf,uart1_RxCount);
1295   1      
1296   1              EA = 0;
1297   1              if(uart1_RxCount)
1298   1              {
1299   2                      if(Sever_Order == 1)
1300   2                      {
1301   3                              Set_transaction_ID(forward_buffer1, sessonlen);
1302   3                              uart1_count = 6;
1303   3      
1304   3                              uart1_cnt = uart1_RxCount;
1305   3                      }
1306   2      
1307   2                      memcpy(forward_buffer1 + uart1_count, uart1_RxBuf, uart1_RxCount);
1308   2      
1309   2      //              Uart0_Tx(uart1_RxBuf,uart1_RxCount);               // for test !
1310   2                      uart1_count += uart1_RxCount;
1311   2                      uart1_RxCount = 0;
1312   2                      EA = 1;
1313   2              
1314   2              }
1315   1              else
1316   1              {
1317   2                      EA = 1;
1318   2                      return;
1319   2              }
1320   1      
1321   1              i = 0;
1322   1              if(uart1_count)
1323   1              {
1324   2                      LED = Zigbee_OK;
1325   2      
1326   2                      if(Sever_Order == SERVER_TCPIP)  //Sever Order is from TCP/IP
1327   2                      {                   
1328   3                       if((forward_buffer1[6] == 0xff)&&(forward_buffer1[6 + 1] == 0x19))
1329   3                       {
1330   4                              //      length = 15;
1331   4                              for(i = 0;((forward_buffer1[9 * i + 6] == 0xff) && (forward_buffer1[9 * i + 7] == 0x19)); i++)
1332   4                              {        
1333   5                                      if(length > uart1_cnt)
1334   5                                              break;
1335   5                                      else
1336   5                                      length = 9 * i + 15;
1337   5                              }
1338   4                       }
1339   3                       else if((forward_buffer1[6 + 1] == 0x03)&&(TsataId == forward_buffer1[6])) 
1340   3                               length = forward_buffer1[6 + 2] + 9 ;          //6head + 3
1341   3      
1342   3                       else if((forward_buffer1[6 + 1] == 0x06)&&(TsataId == forward_buffer1[6]))             
1343   3                               length = 12;
1344   3      
1345   3                       else if((forward_buffer1[6 + 1] == 0x10)&&(TsataId == forward_buffer1[6]))
1346   3                               length = 12 ;
1347   3      
1348   3                       else
1349   3                               length = 0;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 23  

1350   3      
1351   3                              TCPIP_TcpSend(TcpSocket_ME, forward_buffer1, length , TCPIP_SEND_NOT_FINAL);
1352   3      
1353   3              //              Uart0_Tx(forward_buffer,length);
1354   3                      
1355   3                      }
1356   2                      else if(Sever_Order == SERVER_RS232)
1357   2                      {
1358   3                              Uart0_Tx(forward_buffer1, uart1_count);
1359   3      
1360   3                       if((uart1_RxBuf[0] == 0xff)&&(uart1_RxBuf[1] == 0x19))
1361   3                               length = 9;
1362   3                       else 
1363   3                               length = uart1_RxBuf[2] + 5 ;
1364   3      
1365   3                              Uart0_Tx(forward_buffer1, length);
1366   3      
1367   3                      }
1368   2                      else if(Sever_Order == SERVER_USB)
1369   2                      {
1370   3                              memcpy(UpBuf, forward_buffer1, uart1_count);
1371   3                              UpCtr = uart1_count;
1372   3                              UpIndex = 0;
1373   3                              ENDP2_NEED_UP_FLAG = 1;
1374   3                      }
1375   2                      else if(Sever_Order == SERVER_SCHEDULE)
1376   2                      {
1377   3                              if(uart1_count == 8)
1378   3                              {
1379   4                                      U8_T i;
1380   4                                      InitCRC16();
1381   4                                      for(i = 0; i < 6; i++)
1382   4                                              CRC16_Tstat(forward_buffer1[i]);
1383   4      
1384   4                                      if((forward_buffer1[6] == CRChi) && (forward_buffer1[7] == CRClo))
1385   4                                      {
1386   5                                              schedule_flag = 1;
1387   5                                      }
1388   4                              }
1389   3                      }
1390   2                      else if(Sever_Order == SERVER_SCAN)
1391   2                      {
1392   3                              switch(scan_state)
1393   3                              {
1394   4                                      case SCAN_BINSEARCH:
1395   4                                              scan_response_state = MULTIPLE_ID;
1396   4                                              if(uart1_count >= 9) // right
1397   4                                              {
1398   5                                                      U8_T i;
1399   5                                                      InitCRC16();
1400   5                                                      for(i = 0; i < 7; i++)
1401   5                                                              CRC16_Tstat(forward_buffer[i]);
1402   5                      
1403   5                                                      if((forward_buffer[7] == CRChi) && (forward_buffer[8] == CRClo))
1404   5                                                      {
1405   6                                                              if((forward_buffer[0] == 0xff) && (forward_buffer[1] == 0x19)) // double check it is the response f
             -or scan command
1406   6                                                              {
1407   7                                                                      current_db.id = forward_buffer[2];
1408   7                                                                      current_db.sn = ((U32_T)forward_buffer[6] << 24) | ((U32_T)forward_buffer[5] << 16) | ((U32_T)forw
             -ard_buffer[4] << 8) | forward_buffer[3];
1409   7                                                                      if(uart1_count == 9)
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 24  

1410   7                                                                      {
1411   8                                                                              scan_response_state = UNIQUE_ID;
1412   8                                                                      }
1413   7                                                                      else
1414   7                                                                      {
1415   8                                                                              scan_response_state = UNIQUE_ID_FROM_MULTIPLE;
1416   8                                                                      }
1417   7                                                              }
1418   6                                                      }
1419   5                                              }
1420   4                                              // and none tstat in the range will wait timeout in the waitrsponse routine
1421   4                                              break;
1422   4                                      case SCAN_ASSIGN_ID_WITH_SN:
1423   4                                              if(uart1_count == 12) //right
1424   4                                              {
1425   5                                                      scan_response_state = ASSIGN_ID;
1426   5                                              }
1427   4                                              break;
1428   4                              }
1429   3                      }
1430   2      
1431   2                      else
1432   2                      {}
1433   2                      
1434   2                      Sever_Order = SERVER_NONE;
1435   2              }
1436   1      
1437   1      }
1438          
1439          
1440          
1441          
1442          void display_ip(void)
1443          {
1444   1              U8_T adr,i;             //num,
1445   1              U32_T sn,a,b,c,d;
1446   1      
1447   1              a =  Para[7];
1448   1              a = a << 24;
1449   1      
1450   1              b =  Para[5];
1451   1              b = b << 16;
1452   1      
1453   1              c =  Para[3];
1454   1              c = c << 8;
1455   1      
1456   1              d =  Para[1];
1457   1      
1458   1              sn = a + b + c + d ;
1459   1      
1460   1      //      Lcd_Show_String(1,1,"    ",1,12);
1461   1              
1462   1              Lcd_Show_String(3,1,"ip = ",1,5);
1463   1              Lcd_Show_Data(3,6,Para[215],0,1);
1464   1              Lcd_Show_String(3,9,".",1,1);
1465   1              Lcd_Show_Data(3,10,Para[217],0,1);
1466   1              Lcd_Show_String(3,13,".",1,1);
1467   1              Lcd_Show_Data(3,14,Para[219],0,1);
1468   1              Lcd_Show_String(3,15,".",1,1);
1469   1              Lcd_Show_Data(3,16,Para[221],0,1);
1470   1      
1471   1      
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 25  

1472   1              Lcd_Show_String(1,1,"id = ",1,5);
1473   1              Lcd_Show_Data(1,6,Para[13],0,1);
1474   1      
1475   1              Lcd_Show_String(2,1,"sn = ",1,5);
1476   1              Lcd_show_for_32bit(2,6,sn,1);
1477   1      
1478   1              
1479   1              adr = Para[9] % 10 ;
1480   1              i = 1;
1481   1              Lcd_Show_String(4,i,"fw:",1,3);
1482   1              Lcd_Show_Data(4,i+3,Para[11],0,1);
1483   1              Lcd_Show_String(4,i+5,".",1,1);
1484   1      //      Lcd_Show_Data(4,7,adr,0,1);
1485   1              Lcd_Show_Data(4,i+6,Para[9],0,1);
1486   1      
1487   1              Lcd_Show_String(4,i+9,"hw:",1,3);
1488   1              Lcd_Show_Data(4,i+12,Para[17],0,1);
1489   1      
1490   1              Lcd_Show_String(4,i+15,"bl:",1,3);
1491   1              Lcd_Show_Data(4,i+18,Para[29],0,1);
1492   1      
1493   1      
1494   1      //      Lcd_Show_Data(4,adr,(U16_T)(sn >> 16),0,1);
1495   1      //      Lcd_Show_Data(4,adr+4,(U16_T)sn,0,1);
1496   1              Lcd_Show_String(0,1,"Network Controller",1,12);
1497   1      }
1498          
1499          void Display_Updating(void)
1500          {
1501   1      
1502   1              Lcd_Show_String(2,5,"Updating...",1,11);
1503   1      }
1504          
1505          
1506          
1507          /*****Uart2 routine***********************/
1508          void Uart2_Receive(void)
1509          {
1510   1              U16_T uart2_count = 0;
1511   1      
1512   1              EA = 0;
1513   1              if(hsurRxCount)
1514   1              {
1515   2                      if(Sever_Order == SERVER_TCPIP)
1516   2                      {
1517   3                              Set_transaction_ID(forward_buffer, sessonlen);
1518   3                              uart2_count = 6;
1519   3                      }
1520   2      
1521   2                      memcpy(forward_buffer + uart2_count, hsurRxBuffer, hsurRxCount);
1522   2                      uart2_count += hsurRxCount;
1523   2                      hsurRxCount = 0;
1524   2                      EA = 1;
1525   2              }
1526   1              else
1527   1              {
1528   2                      EA = 1;
1529   2                      return;
1530   2              }
1531   1      
1532   1              if(uart2_count)
1533   1              {
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 26  

1534   2                      if(Sever_Order == SERVER_TCPIP)  //Sever Order is from TCPIP
1535   2                      {
1536   3                              if(TcpIp_Scan == 1)
1537   3                              {
1538   4                                      TcpIp_Scan = 0;
1539   4                                      TCPIP_TcpSend(TcpSocket_ME, forward_buffer, uart2_count, TCPIP_SEND_NOT_FINAL);
1540   4                              }
1541   3                              else
1542   3                              {
1543   4                                      TCPIP_TcpSend(TcpSocket_ME, forward_buffer, uart2_count-2, TCPIP_SEND_NOT_FINAL);
1544   4                              
1545   4                               //   Uart0_Tx(forward_buffer,uart2_count-2);
1546   4                              
1547   4                              }
1548   3                      LED = S485_OK;
1549   3              
1550   3                      }
1551   2                      else if(Sever_Order == SERVER_RS232)
1552   2                      {
1553   3                              Uart0_Tx(forward_buffer, uart2_count);
1554   3                              LED = S485_OK;
1555   3                      }
1556   2                      else if(Sever_Order == SERVER_USB)
1557   2                      {
1558   3                              memcpy(UpBuf, forward_buffer, uart2_count);
1559   3                              UpCtr = uart2_count;
1560   3                              UpIndex = 0;
1561   3                              ENDP2_NEED_UP_FLAG = 1;
1562   3                              LED = S485_OK;
1563   3                      }
1564   2                      else if(Sever_Order == SERVER_SCHEDULE) // schedule commands
1565   2                      {
1566   3                              if(uart2_count == 8)
1567   3                              {
1568   4                                      U8_T i;
1569   4                                      InitCRC16();
1570   4                                      for(i = 0; i < 6; i++)
1571   4                                              CRC16_Tstat(forward_buffer[i]);
1572   4      
1573   4                                      if((forward_buffer[6] == CRChi) && (forward_buffer[7] == CRClo))
1574   4                                      {
1575   5                                              schedule_flag = 1;
1576   5                                      }
1577   4                              }       
1578   3                      }
1579   2                      else if(Sever_Order == SERVER_SCAN)
1580   2                      {
1581   3                              switch(scan_state)
1582   3                              {
1583   4                                      case SCAN_BINSEARCH:
1584   4                                              scan_response_state = MULTIPLE_ID;
1585   4                                              if(uart2_count >= 9) // right
1586   4                                              {
1587   5                                                      U8_T i;
1588   5                                                      InitCRC16();
1589   5                                                      for(i = 0; i < 7; i++)
1590   5                                                              CRC16_Tstat(forward_buffer[i]);
1591   5                      
1592   5                                                      if((forward_buffer[7] == CRChi) && (forward_buffer[8] == CRClo))
1593   5                                                      {
1594   6                                                              if((forward_buffer[0] == 0xff) && (forward_buffer[1] == 0x19)) // double check it is the response f
             -or scan command
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 27  

1595   6                                                              {
1596   7                                                                      current_db.id = forward_buffer[2];
1597   7                                                                      current_db.sn = ((U32_T)forward_buffer[6] << 24) | ((U32_T)forward_buffer[5] << 16) | ((U32_T)forw
             -ard_buffer[4] << 8) | forward_buffer[3];
1598   7                                                                      if(uart2_count == 9)
1599   7                                                                      {
1600   8                                                                              scan_response_state = UNIQUE_ID;
1601   8                                                                      }
1602   7                                                                      else
1603   7                                                                      {
1604   8                                                                              scan_response_state = UNIQUE_ID_FROM_MULTIPLE;
1605   8                                                                      }
1606   7                                                              }
1607   6                                                      }
1608   5                                              }
1609   4                                              // and none tstat in the range will wait timeout in the waitrsponse routine
1610   4                                              break;
1611   4                                      case SCAN_ASSIGN_ID_WITH_SN:
1612   4                                              if(uart2_count == 12) //right
1613   4                                              {
1614   5                                                      scan_response_state = ASSIGN_ID;
1615   5                                              }
1616   4                                              break;
1617   4                              }
1618   3                      }
1619   2      
1620   2                      else
1621   2                      {
1622   3                              
1623   3                      }
1624   2                      Sever_Order = SERVER_NONE;
1625   2      
1626   2                      
1627   2              }
1628   1      }
1629          
1630          /********** transmit order to tstat ******************/
1631          void Tx_To_Tstat(U8_T *buf, U8_T len)
1632          {
1633   1              U8_T i;
1634   1      
1635   1              Rs485_EN = 1;
1636   1      
1637   1              Uart1_Tx(buf, len);
1638   1      
1639   1      
1640   1              for(i = 0; i < len; i++)  
1641   1                      HSUR_PutChar(buf[i]);
1642   1      
1643   1              if(len < 10)
1644   1                      DELAY_Ms(1);
1645   1              else
1646   1                      DELAY_Ms((len + 1) / 8);
1647   1      
1648   1              Rs485_EN = 0;
1649   1              
1650   1      }
1651          
1652          void LedBeat_task(void) reentrant
1653          {   U16_T i;
1654   1        
1655   1              portTickType xDelayPeriod = ( portTickType ) 500 / portTICK_RATE_MS;  //2000
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 28  

1656   1          portTickType xDelayPeriod1 = ( portTickType ) 100 / portTICK_RATE_MS;
1657   1      
1658   1              for (;;)                                
1659   1              {       
1660   2                      if(err485)
1661   2                      {
1662   3                              Led_485ERR();
1663   3                              for(i = 0; i < 20000;i++);
1664   3                                      err485 = 0;
1665   3      
1666   3                              vTaskDelay(xDelayPeriod1);
1667   3                      } 
1668   2      //              BeatSta=1;
1669   2                      Beat_ON();
1670   2                      vTaskDelay(xDelayPeriod);
1671   2      //              BeatSta=0;
1672   2                      Beat_OFF() ;
1673   2                      vTaskDelay(xDelayPeriod);                                
1674   2              }
1675   1      }
1676          
1677          void Realtimer_task(void) reentrant
1678          {
1679   1      
1680   1              portTickType xDelayPeriod = ( portTickType ) 1000 / portTICK_RATE_MS;//2 minutes writting flash.
1681   1              
1682   1              for (;;)
1683   1              {   
1684   2                           vTaskDelay(xDelayPeriod);
1685   2                  /* if(SetimeFlag)
1686   2                     { SetimeFlag=0;
1687   2                       Initial_Clock();
1688   2                     }*/
1689   2      
1690   2                              // Uart0_Tx(Data,48);
1691   2                   Read_Clock(2);
1692   2              }
1693   1      
1694   1      }
1695          
1696          
1697          void Timer_task(void) reentrant
1698          {
1699   1              unsigned portLONG       count = 0;
1700   1              portTickType xDelayPeriod = ( portTickType ) 3000 / portTICK_RATE_MS;//3000
1701   1          U16_T i=0;
1702   1              
1703   1              for (;;)
1704   1              {     
1705   2              
1706   2                      if(ChangeFlash == 1)
1707   2                   {  
1708   3                              Flash_Write_Schedule();
1709   3                              ChangeFlash=0;                  
1710   3               }
1711   2                       else if(ChangeFlash == 2)
1712   2                   {  
1713   3                              ChangeFlash=0;          
1714   3                              Flash_Write_Schedule(); 
1715   3                        //  IntFlashErase(ERA_RUN,0x070000);          //erase                             
1716   3                        //  MassFlashWrite(0,Para,400);           //write to flash
1717   3                              
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 29  

1718   3               }
1719   2      
1720   2                       if(ChangeIP > 0)  //LHN add
1721   2                       {
1722   3                              ChangeIP++;
1723   3                              if(ChangeIP >= 4)
1724   3                              {
1725   4                                      ChangeIP = 0;
1726   4      
1727   4                                      if(mac_change_enable == 1)
1728   4                                      {
1729   5                                              E2prom_Write_Byte_To_Absolute_Address(0x0b, Para[201]);
1730   5                                              E2prom_Write_Byte_To_Absolute_Address(0x0a, Para[203]);
1731   5                                              E2prom_Write_Byte_To_Absolute_Address(0x09, Para[205]);
1732   5                                              E2prom_Write_Byte_To_Absolute_Address(0x08, Para[207]);
1733   5                                              E2prom_Write_Byte_To_Absolute_Address(0x07, Para[209]);
1734   5                                              E2prom_Write_Byte_To_Absolute_Address(0x06, Para[211]);
1735   5      
1736   5                                              mac_change_enable = 0;
1737   5                                      }
1738   4      
1739   4                                      lcdreset();
1740   4                                      Lcd_Initial();
1741   4                                      Display_reboot();
1742   4                                      AX11000_SoftReboot();
1743   4                              }
1744   3                      }
1745   2      
1746   2                      Read_Clock(2);
1747   2                      vTaskDelay(xDelayPeriod);
1748   2              }
1749   1      }
1750          
1751          
1752          void Ledflash_task(void) reentrant
1753          {
1754   1              portTickType    xDelayPeriod = ( portTickType ) SYS_FREQUENCY_PERIOD / portTICK_RATE_MS;//200
1755   1              portTickType    xDelayPeriod1 = ( portTickType ) SYS_FREQUENCY_PERIOD1 / portTICK_RATE_MS;//100
1756   1      
1757   1              for (;;)
1758   1              {  
1759   2                if(LED==Ethnet_OK){ Led_EthSend(); vTaskDelay(xDelayPeriod1);Led_EthRxD(); vTaskDelay(xDelayPeri
             -od1);
1760   3                                                        LED= None;Led_ReSet();        }
1761   2      
1762   2      
1763   2                        if(LED==RS232_OK) {   Led_RS232_Tx(); vTaskDelay(xDelayPeriod1); Led_RS232_Rx();      vTaskDelay(xDelayPer
             -iod1);        
1764   3                                                                       LED= None;Led_ReSet(); }
1765   2      
1766   2      
1767   2                if(LED==Zigbee_OK) { Led_zigbee_Tx();  vTaskDelay(xDelayPeriod1);     Led_zigbee_Rx(); vTaskDelay(xD
             -elayPeriod1);
1768   3                                                                 LED= None;Led_ReSet();       
1769   3                                                               }
1770   2      
1771   2      
1772   2                        if(LED==Usb_OK) {     Led_USB_Tx(); vTaskDelay(xDelayPeriod1); Led_USB_Rx();vTaskDelay(xDelayPeriod1);
1773   3                                                                 LED= None;Led_ReSet();       }
1774   2      
1775   2      
1776   2                        if(LED==Gsm_OK) {     }
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 30  

1777   2                 
1778   2      
1779   2                        if(LED==S485_OK){  
1780   3                                            Led_485Send();vTaskDelay(xDelayPeriod1);Led_485RxD();vTaskDelay(xDelayPeriod1);
1781   3                                                    LED=None;Led_ReSet();         }
1782   2                          
1783   2      
1784   2                if(LED==S485_ERR){ Led_485ERR(); vTaskDelay(xDelayPeriod1); vTaskDelay(xDelayPeriod1);
1785   3                                                        LED= None;Led_ReSet();        }
1786   2               
1787   2      
1788   2                     vTaskDelay(xDelayPeriod);
1789   2              }
1790   1      }
1791          
1792          
1793          void Scan_task(void)
1794          {
1795   1              portTickType xDelayPeriod = (portTickType)10000 / portTICK_RATE_MS;
1796   1              init_scan();
1797   1              while(1)
1798   1              {
1799   2                      vTaskDelay(xDelayPeriod);
1800   2                      scan_tstat();
1801   2              }
1802   1      }
1803          
1804          
1805          void Uart0_task(void) reentrant
1806          {
1807   1              portTickType xDelayPeriod  = ( portTickType ) 300 / portTICK_RATE_MS;//1000
1808   1              
1809   1              for (;;)
1810   1          {
1811   2              #if 1
1812   2                      Uart0_Receive();
1813   2                      vTaskDelay(xDelayPeriod);
1814   2              #endif   
1815   2          }           
1816   1        
1817   1      }
1818          
1819          void Uart1_task(void) reentrant
1820          {
1821   1              portTickType xDelayPeriod = ( portTickType ) 40 / portTICK_RATE_MS;//50
1822   1              
1823   1              for (;;)
1824   1          { 
1825   2                      vTaskDelay(xDelayPeriod);
1826   2                      if(uart1_timeout == 0)
1827   2                      {
1828   3                              Uart1_Receive();
1829   3                      }
1830   2              }
1831   1      }
1832          
1833          
1834          void Uart2_task(void) reentrant
1835          {
1836   1              portTickType xDelayPeriod = ( portTickType ) 50 / portTICK_RATE_MS;//1000
1837   1      
1838   1              for (;;)
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 31  

1839   1          { 
1840   2                      vTaskDelay(xDelayPeriod);
1841   2                      if(uart2_timeout == 0)
1842   2                      {
1843   3                              Uart2_Receive();
1844   3                      }
1845   2              }
1846   1      }
1847          
1848          
1849          void Schedule_task(void) reentrant
1850          {
1851   1              static U8_T     count = 0;
1852   1              portTickType xDelayPeriod = ( portTickType ) 500 / portTICK_RATE_MS;//500
1853   1              for (;;)
1854   1              { 
1855   2      #if 1
1856   2      /* implement CaculateTime rution  per 500ms */
1857   2                      CaculateTime();
1858   2      /* implement CheckWeeklyRoutines rution  per 1s */
1859   2                      if(count % 2 == 0)  // 1s
1860   2                      {
1861   3                              //Para[1]++;
1862   3                              CheckWeeklyRoutines();
1863   3                      }
1864   2      /* implement CheckAnnualRoutines rution  per 3s */
1865   2      /* implement CheckIdRoutines rution  per 3s */  
1866   2                      if(count % 6 == 0)  // 3s
1867   2                      {
1868   3                              //Para[3]++;
1869   3                              CheckAnnualRoutines();
1870   3                              CheckIdRoutines();
1871   3                      }
1872   2      
1873   2      #endif          
1874   2                      if(count < 6) count++;
1875   2                      else count = 0;
1876   2      
1877   2                      vTaskDelay(xDelayPeriod);
1878   2              }
1879   1      }
1880          
1881          void TimeServer_task(void) reentrant
1882          {
1883   1              portTickType xDelayPeriod = ( portTickType ) 1000 / portTICK_RATE_MS;  //2000
1884   1          U8_T i;
1885   1              U32_T ip;//ntp.fudan.edu.cn=0x3D812A2C; 0xc0a800c7;192.168.0.199 0x4137150f;time.windows.com
1886   1              U8_T Data[48]={0xd9,0x00,0x0a,0xfa,0x00,0x00,0x00,0x00,0x00,0x01,0x04}; //{0x65,0,0x0b,0};
1887   1              for (;;)
1888   1              { 
1889   2                              Time_Server.Leng++;
1890   2                              if( (Time_Server.Leng == 50000) || (Para[355] == 6))                                                                 
1891   2                              {       
1892   3                                      Para[355] = 0;
1893   3                                      Para[399] = 0;
1894   3      
1895   3                                      ip = ((U32_T)Para[357]) << 24 | ((U32_T)Para[359]) << 16 | ((U32_T)Para[361]) << 8 | (U32_T)Para[363];
1896   3                                      Time_Server.UdpSocket = TCPIP_UdpNew(gudpbc_InterAppId, 0, ip, 1234,123);
1897   3                                      if(Time_Server.UdpSocket != TCPIP_NO_NEW_CONN)
1898   3                                      {
1899   4                                              for(i = 11; i < 40; i++)
1900   4                                                      Data[i] = 0;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 32  

1901   4                                              Data[40] = 0xd2;Data[41] = 0x3c;Data[42] = 0xde;Data[43] = 0xd6;
1902   4                                              Data[44] = 0xe8;Data[45] = 0;Data[46] = 0;Data[47] = 0;                         
1903   4                                      //      Uart0_Tx(Data,48);
1904   4                                      //      DELAY_Ms(5);
1905   4                                              TCPIP_UdpSend(Time_Server.UdpSocket, 0, 0, Data,48);
1906   4                                      }
1907   3                              }
1908   2      
1909   2                              if (Time_Server.Leng >= 50110) 
1910   2                                      Time_Server.Leng = 0;
1911   2                                                              
1912   2                              vTaskDelay(xDelayPeriod);
1913   2                      }
1914   1      }
1915          
1916          void UdpBroadcast_task(void)
1917          {
1918   1              portTickType xDelayPeriod = ( portTickType ) 2000 / portTICK_RATE_MS;
1919   1              while(1)
1920   1              {
1921   2                      vTaskDelay(xDelayPeriod);
1922   2              }
1923   1      }
1924          
1925          
1926          
1927          void USB_task(void)
1928          {
1929   1              U8_T len, length;
1930   1              U16_T StartAdd;
1931   1              portTickType xDelayPeriod = (portTickType)20 / portTICK_RATE_MS;
1932   1      
1933   1              CH375_Init();
1934   1      
1935   1              while(1)
1936   1              {   
1937   2                      vTaskDelay(xDelayPeriod);
1938   2                      if(usb_poll() == TRUE)
1939   2                      {
1940   3                              mCH375Interrupt();
1941   3                      }
1942   2                      else
1943   2                      {
1944   3                              if(USB_timeout == 0)
1945   3                              {
1946   4                                      if(DownCtr > 0)
1947   4                                      {
1948   5                                         LED = Usb_OK;
1949   5      
1950   5                                              if((DownBuf[0] == Para[13]) || (DownBuf[0] == 0xff))    // Address of NetControl 
1951   5                                              { 
1952   6                                                      if(DownBuf[1] == 0x19)          //scan Tsnet
1953   6                                                      {
1954   7                                                              Sever_Order = SERVER_USB;               //USB
1955   7                                                              Sever_id = DownBuf[0];
1956   7                                                              Tx_To_Tstat(DownBuf, DownCtr);                                                                                                                  
1957   7                                                      }                                       
1958   6                                                      else if(DownBuf[1] == 0x1a)     //scan NC
1959   6                                                      { 
1960   7                                                              UpCtr = 0;
1961   7                                                              UpBuf[UpCtr++] = DownBuf[0];
1962   7                                                              UpBuf[UpCtr++] = 0x19;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 33  

1963   7                                                              UpBuf[UpCtr++] = Para[13];                                               
1964   7                                                              UpBuf[UpCtr++] = Para[1];
1965   7                                                              UpBuf[UpCtr++] = Para[3];
1966   7                                                              UpBuf[UpCtr++] = Para[5];
1967   7                                                              UpBuf[UpCtr++] = Para[7];
1968   7                                                              InitCRC16();
1969   7                                                              for(len = 0; len < UpCtr; len++)
1970   7                                                                      CRC16_Tstat(UpBuf[len]);
1971   7                                                              UpBuf[UpCtr++] = CRChi;
1972   7                                                              UpBuf[UpCtr++] = CRClo;
1973   7                                                              UpIndex = 0;
1974   7                                                              ENDP2_NEED_UP_FLAG = 1;                                  
1975   7                                                      }
1976   6                                                      else if(DownBuf[1] == read) 
1977   6                                                      {
1978   7                                                              UpBuf[0] = DownBuf[0];
1979   7                                                              UpBuf[1] = DownBuf[1];
1980   7                                                              length = (DownBuf[4] << 8) | DownBuf[5];
1981   7                                                              UpBuf[2] = 2 * length;
1982   7                                                              UpCtr = 3 + UpBuf[2];
1983   7                                                              StartAdd = (DownBuf[2] << 8) | DownBuf[3];                                                                           
1984   7                                                              for(len = 0; len < length; len++)
1985   7                                                              {
1986   8                                                                      if(StartAdd < 200)
1987   8                                                                      {
1988   9                                                                              UpBuf[3 + 2 * len] = Para[2 * (StartAdd + len)];  
1989   9                                                                              UpBuf[4 + 2 * len] = Para[2 * (StartAdd + len) + 1];
1990   9                                                                      }
1991   8                                                                      else if((StartAdd + len) >= MODBUS_TIMER_ADDRESS) 
1992   8                                                                      {
1993   9                                                                              if(StartAdd + len < MODBUS_TIMER_ADDRESS + 8)
1994   9                                                                              {        
1995  10                                                                              //  YEAR  MONTH  WEEK DATE  HOUR  MINUTE  SECOND 
1996  10                                                                                      UpBuf[3 + 2 * len] = 0;
1997  10                                                                                      switch(StartAdd + len - MODBUS_TIMER_ADDRESS)
1998  10                                                                                      {
1999  11                                                                                              case 7:
2000  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.sec;
2001  11                                                                                                      break;  
2002  11                                                                                              case 6:
2003  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.min;
2004  11                                                                                                      break;
2005  11                                                                                              case 5:
2006  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.hour;
2007  11                                                                                                      break;
2008  11                                                                                              case 4:
2009  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.day;
2010  11                                                                                                      break;
2011  11                                                                                              case 3:
2012  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.dayofweek;
2013  11                                                                                                      break;
2014  11                                                                                              case 2:
2015  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.month;
2016  11                                                                                                      break;
2017  11                                                                                              case 1:
2018  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.year;
2019  11                                                                                                      break;
2020  11                                                                                              case 0:
2021  11                                                                                                      UpBuf[4 + 2 * len] = Time.UN.Current.centary;
2022  11                                                                                                      break;
2023  11                                                                                      }               
2024  10                                                                              }
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 34  

2025   9                                                                              else if(StartAdd + len >= MODBUS_WR_DESCRIP_FIRST && StartAdd + len < MODBUS_WR_DESCRIP_LAST)
2026   9                                                                              {
2027  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_DESCRIP_FIRST) / WR_DESCRIPTION_SIZE;
2028  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_DESCRIP_FIRST) % WR_DESCRIPTION_SIZE;
2029  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].UN.all[temp_address];
2030  10                                                                                  if((temp_address == (WR_DESCRIPTION_SIZE - 1)) && (send_buffer != 0xff))
2031  10                                                                                      {
2032  11                                                                                              if((send_buffer & 0x80) == 0)
2033  11                                                                                              {
2034  12                                                                                                      if(GetBit(temp_number, wr_state_index))
2035  12                                                                                                              send_buffer |= 0x40;
2036  12                                                                                                      else
2037  12                                                                                                              send_buffer &= 0xbf;
2038  12                                                                                              }
2039  11      
2040  11                                                                                              if(GetBit(temp_number, holiday1_state_index))
2041  11                                                                                                      send_buffer |= 0x20;
2042  11                                                                                              else
2043  11                                                                                                      send_buffer &= 0xdf;
2044  11      
2045  11                                                                                              if(GetBit(temp_number, holiday2_state_index))
2046  11                                                                                                      send_buffer |= 0x10;
2047  11                                                                                              else
2048  11                                                                                                      send_buffer &= 0xef;
2049  11                                                                                      }
2050  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2051  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2052  10                                                                              }
2053   9                                                                              else if(StartAdd + len >= MODBUS_AR_DESCRIP_FIRST && StartAdd + len < MODBUS_AR_DESCRIP_LAST)
2054   9                                                                              {
2055  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_AR_DESCRIP_FIRST) / AR_DESCRIPTION_SIZE;    // line
2056  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_AR_DESCRIP_FIRST) % AR_DESCRIPTION_SIZE;
2057  10                                                                                      U8_T send_buffer = AR_Roution[temp_number].UN.all[temp_address];
2058  10                                      
2059  10                                                                                      if(temp_address == (AR_DESCRIPTION_SIZE - 1))
2060  10                                                                                      {
2061  11                                                                                              if((send_buffer & 0x80) == 0)
2062  11                                                                                              {
2063  12                                                                                                      if(GetBit(temp_number, ar_state_index))
2064  12                                                                                                              send_buffer |= 0x40;
2065  12                                                                                                      else
2066  12                                                                                                              send_buffer &= 0xbf;
2067  12                                                                                              }
2068  11                                                                                      }
2069  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2070  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2071  10                                                                              }
2072   9                                                                              else if(StartAdd + len >= MODBUS_ID_FIRST && StartAdd + len < MODBUS_ID_LAST)
2073   9                                                                              {
2074  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_ID_FIRST) / ID_SIZE;
2075  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_ID_FIRST) % ID_SIZE;
2076  10                                                                                      U8_T send_buffer = ID_Config[temp_number].all[temp_address];
2077  10                                                      
2078  10                                                                                      if((temp_address == (ID_SIZE - 1)) && (send_buffer != 0xff))
2079  10                                                                                      {
2080  11                                                                                              if((send_buffer & 0x80) == 0)
2081  11                                                                                              {
2082  12                                                                                                      if(GetBit(temp_number, output_state_index))
2083  12                                                                                                              send_buffer |= 0x40;
2084  12                                                                                                      else
2085  12                                                                                                              send_buffer &= 0xbf;
2086  12                                                                                              }
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 35  

2087  11      
2088  11                                                                                              if(GetBit(temp_number, schedual1_state_index))
2089  11                                                                                                      send_buffer |= 0x20;
2090  11                                                                                              else
2091  11                                                                                                      send_buffer &= 0xdf;
2092  11      
2093  11                                                                                              if(GetBit(temp_number, schedual2_state_index))
2094  11                                                                                                      send_buffer |= 0x10;
2095  11                                                                                              else
2096  11                                                                                                      send_buffer &= 0xef;
2097  11                                                                                      }
2098  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2099  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;       
2100  10                                                                              }
2101   9                                                                              else if(StartAdd + len >= MODBUS_AR_TIME_FIRST && StartAdd + len < MODBUS_WR_ONTIME_FIRST)
2102   9                                                                              {
2103  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_AR_TIME_FIRST) / AR_TIME_SIZE;
2104  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_AR_TIME_FIRST) % AR_TIME_SIZE;
2105  10                                                                                      U8_T send_buffer = AR_Roution[temp_number].Time[temp_address];
2106  10                                                      
2107  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2108  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;
2109  10                                                                              }
2110   9                                                                              else if(StartAdd + len >= MODBUS_WR_ONTIME_FIRST && StartAdd + len < MODBUS_WR_OFFTIME_FIRST)
2111   9                                                                              {
2112  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_ONTIME_FIRST) / WR_TIME_SIZE;            
2113  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_ONTIME_FIRST) % WR_TIME_SIZE;
2114  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].OnTime[temp_address];
2115  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2116  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;
2117  10                                                                              }
2118   9                                                                              else if(StartAdd + len >= MODBUS_WR_OFFTIME_FIRST && StartAdd + len < MODBUS_TOTAL_PARAMETERS)
2119   9                                                                              {
2120  10                                                                                      U8_T temp_number = (StartAdd + len - MODBUS_WR_OFFTIME_FIRST) / WR_TIME_SIZE;
2121  10                                                                                      U8_T temp_address = (StartAdd + len - MODBUS_WR_OFFTIME_FIRST) % WR_TIME_SIZE;
2122  10                                                                                      U8_T send_buffer = WR_Roution[temp_number].OffTime[temp_address];
2123  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2124  10                                                                                      UpBuf[4 + 2 * len] = send_buffer;                       
2125  10                                                                              }
2126   9      //                                                                      else if(StartAdd==0xee10) //for ISP read address of 0xee10
2127   9      //                                                                      {  
2128   9      //                                                                              RealNum = 2;
2129   9      //                                                                              send_tcp[UIP_HEAD] = uip_appdata[UIP_HEAD];//
2130   9      //                                                                              send_tcp[UIP_HEAD+1] = READ_VARIABLES;//
2131   9      //                                                                              send_tcp[UIP_HEAD+2] = RealNum;
2132   9      //                                                                              send_tcp[UIP_HEAD+3] = send_tcp[UIP_HEAD+4]=0;//00                              
2133   9      //                                                                      }
2134   9                                                                              else
2135   9                                                                              {
2136  10                                                                                      UpBuf[3 + 2 * len] = 0; 
2137  10                                                                                      UpBuf[4 + 2 * len] = 1;
2138  10                                                                              }                                               
2139   9                                                                      } 
2140   8                                                              }
2141   7      
2142   7                                                              InitCRC16();
2143   7                                                              for(len = 0; len < UpCtr; len++)
2144   7                                                                      CRC16_Tstat(UpBuf[len]);
2145   7      
2146   7                                                              UpBuf[UpCtr++] = CRChi;                        
2147   7                                                              UpBuf[UpCtr++] = CRClo;
2148   7      
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 36  

2149   7                                                              UpIndex = 0;
2150   7                                                              ENDP2_NEED_UP_FLAG = 1;                                                                                         
2151   7                                                      }
2152   6                                                      else if(DownBuf[1] == swrite) 
2153   6                                                      {
2154   7                                                              if(((DownBuf[2] << 8) | DownBuf[3]) < 200)
2155   7                                                              {
2156   8                                                                      if(((DownBuf[2] << 8) | DownBuf[3]) == 106)
2157   8                                                                      {
2158   9                                                                              if((((Para[212] << 8) | Para[213]) == 0) && (((DownBuf[4] << 8) | DownBuf[5]) != 0))
2159   9                                                                              {
2160  10                                                                                      Para[212] = DownBuf[4];
2161  10                                                                                      Para[213] = DownBuf[5];
2162  10                                                                                      ChangeIP = 1;
2163  10                                                                                      ChangeFlash = 2;
2164  10                                                                              }
2165   9                                                                      }
2166   8                                                                      else if((((DownBuf[2] << 8) | DownBuf[3]) >= 107) && (((DownBuf[2] << 8) | DownBuf[3]) <= 120)) //
             -IP change ,reset cpu
2167   8                                                                      {
2168   9                                                                              if(((Para[212] << 8) | Para[213]) == 0)
2169   9                                                                              {
2170  10                                                                                      Para[2*DownBuf[3]] = DownBuf[4];                //write to bufffer array high bit
2171  10                                                                                      Para[2*DownBuf[3] + 1] = DownBuf[5];    //write to bufffer array low bit
2172  10                                                                                      ChangeFlash = 2;
2173  10                                                                                      ChangeIP = 1;
2174  10                                                                              }
2175   9                                                                      }
2176   8                                                                      else
2177   8                                                                      {
2178   9                                                                              Para[2*DownBuf[3]] = DownBuf[4];                        //write to bufffer array high bit
2179   9                                                                              Para[2*DownBuf[3] + 1] = DownBuf[5];            //write to bufffer array low bit
2180   9                                                                              ChangeFlash = 2;
2181   9                                                                      }
2182   8                                                              }
2183   7      
2184   7                                                              for(len = 0; len < DownCtr; len++)
2185   7                                                                      UpBuf[len] = DownBuf[len];
2186   7      
2187   7                                                              UpCtr = len;
2188   7                                                              UpIndex = 0;
2189   7                                                              ENDP2_NEED_UP_FLAG = 1;
2190   7                                                      }
2191   6                                              }
2192   5                                              else
2193   5                                              {
2194   6                                                      Sever_Order = SERVER_USB;               //USB
2195   6                                                      Sever_id = DownBuf[0];                            
2196   6                                                      Tx_To_Tstat(DownBuf, DownCtr);                                                                                                                   
2197   6                                              } 
2198   5                                              
2199   5                                              DownCtr = 0;
2200   5                                      }
2201   4                              }
2202   3      
2203   3                              if((ENDP2_NEED_UP_FLAG == 1) && (ENDP2_UP_SUC_FLAG == 1) && UpCtr)
2204   3                              {
2205   4                                      ENDP2_UP_SUC_FLAG = 0;
2206   4                                      if(UpCtr > BULK_IN_ENDP_MAX_SIZE)
2207   4                                      {
2208   5                                              length = BULK_IN_ENDP_MAX_SIZE;
2209   5                                              UpCtr -= BULK_IN_ENDP_MAX_SIZE;
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 37  

2210   5                                      }
2211   4                                      else
2212   4                                      {
2213   5                                              length = UpCtr;
2214   5                                              UpCtr = 0;
2215   5                                              ENDP2_NEED_UP_FLAG = 0;
2216   5                                      }
2217   4      
2218   4                                      CH375_WR_CMD_PORT(CMD_WR_USB_DATA7);                    // 2
2219   4                                      CH375_WR_DAT_PORT(length);
2220   4                                      for(len = 0; len < length; len++)
2221   4                                              CH375_WR_DAT_PORT(UpBuf[UpIndex++]);
2222   4                              }
2223   3                      }
2224   2              }
2225   1      }
2226          
2227          
2228          BOOL send_out = TRUE;
2229          U8_T test_setpoint[] = { 0xfe, 0x06, 0x01, 0x5b, 0x00, 0x19, 0x2c, 0x20}; 
2230          U8_T rev_cnt = 0;
2231          
2232          void gsm_task(void) reentrant                                           // LJ
2233          {
2234   1              U8_T end_ch = 0x1a;
2235   1              char temp_gsm[100];
2236   1              portTickType xDelayPeriod = ( portTickType)     1000 / portTICK_RATE_MS;
2237   1      
2238   1              gsm_init();                     // LJ
2239   1          
2240   1              for (;;)
2241   1              {
2242   2                      vTaskDelay(xDelayPeriod);
2243   2      
2244   2      //         GSM_SWITCH = ~GSM_SWITCH;
2245   2      
2246   2                      switch ( g_state)
2247   2                      {
2248   3                              case GSM_INITING:
2249   3                                      gsm_module_init();
2250   3                                      break;
2251   3                              case GSM_ERROR:
2252   3      //                              gsm_debug( "RETURN ERROR");
2253   3                                      break;
2254   3                              case GSM_INIT_DONE:
2255   3                                      if(0)          // wait for temperature register
2256   3                                      {
2257   4                                              if(send_out)
2258   4                                              {
2259   5                                                      sprintf( temp_gsm, "AT+CMGS=\"%s\"", &phoneNumber[3]);
2260   5                                                      send_at_cmd( temp_gsm);
2261   5                                                      MicroWait(65000);
2262   5                                                      send_at_cmd( "NetworkController");
2263   5                                                                      simulate_write_byte(0x1a);
2264   5                                              //      Uart1_Tx( &end_ch, 1);
2265   5                                                      //g_state = SMS_SENDING;
2266   5                                                      send_out = FALSE;
2267   5                                              }
2268   4                                      }
2269   3                                      break;                          
2270   3                              case SMS_READY:
2271   3                                      send_at_cmd( "Test GSM module first time");
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 38  

2272   3                              //      Uart1_Tx( &end_ch, 1);
2273   3                              simulate_write_byte(0x1a);
2274   3                                      g_state = GSM_INIT_DONE;
2275   3                                      break;
2276   3                              case SMS_SEND_SUCCESS:
2277   3                                      g_state = GSM_INIT_DONE;
2278   3                                      break;
2279   3                              case GET_MSG:
2280   3      //                              gsm_debug( "send cmgr");
2281   3                                      send_at_cmd( "AT+CMGR=1");
2282   3                                      rev_cnt++;
2283   3                                      g_state = GSM_INIT_DONE;
2284   3                                      if( rev_cnt > 9)
2285   3                                      {
2286   4                                              g_state = GSM_INIT_DONE;
2287   4                                              rev_cnt = 0;
2288   4                                              send_at_cmd( "AT+CMGD=1");                         // 10
2289   4                                      }
2290   3                                      break;
2291   3                              case SET_POINT:
2292   3                                      Tx_To_Tstat( test_setpoint, 8);
2293   3                                      g_state = GSM_INIT_DONE;
2294   3                                      break;
2295   3                              default:
2296   3                                      break;
2297   3                      }
2298   2                      if( gsm_RxBuf.size > 1)
2299   2                      {
2300   3                              gsm_msg_process (gsm_RxBuf.buf); 
2301   3                      }
2302   2              }
2303   1      }
2304          
2305          
2306          
2307          
2308          /*
2309           * ----------------------------------------------------------------------------
2310           * Function Name: main
2311           * Purpose:
2312           * Params:
2313           * Returns:
2314           * Note:
2315           * ----------------------------------------------------------------------------*/
2316          
2317          void main(void )
2318          { 
2319   1              U16_T i;
2320   1          U8_T FlashFlag=0; //flash 
2321   1          U8_T dat[100];
2322   1          U16_T baudRateDiv=0;
2323   1              U8_T flag_store_schedule;
2324   1              ExecuteRuntimeFlag = 1;
2325   1      
2326   1         #if  RS485_EN2
                      Rs485_2_EN = 0;
                 #endif
2329   1      
2330   1              AX11000_Init();
2331   1              UART_Init(0);
2332   1              UART_Init(1);
2333   1              Lcd_Initial();
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 39  

2334   1      
2335   1          HSUR_InitValue();
2336   1              switch (CSREPR & (BIT6|BIT7))
2337   1                      {
2338   2                  case SCS_25M:
2339   2                              baudRateDiv = UR2_BR25_19200;
2340   2                              break;
2341   2                      case SCS_50M:
2342   2                              baudRateDiv = UR2_BR50_19200;
2343   2                              break;
2344   2                      case SCS_100M:
2345   2                              baudRateDiv = UR2_BR100_19200;
2346   2                              break;
2347   2                      }
2348   1      
2349   1              HSUR_Setup(baudRateDiv, (UR2_CHAR_8|UR2_STOP_10), (UR2_RDI_ENB|UR2_RLSI_ENB),
2350   1              (UR2_FIFO_MODE|UR2_RXFIFO_RST|UR2_TXFIFO_RST|UR2_TRIG_08), UR2_RTS);
2351   1              
2352   1          I2C_Init();
2353   1      
2354   1      
2355   1              for(i = 0; i < 100; i++)
2356   1          { 
2357   2                      IntFlashReadByte(0x70000 + i, &dat[i]);
2358   2                      if(dat[i] == 0xff) FlashFlag++;
2359   2          }
2360   1      
2361   1              if(FlashFlag > 90) //if its the time to program
2362   1              {   
2363   2                      IntFlashReadByte(0x6FFFF, &Parame[29]);
2364   2      
2365   2                      E2prom_Read_Byte_From_Absolute_Address(0x0b, Parame + 201);
2366   2                      E2prom_Read_Byte_From_Absolute_Address(0x0a, Parame + 203);
2367   2                      E2prom_Read_Byte_From_Absolute_Address(0x09, Parame + 205);
2368   2                      E2prom_Read_Byte_From_Absolute_Address(0x08, Parame + 207);
2369   2                      E2prom_Read_Byte_From_Absolute_Address(0x07, Parame + 209);
2370   2                      E2prom_Read_Byte_From_Absolute_Address(0x06, Parame + 211);
2371   2      
2372   2                      MassFlashWrite(0, Parame, 400);   //write datas to address 0,length 400 
2373   2              }
2374   1              
2375   1              for(i = 0; i < 400; i++)   //read 
2376   1                      IntFlashReadByte(0x70000 + i, &Para[i]);   //the first para means location,last means array
2377   1      
2378   1              E2prom_Read_Byte_From_Absolute_Address(0x0b, Para + 201);
2379   1              E2prom_Read_Byte_From_Absolute_Address(0x0a, Para + 203);
2380   1              E2prom_Read_Byte_From_Absolute_Address(0x09, Para + 205);
2381   1              E2prom_Read_Byte_From_Absolute_Address(0x08, Para + 207);
2382   1              E2prom_Read_Byte_From_Absolute_Address(0x07, Para + 209);
2383   1              E2prom_Read_Byte_From_Absolute_Address(0x06, Para + 211);
2384   1      
2385   1              Flash_Inital(); 
2386   1              IntFlashReadByte(0x7fff0, &flag_store_schedule);
2387   1              if(flag_store_schedule == 0x55) 
2388   1              {
2389   2                      Flash_Read_Schedule();    // read scheduel data from flash
2390   2              }
2391   1              if(Para[29] != Parame[29])    //botload is changed,user configure can't erase.so if software revision nee
             -d to change
2392   1              {                                                         //there must a mistake on this.//
2393   2                      Para[29] = Parame[29];    //Para[9] is fireware low byte not bootloader version ,alreafy modify.//
2394   2                      Flash_Write_Schedule();   //para[29] is bootloader version. heng@temcocontrols.com//
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 40  

2395   2              }
2396   1              if(Para[33]==0x1f)                        //if update is not completed,flashing led shows this statement.
2397   1              FlagIsp=1; 
2398   1      
2399   1              display_ip();
2400   1              Hardware_Revision = Read_Hardware_Revision();
2401   1      
2402   1      
2403   1      
2404   1       // MAC_SetMacAddr(add_mac);
2405   1      
2406   1        sTaskCreate(TCPIP_Task, (const signed portCHAR * const)"TCPIP_task",
2407   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, (xTaskHandle *)&xHandle1); //0 2
2408   1      
2409   1        sTaskCreate(LedBeat_task, (const signed portCHAR * const)"LedBeat_task",
2410   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle3);  //3
2411   1      
2412   1        sTaskCreate(Timer_task, (const signed portCHAR * const)"Timer_task",
2413   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, (xTaskHandle *)&xHandle2);  //!!!
2414   1      
2415   1         sTaskCreate(Ledflash_task, (const signed portCHAR * const)"Ledflash_task",
2416   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 5, (xTaskHandle *)&xHandle4);  //!!!!
2417   1      
2418   1         sTaskCreate(Uart0_task, (const signed portCHAR * const)"Uart0_task",
2419   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 8, (xTaskHandle *)&xHandle5); //!!!!
2420   1      
2421   1         sTaskCreate(Uart1_task, (const signed portCHAR * const)"Uart1_task",
2422   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 9, (xTaskHandle *)&xHandle6);
2423   1      
2424   1         sTaskCreate(Uart2_task, (const signed portCHAR * const)"Uart2_task",
2425   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 9, (xTaskHandle *)&xHandle9);//!!!!
2426   1      
2427   1         sTaskCreate(Scan_task, (const signed portCHAR * const)"Scan_task",
2428   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 6, (xTaskHandle *)&xHandle12);//8
2429   1      
2430   1         sTaskCreate(Schedule_task, (const signed portCHAR * const)"Schedule_task",
2431   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 6, (xTaskHandle *)&xHandle8);//!!!
2432   1      
2433   1         sTaskCreate(TimeServer_task, (const signed portCHAR * const)"TimeServer_task",
2434   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 7, (xTaskHandle *)&xHandle7);// no 
2435   1      
2436   1         sTaskCreate(UdpBroadcast_task, (const signed portCHAR * const)"UdpBroadcast_task",
2437   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle10);// no 
2438   1      
2439   1          sTaskCreate(USB_task, (const signed portCHAR * const)"USB_task",
2440   1                      portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 10, (xTaskHandle *)&xHandle11);//8
2441   1      
2442   1      #if GSM_TASK_ENABLE
                      sTaskCreate(gsm_task, (const signed portCHAR * const)"gsm_task",
                              portMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, (xTaskHandle *)&xHandle13);           
              #endif
2446   1                 /*GSM task has a issue that may cause TCPIP task very lag */
2447   1      
2448   1        /* Finally kick off the scheduler.  This function should never return. */
2449   1              vTaskStartScheduler( portUSE_PREEMPTION );
2450   1      }
2451          
2452          
2453          
2454          
2455          
2456          /* End of adapter.c */
C51 COMPILER V9.06   MAIN                                                                  05/28/2013 16:06:33 PAGE 41  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16656    ----
   CONSTANT SIZE    =    393    ----
   XDATA SIZE       =    778     185
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    215    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
