C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE BVLC
OBJECT MODULE PLACED IN .\bvlc.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\bvlc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD) DEFINE(KEIL_AX11000) VARBANKING DE
                    -BUG PRINT(.\bvlc.lst) OBJECT(.\bvlc.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2006 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          
  35          #include <stdint.h>     /* for standard integer types uint8_t etc. */
  36          #include <stdbool.h>    /* for the standard bool type. */
  37          //#include <time.h>
  38          //#include "../include/time.h"
  39          #include "../include/t_time.h"
  40          #include "../include/bacenum.h"
  41          #include "../include/bacdcode.h"
  42          #include "../include/bacint.h"
  43          #include "../include/bvlc.h"
  44          #include "../include/bip.h"
  45          #include <string.h>
  46          
  47          
  48          #ifndef DEBUG_ENABLED
  49          #define DEBUG_ENABLED 0
  50          #endif
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 2   

  51          //#include "debug.h"
  52          
  53          /** @file bvlc.c  Handle the BACnet Virtual Link Control (BVLC),
  54           * which includes: BACnet Broadcast Management Device,
  55           * Broadcast Distribution Table, and
  56           * Foreign Device Registration.
  57           */
  58          
  59          /** if we are a foreign device, store the
  60             remote BBMD address/port here in network byte order */
  61          static struct sockaddr_in Remote_BBMD;
  62          
  63          /** result from a client request */
  64          BACNET_BVLC_RESULT BVLC_Result_Code = BVLC_RESULT_SUCCESSFUL_COMPLETION;
  65          
  66          /** The current BVLC Function Code being handled. */
  67          BACNET_BVLC_FUNCTION BVLC_Function_Code = BVLC_RESULT;  /* A safe default */
  68          
  69          /* Define BBMD_ENABLED to get the functions that a
  70           * BBMD needs to handle its services.
  71           * Separately, define BBMD_CLIENT_ENABLED to get the
  72           * functions that allow a client to manage a BBMD.
  73           */
  74          #if defined(BBMD_ENABLED) && BBMD_ENABLED
  75          
  76          typedef struct {
  77              /* true if valid entry - false if not */
  78              bool valid;
  79              /* BACnet/IP address */
  80              struct in_addr dest_address;        /* in network format */
  81              /* BACnet/IP port number - not always 47808=BAC0h */
  82              uint16_t dest_port; /* in network format */
  83              /* Broadcast Distribution Mask */
  84              struct in_addr broadcast_mask;      /* in tework format */
  85          } BBMD_TABLE_ENTRY;
  86          
  87          #ifndef MAX_BBMD_ENTRIES
  88          #define MAX_BBMD_ENTRIES 128
  89          #endif
  90          static BBMD_TABLE_ENTRY BBMD_Table[MAX_BBMD_ENTRIES];
  91          
  92          /*Each device that registers as a foreign device shall be placed
  93          in an entry in the BBMD's Foreign Device Table (FDT). Each
  94          entry shall consist of the 6-octet B/IP address of the registrant;
  95          the 2-octet Time-to-Live value supplied at the time of
  96          registration; and a 2-octet value representing the number of
  97          seconds remaining before the BBMD will purge the registrant's FDT
  98          entry if no re-registration occurs. This value will be initialized
  99          to the 2-octet Time-to-Live value supplied at the time of
 100          registration.*/
 101          typedef struct {
 102              bool valid;
 103              /* BACnet/IP address */
 104              struct in_addr dest_address;
 105              /* BACnet/IP port number - not always 47808=BAC0h */
 106              uint16_t dest_port;
 107              /* seconds for valid entry lifetime */
 108              uint16_t time_to_live;
 109              /* our counter */
 110              time_t seconds_remaining;   /* includes 30 second grace period */
 111          } FD_TABLE_ENTRY;
 112          
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 3   

 113          #ifndef MAX_FD_ENTRIES
 114          #define MAX_FD_ENTRIES 128
 115          #endif
 116          static FD_TABLE_ENTRY FD_Table[MAX_FD_ENTRIES];
 117          
 118          
 119          void bvlc_maintenance_timer(
 120              time_t seconds)
 121          {
 122   1          unsigned i = 0;
 123   1      
 124   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 125   2              if (FD_Table[i].valid) {
 126   3                  if (FD_Table[i].seconds_remaining) {
 127   4                      if (FD_Table[i].seconds_remaining < seconds) {
 128   5                          FD_Table[i].seconds_remaining = 0;
 129   5                      } else {
 130   5                          FD_Table[i].seconds_remaining -= seconds;
 131   5                      }
 132   4                      if (FD_Table[i].seconds_remaining == 0) {
 133   5                          FD_Table[i].valid = false;
 134   5                      }
 135   4                  }
 136   3              }
 137   2          }
 138   1      }
 139          
 140          /* copy the source internet address to the BACnet address */
 141          /* FIXME: IPv6? */
 142          static void bvlc_internet_to_bacnet_address(
 143              BACNET_ADDRESS * src,       /* returns the BACnet source address */
 144              struct sockaddr_in *sin)
 145          {       /* source address in network order */
 146   1      
 147   1          if (src && sin) {
 148   2              memcpy(&src->mac[0], &sin->sin_addr.s_addr, 4);
 149   2              memcpy(&src->mac[4], &sin->sin_port, 2);
 150   2              src->mac_len = (uint8_t) 6;
 151   2              src->net = 0;
 152   2              src->len = 0;
 153   2          }
 154   1      
 155   1          return;
 156   1      }
 157          
 158          /* Addressing within B/IP Networks
 159             In the case of B/IP networks, six octets consisting of the four-octet
 160             IP address followed by a two-octet UDP port number (both of
 161             which shall be transmitted most significant octet first).
 162             Note: for local storage, the storage order is NETWORK byte order.
 163             Note: BACnet unsigned is encoded as most significant octet. */
 164          static int bvlc_encode_bip_address(
 165              uint8_t * pdu,      /* buffer to store encoding */
 166              struct in_addr *address,    /* in network format */
 167              uint16_t port)
 168          {       /* in network format */
 169   1          int len = 0;
 170   1      
 171   1          if (pdu) {
 172   2              memcpy(&pdu[0], &address->s_addr, 4);
 173   2              memcpy(&pdu[4], &port, 2);
 174   2              len = 6;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 4   

 175   2          }
 176   1      
 177   1          return len;
 178   1      }
 179          
 180          static int bvlc_decode_bip_address(
 181              uint8_t * pdu,      /* buffer to extract encoded address */
 182              struct in_addr *address,    /* in network format */
 183              uint16_t * port)
 184          {       /* in network format */
 185   1          int len = 0;
 186   1      
 187   1          if (pdu) {
 188   2              memcpy(&address->s_addr, &pdu[0], 4);
 189   2              memcpy(port, &pdu[4], 2);
 190   2              len = 6;
 191   2          }
 192   1      
 193   1          return len;
 194   1      }
 195          
 196          /* used for both read and write entries */
 197          static int bvlc_encode_address_entry(
 198              uint8_t * pdu,
 199              struct in_addr *address,
 200              uint16_t port,      /* in network byte order */
 201              struct in_addr *mask)
 202          {
 203   1          int len = 0;
 204   1      
 205   1          if (pdu) {
 206   2              len = bvlc_encode_bip_address(pdu, address, port);
 207   2              memcpy(&pdu[len], &mask->s_addr, 4);
 208   2              len += 4;
 209   2          }
 210   1      
 211   1          return len;
 212   1      }
 213          #endif
 214          
 215          
 216          static int bvlc_encode_bvlc_result(
 217              uint8_t * pdu,
 218              BACNET_BVLC_RESULT result_code)
 219          {
 220   1          if (pdu) {
 221   2              pdu[0] = BVLL_TYPE_BACNET_IP;
 222   2              pdu[1] = BVLC_RESULT;
 223   2              /* The 2-octet BVLC Length field is the length, in octets,
 224   2                 of the entire BVLL message, including the two octets of the
 225   2                 length field itself, most significant octet first. */
 226   2              encode_unsigned16(&pdu[2], 6);
 227   2              encode_unsigned16(&pdu[4], (uint16_t) result_code);
 228   2          }
 229   1      
 230   1          return 6;
 231   1      }
 232          
 233          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_write_bdt_init(
                  uint8_t * pdu,
                  unsigned entries)
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 5   

              {
                  int len = 0;
                  uint16_t BVLC_length = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_WRITE_BROADCAST_DISTRIBUTION_TABLE;
                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      BVLC_length = 4 + (uint16_t) (entries * 10);
                      encode_unsigned16(&pdu[2], BVLC_length);
                      len = 4;
                  }
              
                  return len;
              }
              #endif
 255          
 256          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_read_bdt(
                  uint8_t * pdu)
              {
                  int len = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_READ_BROADCAST_DIST_TABLE;
                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      encode_unsigned16(&pdu[2], 4);
                      len = 4;
                  }
              
                  return len;
              }
              #endif
 275          
 276          
 277          #if defined(BBMD_ENABLED) && BBMD_ENABLED
 278          static int bvlc_encode_read_bdt_ack_init(
 279              uint8_t * pdu,
 280              unsigned entries)
 281          {
 282   1          int len = 0;
 283   1          uint16_t BVLC_length = 0;
 284   1      
 285   1          if (pdu) {
 286   2              pdu[0] = BVLL_TYPE_BACNET_IP;
 287   2              pdu[1] = BVLC_READ_BROADCAST_DIST_TABLE_ACK;
 288   2              /* The 2-octet BVLC Length field is the length, in octets,
 289   2                 of the entire BVLL message, including the two octets of the
 290   2                 length field itself, most significant octet first. */
 291   2              BVLC_length = 4 + (uint16_t) (entries * 10);
 292   2              encode_unsigned16(&pdu[2], BVLC_length);
 293   2              len = 4;
 294   2          }
 295   1      
 296   1          return len;
 297   1      }
 298          
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 6   

 299          static int bvlc_encode_read_bdt_ack(
 300              uint8_t * pdu,
 301              uint16_t max_pdu)
 302          {
 303   1          int pdu_len = 0;    /* return value */
 304   1          int len = 0;
 305   1          unsigned count = 0;
 306   1          unsigned i;
 307   1      
 308   1          for (i = 0; i < MAX_BBMD_ENTRIES; i++) {
 309   2              if (BBMD_Table[i].valid) {
 310   3                  count++;
 311   3              }
 312   2          }
 313   1          len = bvlc_encode_read_bdt_ack_init(&pdu[0], count);
 314   1          pdu_len += len;
 315   1          for (i = 0; i < MAX_BBMD_ENTRIES; i++) {
 316   2              if (BBMD_Table[i].valid) {
 317   3                  /* too much to send */
 318   3                  if ((pdu_len + 10) > max_pdu) {
 319   4                      pdu_len = 0;
 320   4                      break;
 321   4                  }
 322   3                  len =
 323   3                      bvlc_encode_address_entry(&pdu[pdu_len],
 324   3                      &BBMD_Table[i].dest_address, BBMD_Table[i].dest_port,
 325   3                      &BBMD_Table[i].broadcast_mask);
 326   3                  pdu_len += len;
 327   3              }
 328   2          }
 329   1      
 330   1          return pdu_len;
 331   1      }
 332          
 333          static int bvlc_encode_forwarded_npdu(
 334              uint8_t * pdu,
 335              struct sockaddr_in *sin,    /* source address in network order */
 336              uint8_t * npdu,
 337              unsigned npdu_length)
 338          {
 339   1          int len = 0;
 340   1      
 341   1          unsigned i; /* for loop counter */
 342   1      
 343   1          if (pdu) {
 344   2              pdu[0] = BVLL_TYPE_BACNET_IP;
 345   2              pdu[1] = BVLC_FORWARDED_NPDU;
 346   2              /* The 2-octet BVLC Length field is the length, in octets,
 347   2                 of the entire BVLL message, including the two octets of the
 348   2                 length field itself, most significant octet first. */
 349   2              encode_unsigned16(&pdu[2], (uint16_t) (4 + 6 + npdu_length));
 350   2              len = 4;
 351   2              len +=
 352   2                  bvlc_encode_bip_address(&pdu[len], &sin->sin_addr, sin->sin_port);
 353   2              for (i = 0; i < npdu_length; i++) {
 354   3                  pdu[len] = npdu[i];
 355   3                  len++;
 356   3              }
 357   2          }
 358   1      
 359   1          return len;
 360   1      }
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 7   

 361          #endif
 362          
 363          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_read_fdt(
                  uint8_t * pdu)
              {
                  int len = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_READ_FOREIGN_DEVICE_TABLE;
                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      encode_unsigned16(&pdu[2], 4);
                      len = 4;
                  }
              
                  return len;
              }
              #endif
 382          
 383          
 384          #if defined(BBMD_ENABLED) && BBMD_ENABLED
 385          static int bvlc_encode_read_fdt_ack_init(
 386              uint8_t * pdu,
 387              unsigned entries)
 388          {
 389   1          int len = 0;
 390   1          uint16_t BVLC_length = 0;
 391   1      
 392   1          if (pdu) {
 393   2              pdu[0] = BVLL_TYPE_BACNET_IP;
 394   2              pdu[1] = BVLC_READ_FOREIGN_DEVICE_TABLE_ACK;
 395   2              /* The 2-octet BVLC Length field is the length, in octets,
 396   2                 of the entire BVLL message, including the two octets of the
 397   2                 length field itself, most significant octet first. */
 398   2              BVLC_length = 4 + (uint16_t) (entries * 10);
 399   2              encode_unsigned16(&pdu[2], BVLC_length);
 400   2              len = 4;
 401   2          }
 402   1      
 403   1          return len;
 404   1      }
 405          
 406          static int bvlc_encode_read_fdt_ack(
 407              uint8_t * pdu,
 408              uint16_t max_pdu)
 409          {
 410   1          int pdu_len = 0;    /* return value */
 411   1          int len = 0;
 412   1          unsigned count = 0;
 413   1          unsigned i;
 414   1          uint16_t seconds_remaining = 0;
 415   1      
 416   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 417   2              if (FD_Table[i].valid) {
 418   3                  count++;
 419   3              }
 420   2          }
 421   1          len = bvlc_encode_read_fdt_ack_init(&pdu[0], count);
 422   1          pdu_len += len;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 8   

 423   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 424   2              if (FD_Table[i].valid) {
 425   3                  /* too much to send */
 426   3                  if ((pdu_len + 10) > max_pdu) {
 427   4                      pdu_len = 0;
 428   4                      break;
 429   4                  }
 430   3                  len =
 431   3                      bvlc_encode_bip_address(&pdu[pdu_len],
 432   3                      &FD_Table[i].dest_address, FD_Table[i].dest_port);
 433   3                  pdu_len += len;
 434   3                  len = encode_unsigned16(&pdu[pdu_len], FD_Table[i].time_to_live);
 435   3                  pdu_len += len;
 436   3                  seconds_remaining = (uint16_t) FD_Table[i].seconds_remaining;
 437   3                  len = encode_unsigned16(&pdu[pdu_len], seconds_remaining);
 438   3                  pdu_len += len;
 439   3              }
 440   2          }
 441   1      
 442   1          return pdu_len;
 443   1      }
 444          #endif
 445          
 446          
 447          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_delete_fdt_entry(
                  uint8_t * pdu,
                  uint32_t address,   /* in network byte order */
                  uint16_t port)
              {       /* in network byte order */
                  int len = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_DELETE_FOREIGN_DEVICE_TABLE_ENTRY;
                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      encode_unsigned16(&pdu[2], 10);
                      /* FDT Entry */
                      encode_unsigned32(&pdu[4], address);
                      encode_unsigned16(&pdu[8], port);
                      len = 10;
                  }
              
                  return len;
              }
              #endif
 471          
 472          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_original_unicast_npdu(
                  uint8_t * pdu,
                  uint8_t * npdu,
                  unsigned npdu_length)
              {
                  int len = 0;        /* return value */
                  unsigned i = 0;     /* loop counter */
                  uint16_t BVLC_length = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_ORIGINAL_UNICAST_NPDU;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 9   

                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      BVLC_length = 4 + (uint16_t) npdu_length;
                      len = encode_unsigned16(&pdu[2], BVLC_length) + 2;
                      for (i = 0; i < npdu_length; i++) {
                          pdu[len] = npdu[i];
                          len++;
                      }
                  }
              
                  return len;
              }
              #endif
 499          
 500          #if defined(BBMD_CLIENT_ENABLED) && BBMD_CLIENT_ENABLED
              int bvlc_encode_original_broadcast_npdu(
                  uint8_t * pdu,
                  uint8_t * npdu,
                  unsigned npdu_length)
              {
                  int len = 0;        /* return value */
                  unsigned i = 0;     /* loop counter */
                  uint16_t BVLC_length = 0;
              
                  if (pdu) {
                      pdu[0] = BVLL_TYPE_BACNET_IP;
                      pdu[1] = BVLC_ORIGINAL_BROADCAST_NPDU;
                      /* The 2-octet BVLC Length field is the length, in octets,
                         of the entire BVLL message, including the two octets of the
                         length field itself, most significant octet first. */
                      BVLC_length = 4 + (uint16_t) npdu_length;
                      len = encode_unsigned16(&pdu[2], BVLC_length) + 2;
                      for (i = 0; i < npdu_length; i++) {
                          pdu[len] = npdu[i];
                          len++;
                      }
                  }
              
                  return len;
              }
              #endif
 527          
 528          
 529          #if defined(BBMD_ENABLED) && BBMD_ENABLED
 530          static bool bvlc_create_bdt(
 531              uint8_t * npdu,
 532              uint16_t npdu_length)
 533          {
 534   1          bool status = false;
 535   1          unsigned i = 0;
 536   1          uint16_t pdu_offset = 0;
 537   1      
 538   1          for (i = 0; i < MAX_BBMD_ENTRIES; i++) {
 539   2              if (npdu_length >= 10) {
 540   3                  BBMD_Table[i].valid = true;
 541   3                  memcpy(&BBMD_Table[i].dest_address.s_addr, &npdu[pdu_offset], 4);
 542   3                  pdu_offset += 4;
 543   3                  memcpy(&BBMD_Table[i].dest_port, &npdu[pdu_offset], 2);
 544   3                  pdu_offset += 2;
 545   3                  memcpy(&BBMD_Table[i].broadcast_mask.s_addr, &npdu[pdu_offset], 4);
 546   3                  pdu_offset += 4;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 10  

 547   3                  npdu_length -= (4 + 2 + 4);
 548   3              } else {
 549   3                  BBMD_Table[i].valid = false;
 550   3                  BBMD_Table[i].dest_address.s_addr = 0;
 551   3                  BBMD_Table[i].dest_port = 0;
 552   3                  BBMD_Table[i].broadcast_mask.s_addr = 0;
 553   3              }
 554   2          }
 555   1          /* did they all fit? */
 556   1          if (npdu_length < 10) {
 557   2              status = true;
 558   2          }
 559   1      
 560   1          return status;
 561   1      }
 562          
 563          /** Handle a foreign device registration. */
 564          static bool bvlc_register_foreign_device(
 565              struct sockaddr_in *sin,    /* source address in network order */
 566              uint16_t time_to_live)
 567          {       /* time in seconds */
 568   1          unsigned i = 0;
 569   1          bool status = false;
 570   1      
 571   1          /* am I here already?  If so, update my time to live... */
 572   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 573   2              if (FD_Table[i].valid) {
 574   3                  if ((FD_Table[i].dest_address.s_addr == sin->sin_addr.s_addr) &&
 575   3                      (FD_Table[i].dest_port == sin->sin_port)) {
 576   4                      status = true;
 577   4                      FD_Table[i].time_to_live = time_to_live;
 578   4                      /*  Upon receipt of a BVLL Register-Foreign-Device message,
 579   4                         a BBMD shall start a timer with a value equal to the
 580   4                         Time-to-Live parameter supplied plus a fixed grace
 581   4                         period of 30 seconds. */
 582   4                      FD_Table[i].seconds_remaining = time_to_live + 30;
 583   4                      break;
 584   4                  }
 585   3              }
 586   2          }
 587   1          if (!status) {
 588   2              for (i = 0; i < MAX_FD_ENTRIES; i++) {
 589   3                  if (!FD_Table[i].valid) {
 590   4                      FD_Table[i].dest_address.s_addr = sin->sin_addr.s_addr;
 591   4                      FD_Table[i].dest_port = sin->sin_port;
 592   4                      FD_Table[i].time_to_live = time_to_live;
 593   4                      FD_Table[i].seconds_remaining = time_to_live + 30;
 594   4                      FD_Table[i].valid = true;
 595   4                      status = true;
 596   4                      break;
 597   4                  }
 598   3              }
 599   2          }
 600   1      
 601   1      
 602   1          return status;
 603   1      }
 604          
 605          static bool bvlc_delete_foreign_device(
 606              uint8_t * pdu)
 607          {
 608   1          struct sockaddr_in sin = { 0 };     /* the ip address */
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 11  

 609   1          uint16_t port = 0;  /* the decoded port */
 610   1          bool status = false;        /* return value */
 611   1          unsigned i = 0;
 612   1      
 613   1          bvlc_decode_bip_address(pdu, &sin.sin_addr, &port);
 614   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 615   2              if (FD_Table[i].valid) {
 616   3                  if ((FD_Table[i].dest_address.s_addr == sin.sin_addr.s_addr) &&
 617   3                      (FD_Table[i].dest_port == sin.sin_port)) {
 618   4                      FD_Table[i].valid = false;
 619   4                      FD_Table[i].seconds_remaining = 0;
 620   4                      status = true;
 621   4                      break;
 622   4                  }
 623   3              }
 624   2          }
 625   1          return status;
 626   1      }
 627          #endif
 628          
 629          /** The common send function for bvlc functions, using b/ip. */
 630          static int bvlc_send_mpdu(
 631              struct sockaddr_in *dest,   /* the destination address */
 632              uint8_t * mtu,      /* the data */
 633              uint16_t mtu_len)
 634          {       /* amount of data to send  */
 635   1          struct sockaddr_in bvlc_dest = { 0 };
 636   1      
 637   1          /* assumes that the driver has already been initialized */
 638   1          if (bip_socket() < 0) {
 639   2              return 0;
 640   2          }
 641   1          /* load destination IP address */
 642   1          bvlc_dest.sin_family = AF_INET;
 643   1          bvlc_dest.sin_addr.s_addr = dest->sin_addr.s_addr;
 644   1          bvlc_dest.sin_port = dest->sin_port;
 645   1          memset(&(bvlc_dest.sin_zero), '\0', 8);
 646   1          /* Send the packet */
 647   1          return sendto(bip_socket(), (char *) mtu, mtu_len, 0,
*** WARNING C206 IN LINE 647 OF ..\src\bacnet\bvlc.c: 'sendto': missing function-prototype
*** ERROR C267 IN LINE 647 OF ..\src\bacnet\bvlc.c: 'sendto': requires ANSI-style prototype
 648   1              (struct sockaddr *) &bvlc_dest, sizeof(struct sockaddr));
 649   1      }
 650          
 651          
 652          #if defined(BBMD_ENABLED) && BBMD_ENABLED
 653          static void bvlc_bdt_forward_npdu(
 654              struct sockaddr_in *sin,    /* source address in network order */
 655              uint8_t * npdu,     /* the NPDU */
 656              uint16_t npdu_length)
 657          {       /* length of the NPDU  */
 658   1          uint8_t mtu[MAX_MPDU] = { 0 };
 659   1          uint16_t mtu_len = 0;
 660   1          unsigned i = 0;     /* loop counter */
 661   1          struct sockaddr_in bip_dest = { 0 };
 662   1      
 663   1          mtu_len =
 664   1              (uint16_t) bvlc_encode_forwarded_npdu(&mtu[0], sin, npdu, npdu_length);
 665   1          /* loop through the BDT and send one to each entry, except us */
 666   1          for (i = 0; i < MAX_BBMD_ENTRIES; i++) {
 667   2              if (BBMD_Table[i].valid) {
 668   3                  /* The B/IP address to which the Forwarded-NPDU message is
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 12  

 669   3                     sent is formed by inverting the broadcast distribution
 670   3                     mask in the BDT entry and logically ORing it with the
 671   3                     BBMD address of the same entry. */
 672   3                  bip_dest.sin_addr.s_addr =
 673   3                      ((~BBMD_Table[i].broadcast_mask.s_addr) | BBMD_Table[i].
 674   3                      dest_address.s_addr);
 675   3                  bip_dest.sin_port = BBMD_Table[i].dest_port;
 676   3                  /* don't send to my broadcast address and same port */
 677   3                  if ((bip_dest.sin_addr.s_addr == bip_get_broadcast_addr())
 678   3                      && (bip_dest.sin_port == bip_get_port())) {
 679   4                      continue;
 680   4                  }
 681   3                  /* don't send to my ip address and same port */
 682   3                  if ((bip_dest.sin_addr.s_addr == bip_get_addr()) &&
 683   3                      (bip_dest.sin_port == bip_get_port())) {
 684   4                      continue;
 685   4                  }
 686   3                  bvlc_send_mpdu(&bip_dest, mtu, mtu_len);
 687   3                  debug_printf("BVLC: BDT Sent Forwarded-NPDU to %s:%04X\n",
 688   3                      inet_ntoa(bip_dest.sin_addr), ntohs(bip_dest.sin_port));
 689   3              }
 690   2          }
 691   1      
 692   1          return;
 693   1      }
 694          
 695          /* Generate BVLL Forwarded-NPDU message on its local IP subnet using
 696             the local B/IP broadcast address as the destination address.  */
 697          static void bvlc_forward_npdu(
 698              struct sockaddr_in *sin,    /* source address in network order */
 699              uint8_t * npdu,     /* the NPDU */
 700              uint16_t npdu_length)
 701          {       /* length of the NPDU  */
 702   1          uint8_t mtu[MAX_MPDU] = { 0 };
 703   1          uint16_t mtu_len = 0;
 704   1          struct sockaddr_in bip_dest = { 0 };
 705   1      
 706   1          mtu_len =
 707   1              (uint16_t) bvlc_encode_forwarded_npdu(&mtu[0], sin, npdu, npdu_length);
 708   1          bip_dest.sin_addr.s_addr = bip_get_broadcast_addr();
 709   1          bip_dest.sin_port = bip_get_port();
 710   1          bvlc_send_mpdu(&bip_dest, mtu, mtu_len);
 711   1          debug_printf("BVLC: Sent Forwarded-NPDU as local broadcast.\n");
 712   1      }
 713          
 714          static void bvlc_fdt_forward_npdu(
 715              struct sockaddr_in *sin,    /* source address in network order */
 716              uint8_t * npdu,     /* returns the NPDU */
 717              uint16_t max_npdu)
 718          {       /* amount of space available in the NPDU  */
 719   1          uint8_t mtu[MAX_MPDU] = { 0 };
 720   1          uint16_t mtu_len = 0;
 721   1          unsigned i = 0;     /* loop counter */
 722   1          struct sockaddr_in bip_dest = { 0 };
 723   1      
 724   1          mtu_len =
 725   1              (uint16_t) bvlc_encode_forwarded_npdu(&mtu[0], sin, npdu, max_npdu);
 726   1          /* loop through the FDT and send one to each entry */
 727   1          for (i = 0; i < MAX_FD_ENTRIES; i++) {
 728   2              if (FD_Table[i].valid && FD_Table[i].seconds_remaining) {
 729   3                  bip_dest.sin_addr.s_addr = FD_Table[i].dest_address.s_addr;
 730   3                  bip_dest.sin_port = FD_Table[i].dest_port;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 13  

 731   3                  /* don't send to my ip address and same port */
 732   3                  if ((bip_dest.sin_addr.s_addr == bip_get_addr()) &&
 733   3                      (bip_dest.sin_port == bip_get_port())) {
 734   4                      continue;
 735   4                  }
 736   3                  /* don't send to src ip address and same port */
 737   3                  if ((bip_dest.sin_addr.s_addr == sin->sin_addr.s_addr) &&
 738   3                      (bip_dest.sin_port == sin->sin_port)) {
 739   4                      continue;
 740   4                  }
 741   3                  bvlc_send_mpdu(&bip_dest, mtu, mtu_len);
 742   3                  debug_printf("BVLC: FDT Sent Forwarded-NPDU to %s:%04X\n",
 743   3                      inet_ntoa(bip_dest.sin_addr), ntohs(bip_dest.sin_port));
 744   3              }
 745   2          }
 746   1      
 747   1          return;
 748   1      }
 749          #endif
 750          
 751          
 752          static void bvlc_send_result(
 753              struct sockaddr_in *dest,   /* the destination address */
 754              BACNET_BVLC_RESULT result_code)
 755          {
 756   1          uint8_t mtu[MAX_MPDU] = { 0 };
 757   1          uint16_t mtu_len = 0;
 758   1      
 759   1          mtu_len = (uint16_t) bvlc_encode_bvlc_result(&mtu[0], result_code);
 760   1          bvlc_send_mpdu(dest, mtu, mtu_len);
 761   1      
 762   1          return;
 763   1      }
 764          
 765          #if defined(BBMD_ENABLED) && BBMD_ENABLED
 766          static int bvlc_send_bdt(
 767              struct sockaddr_in *dest)
 768          {
 769   1          uint8_t mtu[MAX_MPDU] = { 0 };
 770   1          uint16_t mtu_len = 0;
 771   1      
 772   1          mtu_len = (uint16_t) bvlc_encode_read_bdt_ack(&mtu[0], sizeof(mtu));
 773   1          if (mtu_len) {
 774   2              bvlc_send_mpdu(dest, &mtu[0], mtu_len);
 775   2          }
 776   1      
 777   1          return mtu_len;
 778   1      }
 779          
 780          static int bvlc_send_fdt(
 781              struct sockaddr_in *dest)
 782          {
 783   1          uint8_t mtu[MAX_MPDU] = { 0 };
 784   1          uint16_t mtu_len = 0;
 785   1      
 786   1          mtu_len = (uint16_t) bvlc_encode_read_fdt_ack(&mtu[0], sizeof(mtu));
 787   1          if (mtu_len) {
 788   2              bvlc_send_mpdu(dest, &mtu[0], mtu_len);
 789   2          }
 790   1      
 791   1          return mtu_len;
 792   1      }
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 14  

 793          
 794          static bool bvlc_bdt_member_mask_is_unicast(
 795              struct sockaddr_in *sin)
 796          {       /* network order address */
 797   1          bool unicast = false;
 798   1          unsigned i = 0;     /* loop counter */
 799   1      
 800   1          for (i = 0; i < MAX_BBMD_ENTRIES; i++) {
 801   2              if (BBMD_Table[i].valid) {
 802   3                  /* find the source address in the table */
 803   3                  if ((BBMD_Table[i].dest_address.s_addr == sin->sin_addr.s_addr) &&
 804   3                      (BBMD_Table[i].dest_port == sin->sin_port)) {
 805   4                      /* unicast mask? */
 806   4                      if (BBMD_Table[i].broadcast_mask.s_addr == 0xFFFFFFFFL) {
 807   5                          unicast = true;
 808   5                          break;
 809   5                      }
 810   4                  }
 811   3              }
 812   2          }
 813   1      
 814   1          return unicast;
 815   1      }
 816          
 817          /* returns:
 818              Number of bytes received, or 0 if none or timeout. */
 819          uint16_t bvlc_receive(
 820              BACNET_ADDRESS * src,       /* returns the source address */
 821              uint8_t * npdu,     /* returns the NPDU */
 822              uint16_t max_npdu,  /* amount of space available in the NPDU  */
 823              unsigned timeout)
 824          {       /* number of milliseconds to wait for a packet */
 825   1          uint16_t npdu_len = 0;      /* return value */
 826   1          fd_set read_fds;
 827   1          int max = 0;
 828   1          struct timeval select_timeout;
 829   1          struct sockaddr_in sin = { 0 };
 830   1          struct sockaddr_in original_sin = { 0 };
 831   1          struct sockaddr_in dest = { 0 };
 832   1          int sin_len = sizeof(sin);
 833   1          int received_bytes = 0;
 834   1          uint16_t result_code = 0;
 835   1          uint16_t i = 0;
 836   1          bool status = false;
 837   1          uint16_t time_to_live = 0;
 838   1      
 839   1          /* Make sure the socket is open */
 840   1          if (bip_socket() < 0) {
 841   2              return 0;
 842   2          }
 843   1      
 844   1          /* we could just use a non-blocking socket, but that consumes all
 845   1             the CPU time.  We can use a timeout; it is only supported as
 846   1             a select. */
 847   1          if (timeout >= 1000) {
 848   2              select_timeout.tv_sec = timeout / 1000;
 849   2              select_timeout.tv_usec =
 850   2                  1000 * (timeout - select_timeout.tv_sec * 1000);
 851   2          } else {
 852   2              select_timeout.tv_sec = 0;
 853   2              select_timeout.tv_usec = 1000 * timeout;
 854   2          }
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 15  

 855   1          FD_ZERO(&read_fds);
 856   1          FD_SET(bip_socket(), &read_fds);
 857   1          max = bip_socket();
 858   1          /* see if there is a packet for us */
 859   1          if (select(max + 1, &read_fds, NULL, NULL, &select_timeout) > 0) {
 860   2              received_bytes =
 861   2                  recvfrom(bip_socket(), (char *) &npdu[0], max_npdu, 0,
 862   2                  (struct sockaddr *) &sin, &sin_len);
 863   2          } else {
 864   2              return 0;
 865   2          }
 866   1          /* See if there is a problem */
 867   1          if (received_bytes < 0) {
 868   2              return 0;
 869   2          }
 870   1          /* no problem, just no bytes */
 871   1          if (received_bytes == 0) {
 872   2              return 0;
 873   2          }
 874   1          /* the signature of a BACnet/IP packet */
 875   1          if (npdu[0] != BVLL_TYPE_BACNET_IP) {
 876   2              return 0;
 877   2          }
 878   1          BVLC_Function_Code = npdu[1];
 879   1          /* decode the length of the PDU - length is inclusive of BVLC */
 880   1          (void) decode_unsigned16(&npdu[2], &npdu_len);
 881   1          /* subtract off the BVLC header */
 882   1          npdu_len -= 4;
 883   1          switch (BVLC_Function_Code) {
 884   2              case BVLC_RESULT:
 885   2                  /* Upon receipt of a BVLC-Result message containing a result code
 886   2                     of X'0000' indicating the successful completion of the
 887   2                     registration, a foreign device shall start a timer with a value
 888   2                     equal to the Time-to-Live parameter of the preceding Register-
 889   2                     Foreign-Device message. At the expiration of the timer, the
 890   2                     foreign device shall re-register with the BBMD by sending a BVLL
 891   2                     Register-Foreign-Device message */
 892   2                  /* Clients can now get this result */
 893   2                  (void) decode_unsigned16(&npdu[4], &result_code);
 894   2                  BVLC_Result_Code = (BACNET_BVLC_RESULT) result_code;
 895   2                  debug_printf("BVLC: Result Code=%d\n", BVLC_Result_Code);
 896   2                  /* not an NPDU */
 897   2                  npdu_len = 0;
 898   2                  break;
 899   2              case BVLC_WRITE_BROADCAST_DISTRIBUTION_TABLE:
 900   2                  debug_printf("BVLC: Received Write-BDT.\n");
 901   2                  /* Upon receipt of a BVLL Write-Broadcast-Distribution-Table
 902   2                     message, a BBMD shall attempt to create or replace its BDT,
 903   2                     depending on whether or not a BDT has previously existed.
 904   2                     If the creation or replacement of the BDT is successful, the BBMD
 905   2                     shall return a BVLC-Result message to the originating device with
 906   2                     a result code of X'0000'. Otherwise, the BBMD shall return a
 907   2                     BVLC-Result message to the originating device with a result code
 908   2                     of X'0010' indicating that the write attempt has failed. */
 909   2                  status = bvlc_create_bdt(&npdu[4], npdu_len);
 910   2                  if (status) {
 911   3                      bvlc_send_result(&sin, BVLC_RESULT_SUCCESSFUL_COMPLETION);
 912   3                  } else {
 913   3                      bvlc_send_result(&sin,
 914   3                          BVLC_RESULT_WRITE_BROADCAST_DISTRIBUTION_TABLE_NAK);
 915   3                  }
 916   2                  /* not an NPDU */
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 16  

 917   2                  npdu_len = 0;
 918   2                  break;
 919   2              case BVLC_READ_BROADCAST_DIST_TABLE:
 920   2                  debug_printf("BVLC: Received Read-BDT.\n");
 921   2                  /* Upon receipt of a BVLL Read-Broadcast-Distribution-Table
 922   2                     message, a BBMD shall load the contents of its BDT into a BVLL
 923   2                     Read-Broadcast-Distribution-Table-Ack message and send it to the
 924   2                     originating device. If the BBMD is unable to perform the
 925   2                     read of its BDT, it shall return a BVLC-Result message to the
 926   2                     originating device with a result code of X'0020' indicating that
 927   2                     the read attempt has failed. */
 928   2                  if (bvlc_send_bdt(&sin) <= 0) {
 929   3                      bvlc_send_result(&sin,
 930   3                          BVLC_RESULT_READ_BROADCAST_DISTRIBUTION_TABLE_NAK);
 931   3                  }
 932   2                  /* not an NPDU */
 933   2                  npdu_len = 0;
 934   2                  break;
 935   2              case BVLC_READ_BROADCAST_DIST_TABLE_ACK:
 936   2                  debug_printf("BVLC: Received Read-BDT-Ack.\n");
 937   2                  /* FIXME: complete the code for client side read */
 938   2                  /* not an NPDU */
 939   2                  npdu_len = 0;
 940   2                  break;
 941   2              case BVLC_FORWARDED_NPDU:
 942   2                  /* Upon receipt of a BVLL Forwarded-NPDU message, a BBMD shall
 943   2                     process it according to whether it was received from a peer
 944   2                     BBMD as the result of a directed broadcast or a unicast
 945   2                     transmission. A BBMD may ascertain the method by which Forwarded-
 946   2                     NPDU messages will arrive by inspecting the broadcast distribution
 947   2                     mask field in its own BDT entry since all BDTs are required
 948   2                     to be identical. If the message arrived via directed broadcast,
 949   2                     it was also received by the other devices on the BBMD's subnet. In
 950   2                     this case the BBMD merely retransmits the message directly to each
 951   2                     foreign device currently in the BBMD's FDT. If the
 952   2                     message arrived via a unicast transmission it has not yet been
 953   2                     received by the other devices on the BBMD's subnet. In this case,
 954   2                     the message is sent to the devices on the BBMD's subnet using the
 955   2                     B/IP broadcast address as well as to each foreign device
 956   2                     currently in the BBMD's FDT. A BBMD on a subnet with no other
 957   2                     BACnet devices may omit the broadcast using the B/IP
 958   2                     broadcast address. The method by which a BBMD determines whether
 959   2                     or not other BACnet devices are present is a local matter. */
 960   2                  /* decode the 4 byte original address and 2 byte port */
 961   2                  bvlc_decode_bip_address(&npdu[4], &original_sin.sin_addr,
 962   2                      &original_sin.sin_port);
 963   2                  npdu_len -= 6;
 964   2                  /*  Broadcast locally if received via unicast from a BDT member */
 965   2                  if (bvlc_bdt_member_mask_is_unicast(&sin)) {
 966   3                      dest.sin_addr.s_addr = bip_get_broadcast_addr();
 967   3                      dest.sin_port = bip_get_port();
 968   3                      bvlc_send_mpdu(&dest, &npdu[4 + 6], npdu_len);
 969   3                  }
 970   2                  /* use the original addr from the BVLC for src */
 971   2                  dest.sin_addr.s_addr = original_sin.sin_addr.s_addr;
 972   2                  dest.sin_port = original_sin.sin_port;
 973   2                  bvlc_fdt_forward_npdu(&dest, &npdu[4 + 6], npdu_len);
 974   2                  debug_printf("BVLC: Received Forwarded-NPDU from %s:%04X.\n",
 975   2                      inet_ntoa(dest.sin_addr), ntohs(dest.sin_port));
 976   2                  bvlc_internet_to_bacnet_address(src, &dest);
 977   2                  if (npdu_len < max_npdu) {
 978   3                      /* shift the buffer to return a valid PDU */
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 17  

 979   3                      for (i = 0; i < npdu_len; i++) {
 980   4                          npdu[i] = npdu[4 + 6 + i];
 981   4                      }
 982   3                  } else {
 983   3                      /* ignore packets that are too large */
 984   3                      /* clients should check my max-apdu first */
 985   3                      npdu_len = 0;
 986   3                  }
 987   2                  break;
 988   2              case BVLC_REGISTER_FOREIGN_DEVICE:
 989   2                  /* Upon receipt of a BVLL Register-Foreign-Device message, a BBMD
 990   2                     shall start a timer with a value equal to the Time-to-Live
 991   2                     parameter supplied plus a fixed grace period of 30 seconds. If,
 992   2                     within the period during which the timer is active, another BVLL
 993   2                     Register-Foreign-Device message from the same device is received,
 994   2                     the timer shall be reset and restarted. If the time expires
 995   2                     without the receipt of another BVLL Register-Foreign-Device
 996   2                     message from the same foreign device, the FDT entry for this
 997   2                     device shall be cleared. */
 998   2                  (void) decode_unsigned16(&npdu[4], &time_to_live);
 999   2                  if (bvlc_register_foreign_device(&sin, time_to_live)) {
1000   3                      bvlc_send_result(&sin, BVLC_RESULT_SUCCESSFUL_COMPLETION);
1001   3                      debug_printf("BVLC: Registered a Foreign Device.\n");
1002   3                  } else {
1003   3                      bvlc_send_result(&sin,
1004   3                          BVLC_RESULT_REGISTER_FOREIGN_DEVICE_NAK);
1005   3                      debug_printf("BVLC: Failed to Register a Foreign Device.\n");
1006   3                  }
1007   2                  /* not an NPDU */
1008   2                  npdu_len = 0;
1009   2                  break;
1010   2              case BVLC_READ_FOREIGN_DEVICE_TABLE:
1011   2                  debug_printf("BVLC: Received Read-FDT.\n");
1012   2                  /* Upon receipt of a BVLL Read-Foreign-Device-Table message, a
1013   2                     BBMD shall load the contents of its FDT into a BVLL Read-
1014   2                     Foreign-Device-Table-Ack message and send it to the originating
1015   2                     device. If the BBMD is unable to perform the read of its FDT,
1016   2                     it shall return a BVLC-Result message to the originating device
1017   2                     with a result code of X'0040' indicating that the read attempt has
1018   2                     failed. */
1019   2                  if (bvlc_send_fdt(&sin) <= 0) {
1020   3                      bvlc_send_result(&sin,
1021   3                          BVLC_RESULT_READ_FOREIGN_DEVICE_TABLE_NAK);
1022   3                  }
1023   2                  /* not an NPDU */
1024   2                  npdu_len = 0;
1025   2                  break;
1026   2              case BVLC_READ_FOREIGN_DEVICE_TABLE_ACK:
1027   2                  debug_printf("BVLC: Received Read-FDT-Ack.\n");
1028   2                  /* FIXME: complete the code for client side read */
1029   2                  /* not an NPDU */
1030   2                  npdu_len = 0;
1031   2                  break;
1032   2              case BVLC_DELETE_FOREIGN_DEVICE_TABLE_ENTRY:
1033   2                  debug_printf("BVLC: Received Delete-FDT-Entry.\n");
1034   2                  /* Upon receipt of a BVLL Delete-Foreign-Device-Table-Entry
1035   2                     message, a BBMD shall search its foreign device table for an entry
1036   2                     corresponding to the B/IP address supplied in the message. If an
1037   2                     entry is found, it shall be deleted and the BBMD shall return a
1038   2                     BVLC-Result message to the originating device with a result code
1039   2                     of X'0000'. Otherwise, the BBMD shall return a BVLCResult
1040   2                     message to the originating device with a result code of X'0050'
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 18  

1041   2                     indicating that the deletion attempt has failed. */
1042   2                  if (bvlc_delete_foreign_device(&npdu[4])) {
1043   3                      bvlc_send_result(&sin, BVLC_RESULT_SUCCESSFUL_COMPLETION);
1044   3                  } else {
1045   3                      bvlc_send_result(&sin,
1046   3                          BVLC_RESULT_DELETE_FOREIGN_DEVICE_TABLE_ENTRY_NAK);
1047   3                  }
1048   2                  /* not an NPDU */
1049   2                  npdu_len = 0;
1050   2                  break;
1051   2              case BVLC_DISTRIBUTE_BROADCAST_TO_NETWORK:
1052   2                  debug_printf
1053   2                      ("BVLC: Received Distribute-Broadcast-to-Network from %s:%04X.\n",
1054   2                      inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
1055   2                  /* Upon receipt of a BVLL Distribute-Broadcast-To-Network message
1056   2                     from a foreign device, the receiving BBMD shall transmit a
1057   2                     BVLL Forwarded-NPDU message on its local IP subnet using the
1058   2                     local B/IP broadcast address as the destination address. In
1059   2                     addition, a Forwarded-NPDU message shall be sent to each entry
1060   2                     in its BDT as described in the case of the receipt of a
1061   2                     BVLL Original-Broadcast-NPDU as well as directly to each foreign
1062   2                     device currently in the BBMD's FDT except the originating
1063   2                     node. If the BBMD is unable to perform the forwarding function,
1064   2                     it shall return a BVLC-Result message to the foreign device
1065   2                     with a result code of X'0060' indicating that the forwarding
1066   2                     attempt was unsuccessful */
1067   2                  bvlc_forward_npdu(&sin, &npdu[4], npdu_len);
1068   2                  bvlc_bdt_forward_npdu(&sin, &npdu[4], npdu_len);
1069   2                  bvlc_fdt_forward_npdu(&sin, &npdu[4], npdu_len);
1070   2                  /* not an NPDU */
1071   2                  npdu_len = 0;
1072   2                  break;
1073   2              case BVLC_ORIGINAL_UNICAST_NPDU:
1074   2                  debug_printf("BVLC: Received Original-Unicast-NPDU.\n");
1075   2                  /* ignore messages from me */
1076   2                  if ((sin.sin_addr.s_addr == bip_get_addr()) &&
1077   2                      (sin.sin_port == bip_get_port())) {
1078   3                      npdu_len = 0;
1079   3                  } else {
1080   3                      bvlc_internet_to_bacnet_address(src, &sin);
1081   3                      if (npdu_len < max_npdu) {
1082   4                          /* shift the buffer to return a valid PDU */
1083   4                          for (i = 0; i < npdu_len; i++) {
1084   5                              npdu[i] = npdu[4 + i];
1085   5                          }
1086   4                      } else {
1087   4                          /* ignore packets that are too large */
1088   4                          /* clients should check my max-apdu first */
1089   4                          npdu_len = 0;
1090   4                      }
1091   3                  }
1092   2                  break;
1093   2              case BVLC_ORIGINAL_BROADCAST_NPDU:
1094   2                  debug_printf("BVLC: Received Original-Broadcast-NPDU.\n");
1095   2                  /* Upon receipt of a BVLL Original-Broadcast-NPDU message,
1096   2                     a BBMD shall construct a BVLL Forwarded-NPDU message and
1097   2                     send it to each IP subnet in its BDT with the exception
1098   2                     of its own. The B/IP address to which the Forwarded-NPDU
1099   2                     message is sent is formed by inverting the broadcast
1100   2                     distribution mask in the BDT entry and logically ORing it
1101   2                     with the BBMD address of the same entry. This process
1102   2                     produces either the directed broadcast address of the remote
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 19  

1103   2                     subnet or the unicast address of the BBMD on that subnet
1104   2                     depending on the contents of the broadcast distribution
1105   2                     mask. See J.4.3.2.. In addition, the received BACnet NPDU
1106   2                     shall be sent directly to each foreign device currently in
1107   2                     the BBMD's FDT also using the BVLL Forwarded-NPDU message. */
1108   2                  bvlc_internet_to_bacnet_address(src, &sin);
1109   2                  if (npdu_len < max_npdu) {
1110   3                      /* shift the buffer to return a valid PDU */
1111   3                      for (i = 0; i < npdu_len; i++) {
1112   4                          npdu[i] = npdu[4 + i];
1113   4                      }
1114   3                      /* if BDT or FDT entries exist, Forward the NPDU */
1115   3                      bvlc_bdt_forward_npdu(&sin, &npdu[0], npdu_len);
1116   3                      bvlc_fdt_forward_npdu(&sin, &npdu[0], npdu_len);
1117   3                  } else {
1118   3                      /* ignore packets that are too large */
1119   3                      npdu_len = 0;
1120   3                  }
1121   2                  break;
1122   2              default:
1123   2                  break;
1124   2          }
1125   1      
1126   1          return npdu_len;
1127   1      }
1128          
1129          /* function to send a packet out the BACnet/IP socket (Annex J) */
1130          /* returns number of bytes sent on success, negative number on failure */
1131          int bvlc_send_pdu(
1132              BACNET_ADDRESS * dest,      /* destination address */
1133              BACNET_NPDU_DATA * npdu_data,       /* network information */
1134              uint8_t * pdu,      /* any data to be sent - may be null */
1135              unsigned pdu_len)
1136          {       /* number of bytes of data */
1137   1          struct sockaddr_in bvlc_dest = { 0 };
1138   1          uint8_t mtu[MAX_MPDU] = { 0 };
1139   1          uint16_t mtu_len = 0;
1140   1          /* addr and port in network format */
1141   1          struct in_addr address;
1142   1          uint16_t port = 0;
1143   1          uint16_t BVLC_length = 0;
1144   1      
1145   1          /* bip datalink doesn't need to know the npdu data */
1146   1          (void) npdu_data;
1147   1          mtu[0] = BVLL_TYPE_BACNET_IP;
1148   1          if (dest->net == BACNET_BROADCAST_NETWORK) {
1149   2              /* if we are a foreign device */
1150   2              if (Remote_BBMD.sin_port) {
1151   3                  mtu[1] = BVLC_DISTRIBUTE_BROADCAST_TO_NETWORK;
1152   3                  address.s_addr = Remote_BBMD.sin_addr.s_addr;
1153   3                  port = Remote_BBMD.sin_port;
1154   3                  debug_printf("BVLC: Sent Distribute-Broadcast-to-Network.\n");
1155   3              } else {
1156   3                  address.s_addr = bip_get_broadcast_addr();
1157   3                  port = bip_get_port();
1158   3                  mtu[1] = BVLC_ORIGINAL_BROADCAST_NPDU;
1159   3                  debug_printf("BVLC: Sent Original-Broadcast-NPDU.\n");
1160   3              }
1161   2          } else if (dest->mac_len == 6) {
1162   2              /* valid unicast */
1163   2              bvlc_decode_bip_address(&dest->mac[0], &address, &port);
1164   2              mtu[1] = BVLC_ORIGINAL_UNICAST_NPDU;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 20  

1165   2              debug_printf("BVLC: Sent Original-Unicast-NPDU.\n");
1166   2          } else {
1167   2              /* invalid address */
1168   2              return -1;
1169   2          }
1170   1          bvlc_dest.sin_addr.s_addr = address.s_addr;
1171   1          bvlc_dest.sin_port = port;
1172   1          BVLC_length = (uint16_t) pdu_len + 4 /*inclusive */ ;
1173   1          mtu_len = 2;
1174   1          mtu_len += (uint16_t) encode_unsigned16(&mtu[mtu_len], BVLC_length);
1175   1          memcpy(&mtu[mtu_len], pdu, pdu_len);
1176   1          mtu_len += (uint16_t) pdu_len;
1177   1          return bvlc_send_mpdu(&bvlc_dest, mtu, mtu_len);
1178   1      }
1179          #endif
1180          
1181          
1182          /***********************************************
1183           * Functions to register us as a foreign device.
1184           ********************************************* */
1185          
1186          static int bvlc_encode_register_foreign_device(
1187              uint8_t * pdu,
1188              uint16_t time_to_live_seconds)
1189          {
1190   1          int len = 0;
1191   1      
1192   1          if (pdu) {
1193   2              pdu[0] = BVLL_TYPE_BACNET_IP;
1194   2              pdu[1] = BVLC_REGISTER_FOREIGN_DEVICE;
1195   2              /* The 2-octet BVLC Length field is the length, in octets,
1196   2                 of the entire BVLL message, including the two octets of the
1197   2                 length field itself, most significant octet first. */
1198   2              encode_unsigned16(&pdu[2], 6);
1199   2              encode_unsigned16(&pdu[4], time_to_live_seconds);
1200   2              len = 6;
1201   2          }
1202   1      
1203   1          return len;
1204   1      }
1205          
1206          
1207          /** Register as a foreign device with the indicated BBMD.
1208           * @param bbmd_address - IPv4 address (long) of BBMD to register with,
1209           *                       in network byte order.
1210           * @param bbmd_port - Network port of BBMD, in network byte order
1211           * @param time_to_live_seconds - Lease time to use when registering.
1212           * @return Positive number (of bytes sent) on success,
1213           *         0 if no registration request is sent, or
1214           *         -1 if registration fails.
1215           */
1216          int bvlc_register_with_bbmd(
1217              uint32_t bbmd_address,
1218              uint16_t bbmd_port,
1219              uint16_t time_to_live_seconds)
1220          {
1221   1          uint8_t mtu[MAX_MPDU] = { 0 };
1222   1          uint16_t mtu_len = 0;
1223   1          int retval = 0;
1224   1      
1225   1          /* Store the BBMD address and port so that we
1226   1             won't broadcast locally. */
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 21  

1227   1          Remote_BBMD.sin_addr.s_addr = bbmd_address;
1228   1          Remote_BBMD.sin_port = bbmd_port;
1229   1          /* In order for their broadcasts to get here,
1230   1             we need to register our address with the remote BBMD using
1231   1             Write Broadcast Distribution Table, or
1232   1             register with the BBMD as a Foreign Device */
1233   1          mtu_len =
1234   1              (uint16_t) bvlc_encode_register_foreign_device(&mtu[0],
1235   1              time_to_live_seconds);
1236   1          retval = bvlc_send_mpdu(&Remote_BBMD, &mtu[0], mtu_len);
1237   1          return retval;
1238   1      }
1239          
1240          
1241          /** Note any BVLC_RESULT code, or NAK the BVLL message in the unsupported cases.
1242           * Use this handler when you are not a BBMD.
1243           * Sets the BVLC_Function_Code in case it is needed later.
1244           *
1245           * @param sout  [in] Socket address to send any NAK back to.
1246           * @param npdu  [in] The received buffer.
1247           * @param received_bytes [in] How many bytes in npdu[].
1248           * @return Non-zero BVLC_RESULT_ code if we sent a response (NAK) to this
1249           *      BVLC message.  If zero, may need further processing.
1250           */
1251          int bvlc_for_non_bbmd(
1252              struct sockaddr_in *sout,
1253              uint8_t * npdu,
1254              uint16_t received_bytes)
1255          {
1256   1          uint16_t result_code = 0;   /* aka, BVLC_RESULT_SUCCESSFUL_COMPLETION */
1257   1      
1258   1          BVLC_Function_Code = npdu[1];       /* The BVLC function */
1259   1          switch (BVLC_Function_Code) {
1260   2              case BVLC_RESULT:
1261   2                  if (received_bytes >= 6) {
1262   3                      /* This is the result of our foreign device registration */
1263   3                      (void) decode_unsigned16(&npdu[4], &result_code);
1264   3                      BVLC_Result_Code = (BACNET_BVLC_RESULT) result_code;
1265   3                      debug_printf("BVLC: Result Code=%d\n", BVLC_Result_Code);
1266   3                      /* But don't send any response */
1267   3                      result_code = 0;
1268   3                  }
1269   2                  break;
1270   2              case BVLC_WRITE_BROADCAST_DISTRIBUTION_TABLE:
1271   2                  result_code = BVLC_RESULT_WRITE_BROADCAST_DISTRIBUTION_TABLE_NAK;
1272   2                  break;
1273   2              case BVLC_READ_BROADCAST_DIST_TABLE:
1274   2                  result_code = BVLC_RESULT_READ_BROADCAST_DISTRIBUTION_TABLE_NAK;
1275   2                  break;
1276   2                  /* case BVLC_READ_BROADCAST_DIST_TABLE_ACK: */
1277   2              case BVLC_REGISTER_FOREIGN_DEVICE:
1278   2                  result_code = BVLC_RESULT_REGISTER_FOREIGN_DEVICE_NAK;
1279   2                  break;
1280   2              case BVLC_READ_FOREIGN_DEVICE_TABLE:
1281   2                  result_code = BVLC_RESULT_READ_FOREIGN_DEVICE_TABLE_NAK;
1282   2                  break;
1283   2                  /* case BVLC_READ_FOREIGN_DEVICE_TABLE_ACK: */
1284   2              case BVLC_DELETE_FOREIGN_DEVICE_TABLE_ENTRY:
1285   2                  result_code = BVLC_RESULT_DELETE_FOREIGN_DEVICE_TABLE_ENTRY_NAK;
1286   2                  break;
1287   2              case BVLC_DISTRIBUTE_BROADCAST_TO_NETWORK:
1288   2                  result_code = BVLC_RESULT_DISTRIBUTE_BROADCAST_TO_NETWORK_NAK;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 22  

1289   2                  break;
1290   2                  /* case BVLC_FORWARDED_NPDU: */
1291   2                  /* case BVLC_ORIGINAL_UNICAST_NPDU: */
1292   2                  /* case BVLC_ORIGINAL_BROADCAST_NPDU: */
1293   2              default:
1294   2                  break;
1295   2          }
1296   1          if (result_code > 0) {
1297   2              bvlc_send_result(sout, result_code);
1298   2              debug_printf("BVLC: NAK code=%d\n", result_code);
1299   2          }
1300   1      
1301   1          return result_code;
1302   1      }
1303          
1304          /** Returns the last BVLL Result we received, either as the result of a BBMD
1305           * request we sent, or (if not a BBMD or Client), from trying to register
1306           * as a foreign device.
1307           *
1308           * @return BVLC_RESULT_SUCCESSFUL_COMPLETION on success,
1309           * BVLC_RESULT_REGISTER_FOREIGN_DEVICE_NAK if registration failed,
1310           * or one of the other codes (if we are a BBMD).
1311           */
1312          BACNET_BVLC_RESULT bvlc_get_last_result(
1313              void)
1314          {
1315   1          return BVLC_Result_Code;
1316   1      }
1317          
1318          /** Returns the current BVLL Function Code we are processing.
1319           * We have to store this higher layer code for when the lower layers
1320           * need to know what it is, especially to differentiate between
1321           * BVLC_ORIGINAL_UNICAST_NPDU and BVLC_ORIGINAL_BROADCAST_NPDU.
1322           *
1323           * @return A BVLC_ code, such as BVLC_ORIGINAL_UNICAST_NPDU.
1324           */
1325          BACNET_BVLC_FUNCTION bvlc_get_function_code(
1326              void)
1327          {
1328   1          return BVLC_Function_Code;
1329   1      }
1330          
1331          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include "ctest.h"
              
              /* copy the source internet address to the BACnet address */
              /* FIXME: IPv6? */
              static void bvlc_bacnet_to_internet_address(
                  struct sockaddr_in *sin,    /* source address in network order */
                  BACNET_ADDRESS * src)
              {       /* returns the BACnet source address */
              
                  if (src && sin) {
                      if (src->mac_len == 6) {
                          memcpy(&sin->sin_addr.s_addr, &src->mac[0], 4);
                          memcpy(&sin->sin_port, &src->mac[4], 2);
                      }
                  }
              
                  return;
C51 COMPILER V9.06   BVLC                                                                  03/28/2013 13:47:36 PAGE 23  

              }
              
              void testBIPAddress(
                  Test * pTest)
              {
                  uint8_t apdu[50] = { 0 };
                  uint32_t value = 0, test_value = 0;
                  int len = 0, test_len = 0;
                  struct in_addr address;
                  struct in_addr test_address;
                  uint16_t port = 0, test_port = 0;
              
                  address.s_addr = 42;
                  len = bvlc_encode_bip_address(&apdu[0], &address, port);
                  test_len = bvlc_decode_bip_address(&apdu[0], &test_address, &test_port);
                  ct_test(pTest, len == test_len);
                  ct_test(pTest, address.s_addr == test_address.s_addr);
                  ct_test(pTest, port == test_port);
              }
              
              void testInternetAddress(
                  Test * pTest)
              {
                  BACNET_ADDRESS src;
                  BACNET_ADDRESS test_src;
                  struct sockaddr_in sin = { 0 };
                  struct sockaddr_in test_sin = { 0 };
              
                  sin.sin_port = htons(0xBAC0);
                  sin.sin_addr.s_addr = inet_addr("192.168.0.1");
                  bvlc_internet_to_bacnet_address(&src, &sin);
                  bvlc_bacnet_to_internet_address(&test_sin, &src);
                  ct_test(pTest, sin.sin_port == test_sin.sin_port);
                  ct_test(pTest, sin.sin_addr.s_addr == test_sin.sin_addr.s_addr);
              }
              
              #ifdef TEST_BVLC
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACnet Virtual Link Control", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testBIPAddress);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testInternetAddress);
                  assert(rc);
                  /* configure output */
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              
              #endif /* TEST_BBMD */
              #endif /* TEST */

C51 COMPILATION COMPLETE.  1 WARNING(S),  1 ERROR(S)
