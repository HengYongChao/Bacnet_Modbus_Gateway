C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE BACDCODE
OBJECT MODULE PLACED IN .\bacdcode.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\bacdcode.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X602
                    -0) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur
                    -\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SR
                    -C\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\
                    -;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\bacdcode.lst) OBJECT(.\b
                    -acdcode.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2004 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          
  35          #include <string.h>
  36          
  37          #include "../include/bacdef.h"
  38          #include "../include/bacdcode.h"
  39          #include "../include/bacenum.h"
  40          #include "../include/bits.h"
  41          #include "../include/bacstr.h"
  42          #include "../include/bacint.h"
  43          #include "../include/bacreal.h"
  44          
  45          /** @file bacdcode.c  Functions to encode/decode BACnet data types */
  46          
  47          
  48          /* max-segments-accepted
  49             B'000'      Unspecified number of segments accepted.
  50             B'001'      2 segments accepted.
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 2   

  51             B'010'      4 segments accepted.
  52             B'011'      8 segments accepted.
  53             B'100'      16 segments accepted.
  54             B'101'      32 segments accepted.
  55             B'110'      64 segments accepted.
  56             B'111'      Greater than 64 segments accepted.
  57          */
  58          
  59          /* max-APDU-length-accepted
  60             B'0000'  Up to MinimumMessageSize (50 octets)
  61             B'0001'  Up to 128 octets
  62             B'0010'  Up to 206 octets (fits in a LonTalk frame)
  63             B'0011'  Up to 480 octets (fits in an ARCNET frame)
  64             B'0100'  Up to 1024 octets
  65             B'0101'  Up to 1476 octets (fits in an ISO 8802-3 frame)
  66             B'0110'  reserved by ASHRAE
  67             B'0111'  reserved by ASHRAE
  68             B'1000'  reserved by ASHRAE
  69             B'1001'  reserved by ASHRAE
  70             B'1010'  reserved by ASHRAE
  71             B'1011'  reserved by ASHRAE
  72             B'1100'  reserved by ASHRAE
  73             B'1101'  reserved by ASHRAE
  74             B'1110'  reserved by ASHRAE
  75             B'1111'  reserved by ASHRAE
  76          */
  77          
  78          /* Encoding of BACNET Length/Value/Type tag
  79             From clause 20.2.1.3.1
  80          
  81             B'000'   interpreted as Value  = FALSE if application class == BOOLEAN
  82             B'001'   interpreted as Value  = TRUE  if application class == BOOLEAN
  83          
  84             B'000'   interpreted as Length = 0     if application class != BOOLEAN
  85             B'001'   interpreted as Length = 1
  86             B'010'   interpreted as Length = 2
  87             B'011'   interpreted as Length = 3
  88             B'100'   interpreted as Length = 4
  89             B'101'   interpreted as Length > 4
  90             B'110'   interpreted as Type   = Opening Tag
  91             B'111'   interpreted as Type   = Closing Tag
  92          */
  93          
  94          
  95          /* from clause 20.1.2.4 max-segments-accepted */
  96          /* and clause 20.1.2.5 max-APDU-length-accepted */
  97          /* returns the encoded octet */
  98          uint8_t encode_max_segs_max_apdu(
  99              int max_segs,
 100              int max_apdu)
 101          {
 102   1          uint8_t octet = 0;
 103   1      
 104   1          if (max_segs < 2)
 105   1              octet = 0;
 106   1          else if (max_segs < 4)
 107   1              octet = 0x10;
 108   1          else if (max_segs < 8)
 109   1              octet = 0x20;
 110   1          else if (max_segs < 16)
 111   1              octet = 0x30;
 112   1          else if (max_segs < 32)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 3   

 113   1              octet = 0x40;
 114   1          else if (max_segs < 64)
 115   1              octet = 0x50;
 116   1          else if (max_segs == 64)
 117   1              octet = 0x60;
 118   1          else
 119   1              octet = 0x70;
 120   1      
 121   1          /* max_apdu must be 50 octets minimum */
 122   1          if (max_apdu <= 50)
 123   1              octet |= 0x00;
 124   1          else if (max_apdu <= 128)
 125   1              octet |= 0x01;
 126   1          /*fits in a LonTalk frame */
 127   1          else if (max_apdu <= 206)
 128   1              octet |= 0x02;
 129   1          /*fits in an ARCNET or MS/TP frame */
 130   1          else if (max_apdu <= 480)
 131   1              octet |= 0x03;
 132   1          else if (max_apdu <= 1024)
 133   1              octet |= 0x04;
 134   1          /* fits in an ISO 8802-3 frame */
 135   1          else if (max_apdu <= 1476)
 136   1              octet |= 0x05;
 137   1      
 138   1          return octet;
 139   1      }
 140          
 141          /* from clause 20.1.2.4 max-segments-accepted */
 142          /* and clause 20.1.2.5 max-APDU-length-accepted */
 143          /* returns the encoded octet */
 144          int decode_max_segs(
 145              uint8_t octet)
 146          {
 147   1          int max_segs = 0;
 148   1      
 149   1          switch (octet & 0xF0) {
 150   2              case 0:
 151   2                  max_segs = 0;
 152   2                  break;
 153   2              case 0x10:
 154   2                  max_segs = 2;
 155   2                  break;
 156   2              case 0x20:
 157   2                  max_segs = 4;
 158   2                  break;
 159   2              case 0x30:
 160   2                  max_segs = 8;
 161   2                  break;
 162   2              case 0x40:
 163   2                  max_segs = 16;
 164   2                  break;
 165   2              case 0x50:
 166   2                  max_segs = 32;
 167   2                  break;
 168   2              case 0x60:
 169   2                  max_segs = 64;
 170   2                  break;
 171   2              case 0x70:
 172   2                  max_segs = 65;
 173   2                  break;
 174   2              default:
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 4   

 175   2                  break;
 176   2          }
 177   1      
 178   1          return max_segs;
 179   1      }
 180          
 181          int decode_max_apdu(
 182              uint8_t octet)
 183          {
 184   1          int max_apdu = 0;
 185   1      
 186   1          switch (octet & 0x0F) {
 187   2              case 0:
 188   2                  max_apdu = 50;
 189   2                  break;
 190   2              case 1:
 191   2                  max_apdu = 128;
 192   2                  break;
 193   2              case 2:
 194   2                  max_apdu = 206;
 195   2                  break;
 196   2              case 3:
 197   2                  max_apdu = 480;
 198   2                  break;
 199   2              case 4:
 200   2                  max_apdu = 1024;
 201   2                  break;
 202   2              case 5:
 203   2                  max_apdu = 1476;
 204   2                  break;
 205   2              default:
 206   2                  break;
 207   2          }
 208   1      
 209   1          return max_apdu;
 210   1      }
 211          
 212          /* from clause 20.2.1 General Rules for Encoding BACnet Tags */
 213          /* returns the number of apdu bytes consumed */
 214          int encode_tag(
 215              uint8_t * apdu,
 216              uint8_t tag_number,
 217              bool context_specific,
 218              uint32_t len_value_type)
 219          {
 220   1          int len = 1;        /* return value */
 221   1      
 222   1          apdu[0] = 0;
 223   1          if (context_specific)
 224   1              apdu[0] = BIT3;
 225   1      
 226   1          /* additional tag byte after this byte */
 227   1          /* for extended tag byte */
 228   1          if (tag_number <= 14) {
 229   2              apdu[0] |= (tag_number << 4);
 230   2          } else {
 231   2              apdu[0] |= 0xF0;
 232   2              apdu[1] = tag_number;
 233   2              len++;
 234   2          }
 235   1      
 236   1          /* NOTE: additional len byte(s) after extended tag byte */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 5   

 237   1          /* if larger than 4 */
 238   1          if (len_value_type <= 4) {
 239   2              apdu[0] |= len_value_type;
 240   2          } else {
 241   2              apdu[0] |= 5;
 242   2              if (len_value_type <= 253) {
 243   3                  apdu[len++] = (uint8_t) len_value_type;
 244   3              } else if (len_value_type <= 65535) {
 245   3                  apdu[len++] = 254;
 246   3                  len += encode_unsigned16(&apdu[len], (uint16_t) len_value_type);
 247   3              } else {
 248   3                  apdu[len++] = 255;
 249   3                  len += encode_unsigned32(&apdu[len], len_value_type);
 250   3              }
 251   2          }
 252   1      
 253   1          return len;
 254   1      }
 255          
 256          /* from clause 20.2.1.3.2 Constructed Data */
 257          /* returns the number of apdu bytes consumed */
 258          int encode_opening_tag(
 259              uint8_t * apdu,
 260              uint8_t tag_number)
 261          {
 262   1          int len = 1;
 263   1      
 264   1          /* set class field to context specific */
 265   1          apdu[0] = BIT3;
 266   1          /* additional tag byte after this byte for extended tag byte */
 267   1          if (tag_number <= 14) {
 268   2              apdu[0] |= (tag_number << 4);
 269   2          } else {
 270   2              apdu[0] |= 0xF0;
 271   2              apdu[1] = tag_number;
 272   2              len++;
 273   2          }
 274   1          /* set type field to opening tag */
 275   1          apdu[0] |= 6;
 276   1      
 277   1          return len;
 278   1      }
 279          
 280          /* from clause 20.2.1.3.2 Constructed Data */
 281          /* returns the number of apdu bytes consumed */
 282          int encode_closing_tag(
 283              uint8_t * apdu,
 284              uint8_t tag_number)
 285          {
 286   1          int len = 1;
 287   1      
 288   1          /* set class field to context specific */
 289   1          apdu[0] = BIT3;
 290   1          /* additional tag byte after this byte for extended tag byte */
 291   1          if (tag_number <= 14) {
 292   2              apdu[0] |= (tag_number << 4);
 293   2          } else {
 294   2              apdu[0] |= 0xF0;
 295   2              apdu[1] = tag_number;
 296   2              len++;
 297   2          }
 298   1          /* set type field to closing tag */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 6   

 299   1          apdu[0] |= 7;
 300   1      
 301   1          return len;
 302   1      }
 303          
 304          
 305          
 306          int decode_tag_number(
 307              uint8_t * apdu,
 308              uint8_t * tag_number)
 309          {
 310   1          int len = 1;        /* return value */
 311   1      
 312   1          /* decode the tag number first */
 313   1          if (IS_EXTENDED_TAG_NUMBER(apdu[0])) {
 314   2              /* extended tag */
 315   2              if (tag_number) {
 316   3                  *tag_number = apdu[1];
 317   3              }
 318   2              len++;
 319   2          } else {
 320   2              if (tag_number) {
 321   3                  *tag_number = (uint8_t) (apdu[0] >> 4);
 322   3              }
 323   2          }
 324   1      
 325   1          return len;
 326   1      }
 327          
 328          /* Same as function above, but will safely fail if packet has been truncated */
 329          int decode_tag_number_safe(
 330              uint8_t * apdu,
 331              uint32_t apdu_len_remaining,
 332              uint8_t * tag_number)
 333          {
 334   1          int len = 0;        /* return value */
 335   1      
 336   1          /* decode the tag number first */
 337   1          if (apdu_len_remaining >= 1) {
 338   2              if (IS_EXTENDED_TAG_NUMBER(apdu[0]) && apdu_len_remaining >= 2) {
 339   3                  /* extended tag */
 340   3                  if (tag_number) {
 341   4                      *tag_number = apdu[1];
 342   4                  }
 343   3                  len = 2;
 344   3              } else {
 345   3                  if (tag_number) {
 346   4                      *tag_number = (uint8_t) (apdu[0] >> 4);
 347   4                  }
 348   3                  len = 1;
 349   3              }
 350   2          }
 351   1          return len;
 352   1      }
 353          
 354          bool decode_is_opening_tag(
 355              uint8_t * apdu)
 356          {
 357   1          return (bool) ((apdu[0] & 0x07) == 6);
 358   1      }
 359          
 360          /* from clause 20.2.1.3.2 Constructed Data */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 7   

 361          /* returns the number of apdu bytes consumed */
 362          bool decode_is_closing_tag(
 363              uint8_t * apdu)
 364          {
 365   1          return (bool) ((apdu[0] & 0x07) == 7);
 366   1      }
 367          
 368          /* from clause 20.2.1.3.2 Constructed Data */
 369          /* returns the number of apdu bytes consumed */
 370          int decode_tag_number_and_value(
 371              uint8_t * apdu,
 372              uint8_t * tag_number,
 373              uint32_t * value)
 374          {
 375   1          int len = 1;
 376   1          uint16_t value16;
 377   1          uint32_t value32;
 378   1      
 379   1          len = decode_tag_number(&apdu[0], tag_number);
 380   1          if (IS_EXTENDED_VALUE(apdu[0])) {
 381   2              /* tagged as uint32_t */
 382   2              if (apdu[len] == 255) {
 383   3                  len++;
 384   3                  len += decode_unsigned32(&apdu[len], &value32);
 385   3                  if (value) {
 386   4                      *value = value32;
 387   4                  }
 388   3              }
 389   2              /* tagged as uint16_t */
 390   2              else if (apdu[len] == 254) {
 391   3                  len++;
 392   3                  len += decode_unsigned16(&apdu[len], &value16);
 393   3                  if (value) {
 394   4                      *value = value16;
 395   4                  }
 396   3              }
 397   2              /* no tag - must be uint8_t */
 398   2              else {
 399   3                  if (value) {
 400   4                      *value = apdu[len];
 401   4                  }
 402   3                  len++;
 403   3              }
 404   2          } else if (IS_OPENING_TAG(apdu[0]) && value) {
 405   2              *value = 0;
 406   2          } else if (IS_CLOSING_TAG(apdu[0]) && value) {
 407   2              /* closing tag */
 408   2              *value = 0;
 409   2          } else if (value) {
 410   2              /* small value */
 411   2              *value = apdu[0] & 0x07;
 412   2          }
 413   1      
 414   1          return len;
 415   1      }
 416          
 417          /* Same as function above, but will safely fail is packet has been truncated */
 418          int decode_tag_number_and_value_safe(
 419              uint8_t * apdu,
 420              uint32_t apdu_len_remaining,
 421              uint8_t * tag_number,
 422              uint32_t * value)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 8   

 423          {
 424   1          int len = 0;
 425   1      
 426   1          len = decode_tag_number_safe(&apdu[0], apdu_len_remaining, tag_number);
 427   1      
 428   1          if (len > 0) {
 429   2              apdu_len_remaining -= len;
 430   2              if (IS_EXTENDED_VALUE(apdu[0])) {
 431   3                  /* tagged as uint32_t */
 432   3                  if (apdu[len] == 255 && apdu_len_remaining >= 5) {
 433   4                      uint32_t value32;
 434   4                      len++;
 435   4                      len += decode_unsigned32(&apdu[len], &value32);
 436   4                      if (value) {
 437   5                          *value = value32;
 438   5                      }
 439   4                  }
 440   3                  /* tagged as uint16_t */
 441   3                  else if (apdu[len] == 254 && apdu_len_remaining >= 3) {
 442   4                      uint16_t value16;
 443   4                      len++;
 444   4                      len += decode_unsigned16(&apdu[len], &value16);
 445   4                      if (value) {
 446   5                          *value = value16;
 447   5                      }
 448   4                  }
 449   3                  /* no tag - must be uint8_t */
 450   3                  else if (apdu[len] < 254 && apdu_len_remaining >= 1) {
 451   4                      if (value) {
 452   5                          *value = apdu[len];
 453   5                      }
 454   4                      len++;
 455   4                  } else {
 456   4                      /* packet is truncated */
 457   4                      len = 0;
 458   4                  }
 459   3              } else if (IS_OPENING_TAG(apdu[0]) && value) {
 460   3                  *value = 0;
 461   3              } else if (IS_CLOSING_TAG(apdu[0]) && value) {
 462   3                  /* closing tag */
 463   3                  *value = 0;
 464   3              } else if (value) {
 465   3                  /* small value */
 466   3                  *value = apdu[0] & 0x07;
 467   3              }
 468   2          }
 469   1          return len;
 470   1      }
 471          
 472          /* from clause 20.2.1.3.2 Constructed Data */
 473          /* returns true if the tag is context specific and matches */
 474          bool decode_is_context_tag(
 475              uint8_t * apdu,
 476              uint8_t tag_number)
 477          {
 478   1          uint8_t my_tag_number = 0;
 479   1      
 480   1          decode_tag_number(apdu, &my_tag_number);
 481   1          return (bool) (IS_CONTEXT_SPECIFIC(*apdu) &&
 482   1              (my_tag_number == tag_number));
 483   1      }
 484          
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 9   

 485          bool decode_is_context_tag_with_length(
 486              uint8_t * apdu,
 487              uint8_t tag_number,
 488              int *tag_length)
 489          {
 490   1          uint8_t my_tag_number = 0;
 491   1      
 492   1          *tag_length = decode_tag_number(apdu, &my_tag_number);
 493   1      
 494   1          return (bool) (IS_CONTEXT_SPECIFIC(*apdu) &&
 495   1              (my_tag_number == tag_number));
 496   1      }
 497          
 498          /* from clause 20.2.1.3.2 Constructed Data */
 499          /* returns the true if the tag matches */
 500          bool decode_is_opening_tag_number(
 501              uint8_t * apdu,
 502              uint8_t tag_number)
 503          {
 504   1          uint8_t my_tag_number = 0;
 505   1      
 506   1          decode_tag_number(apdu, &my_tag_number);
 507   1          return (bool) (IS_OPENING_TAG(apdu[0]) && (my_tag_number == tag_number));
 508   1      }
 509          
 510          /* from clause 20.2.1.3.2 Constructed Data */
 511          /* returns the number of apdu bytes consumed */
 512          bool decode_is_closing_tag_number(
 513              uint8_t * apdu,
 514              uint8_t tag_number)
 515          {
 516   1          uint8_t my_tag_number = 0;
 517   1      
 518   1          decode_tag_number(apdu, &my_tag_number);
 519   1          return (bool) (IS_CLOSING_TAG(apdu[0]) && (my_tag_number == tag_number));
 520   1      }
 521          
 522          /* from clause 20.2.3 Encoding of a Boolean Value */
 523          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 524          /* returns the number of apdu bytes consumed */
 525          int encode_application_boolean(
 526              uint8_t * apdu,
 527              bool boolean_value)
 528          {
 529   1          int len = 0;
 530   1          uint32_t len_value = 0;
 531   1      
 532   1          if (boolean_value) {
 533   2              len_value = 1;
 534   2          }
 535   1          len =
 536   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_BOOLEAN, false, len_value);
 537   1      
 538   1          return len;
 539   1      }
 540          
 541          /* context tagged is encoded differently */
 542          int encode_context_boolean(
 543              uint8_t * apdu,
 544              uint8_t tag_number,
 545              bool boolean_value)
 546          {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 10  

 547   1          int len = 0;        /* return value */
 548   1      
 549   1          len = encode_tag(&apdu[0], (uint8_t) tag_number, true, 1);
 550   1          apdu[len] = (bool) (boolean_value ? 1 : 0);
 551   1          len++;
 552   1      
 553   1          return len;
 554   1      }
 555          
 556          bool decode_context_boolean(
 557              uint8_t * apdu)
 558          {
 559   1          bool boolean_value = false;
 560   1      
 561   1          if (apdu[0]) {
 562   2              boolean_value = true;
 563   2          }
 564   1      
 565   1          return boolean_value;
 566   1      }
 567          
 568          int decode_context_boolean2(
 569              uint8_t * apdu,
 570              uint8_t tag_number,
 571              bool * boolean_value)
 572          {
 573   1          int len = 0;
 574   1          if (decode_is_context_tag_with_length(&apdu[len], tag_number, &len)) {
 575   2              if (apdu[len]) {
 576   3                  *boolean_value = true;
 577   3              } else {
 578   3                  *boolean_value = false;
 579   3              }
 580   2              len++;
 581   2          } else {
 582   2              len = BACNET_STATUS_ERROR;
 583   2          }
 584   1          return len;
 585   1      }
 586          
 587          /* from clause 20.2.3 Encoding of a Boolean Value */
 588          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 589          /* returns the number of apdu bytes consumed */
 590          bool decode_boolean(
 591              uint32_t len_value)
 592          {
 593   1          bool boolean_value = false;
 594   1      
 595   1          if (len_value) {
 596   2              boolean_value = true;
 597   2          }
 598   1      
 599   1          return boolean_value;
 600   1      }
 601          
 602          /* from clause 20.2.2 Encoding of a Null Value */
 603          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 604          /* returns the number of apdu bytes consumed */
 605          int encode_application_null(
 606              uint8_t * apdu)
 607          {
 608   1          return encode_tag(&apdu[0], BACNET_APPLICATION_TAG_NULL, false, 0);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 11  

 609   1      }
 610          
 611          int encode_context_null(
 612              uint8_t * apdu,
 613              uint8_t tag_number)
 614          {
 615   1          return encode_tag(&apdu[0], tag_number, true, 0);
 616   1      }
 617          
 618          static uint8_t byte_reverse_bits(
 619              uint8_t in_byte)
 620          {
 621   1          uint8_t out_byte = 0;
 622   1      
 623   1          if (in_byte & BIT0) {
 624   2              out_byte |= BIT7;
 625   2          }
 626   1          if (in_byte & BIT1) {
 627   2              out_byte |= BIT6;
 628   2          }
 629   1          if (in_byte & BIT2) {
 630   2              out_byte |= BIT5;
 631   2          }
 632   1          if (in_byte & BIT3) {
 633   2              out_byte |= BIT4;
 634   2          }
 635   1          if (in_byte & BIT4) {
 636   2              out_byte |= BIT3;
 637   2          }
 638   1          if (in_byte & BIT5) {
 639   2              out_byte |= BIT2;
 640   2          }
 641   1          if (in_byte & BIT6) {
 642   2              out_byte |= BIT1;
 643   2          }
 644   1          if (in_byte & BIT7) {
 645   2              out_byte |= BIT0;
 646   2          }
 647   1      
 648   1          return out_byte;
 649   1      }
 650          
 651          /* from clause 20.2.10 Encoding of a Bit String Value */
 652          /* returns the number of apdu bytes consumed */
 653          int decode_bitstring(
 654              uint8_t * apdu,
 655              uint32_t len_value,
 656              BACNET_BIT_STRING * bit_string)
 657          {
 658   1          int len = 0;
 659   1          uint8_t unused_bits = 0;
 660   1          uint32_t i = 0;
 661   1          uint32_t bytes_used = 0;
 662   1      
 663   1      
 664   1          bitstring_init(bit_string);
 665   1          if (len_value) {
 666   2              /* the first octet contains the unused bits */
 667   2              bytes_used = len_value - 1;
 668   2              if (bytes_used <= MAX_BITSTRING_BYTES) {
 669   3                  len = 1;
 670   3                  for (i = 0; i < bytes_used; i++) {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 12  

 671   4                      bitstring_set_octet(bit_string, (uint8_t) i,
 672   4                          byte_reverse_bits(apdu[len++]));
 673   4                  }
 674   3                  unused_bits = (uint8_t) (apdu[0] & 0x07);
 675   3                  bitstring_set_bits_used(bit_string, (uint8_t) bytes_used,
 676   3                      unused_bits);
 677   3              }
 678   2          }
 679   1      
 680   1          return len;
 681   1      }
 682          
 683          int decode_context_bitstring(
 684              uint8_t * apdu,
 685              uint8_t tag_number,
 686              BACNET_BIT_STRING * bit_string)
 687          {
 688   1          uint32_t len_value;
 689   1          int len = 0;
 690   1      
 691   1          if (decode_is_context_tag(&apdu[len], tag_number)) {
 692   2              len +=
 693   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
 694   2              len += decode_bitstring(&apdu[len], len_value, bit_string);
 695   2          } else {
 696   2              len = BACNET_STATUS_ERROR;
 697   2          }
 698   1          return len;
 699   1      }
 700          
 701          
 702          /* from clause 20.2.10 Encoding of a Bit String Value */
 703          /* returns the number of apdu bytes consumed */
 704          int encode_bitstring(
 705              uint8_t * apdu,
 706              BACNET_BIT_STRING * bit_string)
 707          {
 708   1          int len = 0;
 709   1          uint8_t remaining_used_bits = 0;
 710   1          uint8_t used_bytes = 0;
 711   1          uint8_t i = 0;
 712   1      
 713   1          /* if the bit string is empty, then the first octet shall be zero */
 714   1          if (bitstring_bits_used(bit_string) == 0) {
 715   2              apdu[len++] = 0;
 716   2          } else {
 717   2              used_bytes = bitstring_bytes_used(bit_string);
 718   2              remaining_used_bits =
 719   2                  (uint8_t) (bitstring_bits_used(bit_string) - ((used_bytes -
 720   2                          1) * 8));
 721   2              /* number of unused bits in the subsequent final octet */
 722   2              apdu[len++] = (uint8_t) (8 - remaining_used_bits);
 723   2              for (i = 0; i < used_bytes; i++) {
 724   3                  apdu[len++] = byte_reverse_bits(bitstring_octet(bit_string, i));
 725   3              }
 726   2          }
 727   1      
 728   1          return len;
 729   1      }
 730          
 731          int encode_application_bitstring(
 732              uint8_t * apdu,
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 13  

 733              BACNET_BIT_STRING * bit_string)
 734          {
 735   1          int len = 0;
 736   1          uint32_t bit_string_encoded_length = 1;     /* 1 for the bits remaining octet */
 737   1      
 738   1          /* bit string may use more than 1 octet for the tag, so find out how many */
 739   1          bit_string_encoded_length += bitstring_bytes_used(bit_string);
 740   1          len =
 741   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_BIT_STRING, false,
 742   1              bit_string_encoded_length);
 743   1          len += encode_bitstring(&apdu[len], bit_string);
 744   1      
 745   1          return len;
 746   1      }
 747          
 748          int encode_context_bitstring(
 749              uint8_t * apdu,
 750              uint8_t tag_number,
 751              BACNET_BIT_STRING * bit_string)
 752          {
 753   1          int len = 0;
 754   1          uint32_t bit_string_encoded_length = 1;     /* 1 for the bits remaining octet */
 755   1      
 756   1          /* bit string may use more than 1 octet for the tag, so find out how many */
 757   1          bit_string_encoded_length += bitstring_bytes_used(bit_string);
 758   1          len = encode_tag(&apdu[0], tag_number, true, bit_string_encoded_length);
 759   1          len += encode_bitstring(&apdu[len], bit_string);
 760   1      
 761   1          return len;
 762   1      }
 763          
 764          /* from clause 20.2.14 Encoding of an Object Identifier Value */
 765          /* returns the number of apdu bytes consumed */
 766          int decode_object_id(
 767              uint8_t * apdu,
 768              uint16_t * object_type,
 769              uint32_t * instance)
 770          {
 771   1          uint32_t value = 0;
 772   1          int len = 0;
 773   1      
 774   1          len = decode_unsigned32(apdu, &value);
 775   1          *object_type =
 776   1              (uint16_t) (((value >> BACNET_INSTANCE_BITS) & BACNET_MAX_OBJECT));
 777   1          *instance = (value & BACNET_MAX_INSTANCE);
 778   1      
 779   1          return len;
 780   1      }
 781          
 782          int decode_object_id_safe(
 783              uint8_t * apdu,
 784              uint32_t len_value,
 785              uint16_t * object_type,
 786              uint32_t * instance)
 787          {
 788   1          if (len_value != 4) {
 789   2              return 0;
 790   2          } else {
 791   2              return decode_object_id(apdu, object_type, instance);
 792   2          }
 793   1      }
 794          
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 14  

 795          int decode_context_object_id(
 796              uint8_t * apdu,
 797              uint8_t tag_number,
 798              uint16_t * object_type,
 799              uint32_t * instance)
 800          {
 801   1          int len = 0;
 802   1      
 803   1          if (decode_is_context_tag_with_length(&apdu[len], tag_number, &len)) {
 804   2              len += decode_object_id(&apdu[len], object_type, instance);
 805   2          } else {
 806   2              len = BACNET_STATUS_ERROR;
 807   2          }
 808   1          return len;
 809   1      }
 810          
 811          /* from clause 20.2.14 Encoding of an Object Identifier Value */
 812          /* returns the number of apdu bytes consumed */
 813          int encode_bacnet_object_id(
 814              uint8_t * apdu,
 815              int object_type,
 816              uint32_t instance)
 817          {
 818   1          uint32_t value = 0;
 819   1          uint32_t type = 0;
 820   1          int len = 0;
 821   1      
 822   1          type = (uint32_t) object_type;
 823   1          value =
 824   1              ((type & BACNET_MAX_OBJECT) << BACNET_INSTANCE_BITS) | (instance &
 825   1              BACNET_MAX_INSTANCE);
 826   1          len = encode_unsigned32(apdu, value);
 827   1      
 828   1          return len;
 829   1      }
 830          
 831          /* from clause 20.2.14 Encoding of an Object Identifier Value */
 832          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 833          /* returns the number of apdu bytes consumed */
 834          int encode_context_object_id(
 835              uint8_t * apdu,
 836              uint8_t tag_number,
 837              int object_type,
 838              uint32_t instance)
 839          {
 840   1          int len = 0;
 841   1      
 842   1          /* length of object id is 4 octets, as per 20.2.14 */
 843   1      
 844   1          len = encode_tag(&apdu[0], tag_number, true, 4);
 845   1          len += encode_bacnet_object_id(&apdu[len], object_type, instance);
 846   1      
 847   1          return len;
 848   1      }
 849          
 850          /* from clause 20.2.14 Encoding of an Object Identifier Value */
 851          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 852          /* returns the number of apdu bytes consumed */
 853          int encode_application_object_id(
 854              uint8_t * apdu,
 855              int object_type,
 856              uint32_t instance)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 15  

 857          {
 858   1          int len = 0;
 859   1      
 860   1          /* assumes that the tag only consumes 1 octet */
 861   1          len = encode_bacnet_object_id(&apdu[1], object_type, instance);
 862   1          len +=
 863   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_OBJECT_ID, false,
 864   1              (uint32_t) len);
 865   1      
 866   1          return len;
 867   1      }
 868          
 869          #if BACNET_USE_OCTETSTRING
 870          
 871          /* from clause 20.2.8 Encoding of an Octet String Value */
 872          /* returns the number of apdu bytes consumed */
 873          int encode_octet_string(
 874              uint8_t * apdu,
 875              BACNET_OCTET_STRING * octet_string)
 876          {
 877   1          int len = 0;        /* return value */
 878   1          uint8_t *value;
 879   1          int i = 0;  /* loop counter */
 880   1      
 881   1          if (octet_string) {
 882   2              /* FIXME: might need to pass in the length of the APDU
 883   2                 to bounds check since it might not be the only data chunk */
 884   2              len = (int) octetstring_length(octet_string);
 885   2              value = octetstring_value(octet_string);
 886   2              for (i = 0; i < len; i++) {
 887   3                  apdu[i] = value[i];
 888   3              }
 889   2          }
 890   1      
 891   1          return len;
 892   1      }
 893          
 894          /* from clause 20.2.8 Encoding of an Octet String Value */
 895          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 896          /* returns the number of apdu bytes consumed */
 897          int encode_application_octet_string(
 898              uint8_t * apdu,
 899              BACNET_OCTET_STRING * octet_string)
 900          {
 901   1          int apdu_len = 0;
 902   1      
 903   1          if (octet_string) {
 904   2              apdu_len =
 905   2                  encode_tag(&apdu[0], BACNET_APPLICATION_TAG_OCTET_STRING, false,
 906   2                  octetstring_length(octet_string));
 907   2              /* FIXME: probably need to pass in the length of the APDU
 908   2                 to bounds check since it might not be the only data chunk */
 909   2              if ((apdu_len + octetstring_length(octet_string)) < MAX_APDU) {
 910   3                  apdu_len += encode_octet_string(&apdu[apdu_len], octet_string);
 911   3              } else {
 912   3                  apdu_len = 0;
 913   3              }
 914   2          }
 915   1      
 916   1          return apdu_len;
 917   1      }
 918          
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 16  

 919          /* from clause 20.2.8 Encoding of an Octet String Value */
 920          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 921          /* returns the number of apdu bytes consumed */
 922          int encode_context_octet_string(
 923              uint8_t * apdu,
 924              uint8_t tag_number,
 925              BACNET_OCTET_STRING * octet_string)
 926          {
 927   1          int apdu_len = 0;
 928   1      
 929   1          if (apdu && octet_string) {
 930   2              apdu_len =
 931   2                  encode_tag(&apdu[0], tag_number, true,
 932   2                  octetstring_length(octet_string));
 933   2              if ((apdu_len + octetstring_length(octet_string)) < MAX_APDU) {
 934   3                  apdu_len += encode_octet_string(&apdu[apdu_len], octet_string);
 935   3              } else {
 936   3                  apdu_len = 0;
 937   3              }
 938   2          }
 939   1      
 940   1          return apdu_len;
 941   1      }
 942          
 943          /* from clause 20.2.8 Encoding of an Octet String Value */
 944          /* and 20.2.1 General Rules for Encoding BACnet Tags */
 945          /* returns the number of apdu bytes consumed */
 946          int decode_octet_string(
 947              uint8_t * apdu,
 948              uint32_t len_value,
 949              BACNET_OCTET_STRING * octet_string)
 950          {
 951   1          int len = 0;        /* return value */
 952   1          bool status = false;
 953   1      
 954   1          status = octetstring_init(octet_string, &apdu[0], len_value);
 955   1          if (status) {
 956   2              len = (int) len_value;
 957   2          }
 958   1      
 959   1          return len;
 960   1      }
 961          
 962          int decode_context_octet_string(
 963              uint8_t * apdu,
 964              uint8_t tag_number,
 965              BACNET_OCTET_STRING * octet_string)
 966          {
 967   1          int len = 0;        /* return value */
 968   1          bool status = false;
 969   1          uint32_t len_value = 0;
 970   1      
 971   1          if (decode_is_context_tag(&apdu[len], tag_number)) {
 972   2              len +=
 973   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
 974   2      
 975   2              status = octetstring_init(octet_string, &apdu[len], len_value);
 976   2      
 977   2              if (status) {
 978   3                  len += len_value;
 979   3              }
 980   2          } else {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 17  

 981   2              len = BACNET_STATUS_ERROR;
 982   2          }
 983   1      
 984   1          return len;
 985   1      }
 986          #endif
 987          
 988          /* from clause 20.2.9 Encoding of a Character String Value */
 989          /* returns the number of apdu bytes consumed */
 990          int encode_bacnet_character_string(
 991              uint8_t * apdu,
 992              BACNET_CHARACTER_STRING * char_string)
 993          {
 994   1          int len, i;
 995   1          char *pString;
 996   1      
 997   1          len = (int) characterstring_length(char_string);
 998   1          apdu[0] = characterstring_encoding(char_string);
 999   1          pString = characterstring_value(char_string);
1000   1          for (i = 0; i < len; i++) {
1001   2              apdu[1 + i] = (uint8_t) pString[i];
1002   2          }
1003   1      
1004   1          return len + 1 /* for encoding */ ;
1005   1      }
1006          
1007          /* from clause 20.2.9 Encoding of a Character String Value */
1008          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1009          /* returns the number of apdu bytes consumed */
1010          int encode_application_character_string(
1011              uint8_t * apdu,
1012              BACNET_CHARACTER_STRING * char_string)
1013          {
1014   1          int len = 0;
1015   1          int string_len = 0;
1016   1      
1017   1          string_len =
1018   1              (int) characterstring_length(char_string) + 1 /* for encoding */ ;
1019   1          len =
1020   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_CHARACTER_STRING, false,
1021   1              (uint32_t) string_len);
1022   1          if ((len + string_len) < MAX_APDU) {
1023   2              len += encode_bacnet_character_string(&apdu[len], char_string);
1024   2          } else {
1025   2              len = 0;
1026   2          }
1027   1      
1028   1          return len;
1029   1      }
1030          
1031          int encode_context_character_string(
1032              uint8_t * apdu,
1033              uint8_t tag_number,
1034              BACNET_CHARACTER_STRING * char_string)
1035          {
1036   1          int len = 0;
1037   1          int string_len = 0;
1038   1      
1039   1          string_len =
1040   1              (int) characterstring_length(char_string) + 1 /* for encoding */ ;
1041   1          len += encode_tag(&apdu[0], tag_number, true, (uint32_t) string_len);
1042   1          if ((len + string_len) < MAX_APDU) {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 18  

1043   2              len += encode_bacnet_character_string(&apdu[len], char_string);
1044   2          } else {
1045   2              len = 0;
1046   2          }
1047   1      
1048   1          return len;
1049   1      }
1050          
1051          /* from clause 20.2.9 Encoding of a Character String Value */
1052          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1053          /* returns the number of apdu bytes consumed */
1054          int decode_character_string(
1055              uint8_t * apdu,
1056              uint32_t len_value,
1057              BACNET_CHARACTER_STRING * char_string)
1058          {
1059   1          int len = 0;        /* return value */
1060   1          bool status = false;
1061   1      
1062   1          status =
1063   1              characterstring_init(char_string, apdu[0], (char *) &apdu[1],
1064   1              len_value - 1);
1065   1          if (status) {
1066   2              len = (int) len_value;
1067   2          }
1068   1      
1069   1          return len;
1070   1      }
1071          
1072          int decode_context_character_string(
1073              uint8_t * apdu,
1074              uint8_t tag_number,
1075              BACNET_CHARACTER_STRING * char_string)
1076          {
1077   1          int len = 0;        /* return value */
1078   1          bool status = false;
1079   1          uint32_t len_value = 0;
1080   1      
1081   1          if (decode_is_context_tag(&apdu[len], tag_number)) {
1082   2              len +=
1083   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
1084   2      
1085   2              status =
1086   2                  characterstring_init(char_string, apdu[len],
1087   2                  (char *) &apdu[len + 1], len_value - 1);
1088   2              if (status) {
1089   3                  len += len_value;
1090   3              }
1091   2          } else {
1092   2              len = BACNET_STATUS_ERROR;
1093   2          }
1094   1      
1095   1          return len;
1096   1      }
1097          
1098          /* from clause 20.2.4 Encoding of an Unsigned Integer Value */
1099          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1100          /* returns the number of apdu bytes consumed */
1101          int decode_unsigned(
1102              uint8_t * apdu,
1103              uint32_t len_value,
1104              uint32_t * value)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 19  

1105          {
1106   1          uint16_t unsigned16_value = 0;
1107   1      
1108   1          if (value) {
1109   2              switch (len_value) {
1110   3                  case 1:
1111   3                      *value = apdu[0];
1112   3                      break;
1113   3                  case 2:
1114   3                      decode_unsigned16(&apdu[0], &unsigned16_value);
1115   3                      *value = unsigned16_value;
1116   3                      break;
1117   3                  case 3:
1118   3                      decode_unsigned24(&apdu[0], value);
1119   3                      break;
1120   3                  case 4:
1121   3                      decode_unsigned32(&apdu[0], value);
1122   3                      break;
1123   3                  default:
1124   3                      *value = 0;
1125   3                      break;
1126   3              }
1127   2          }
1128   1      
1129   1          return (int) len_value;
1130   1      }
1131          
1132          int decode_context_unsigned(
1133              uint8_t * apdu,
1134              uint8_t tag_number,
1135              uint32_t * value)
1136          {
1137   1          uint32_t len_value;
1138   1          int len = 0;
1139   1      
1140   1          if (decode_is_context_tag(&apdu[len], tag_number)) {
1141   2              len +=
1142   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
1143   2              len += decode_unsigned(&apdu[len], len_value, value);
1144   2          } else {
1145   2              len = BACNET_STATUS_ERROR;
1146   2          }
1147   1          return len;
1148   1      }
1149          
1150          
1151          /* from clause 20.2.4 Encoding of an Unsigned Integer Value */
1152          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1153          /* returns the number of apdu bytes consumed */
1154          int encode_bacnet_unsigned(
1155              uint8_t * apdu,
1156              uint32_t value)
1157          {
1158   1          int len = 0;        /* return value */
1159   1      
1160   1          if (value < 0x100) {
1161   2              apdu[0] = (uint8_t) value;
1162   2              len = 1;
1163   2          } else if (value < 0x10000) {
1164   2              len = encode_unsigned16(&apdu[0], (uint16_t) value);
1165   2          } else if (value < 0x1000000) {
1166   2              len = encode_unsigned24(&apdu[0], value);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 20  

1167   2          } else {
1168   2              len = encode_unsigned32(&apdu[0], value);
1169   2          }
1170   1      
1171   1          return len;
1172   1      }
1173          
1174          /* from clause 20.2.4 Encoding of an Unsigned Integer Value */
1175          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1176          /* returns the number of apdu bytes consumed */
1177          int encode_context_unsigned(
1178              uint8_t * apdu,
1179              uint8_t tag_number,
1180              uint32_t value)
1181          {
1182   1          int len = 0;
1183   1      
1184   1          /* length of unsigned is variable, as per 20.2.4 */
1185   1          if (value < 0x100) {
1186   2              len = 1;
1187   2          } else if (value < 0x10000) {
1188   2              len = 2;
1189   2          } else if (value < 0x1000000) {
1190   2              len = 3;
1191   2          } else {
1192   2              len = 4;
1193   2          }
1194   1      
1195   1          len = encode_tag(&apdu[0], tag_number, true, (uint32_t) len);
1196   1          len += encode_bacnet_unsigned(&apdu[len], value);
1197   1      
1198   1          return len;
1199   1      }
1200          
1201          /* from clause 20.2.4 Encoding of an Unsigned Integer Value */
1202          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1203          /* returns the number of apdu bytes consumed */
1204          int encode_application_unsigned(
1205              uint8_t * apdu,
1206              uint32_t value)
1207          {
1208   1          int len = 0;
1209   1      
1210   1          len = encode_bacnet_unsigned(&apdu[1], value);
1211   1          len +=
1212   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_UNSIGNED_INT, false,
1213   1              (uint32_t) len);
1214   1      
1215   1          return len;
1216   1      }
1217          
1218          /* from clause 20.2.11 Encoding of an Enumerated Value */
1219          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1220          /* returns the number of apdu bytes consumed */
1221          int decode_enumerated(
1222              uint8_t * apdu,
1223              uint32_t len_value,
1224              uint32_t * value)
1225          {
1226   1          uint32_t unsigned_value = 0;
1227   1          int len;
1228   1      
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 21  

1229   1          len = decode_unsigned(apdu, len_value, &unsigned_value);
1230   1          if (value) {
1231   2              *value = unsigned_value;
1232   2          }
1233   1      
1234   1          return len;
1235   1      }
1236          
1237          int decode_context_enumerated(
1238              uint8_t * apdu,
1239              uint8_t tag_value,
1240              uint32_t * value)
1241          {
1242   1          int len = 0;
1243   1          uint8_t tag_number;
1244   1          uint32_t len_value;
1245   1      
1246   1          if (decode_is_context_tag(&apdu[len], tag_value)) {
1247   2              len +=
1248   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
1249   2              len += decode_enumerated(&apdu[len], len_value, value);
1250   2          } else {
1251   2              len = BACNET_STATUS_ERROR;
1252   2          }
1253   1          return len;
1254   1      }
1255          
1256          /* from clause 20.2.11 Encoding of an Enumerated Value */
1257          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1258          /* returns the number of apdu bytes consumed */
1259          int encode_bacnet_enumerated(
1260              uint8_t * apdu,
1261              uint32_t value)
1262          {
1263   1          return encode_bacnet_unsigned(apdu, value);
1264   1      }
1265          
1266          /* from clause 20.2.11 Encoding of an Enumerated Value */
1267          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1268          /* returns the number of apdu bytes consumed */
1269          int encode_application_enumerated(
1270              uint8_t * apdu,
1271              uint32_t value)
1272          {
1273   1          int len = 0;        /* return value */
1274   1      
1275   1          /* assumes that the tag only consumes 1 octet */
1276   1          len = encode_bacnet_enumerated(&apdu[1], value);
1277   1          len +=
1278   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_ENUMERATED, false,
1279   1              (uint32_t) len);
1280   1      
1281   1          return len;
1282   1      }
1283          
1284          /* from clause 20.2.11 Encoding of an Enumerated Value */
1285          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1286          /* returns the number of apdu bytes consumed */
1287          int encode_context_enumerated(
1288              uint8_t * apdu,
1289              uint8_t tag_number,
1290              uint32_t value)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 22  

1291          {
1292   1          int len = 0;        /* return value */
1293   1      
1294   1          /* length of enumerated is variable, as per 20.2.11 */
1295   1          if (value < 0x100) {
1296   2              len = 1;
1297   2          } else if (value < 0x10000) {
1298   2              len = 2;
1299   2          } else if (value < 0x1000000) {
1300   2              len = 3;
1301   2          } else {
1302   2              len = 4;
1303   2          }
1304   1      
1305   1          len = encode_tag(&apdu[0], tag_number, true, (uint32_t) len);
1306   1          len += encode_bacnet_enumerated(&apdu[len], value);
1307   1      
1308   1          return len;
1309   1      }
1310          
1311          #if BACNET_USE_SIGNED
1312          /* from clause 20.2.5 Encoding of a Signed Integer Value */
1313          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1314          /* returns the number of apdu bytes consumed */
1315          int decode_signed(
1316              uint8_t * apdu,
1317              uint32_t len_value,
1318              int32_t * value)
1319          {
1320   1          if (value) {
1321   2              switch (len_value) {
1322   3                  case 1:
1323   3                      decode_signed8(&apdu[0], value);
1324   3                      break;
1325   3                  case 2:
1326   3                      decode_signed16(&apdu[0], value);
1327   3                      break;
1328   3                  case 3:
1329   3                      decode_signed24(&apdu[0], value);
1330   3                      break;
1331   3                  case 4:
1332   3                      decode_signed32(&apdu[0], value);
1333   3                      break;
1334   3                  default:
1335   3                      *value = 0;
1336   3                      break;
1337   3              }
1338   2          }
1339   1      
1340   1          return (int) len_value;
1341   1      }
1342          
1343          int decode_context_signed(
1344              uint8_t * apdu,
1345              uint8_t tag_number,
1346              int32_t * value)
1347          {
1348   1          uint32_t len_value;
1349   1          int len = 0;
1350   1      
1351   1          if (decode_is_context_tag(&apdu[len], tag_number)) {
1352   2              len +=
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 23  

1353   2                  decode_tag_number_and_value(&apdu[len], &tag_number, &len_value);
1354   2              len += decode_signed(&apdu[len], len_value, value);
1355   2          } else {
1356   2              len = BACNET_STATUS_ERROR;
1357   2          }
1358   1          return len;
1359   1      }
1360          
1361          /* from clause 20.2.5 Encoding of a Signed Integer Value */
1362          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1363          /* returns the number of apdu bytes consumed */
1364          int encode_bacnet_signed(
1365              uint8_t * apdu,
1366              int32_t value)
1367          {
1368   1          int len = 0;        /* return value */
1369   1      
1370   1          /* don't encode the leading X'FF' or X'00' of the two's compliment.
1371   1             That is, the first octet of any multi-octet encoded value shall
1372   1             not be X'00' if the most significant bit (bit 7) of the second
1373   1             octet is 0, and the first octet shall not be X'FF' if the most
1374   1             significant bit of the second octet is 1. */
1375   1          if ((value >= -128) && (value < 128)) {
1376   2              len = encode_signed8(&apdu[0], (int8_t) value);
1377   2          } else if ((value >= -32768) && (value < 32768)) {
1378   2              len = encode_signed16(&apdu[0], (int16_t) value);
1379   2          } else if ((value > -8388608) && (value < 8388608)) {
1380   2              len = encode_signed24(&apdu[0], value);
1381   2          } else {
1382   2              len = encode_signed32(&apdu[0], value);
1383   2          }
1384   1      
1385   1          return len;
1386   1      }
1387          
1388          /* from clause 20.2.5 Encoding of a Signed Integer Value */
1389          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1390          /* returns the number of apdu bytes consumed */
1391          int encode_application_signed(
1392              uint8_t * apdu,
1393              int32_t value)
1394          {
1395   1          int len = 0;        /* return value */
1396   1      
1397   1          /* assumes that the tag only consumes 1 octet */
1398   1          len = encode_bacnet_signed(&apdu[1], value);
1399   1          len +=
1400   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_SIGNED_INT, false,
1401   1              (uint32_t) len);
1402   1      
1403   1          return len;
1404   1      }
1405          
1406          /* from clause 20.2.5 Encoding of a Signed Integer Value */
1407          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1408          /* returns the number of apdu bytes consumed */
1409          int encode_context_signed(
1410              uint8_t * apdu,
1411              uint8_t tag_number,
1412              int32_t value)
1413          {
1414   1          int len = 0;        /* return value */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 24  

1415   1      
1416   1          /* length of signed int is variable, as per 20.2.11 */
1417   1          if ((value >= -128) && (value < 128)) {
1418   2              len = 1;
1419   2          } else if ((value >= -32768) && (value < 32768)) {
1420   2              len = 2;
1421   2          } else if ((value > -8388608) && (value < 8388608)) {
1422   2              len = 3;
1423   2          } else {
1424   2              len = 4;
1425   2          }
1426   1      
1427   1          len = encode_tag(&apdu[0], tag_number, true, (uint32_t) len);
1428   1          len += encode_bacnet_signed(&apdu[len], value);
1429   1      
1430   1          return len;
1431   1      }
1432          #endif
1433          
1434          /* from clause 20.2.6 Encoding of a Real Number Value */
1435          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1436          /* returns the number of apdu bytes consumed */
1437          int encode_application_real(
1438              uint8_t * apdu,
1439              float value)
1440          {
1441   1          int len = 0;
1442   1      
1443   1          /* assumes that the tag only consumes 1 octet */
1444   1          len = encode_bacnet_real(value, &apdu[1]);
1445   1          len +=
1446   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_REAL, false,
1447   1              (uint32_t) len);
1448   1      
1449   1          return len;
1450   1      }
1451          
1452          int encode_context_real(
1453              uint8_t * apdu,
1454              uint8_t tag_number,
1455              float value)
1456          {
1457   1          int len = 0;
1458   1      
1459   1          /* length of double is 4 octets, as per 20.2.6 */
1460   1          len = encode_tag(&apdu[0], tag_number, true, 4);
1461   1          len += encode_bacnet_real(value, &apdu[len]);
1462   1          return len;
1463   1      }
1464          
1465          #if BACNET_USE_DOUBLE
1466          /* from clause 20.2.7 Encoding of a Double Precision Real Number Value */
1467          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1468          /* returns the number of apdu bytes consumed */
1469          int encode_application_double(
1470              uint8_t * apdu,
1471              double value)
1472          {
1473   1          int len = 0;
1474   1      
1475   1          /* assumes that the tag only consumes 2 octet */
1476   1          len = encode_bacnet_double(value, &apdu[2]);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 25  

1477   1      
1478   1          len +=
1479   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_DOUBLE, false,
1480   1              (uint32_t) len);
1481   1      
1482   1          return len;
1483   1      }
1484          
1485          int encode_context_double(
1486              uint8_t * apdu,
1487              uint8_t tag_number,
1488              double value)
1489          {
1490   1          int len = 0;
1491   1      
1492   1          /* length of double is 8 octets, as per 20.2.7 */
1493   1          len = encode_tag(&apdu[0], tag_number, true, 8);
1494   1          len += encode_bacnet_double(value, &apdu[len]);
1495   1      
1496   1          return len;
1497   1      }
1498          #endif
1499          
1500          /* from clause 20.2.13 Encoding of a Time Value */
1501          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1502          /* returns the number of apdu bytes consumed */
1503          int encode_bacnet_time(
1504              uint8_t * apdu,
1505              BACNET_TIME * btime)
1506          {
1507   1          apdu[0] = btime->hour;
1508   1          apdu[1] = btime->min;
1509   1          apdu[2] = btime->sec;
1510   1          apdu[3] = btime->hundredths;
1511   1      
1512   1          return 4;
1513   1      }
1514          
1515          /* from clause 20.2.13 Encoding of a Time Value */
1516          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1517          /* returns the number of apdu bytes consumed */
1518          int encode_application_time(
1519              uint8_t * apdu,
1520              BACNET_TIME * btime)
1521          {
1522   1          int len = 0;
1523   1      
1524   1          /* assumes that the tag only consumes 1 octet */
1525   1          len = encode_bacnet_time(&apdu[1], btime);
1526   1          len +=
1527   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_TIME, false,
1528   1              (uint32_t) len);
1529   1      
1530   1          return len;
1531   1      }
1532          
1533          int encode_context_time(
1534              uint8_t * apdu,
1535              uint8_t tag_number,
1536              BACNET_TIME * btime)
1537          {
1538   1          int len = 0;        /* return value */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 26  

1539   1      
1540   1          /* length of time is 4 octets, as per 20.2.13 */
1541   1          len = encode_tag(&apdu[0], tag_number, true, 4);
1542   1          len += encode_bacnet_time(&apdu[len], btime);
1543   1      
1544   1          return len;
1545   1      }
1546          
1547          /* from clause 20.2.13 Encoding of a Time Value */
1548          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1549          /* returns the number of apdu bytes consumed */
1550          int decode_bacnet_time(
1551              uint8_t * apdu,
1552              BACNET_TIME * btime)
1553          {
1554   1          btime->hour = apdu[0];
1555   1          btime->min = apdu[1];
1556   1          btime->sec = apdu[2];
1557   1          btime->hundredths = apdu[3];
1558   1      
1559   1          return 4;
1560   1      }
1561          
1562          int decode_bacnet_time_safe(
1563              uint8_t * apdu,
1564              uint32_t len_value,
1565              BACNET_TIME * btime)
1566          {
1567   1          if (len_value != 4) {
1568   2              btime->hour = 0;
1569   2              btime->hundredths = 0;
1570   2              btime->min = 0;
1571   2              btime->sec = 0;
1572   2              return (int) len_value;
1573   2          } else {
1574   2              return decode_bacnet_time(apdu, btime);
1575   2          }
1576   1      }
1577          
1578          int decode_application_time(
1579              uint8_t * apdu,
1580              BACNET_TIME * btime)
1581          {
1582   1          int len = 0;
1583   1          uint8_t tag_number;
1584   1          decode_tag_number(&apdu[len], &tag_number);
1585   1      
1586   1          if (tag_number == BACNET_APPLICATION_TAG_TIME) {
1587   2              len++;
1588   2              len += decode_bacnet_time(&apdu[len], btime);
1589   2          } else {
1590   2              len = BACNET_STATUS_ERROR;
1591   2          }
1592   1          return len;
1593   1      }
1594          
1595          
1596          int decode_context_bacnet_time(
1597              uint8_t * apdu,
1598              uint8_t tag_number,
1599              BACNET_TIME * btime)
1600          {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 27  

1601   1          int len = 0;
1602   1      
1603   1          if (decode_is_context_tag_with_length(&apdu[len], tag_number, &len)) {
1604   2              len += decode_bacnet_time(&apdu[len], btime);
1605   2          } else {
1606   2              len = BACNET_STATUS_ERROR;
1607   2          }
1608   1          return len;
1609   1      }
1610          
1611          
1612          /* BACnet Date */
1613          /* year = years since 1900 */
1614          /* month 1=Jan */
1615          /* day = day of month */
1616          /* wday 1=Monday...7=Sunday */
1617          
1618          /* from clause 20.2.12 Encoding of a Date Value */
1619          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1620          /* returns the number of apdu bytes consumed */
1621          int encode_bacnet_date(
1622              uint8_t * apdu,
1623              BACNET_DATE * bdate)
1624          {
1625   1          /* allow 2 digit years */
1626   1          if (bdate->year >= 1900) {
1627   2              apdu[0] = (uint8_t) (bdate->year - 1900);
1628   2          } else if (bdate->year < 0x100) {
1629   2              apdu[0] = (uint8_t) bdate->year;
1630   2      
1631   2          } else {
1632   2              /*
1633   2               ** Don't try and guess what the user meant here. Just fail
1634   2               */
1635   2              return BACNET_STATUS_ERROR;
1636   2          }
1637   1      
1638   1      
1639   1          apdu[1] = bdate->month;
1640   1          apdu[2] = bdate->day;
1641   1          apdu[3] = bdate->wday;
1642   1      
1643   1          return 4;
1644   1      }
1645          
1646          
1647          /* from clause 20.2.12 Encoding of a Date Value */
1648          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1649          /* returns the number of apdu bytes consumed */
1650          int encode_application_date(
1651              uint8_t * apdu,
1652              BACNET_DATE * bdate)
1653          {
1654   1          int len = 0;
1655   1      
1656   1          /* assumes that the tag only consumes 1 octet */
1657   1          len = encode_bacnet_date(&apdu[1], bdate);
1658   1          len +=
1659   1              encode_tag(&apdu[0], BACNET_APPLICATION_TAG_DATE, false,
1660   1              (uint32_t) len);
1661   1      
1662   1          return len;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 28  

1663   1      
1664   1      }
1665          
1666          int encode_context_date(
1667              uint8_t * apdu,
1668              uint8_t tag_number,
1669              BACNET_DATE * bdate)
1670          {
1671   1          int len = 0;        /* return value */
1672   1      
1673   1          /* length of date is 4 octets, as per 20.2.12 */
1674   1          len = encode_tag(&apdu[0], tag_number, true, 4);
1675   1          len += encode_bacnet_date(&apdu[len], bdate);
1676   1      
1677   1          return len;
1678   1      }
1679          
1680          /* from clause 20.2.12 Encoding of a Date Value */
1681          /* and 20.2.1 General Rules for Encoding BACnet Tags */
1682          /* returns the number of apdu bytes consumed */
1683          int decode_date(
1684              uint8_t * apdu,
1685              BACNET_DATE * bdate)
1686          {
1687   1          bdate->year = (uint16_t) (apdu[0] + 1900);
1688   1          bdate->month = apdu[1];
1689   1          bdate->day = apdu[2];
1690   1          bdate->wday = apdu[3];
1691   1      
1692   1          return 4;
1693   1      }
1694          
1695          int decode_date_safe(
1696              uint8_t * apdu,
1697              uint32_t len_value,
1698              BACNET_DATE * bdate)
1699          {
1700   1          if (len_value != 4) {
1701   2              bdate->day = 0;
1702   2              bdate->month = 0;
1703   2              bdate->wday = 0;
1704   2              bdate->year = 0;
1705   2              return (int) len_value;
1706   2          } else {
1707   2              return decode_date(apdu, bdate);
1708   2          }
1709   1      }
1710          
1711          
1712          int decode_application_date(
1713              uint8_t * apdu,
1714              BACNET_DATE * bdate)
1715          {
1716   1          int len = 0;
1717   1          uint8_t tag_number;
1718   1          decode_tag_number(&apdu[len], &tag_number);
1719   1      
1720   1          if (tag_number == BACNET_APPLICATION_TAG_DATE) {
1721   2              len++;
1722   2              len += decode_date(&apdu[len], bdate);
1723   2          } else {
1724   2              len = BACNET_STATUS_ERROR;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 29  

1725   2          }
1726   1          return len;
1727   1      }
1728          
1729          int decode_context_date(
1730              uint8_t * apdu,
1731              uint8_t tag_number,
1732              BACNET_DATE * bdate)
1733          {
1734   1          int len = 0;
1735   1      
1736   1          if (decode_is_context_tag_with_length(&apdu[len], tag_number, &len)) {
1737   2              len += decode_date(&apdu[len], bdate);
1738   2          } else {
1739   2              len = BACNET_STATUS_ERROR;
1740   2          }
1741   1          return len;
1742   1      }
1743          
1744          
1745          
1746          /* returns the number of apdu bytes consumed */
1747          int encode_simple_ack(
1748              uint8_t * apdu,
1749              uint8_t invoke_id,
1750              uint8_t service_choice)
1751          {
1752   1          apdu[0] = PDU_TYPE_SIMPLE_ACK;
1753   1          apdu[1] = invoke_id;
1754   1          apdu[2] = service_choice;
1755   1      
1756   1          return 3;
1757   1      }
1758          
1759          /* end of decoding_encoding.c */
1760          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include <ctype.h>
              #include "ctest.h"
              
              static int get_apdu_len(
                  bool extended_tag,
                  uint32_t value)
              {
                  int test_len = 1;
              
                  if (extended_tag) {
                      test_len++;
                  }
                  if (value <= 4) {
                      test_len += 0;  /* do nothing... */
                  } else if (value <= 253) {
                      test_len += 1;
                  } else if (value <= 65535) {
                      test_len += 3;
                  } else {
                      test_len += 5;
                  }
              
                  return test_len;
              }
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 30  

              
              static void print_apdu(
                  uint8_t * pBlock,
                  uint32_t num)
              {
                  size_t lines = 0;   /* number of lines to print */
                  size_t line = 0;    /* line of text counter */
                  size_t last_line = 0;       /* line on which the last text resided */
                  unsigned long count = 0;    /* address to print */
                  unsigned int i = 0; /* counter */
              
                  if (pBlock && num) {
                      /* how many lines to print? */
                      num--;  /* adjust */
                      lines = (num / 16) + 1;
                      last_line = num % 16;
              
                      /* create the line */
                      for (line = 0; line < lines; line++) {
                          /* start with the address */
                          printf("%08lX: ", count);
                          /* hex representation */
                          for (i = 0; i < 16; i++) {
                              if (((line == (lines - 1)) && (i <= last_line)) ||
                                  (line != (lines - 1))) {
                                  printf("%02X ", (unsigned) (0x00FF & pBlock[i]));
                              } else {
                                  printf("-- ");
                              }
                          }
                          printf(" ");
                          /* print the characters if valid */
                          for (i = 0; i < 16; i++) {
                              if (((line == (lines - 1)) && (i <= last_line)) ||
                                  (line != (lines - 1))) {
                                  if (isprint(pBlock[i])) {
                                      printf("%c", pBlock[i]);
                                  } else {
                                      printf(".");
                                  }
                              } else {
                                  printf(".");
                              }
                          }
                          printf("\r\n");
                          pBlock += 16;
                          count += 16;
                      }
                  }
              
                  return;
              }
              
              void testBACDCodeTags(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU] = { 0 };
                  uint8_t tag_number = 0, test_tag_number = 0;
                  int len = 0, test_len = 0;
                  uint32_t value = 0, test_value = 0;
              
                  for (tag_number = 0;; tag_number++) {
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 31  

                      len = encode_opening_tag(&apdu[0], tag_number);
                      test_len = get_apdu_len(IS_EXTENDED_TAG_NUMBER(apdu[0]), 0);
                      ct_test(pTest, len == test_len);
                      len = decode_tag_number_and_value(&apdu[0], &test_tag_number, &value);
                      ct_test(pTest, value == 0);
                      ct_test(pTest, len == test_len);
                      ct_test(pTest, tag_number == test_tag_number);
                      ct_test(pTest, IS_OPENING_TAG(apdu[0]) == true);
                      ct_test(pTest, IS_CLOSING_TAG(apdu[0]) == false);
                      len = encode_closing_tag(&apdu[0], tag_number);
                      ct_test(pTest, len == test_len);
                      len = decode_tag_number_and_value(&apdu[0], &test_tag_number, &value);
                      ct_test(pTest, len == test_len);
                      ct_test(pTest, value == 0);
                      ct_test(pTest, tag_number == test_tag_number);
                      ct_test(pTest, IS_OPENING_TAG(apdu[0]) == false);
                      ct_test(pTest, IS_CLOSING_TAG(apdu[0]) == true);
                      /* test the len-value-type portion */
                      for (value = 1;; value = value << 1) {
                          len = encode_tag(&apdu[0], tag_number, false, value);
                          len =
                              decode_tag_number_and_value(&apdu[0], &test_tag_number,
                              &test_value);
                          ct_test(pTest, tag_number == test_tag_number);
                          ct_test(pTest, value == test_value);
                          test_len = get_apdu_len(IS_EXTENDED_TAG_NUMBER(apdu[0]), value);
                          ct_test(pTest, len == test_len);
                          /* stop at the the last value */
                          if (value & BIT31) {
                              break;
                          }
                      }
                      /* stop after the last tag number */
                      if (tag_number == 255) {
                          break;
                      }
                  }
              
                  return;
              }
              
              void testBACDCodeEnumerated(
                  Test * pTest)
              {
                  uint8_t array[5] = { 0 };
                  uint8_t encoded_array[5] = { 0 };
                  uint32_t value = 1;
                  uint32_t decoded_value = 0;
                  int i = 0, apdu_len = 0;
                  int len = 0;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  uint8_t tag_number = 0;
                  uint32_t len_value = 0;
              
                  for (i = 0; i < 31; i++) {
                      apdu_len = encode_application_enumerated(&array[0], value);
                      len = decode_tag_number_and_value(&array[0], &tag_number, &len_value);
                      len += decode_enumerated(&array[len], len_value, &decoded_value);
                      ct_test(pTest, decoded_value == value);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_ENUMERATED);
                      ct_test(pTest, len == apdu_len);
                      /* encode back the value */
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 32  

                      encode_application_enumerated(&encoded_array[0], decoded_value);
                      ct_test(pTest, memcmp(&array[0], &encoded_array[0],
                              sizeof(array)) == 0);
                      /* an enumerated will take up to 4 octects */
                      /* plus a one octet for the tag */
                      apdu_len = encode_application_enumerated(&apdu[0], value);
                      len = decode_tag_number_and_value(&apdu[0], &tag_number, NULL);
                      ct_test(pTest, len == 1);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_ENUMERATED);
                      ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == false);
                      /* context specific encoding */
                      apdu_len = encode_context_enumerated(&apdu[0], 3, value);
                      ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == true);
                      len = decode_tag_number_and_value(&apdu[0], &tag_number, NULL);
                      ct_test(pTest, len == 1);
                      ct_test(pTest, tag_number == 3);
                      /* test the interesting values */
                      value = value << 1;
                  }
              
                  return;
              }
              
              void testBACDCodeReal(
                  Test * pTest)
              {
                  uint8_t real_array[4] = { 0 };
                  uint8_t encoded_array[4] = { 0 };
                  float value = 42.123F;
                  float decoded_value = 0.0F;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  int len = 0, apdu_len = 0;
                  uint8_t tag_number = 0;
                  uint32_t long_value = 0;
              
                  encode_bacnet_real(value, &real_array[0]);
                  decode_real(&real_array[0], &decoded_value);
                  ct_test(pTest, decoded_value == value);
                  encode_bacnet_real(value, &encoded_array[0]);
                  ct_test(pTest, memcmp(&real_array, &encoded_array,
                          sizeof(real_array)) == 0);
              
                  /* a real will take up 4 octects plus a one octet tag */
                  apdu_len = encode_application_real(&apdu[0], value);
                  ct_test(pTest, apdu_len == 5);
                  /* len tells us how many octets were used for encoding the value */
                  len = decode_tag_number_and_value(&apdu[0], &tag_number, &long_value);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_REAL);
                  ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == false);
                  ct_test(pTest, len == 1);
                  ct_test(pTest, long_value == 4);
                  decode_real(&apdu[len], &decoded_value);
                  ct_test(pTest, decoded_value == value);
              
                  return;
              }
              
              void testBACDCodeDouble(
                  Test * pTest)
              {
                  uint8_t double_array[8] = { 0 };
                  uint8_t encoded_array[8] = { 0 };
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 33  

                  double value = 42.123;
                  double decoded_value = 0.0;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  int len = 0, apdu_len = 0;
                  uint8_t tag_number = 0;
                  uint32_t long_value = 0;
              
                  encode_bacnet_double(value, &double_array[0]);
                  decode_double(&double_array[0], &decoded_value);
                  ct_test(pTest, decoded_value == value);
                  encode_bacnet_double(value, &encoded_array[0]);
                  ct_test(pTest, memcmp(&double_array, &encoded_array,
                          sizeof(double_array)) == 0);
              
                  /* a real will take up 4 octects plus a one octet tag */
                  apdu_len = encode_application_double(&apdu[0], value);
                  ct_test(pTest, apdu_len == 10);
                  /* len tells us how many octets were used for encoding the value */
                  len = decode_tag_number_and_value(&apdu[0], &tag_number, &long_value);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_DOUBLE);
                  ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == false);
                  ct_test(pTest, len == 2);
                  ct_test(pTest, long_value == 8);
                  decode_double(&apdu[len], &decoded_value);
                  ct_test(pTest, decoded_value == value);
              
                  return;
              }
              
              void testBACDCodeUnsignedValue(
                  Test * pTest,
                  uint32_t value)
              {
                  uint8_t array[5] = { 0 };
                  uint8_t encoded_array[5] = { 0 };
                  uint32_t decoded_value = 0;
                  int len, apdu_len;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  uint8_t tag_number = 0;
                  uint32_t len_value = 0;
              
                  len_value = encode_application_unsigned(&array[0], value);
                  len = decode_tag_number_and_value(&array[0], &tag_number, &len_value);
                  len = decode_unsigned(&array[len], len_value, &decoded_value);
                  ct_test(pTest, decoded_value == value);
                  if (decoded_value != value) {
                      printf("value=%lu decoded_value=%lu\n", (unsigned long) value,
                          (unsigned long) decoded_value);
                      print_apdu(&array[0], sizeof(array));
                  }
                  encode_application_unsigned(&encoded_array[0], decoded_value);
                  ct_test(pTest, memcmp(&array[0], &encoded_array[0], sizeof(array)) == 0);
                  /* an unsigned will take up to 4 octects */
                  /* plus a one octet for the tag */
                  apdu_len = encode_application_unsigned(&apdu[0], value);
                  /* apdu_len varies... */
                  /*ct_test(pTest, apdu_len == 5); */
                  len = decode_tag_number_and_value(&apdu[0], &tag_number, NULL);
                  ct_test(pTest, len == 1);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_UNSIGNED_INT);
                  ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == false);
              }
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 34  

              
              void testBACDCodeUnsigned(
                  Test * pTest)
              {
                  uint32_t value = 1;
                  int i;
              
                  for (i = 0; i < 32; i++) {
                      testBACDCodeUnsignedValue(pTest, value - 1);
                      testBACDCodeUnsignedValue(pTest, value);
                      testBACDCodeUnsignedValue(pTest, value + 1);
                      value = value << 1;
                  }
              
                  return;
              }
              
              void testBACnetUnsigned(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  uint32_t value = 0, test_value = 0;
                  int len = 0, test_len = 0;
              
                  for (value = 0;; value += 0xFF) {
                      len = encode_bacnet_unsigned(&apdu[0], value);
                      test_len = decode_unsigned(&apdu[0], len, &test_value);
                      ct_test(pTest, len == test_len);
                      ct_test(pTest, value == test_value);
                      if (value == 0xFFFFFFFF)
                          break;
                  }
              }
              
              void testBACDCodeSignedValue(
                  Test * pTest,
                  int32_t value)
              {
                  uint8_t array[5] = { 0 };
                  uint8_t encoded_array[5] = { 0 };
                  int32_t decoded_value = 0;
                  int len = 0, apdu_len = 0;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  uint8_t tag_number = 0;
                  uint32_t len_value = 0;
                  int diff = 0;
              
                  len = encode_application_signed(&array[0], value);
                  len = decode_tag_number_and_value(&array[0], &tag_number, &len_value);
                  len = decode_signed(&array[len], len_value, &decoded_value);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_SIGNED_INT);
                  ct_test(pTest, decoded_value == value);
                  if (decoded_value != value) {
                      printf("value=%ld decoded_value=%ld\n", (long) value,
                          (long) decoded_value);
                      print_apdu(&array[0], sizeof(array));
                  }
                  encode_application_signed(&encoded_array[0], decoded_value);
                  diff = memcmp(&array[0], &encoded_array[0], sizeof(array));
                  ct_test(pTest, diff == 0);
                  if (diff) {
                      printf("value=%ld decoded_value=%ld\n", (long) value,
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 35  

                          (long) decoded_value);
                      print_apdu(&array[0], sizeof(array));
                      print_apdu(&encoded_array[0], sizeof(array));
                  }
                  /* a signed int will take up to 4 octects */
                  /* plus a one octet for the tag */
                  apdu_len = encode_application_signed(&apdu[0], value);
                  len = decode_tag_number_and_value(&apdu[0], &tag_number, NULL);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_SIGNED_INT);
                  ct_test(pTest, IS_CONTEXT_SPECIFIC(apdu[0]) == false);
              
                  return;
              }
              
              void testBACDCodeSigned(
                  Test * pTest)
              {
                  int value = 1;
                  int i = 0;
              
                  for (i = 0; i < 32; i++) {
                      testBACDCodeSignedValue(pTest, value - 1);
                      testBACDCodeSignedValue(pTest, value);
                      testBACDCodeSignedValue(pTest, value + 1);
                      value = value << 1;
                  }
              
                  testBACDCodeSignedValue(pTest, -1);
                  value = -2;
                  for (i = 0; i < 32; i++) {
                      testBACDCodeSignedValue(pTest, value - 1);
                      testBACDCodeSignedValue(pTest, value);
                      testBACDCodeSignedValue(pTest, value + 1);
                      value = value << 1;
                  }
              
                  return;
              }
              
              void testBACnetSigned(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  int32_t value = 0, test_value = 0;
                  int len = 0, test_len = 0;
              
                  for (value = -2147483647; value < 0; value += 127) {
                      len = encode_bacnet_signed(&apdu[0], value);
                      test_len = decode_signed(&apdu[0], len, &test_value);
                      ct_test(pTest, len == test_len);
                      ct_test(pTest, value == test_value);
                  }
                  for (value = 2147483647; value > 0; value -= 127) {
                      len = encode_bacnet_signed(&apdu[0], value);
                      test_len = decode_signed(&apdu[0], len, &test_value);
                      ct_test(pTest, len == test_len);
                      ct_test(pTest, value == test_value);
                  }
              }
              
              void testBACDCodeOctetString(
                  Test * pTest)
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 36  

              {
                  uint8_t array[MAX_APDU] = { 0 };
                  uint8_t encoded_array[MAX_APDU] = { 0 };
                  BACNET_OCTET_STRING octet_string;
                  BACNET_OCTET_STRING test_octet_string;
                  uint8_t test_value[MAX_APDU] = { "" };
                  int i;      /* for loop counter */
                  int apdu_len;
                  int len;
                  uint8_t tag_number = 0;
                  uint32_t len_value = 0;
                  bool status = false;
                  int diff = 0;       /* for memcmp */
              
                  status = octetstring_init(&octet_string, NULL, 0);
                  ct_test(pTest, status == true);
                  apdu_len = encode_application_octet_string(&array[0], &octet_string);
                  len = decode_tag_number_and_value(&array[0], &tag_number, &len_value);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_OCTET_STRING);
                  len += decode_octet_string(&array[len], len_value, &test_octet_string);
                  ct_test(pTest, apdu_len == len);
                  diff =
                      memcmp(octetstring_value(&octet_string), &test_value[0],
                      octetstring_length(&octet_string));
                  ct_test(pTest, diff == 0);
              
                  for (i = 0; i < (MAX_APDU - 6); i++) {
                      test_value[i] = '0' + (i % 10);
                      status = octetstring_init(&octet_string, test_value, i);
                      ct_test(pTest, status == true);
                      apdu_len =
                          encode_application_octet_string(&encoded_array[0], &octet_string);
                      len =
                          decode_tag_number_and_value(&encoded_array[0], &tag_number,
                          &len_value);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_OCTET_STRING);
                      len +=
                          decode_octet_string(&encoded_array[len], len_value,
                          &test_octet_string);
                      if (apdu_len != len) {
                          printf("test octet string=#%d\n", i);
                      }
                      ct_test(pTest, apdu_len == len);
                      diff =
                          memcmp(octetstring_value(&octet_string), &test_value[0],
                          octetstring_length(&octet_string));
                      if (diff) {
                          printf("test octet string=#%d\n", i);
                      }
                      ct_test(pTest, diff == 0);
                  }
              
                  return;
              }
              
              void testBACDCodeCharacterString(
                  Test * pTest)
              {
                  uint8_t array[MAX_APDU] = { 0 };
                  uint8_t encoded_array[MAX_APDU] = { 0 };
                  BACNET_CHARACTER_STRING char_string;
                  BACNET_CHARACTER_STRING test_char_string;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 37  

                  char test_value[MAX_APDU] = { "" };
                  int i;      /* for loop counter */
                  int apdu_len;
                  int len;
                  uint8_t tag_number = 0;
                  uint32_t len_value = 0;
                  int diff = 0;       /* for comparison */
                  bool status = false;
              
                  status = characterstring_init(&char_string, CHARACTER_ANSI_X34, NULL, 0);
                  ct_test(pTest, status == true);
                  apdu_len = encode_application_character_string(&array[0], &char_string);
                  len = decode_tag_number_and_value(&array[0], &tag_number, &len_value);
                  ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_CHARACTER_STRING);
                  len += decode_character_string(&array[len], len_value, &test_char_string);
                  ct_test(pTest, apdu_len == len);
                  diff =
                      memcmp(characterstring_value(&char_string), &test_value[0],
                      characterstring_length(&char_string));
                  ct_test(pTest, diff == 0);
                  for (i = 0; i < MAX_CHARACTER_STRING_BYTES - 1; i++) {
                      test_value[i] = 'S';
                      test_value[i + 1] = '\0';
                      status = characterstring_init_ansi(&char_string, test_value);
                      ct_test(pTest, status == true);
                      apdu_len =
                          encode_application_character_string(&encoded_array[0],
                          &char_string);
                      len =
                          decode_tag_number_and_value(&encoded_array[0], &tag_number,
                          &len_value);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_CHARACTER_STRING);
                      len +=
                          decode_character_string(&encoded_array[len], len_value,
                          &test_char_string);
                      if (apdu_len != len) {
                          printf("test string=#%d apdu_len=%d len=%d\n", i, apdu_len, len);
                      }
                      ct_test(pTest, apdu_len == len);
                      diff =
                          memcmp(characterstring_value(&char_string), &test_value[0],
                          characterstring_length(&char_string));
                      if (diff) {
                          printf("test string=#%d\n", i);
                      }
                      ct_test(pTest, diff == 0);
                  }
              
                  return;
              }
              
              void testBACDCodeObject(
                  Test * pTest)
              {
                  uint8_t object_array[4] = {
                      0
                  };
                  uint8_t encoded_array[4] = {
                      0
                  };
                  uint16_t type = OBJECT_BINARY_INPUT;
                  uint16_t decoded_type = OBJECT_ANALOG_OUTPUT;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 38  

                  uint32_t instance = 123;
                  uint32_t decoded_instance = 0;
              
                  encode_bacnet_object_id(&encoded_array[0], type, instance);
                  decode_object_id(&encoded_array[0], &decoded_type, &decoded_instance);
                  ct_test(pTest, decoded_type == type);
                  ct_test(pTest, decoded_instance == instance);
                  encode_bacnet_object_id(&object_array[0], type, instance);
                  ct_test(pTest, memcmp(&object_array[0], &encoded_array[0],
                          sizeof(object_array)) == 0);
                  for (type = 0; type < 1024; type++) {
                      for (instance = 0; instance <= BACNET_MAX_INSTANCE; instance += 1024) {
                          encode_bacnet_object_id(&encoded_array[0], type, instance);
                          decode_object_id(&encoded_array[0], &decoded_type,
                              &decoded_instance);
                          ct_test(pTest, decoded_type == type);
                          ct_test(pTest, decoded_instance == instance);
                          encode_bacnet_object_id(&object_array[0], type, instance);
                          ct_test(pTest, memcmp(&object_array[0], &encoded_array[0],
                                  sizeof(object_array)) == 0);
                      }
                  }
              
                  return;
              }
              
              void testBACDCodeMaxSegsApdu(
                  Test * pTest)
              {
                  int max_segs[8] = { 0, 2, 4, 8, 16, 32, 64, 65 };
                  int max_apdu[6] = { 50, 128, 206, 480, 1024, 1476 };
                  int i = 0;
                  int j = 0;
                  uint8_t octet = 0;
              
                  /* test */
                  for (i = 0; i < 8; i++) {
                      for (j = 0; j < 6; j++) {
                          octet = encode_max_segs_max_apdu(max_segs[i], max_apdu[j]);
                          ct_test(pTest, max_segs[i] == decode_max_segs(octet));
                          ct_test(pTest, max_apdu[j] == decode_max_apdu(octet));
                      }
                  }
              }
              
              void testBACDCodeBitString(
                  Test * pTest)
              {
                  uint8_t bit = 0;
                  BACNET_BIT_STRING bit_string;
                  BACNET_BIT_STRING decoded_bit_string;
                  uint8_t apdu[MAX_APDU] = { 0 };
                  uint32_t len_value = 0;
                  uint8_t tag_number = 0;
                  int len = 0;
              
                  bitstring_init(&bit_string);
                  /* verify initialization */
                  ct_test(pTest, bitstring_bits_used(&bit_string) == 0);
                  for (bit = 0; bit < (MAX_BITSTRING_BYTES * 8); bit++) {
                      ct_test(pTest, bitstring_bit(&bit_string, bit) == false);
                  }
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 39  

                  /* test encode/decode -- true */
                  for (bit = 0; bit < (MAX_BITSTRING_BYTES * 8); bit++) {
                      bitstring_set_bit(&bit_string, bit, true);
                      ct_test(pTest, bitstring_bits_used(&bit_string) == (bit + 1));
                      ct_test(pTest, bitstring_bit(&bit_string, bit) == true);
                      /* encode */
                      len = encode_application_bitstring(&apdu[0], &bit_string);
                      /* decode */
                      len = decode_tag_number_and_value(&apdu[0], &tag_number, &len_value);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_BIT_STRING);
                      len += decode_bitstring(&apdu[len], len_value, &decoded_bit_string);
                      ct_test(pTest, bitstring_bits_used(&decoded_bit_string) == (bit + 1));
                      ct_test(pTest, bitstring_bit(&decoded_bit_string, bit) == true);
                  }
                  /* test encode/decode -- false */
                  bitstring_init(&bit_string);
                  for (bit = 0; bit < (MAX_BITSTRING_BYTES * 8); bit++) {
                      bitstring_set_bit(&bit_string, bit, false);
                      ct_test(pTest, bitstring_bits_used(&bit_string) == (bit + 1));
                      ct_test(pTest, bitstring_bit(&bit_string, bit) == false);
                      /* encode */
                      len = encode_application_bitstring(&apdu[0], &bit_string);
                      /* decode */
                      len = decode_tag_number_and_value(&apdu[0], &tag_number, &len_value);
                      ct_test(pTest, tag_number == BACNET_APPLICATION_TAG_BIT_STRING);
                      len += decode_bitstring(&apdu[len], len_value, &decoded_bit_string);
                      ct_test(pTest, bitstring_bits_used(&decoded_bit_string) == (bit + 1));
                      ct_test(pTest, bitstring_bit(&decoded_bit_string, bit) == false);
                  }
              }
              
              void testUnsignedContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  /* 32 bit number */
                  uint32_t in = 0xdeadbeef;
                  uint32_t out;
              
                  outLen2 = decode_context_unsigned(apdu, 9, &out);
              
                  in = 0xdeadbeef;
                  inLen = encode_context_unsigned(apdu, 10, in);
                  outLen = decode_context_unsigned(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_unsigned(apdu, large_context_tag, in);
                  outLen = decode_context_unsigned(apdu, large_context_tag, &out);
                  outLen2 = decode_context_unsigned(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 40  

                  /* 16 bit number */
                  in = 0xdead;
                  inLen = encode_context_unsigned(apdu, 10, in);
                  outLen = decode_context_unsigned(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_unsigned(apdu, large_context_tag, in);
                  outLen = decode_context_unsigned(apdu, large_context_tag, &out);
                  outLen2 = decode_context_unsigned(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 8 bit number */
                  in = 0xde;
                  inLen = encode_context_unsigned(apdu, 10, in);
                  outLen = decode_context_unsigned(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_unsigned(apdu, large_context_tag, in);
                  outLen = decode_context_unsigned(apdu, large_context_tag, &out);
                  outLen2 = decode_context_unsigned(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 4 bit number */
                  in = 0xd;
                  inLen = encode_context_unsigned(apdu, 10, in);
                  outLen = decode_context_unsigned(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_unsigned(apdu, large_context_tag, in);
                  outLen = decode_context_unsigned(apdu, large_context_tag, &out);
                  outLen2 = decode_context_unsigned(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 2 bit number */
                  in = 0x2;
                  inLen = encode_context_unsigned(apdu, 10, in);
                  outLen = decode_context_unsigned(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_unsigned(apdu, large_context_tag, in);
                  outLen = decode_context_unsigned(apdu, large_context_tag, &out);
                  outLen2 = decode_context_unsigned(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
              }
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 41  

              
              void testSignedContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
              
                  /* 32 bit number */
                  int32_t in = 0xdeadbeef;
                  int32_t out;
              
                  outLen2 = decode_context_signed(apdu, 9, &out);
              
                  in = 0xdeadbeef;
                  inLen = encode_context_signed(apdu, 10, in);
                  outLen = decode_context_signed(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_signed(apdu, large_context_tag, in);
                  outLen = decode_context_signed(apdu, large_context_tag, &out);
                  outLen2 = decode_context_signed(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  /* 16 bit number */
                  in = 0xdead;
                  inLen = encode_context_signed(apdu, 10, in);
                  outLen = decode_context_signed(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_signed(apdu, large_context_tag, in);
                  outLen = decode_context_signed(apdu, large_context_tag, &out);
                  outLen2 = decode_context_signed(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  /* 8 bit number */
                  in = 0xde;
                  inLen = encode_context_signed(apdu, 10, in);
                  outLen = decode_context_signed(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_signed(apdu, large_context_tag, in);
                  outLen = decode_context_signed(apdu, large_context_tag, &out);
                  outLen2 = decode_context_signed(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 42  

                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  /* 4 bit number */
                  in = 0xd;
                  inLen = encode_context_signed(apdu, 10, in);
                  outLen = decode_context_signed(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_signed(apdu, large_context_tag, in);
                  outLen = decode_context_signed(apdu, large_context_tag, &out);
                  outLen2 = decode_context_signed(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  /* 2 bit number */
                  in = 0x2;
                  inLen = encode_context_signed(apdu, 10, in);
                  outLen = decode_context_signed(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_signed(apdu, large_context_tag, in);
                  outLen = decode_context_signed(apdu, large_context_tag, &out);
                  outLen2 = decode_context_signed(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
              }
              
              void testEnumeratedContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  /* 32 bit number */
                  uint32_t in = 0xdeadbeef;
                  uint32_t out;
              
                  outLen2 = decode_context_enumerated(apdu, 9, &out);
              
                  in = 0xdeadbeef;
                  inLen = encode_context_enumerated(apdu, 10, in);
                  outLen = decode_context_enumerated(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_enumerated(apdu, large_context_tag, in);
                  outLen = decode_context_enumerated(apdu, large_context_tag, &out);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 43  

                  outLen2 = decode_context_enumerated(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  /* 16 bit number */
                  in = 0xdead;
                  inLen = encode_context_enumerated(apdu, 10, in);
                  outLen = decode_context_enumerated(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_enumerated(apdu, large_context_tag, in);
                  outLen = decode_context_enumerated(apdu, large_context_tag, &out);
                  outLen2 = decode_context_enumerated(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 8 bit number */
                  in = 0xde;
                  inLen = encode_context_enumerated(apdu, 10, in);
                  outLen = decode_context_enumerated(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_enumerated(apdu, large_context_tag, in);
                  outLen = decode_context_enumerated(apdu, large_context_tag, &out);
                  outLen2 = decode_context_enumerated(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 4 bit number */
                  in = 0xd;
                  inLen = encode_context_enumerated(apdu, 10, in);
                  outLen = decode_context_enumerated(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_enumerated(apdu, large_context_tag, in);
                  outLen = decode_context_enumerated(apdu, large_context_tag, &out);
                  outLen2 = decode_context_enumerated(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  /* 2 bit number */
                  in = 0x2;
                  inLen = encode_context_enumerated(apdu, 10, in);
                  outLen = decode_context_enumerated(apdu, 10, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_enumerated(apdu, large_context_tag, in);
                  outLen = decode_context_enumerated(apdu, large_context_tag, &out);
                  outLen2 = decode_context_enumerated(apdu, large_context_tag - 1, &out);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 44  

              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              }
              
              void testFloatContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  /* 32 bit number */
                  float in;
                  float out;
              
              
                  in = 0.1234f;
                  inLen = encode_context_real(apdu, 10, in);
                  outLen = decode_context_real(apdu, 10, &out);
                  outLen2 = decode_context_real(apdu, 9, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_real(apdu, large_context_tag, in);
                  outLen = decode_context_real(apdu, large_context_tag, &out);
                  outLen2 = decode_context_real(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  in = 0.0f;
                  inLen = encode_context_real(apdu, 10, in);
                  outLen = decode_context_real(apdu, 10, &out);
                  outLen2 = decode_context_real(apdu, 9, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_real(apdu, large_context_tag, in);
                  outLen = decode_context_real(apdu, large_context_tag, &out);
                  outLen2 = decode_context_real(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              }
              
              void testDoubleContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 45  

              
                  /* 64 bit number */
                  double in;
                  double out;
              
              
                  in = 0.1234;
                  inLen = encode_context_double(apdu, 10, in);
                  outLen = decode_context_double(apdu, 10, &out);
                  outLen2 = decode_context_double(apdu, 9, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_double(apdu, large_context_tag, in);
                  outLen = decode_context_double(apdu, large_context_tag, &out);
                  outLen2 = decode_context_double(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  in = 0.0;
                  inLen = encode_context_double(apdu, 10, in);
                  outLen = decode_context_double(apdu, 10, &out);
                  outLen2 = decode_context_double(apdu, 9, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
              
                  inLen = encode_context_double(apdu, large_context_tag, in);
                  outLen = decode_context_double(apdu, large_context_tag, &out);
                  outLen2 = decode_context_double(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in == out);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              }
              
              void testObjectIDContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  /* 32 bit number */
                  uint16_t in_type;
                  uint32_t in_id;
              
                  uint16_t out_type;
                  uint32_t out_id;
              
                  in_type = 0xde;
                  in_id = 0xbeef;
              
                  inLen = encode_context_object_id(apdu, 10, in_type, in_id);
                  outLen = decode_context_object_id(apdu, 10, &out_type, &out_id);
                  outLen2 = decode_context_object_id(apdu, 9, &out_type, &out_id);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 46  

              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in_type == out_type);
                  ct_test(pTest, in_id == out_id);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              
                  inLen = encode_context_object_id(apdu, large_context_tag, in_type, in_id);
                  outLen =
                      decode_context_object_id(apdu, large_context_tag, &out_type, &out_id);
                  outLen2 =
                      decode_context_object_id(apdu, large_context_tag - 1, &out_type,
                      &out_id);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in_type == out_type);
                  ct_test(pTest, in_id == out_id);
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
              }
              
              void testCharacterStringContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
              
                  BACNET_CHARACTER_STRING in;
                  BACNET_CHARACTER_STRING out;
              
                  characterstring_init_ansi(&in, "This is a test");
              
                  inLen = encode_context_character_string(apdu, 10, &in);
                  outLen = decode_context_character_string(apdu, 10, &out);
                  outLen2 = decode_context_character_string(apdu, 9, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.length == out.length);
                  ct_test(pTest, in.encoding == out.encoding);
                  ct_test(pTest, strcmp(in.value, out.value) == 0);
              
                  inLen = encode_context_character_string(apdu, large_context_tag, &in);
                  outLen = decode_context_character_string(apdu, large_context_tag, &out);
                  outLen2 =
                      decode_context_character_string(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.length == out.length);
                  ct_test(pTest, in.encoding == out.encoding);
                  ct_test(pTest, strcmp(in.value, out.value) == 0);
              }
              
              void testBitStringContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 47  

                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  BACNET_BIT_STRING in;
                  BACNET_BIT_STRING out;
              
                  bitstring_init(&in);
                  bitstring_set_bit(&in, 1, true);
                  bitstring_set_bit(&in, 3, true);
                  bitstring_set_bit(&in, 6, true);
                  bitstring_set_bit(&in, 10, false);
                  bitstring_set_bit(&in, 11, true);
                  bitstring_set_bit(&in, 12, false);
              
                  inLen = encode_context_bitstring(apdu, 10, &in);
                  outLen = decode_context_bitstring(apdu, 10, &out);
                  outLen2 = decode_context_bitstring(apdu, 9, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.bits_used == out.bits_used);
                  ct_test(pTest, memcmp(in.value, out.value, MAX_BITSTRING_BYTES) == 0);
              
                  inLen = encode_context_bitstring(apdu, large_context_tag, &in);
                  outLen = decode_context_bitstring(apdu, large_context_tag, &out);
                  outLen2 = decode_context_bitstring(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.bits_used == out.bits_used);
                  ct_test(pTest, memcmp(in.value, out.value, MAX_BITSTRING_BYTES) == 0);
              }
              
              void testOctetStringContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
              
                  BACNET_OCTET_STRING in;
                  BACNET_OCTET_STRING out;
              
                  uint8_t initData[] = { 0xde, 0xad, 0xbe, 0xef };
              
                  octetstring_init(&in, initData, sizeof(initData));
              
                  inLen = encode_context_octet_string(apdu, 10, &in);
                  outLen = decode_context_octet_string(apdu, 10, &out);
                  outLen2 = decode_context_octet_string(apdu, 9, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.length == out.length);
                  ct_test(pTest, octetstring_value_same(&in, &out));
              
                  inLen = encode_context_octet_string(apdu, large_context_tag, &in);
                  outLen = decode_context_octet_string(apdu, large_context_tag, &out);
                  outLen2 = decode_context_octet_string(apdu, large_context_tag - 1, &out);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 48  

              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.length == out.length);
                  ct_test(pTest, octetstring_value_same(&in, &out));
              
              }
              
              void testTimeContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
                  BACNET_TIME in;
                  BACNET_TIME out;
              
                  in.hour = 10;
                  in.hundredths = 20;
                  in.min = 30;
                  in.sec = 40;
              
                  inLen = encode_context_time(apdu, 10, &in);
                  outLen = decode_context_bacnet_time(apdu, 10, &out);
                  outLen2 = decode_context_bacnet_time(apdu, 9, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.hour == out.hour);
                  ct_test(pTest, in.hundredths == out.hundredths);
                  ct_test(pTest, in.min == out.min);
                  ct_test(pTest, in.sec == out.sec);
              
                  inLen = encode_context_time(apdu, large_context_tag, &in);
                  outLen = decode_context_bacnet_time(apdu, large_context_tag, &out);
                  outLen2 = decode_context_bacnet_time(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.hour == out.hour);
                  ct_test(pTest, in.hundredths == out.hundredths);
                  ct_test(pTest, in.min == out.min);
                  ct_test(pTest, in.sec == out.sec);
              
              
              }
              
              void testDateContextDecodes(
                  Test * pTest)
              {
                  uint8_t apdu[MAX_APDU];
                  int inLen;
                  int outLen;
                  int outLen2;
                  uint8_t large_context_tag = 0xfe;
              
              
                  BACNET_DATE in;
                  BACNET_DATE out;
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 49  

              
                  in.day = 3;
                  in.month = 10;
                  in.wday = 5;
                  in.year = 1945;
              
                  inLen = encode_context_date(apdu, 10, &in);
                  outLen = decode_context_date(apdu, 10, &out);
                  outLen2 = decode_context_date(apdu, 9, &out);
              
                  ct_test(pTest, outLen2 == BACNET_STATUS_ERROR);
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.day == out.day);
                  ct_test(pTest, in.month == out.month);
                  ct_test(pTest, in.wday == out.wday);
                  ct_test(pTest, in.year == out.year);
              
                  /* Test large tags */
                  inLen = encode_context_date(apdu, large_context_tag, &in);
                  outLen = decode_context_date(apdu, large_context_tag, &out);
                  outLen2 = decode_context_date(apdu, large_context_tag - 1, &out);
              
                  ct_test(pTest, inLen == outLen);
                  ct_test(pTest, in.day == out.day);
                  ct_test(pTest, in.month == out.month);
                  ct_test(pTest, in.wday == out.wday);
                  ct_test(pTest, in.year == out.year);
              }
              
              
              #ifdef TEST_DECODE
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACDCode", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testBACDCodeTags);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeReal);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeUnsigned);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetUnsigned);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeSigned);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetSigned);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeEnumerated);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeOctetString);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeCharacterString);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeObject);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeMaxSegsApdu);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACDCodeBitString);
C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 50  

                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testUnsignedContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testSignedContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testEnumeratedContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testCharacterStringContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testFloatContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testDoubleContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testObjectIDContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testBitStringContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testTimeContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testDateContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testOctetStringContextDecodes);
                  assert(rc);
              
                  rc = ct_addTestFunction(pTest, testBACDCodeDouble);
                  assert(rc);
                  /* configure output */
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_DECODE */
              #endif /* TEST */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14242    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     671
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.06   BACDCODE                                                              03/13/2013 09:32:33 PAGE 51  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
