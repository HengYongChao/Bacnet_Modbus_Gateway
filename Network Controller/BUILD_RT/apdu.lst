C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE APDU
OBJECT MODULE PLACED IN .\apdu.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\apdu.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD) DEFINE(KEIL_AX11000) VARBANKING DE
                    -BUG PRINT(.\apdu.lst) OBJECT(.\apdu.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2005 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          #include <stdbool.h>
  35          #include <stdint.h>
  36          #include <stddef.h>
  37          #include "bits.h"
  38          #include "apdu.h"
  39          #include "bacdef.h"
  40          #include "bacdcode.h"
  41          #include "bacenum.h"
  42          #include "tsm.h"
  43          #include "dcc.h"
  44          #include "iam.h"
  45          
  46          /** @file apdu.c  Handles APDU services */
  47          
  48          extern int Routed_Device_Service_Approval(
  49              BACNET_CONFIRMED_SERVICE service,
  50              int service_argument,
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 2   

  51              uint8_t * apdu_buff,
  52              uint8_t invoke_id);
  53          
  54          
  55          /* APDU Timeout in Milliseconds */
  56          static uint16_t Timeout_Milliseconds = 3000;
  57          /* Number of APDU Retries */
  58          static uint8_t Number_Of_Retries = 3;
  59          
  60          /* a simple table for crossing the services supported */
  61          static BACNET_SERVICES_SUPPORTED
  62              confirmed_service_supported[MAX_BACNET_CONFIRMED_SERVICE] = {
  63              SERVICE_SUPPORTED_ACKNOWLEDGE_ALARM,
  64              SERVICE_SUPPORTED_CONFIRMED_COV_NOTIFICATION,
  65              SERVICE_SUPPORTED_CONFIRMED_EVENT_NOTIFICATION,
  66              SERVICE_SUPPORTED_GET_ALARM_SUMMARY,
  67              SERVICE_SUPPORTED_GET_ENROLLMENT_SUMMARY,
  68              SERVICE_SUPPORTED_SUBSCRIBE_COV,
  69              SERVICE_SUPPORTED_ATOMIC_READ_FILE,
  70              SERVICE_SUPPORTED_ATOMIC_WRITE_FILE,
  71              SERVICE_SUPPORTED_ADD_LIST_ELEMENT,
  72              SERVICE_SUPPORTED_REMOVE_LIST_ELEMENT,
  73              SERVICE_SUPPORTED_CREATE_OBJECT,
  74              SERVICE_SUPPORTED_DELETE_OBJECT,
  75              SERVICE_SUPPORTED_READ_PROPERTY,
  76              SERVICE_SUPPORTED_READ_PROP_CONDITIONAL,
  77              SERVICE_SUPPORTED_READ_PROP_MULTIPLE,
  78              SERVICE_SUPPORTED_WRITE_PROPERTY,
  79              SERVICE_SUPPORTED_WRITE_PROP_MULTIPLE,
  80              SERVICE_SUPPORTED_DEVICE_COMMUNICATION_CONTROL,
  81              SERVICE_SUPPORTED_PRIVATE_TRANSFER,
  82              SERVICE_SUPPORTED_TEXT_MESSAGE,
  83              SERVICE_SUPPORTED_REINITIALIZE_DEVICE,
  84              SERVICE_SUPPORTED_VT_OPEN,
  85              SERVICE_SUPPORTED_VT_CLOSE,
  86              SERVICE_SUPPORTED_VT_DATA,
  87              SERVICE_SUPPORTED_AUTHENTICATE,
  88              SERVICE_SUPPORTED_REQUEST_KEY,
  89              SERVICE_SUPPORTED_READ_RANGE,
  90              SERVICE_SUPPORTED_LIFE_SAFETY_OPERATION,
  91              SERVICE_SUPPORTED_SUBSCRIBE_COV_PROPERTY,
  92              SERVICE_SUPPORTED_GET_EVENT_INFORMATION
  93          };
  94          
  95          /* a simple table for crossing the services supported */
  96          static BACNET_SERVICES_SUPPORTED
  97              unconfirmed_service_supported[MAX_BACNET_UNCONFIRMED_SERVICE] = {
  98              SERVICE_SUPPORTED_I_AM,
  99              SERVICE_SUPPORTED_I_HAVE,
 100              SERVICE_SUPPORTED_UNCONFIRMED_COV_NOTIFICATION,
 101              SERVICE_SUPPORTED_UNCONFIRMED_EVENT_NOTIFICATION,
 102              SERVICE_SUPPORTED_UNCONFIRMED_PRIVATE_TRANSFER,
 103              SERVICE_SUPPORTED_UNCONFIRMED_TEXT_MESSAGE,
 104              SERVICE_SUPPORTED_TIME_SYNCHRONIZATION,
 105              SERVICE_SUPPORTED_WHO_HAS,
 106              SERVICE_SUPPORTED_WHO_IS,
 107              SERVICE_SUPPORTED_UTC_TIME_SYNCHRONIZATION
 108          };
 109          
 110          /* Confirmed Function Handlers */
 111          /* If they are not set, they are handled by a reject message */
 112          static confirmed_function Confirmed_Function[MAX_BACNET_CONFIRMED_SERVICE];
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 3   

 113          
 114          void apdu_set_confirmed_handler(
 115              BACNET_CONFIRMED_SERVICE service_choice,
 116              confirmed_function pFunction)
 117          {
 118   1          if (service_choice < MAX_BACNET_CONFIRMED_SERVICE)
 119   1              Confirmed_Function[service_choice] = pFunction;
 120   1      }
 121          
 122          /* Allow the APDU handler to automatically reject */
 123          static confirmed_function Unrecognized_Service_Handler;
 124          
 125          void apdu_set_unrecognized_service_handler_handler(
 126              confirmed_function pFunction)
 127          {
 128   1          Unrecognized_Service_Handler = pFunction;
 129   1      }
 130          
 131          /* Unconfirmed Function Handlers */
 132          /* If they are not set, they are not handled */
 133          static unconfirmed_function
 134              Unconfirmed_Function[MAX_BACNET_UNCONFIRMED_SERVICE];
 135          
 136          void apdu_set_unconfirmed_handler(
 137              BACNET_UNCONFIRMED_SERVICE service_choice,
 138              unconfirmed_function pFunction)
 139          {
 140   1          if (service_choice < MAX_BACNET_UNCONFIRMED_SERVICE)
 141   1              Unconfirmed_Function[service_choice] = pFunction;
 142   1      }
 143          
 144          bool apdu_service_supported(
 145              BACNET_SERVICES_SUPPORTED service_supported)
 146          {
 147   1          int i = 0;
 148   1          bool status = false;
 149   1          bool found = false;
 150   1      
 151   1          if (service_supported < MAX_BACNET_SERVICES_SUPPORTED) {
 152   2              /* is it a confirmed service? */
 153   2              for (i = 0; i < MAX_BACNET_CONFIRMED_SERVICE; i++) {
 154   3                  if (confirmed_service_supported[i] == service_supported) {
 155   4                      found = true;
 156   4                      if (Confirmed_Function[i] != NULL) {
 157   5      #if BAC_ROUTING
*** WARNING C322 IN LINE 157 OF ..\src\bacnet\apdu.c: unknown identifier
                                  /* Check to see if the current Device supports this service. */
                                  int len =
                                      Routed_Device_Service_Approval(service_supported, 0,
                                      NULL, 0);
                                  if (len > 0)
                                      break;  /* Not supported - return false */
              #endif
 165   5      
 166   5                          status = true;
 167   5                      }
 168   4                      break;
 169   4                  }
 170   3              }
 171   2      
 172   2              if (!found) {
 173   3                  /* is it an unconfirmed service? */
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 4   

 174   3                  for (i = 0; i < MAX_BACNET_UNCONFIRMED_SERVICE; i++) {
 175   4                      if (unconfirmed_service_supported[i] == service_supported) {
 176   5                          if (Unconfirmed_Function[i] != NULL)
 177   5                              status = true;
 178   5                          break;
 179   5                      }
 180   4                  }
 181   3              }
 182   2          }
 183   1          return status;
 184   1      }
 185          
 186          /** Function to translate a SERVICE_SUPPORTED_ enum to its SERVICE_CONFIRMED_
 187           *  or SERVICE_UNCONFIRMED_ index.
 188           *  Useful with the bactext_confirmed_service_name() functions.
 189           *
 190           * @param service_supported [in] The SERVICE_SUPPORTED_ enum value to convert.
 191           * @param index [out] The SERVICE_CONFIRMED_ or SERVICE_UNCONFIRMED_ index,
 192           *                    if found.
 193           * @param bIsConfirmed [out] True if index is a SERVICE_CONFIRMED_ type.
 194           * @return True if a match was found and index and bIsConfirmed are valid.
 195           */
 196          bool apdu_service_supported_to_index(
 197              BACNET_SERVICES_SUPPORTED service_supported,
 198              size_t * index,
 199              bool * bIsConfirmed)
 200          {
 201   1          int i = 0;
 202   1          bool found = false;
 203   1      
 204   1          *bIsConfirmed = false;
 205   1          if (service_supported < MAX_BACNET_SERVICES_SUPPORTED) {
 206   2              /* is it a confirmed service? */
 207   2              for (i = 0; i < MAX_BACNET_CONFIRMED_SERVICE; i++) {
 208   3                  if (confirmed_service_supported[i] == service_supported) {
 209   4                      found = true;
 210   4                      *index = (size_t) i;
 211   4                      *bIsConfirmed = true;
 212   4                      break;
 213   4                  }
 214   3              }
 215   2      
 216   2              if (!found) {
 217   3                  /* is it an unconfirmed service? */
 218   3                  for (i = 0; i < MAX_BACNET_UNCONFIRMED_SERVICE; i++) {
 219   4                      if (unconfirmed_service_supported[i] == service_supported) {
 220   5                          found = true;
 221   5                          *index = (size_t) i;
 222   5                          break;
 223   5                      }
 224   4                  }
 225   3              }
 226   2          }
 227   1          return found;
 228   1      }
 229          
 230          /* Confirmed ACK Function Handlers */
 231          static confirmed_ack_function
 232              Confirmed_ACK_Function[MAX_BACNET_CONFIRMED_SERVICE];
 233          
 234          void apdu_set_confirmed_simple_ack_handler(
 235              BACNET_CONFIRMED_SERVICE service_choice,
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 5   

 236              confirmed_simple_ack_function pFunction)
 237          {
 238   1          switch (service_choice) {
 239   2              case SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM:
 240   2              case SERVICE_CONFIRMED_COV_NOTIFICATION:
 241   2              case SERVICE_CONFIRMED_EVENT_NOTIFICATION:
 242   2              case SERVICE_CONFIRMED_SUBSCRIBE_COV:
 243   2              case SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY:
 244   2              case SERVICE_CONFIRMED_LIFE_SAFETY_OPERATION:
 245   2                  /* Object Access Services */
 246   2              case SERVICE_CONFIRMED_ADD_LIST_ELEMENT:
 247   2              case SERVICE_CONFIRMED_REMOVE_LIST_ELEMENT:
 248   2              case SERVICE_CONFIRMED_DELETE_OBJECT:
 249   2              case SERVICE_CONFIRMED_WRITE_PROPERTY:
 250   2              case SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE:
 251   2                  /* Remote Device Management Services */
 252   2              case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
 253   2              case SERVICE_CONFIRMED_TEXT_MESSAGE:
 254   2              case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
 255   2                  /* Virtual Terminal Services */
 256   2              case SERVICE_CONFIRMED_VT_CLOSE:
 257   2                  /* Security Services */
 258   2              case SERVICE_CONFIRMED_REQUEST_KEY:
 259   2                  Confirmed_ACK_Function[service_choice] =
 260   2                      (confirmed_ack_function) pFunction;
 261   2                  break;
 262   2              default:
 263   2                  break;
 264   2          }
 265   1      }
 266          
 267          void apdu_set_confirmed_ack_handler(
 268              BACNET_CONFIRMED_SERVICE service_choice,
 269              confirmed_ack_function pFunction)
 270          {
 271   1          switch (service_choice) {
 272   2              case SERVICE_CONFIRMED_GET_ALARM_SUMMARY:
 273   2              case SERVICE_CONFIRMED_GET_ENROLLMENT_SUMMARY:
 274   2              case SERVICE_CONFIRMED_GET_EVENT_INFORMATION:
 275   2                  /* File Access Services */
 276   2              case SERVICE_CONFIRMED_ATOMIC_READ_FILE:
 277   2              case SERVICE_CONFIRMED_ATOMIC_WRITE_FILE:
 278   2                  /* Object Access Services */
 279   2              case SERVICE_CONFIRMED_CREATE_OBJECT:
 280   2              case SERVICE_CONFIRMED_READ_PROPERTY:
 281   2              case SERVICE_CONFIRMED_READ_PROP_CONDITIONAL:
 282   2              case SERVICE_CONFIRMED_READ_PROP_MULTIPLE:
 283   2              case SERVICE_CONFIRMED_READ_RANGE:
 284   2                  /* Remote Device Management Services */
 285   2              case SERVICE_CONFIRMED_PRIVATE_TRANSFER:
 286   2                  /* Virtual Terminal Services */
 287   2              case SERVICE_CONFIRMED_VT_OPEN:
 288   2              case SERVICE_CONFIRMED_VT_DATA:
 289   2                  /* Security Services */
 290   2              case SERVICE_CONFIRMED_AUTHENTICATE:
 291   2                  Confirmed_ACK_Function[service_choice] = pFunction;
 292   2                  break;
 293   2              default:
 294   2                  break;
 295   2          }
 296   1      }
 297          
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 6   

 298          static error_function Error_Function[MAX_BACNET_CONFIRMED_SERVICE];
 299          
 300          void apdu_set_error_handler(
 301              BACNET_CONFIRMED_SERVICE service_choice,
 302              error_function pFunction)
 303          {
 304   1          if (service_choice < MAX_BACNET_CONFIRMED_SERVICE)
 305   1              Error_Function[service_choice] = pFunction;
 306   1      }
 307          
 308          static abort_function Abort_Function;
 309          
 310          void apdu_set_abort_handler(
 311              abort_function pFunction)
 312          {
 313   1          Abort_Function = pFunction;
 314   1      }
 315          
 316          static reject_function Reject_Function;
 317          
 318          void apdu_set_reject_handler(
 319              reject_function pFunction)
 320          {
 321   1          Reject_Function = pFunction;
 322   1      }
 323          
 324          uint16_t apdu_decode_confirmed_service_request(
 325              uint8_t * apdu,     /* APDU data */
 326              uint16_t apdu_len,
 327              BACNET_CONFIRMED_SERVICE_DATA * service_data,
 328              uint8_t * service_choice,
 329              uint8_t ** service_request,
 330              uint16_t * service_request_len)
 331          {
 332   1          uint16_t len = 0;   /* counts where we are in PDU */
 333   1      
 334   1          service_data->segmented_message = (apdu[0] & BIT3) ? true : false;
 335   1          service_data->more_follows = (apdu[0] & BIT2) ? true : false;
 336   1          service_data->segmented_response_accepted =
 337   1              (apdu[0] & BIT1) ? true : false;
 338   1          service_data->max_segs = decode_max_segs(apdu[1]);
 339   1          service_data->max_resp = decode_max_apdu(apdu[1]);
 340   1          service_data->invoke_id = apdu[2];
 341   1          len = 3;
 342   1          if (service_data->segmented_message) {
 343   2              service_data->sequence_number = apdu[len++];
 344   2              service_data->proposed_window_number = apdu[len++];
 345   2          }
 346   1          *service_choice = apdu[len++];
 347   1          *service_request = &apdu[len];
 348   1          *service_request_len = apdu_len - len;
 349   1      
 350   1          return len;
 351   1      }
 352          
 353          uint16_t apdu_timeout(
 354              void)
 355          {
 356   1          return Timeout_Milliseconds;
 357   1      }
 358          
 359          void apdu_timeout_set(
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 7   

 360              uint16_t milliseconds)
 361          {
 362   1          Timeout_Milliseconds = milliseconds;
 363   1      }
 364          
 365          uint8_t apdu_retries(
 366              void)
 367          {
 368   1          return Number_Of_Retries;
 369   1      }
 370          
 371          void apdu_retries_set(
 372              uint8_t value)
 373          {
 374   1          Number_Of_Retries = value;
 375   1      }
 376          
 377          
 378          /* When network communications are completely disabled,
 379             only DeviceCommunicationControl and ReinitializeDevice APDUs
 380             shall be processed and no messages shall be initiated.
 381             When the initiation of communications is disabled, 
 382             all APDUs shall be processed and responses returned as 
 383             required... */
 384          static bool apdu_confirmed_dcc_disabled(
 385              uint8_t service_choice)
 386          {
 387   1          bool status = false;
 388   1      
 389   1          if (dcc_communication_disabled()) {
 390   2              switch (service_choice) {
 391   3                  case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
 392   3                  case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
 393   3                      break;
 394   3                  default:
 395   3                      status = true;
 396   3                      break;
 397   3              }
 398   2          }
 399   1      
 400   1          return status;
 401   1      }
 402          
 403          /* When network communications are completely disabled,
 404             only DeviceCommunicationControl and ReinitializeDevice APDUs
 405             shall be processed and no messages shall be initiated. */
 406          /* If the request is valid and the 'Enable/Disable' parameter is
 407             DISABLE_INITIATION, the responding BACnet-user shall
 408             discontinue the initiation of messages except for I-Am
 409             requests issued in accordance with the Who-Is service procedure.*/
 410          static bool apdu_unconfirmed_dcc_disabled(
 411              uint8_t service_choice)
 412          {
 413   1          bool status = false;
 414   1      
 415   1          if (dcc_communication_disabled()) {
 416   2              /* there are no Unconfirmed messages that 
 417   2                 can be processed in this state */
 418   2              status = true;
 419   2          } else if (dcc_communication_initiation_disabled()) {
 420   2              /* WhoIs will be processed and I-Am initiated as response. */
 421   2              switch (service_choice) {
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 8   

 422   3                  case SERVICE_UNCONFIRMED_WHO_IS:
 423   3                      break;
 424   3                  default:
 425   3                      status = true;
 426   3                      break;
 427   3              }
 428   2          }
 429   1      
 430   1          return status;
 431   1      }
 432          
 433          /** Process the APDU header and invoke the appropriate service handler
 434           * to manage the received request.
 435           * Almost all requests and ACKs invoke this function.
 436           * @ingroup MISCHNDLR
 437           *
 438           * @param src [in] The BACNET_ADDRESS of the message's source.
 439           * @param apdu [in] The apdu portion of the request, to be processed.
 440           * @param apdu_len [in] The total (remaining) length of the apdu.
 441           */
 442          void apdu_handler(
 443              BACNET_ADDRESS * src,
 444              uint8_t * apdu,     /* APDU data */
 445              uint16_t apdu_len)
 446          {
 447   1          BACNET_CONFIRMED_SERVICE_DATA service_data = { 0 };
 448   1          BACNET_CONFIRMED_SERVICE_ACK_DATA service_ack_data = { 0 };
 449   1          uint8_t invoke_id = 0;
 450   1          uint8_t service_choice = 0;
 451   1          uint8_t *service_request = NULL;
 452   1          uint16_t service_request_len = 0;
 453   1          int len = 0;        /* counts where we are in PDU */
 454   1          uint8_t tag_number = 0;
 455   1          uint32_t len_value = 0;
 456   1          uint32_t error_code = 0;
 457   1          uint32_t error_class = 0;
 458   1          uint8_t reason = 0;
 459   1          bool server = false;
 460   1      
 461   1          if (apdu) {
 462   2              /* PDU Type */
 463   2              switch (apdu[0] & 0xF0) {
 464   3                  case PDU_TYPE_CONFIRMED_SERVICE_REQUEST:
 465   3                      len =
 466   3                          (int) apdu_decode_confirmed_service_request(&apdu[0],
 467   3                          apdu_len, &service_data, &service_choice, &service_request,
 468   3                          &service_request_len);
 469   3                      if (apdu_confirmed_dcc_disabled(service_choice)) {
 470   4                          /* When network communications are completely disabled,
 471   4                             only DeviceCommunicationControl and ReinitializeDevice APDUs
 472   4                             shall be processed and no messages shall be initiated. */
 473   4                          break;
 474   4                      }
 475   3                      if ((service_choice < MAX_BACNET_CONFIRMED_SERVICE) &&
 476   3                          (Confirmed_Function[service_choice]))
 477   3                          Confirmed_Function[service_choice] (service_request,
 478   3                              service_request_len, src, &service_data);
*** ERROR C212 IN LINE 478 OF ..\src\bacnet\apdu.c: indirect call: parameters do not fit within registers
 479   3                      else if (Unrecognized_Service_Handler)
 480   3                          Unrecognized_Service_Handler(service_request,
 481   3                              service_request_len, src, &service_data);
*** ERROR C212 IN LINE 481 OF ..\src\bacnet\apdu.c: indirect call: parameters do not fit within registers
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 9   

 482   3                      break;
 483   3                  case PDU_TYPE_UNCONFIRMED_SERVICE_REQUEST:
 484   3                      service_choice = apdu[1];
 485   3                      service_request = &apdu[2];
 486   3                      service_request_len = apdu_len - 2;
 487   3                      if (apdu_unconfirmed_dcc_disabled(service_choice)) {
 488   4                          /* When network communications are disabled,
 489   4                             only DeviceCommunicationControl and ReinitializeDevice APDUs
 490   4                             shall be processed and no messages shall be initiated.
 491   4                             If communications have been initiation disabled, then
 492   4                             WhoIs may be processed. */
 493   4                          break;
 494   4                      }
 495   3                      if (service_choice < MAX_BACNET_UNCONFIRMED_SERVICE) {
 496   4                          if (Unconfirmed_Function[service_choice])
 497   4                              Unconfirmed_Function[service_choice] (service_request,
*** ERROR C211 IN LINE 497 OF ..\src\bacnet\apdu.c: call not to a function
*** ERROR C208 IN LINE 497 OF ..\src\bacnet\apdu.c: 'function': too many actual parameters
 498   4                                  service_request_len, src);
 499   4                      }
 500   3                      break;
 501   3                  case PDU_TYPE_SIMPLE_ACK:
 502   3                      invoke_id = apdu[1];
 503   3                      service_choice = apdu[2];
 504   3                      switch (service_choice) {
 505   4                          case SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM:
 506   4                          case SERVICE_CONFIRMED_COV_NOTIFICATION:
 507   4                          case SERVICE_CONFIRMED_EVENT_NOTIFICATION:
 508   4                          case SERVICE_CONFIRMED_SUBSCRIBE_COV:
 509   4                          case SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY:
 510   4                          case SERVICE_CONFIRMED_LIFE_SAFETY_OPERATION:
 511   4                              /* Object Access Services */
 512   4                          case SERVICE_CONFIRMED_ADD_LIST_ELEMENT:
 513   4                          case SERVICE_CONFIRMED_REMOVE_LIST_ELEMENT:
 514   4                          case SERVICE_CONFIRMED_DELETE_OBJECT:
 515   4                          case SERVICE_CONFIRMED_WRITE_PROPERTY:
 516   4                          case SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE:
 517   4                              /* Remote Device Management Services */
 518   4                          case SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
 519   4                          case SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
 520   4                          case SERVICE_CONFIRMED_TEXT_MESSAGE:
 521   4                              /* Virtual Terminal Services */
 522   4                          case SERVICE_CONFIRMED_VT_CLOSE:
 523   4                              /* Security Services */
 524   4                          case SERVICE_CONFIRMED_REQUEST_KEY:
 525   4                              if (Confirmed_ACK_Function[service_choice] != NULL) {
 526   5                                  ((confirmed_simple_ack_function)
 527   5                                      Confirmed_ACK_Function[service_choice]) (src,
 528   5                                      invoke_id);
 529   5                              }
 530   4                              tsm_free_invoke_id(invoke_id);
 531   4                              break;
 532   4                          default:
 533   4                              break;
 534   4                      }
 535   3                      break;
 536   3                  case PDU_TYPE_COMPLEX_ACK:
 537   3                      service_ack_data.segmented_message =
 538   3                          (apdu[0] & BIT3) ? true : false;
 539   3                      service_ack_data.more_follows =
 540   3                          (apdu[0] & BIT2) ? true : false;
 541   3                      invoke_id = service_ack_data.invoke_id = apdu[1];
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 10  

 542   3                      len = 2;
 543   3                      if (service_ack_data.segmented_message) {
 544   4                          service_ack_data.sequence_number = apdu[len++];
 545   4                          service_ack_data.proposed_window_number = apdu[len++];
 546   4                      }
 547   3                      service_choice = apdu[len++];
 548   3                      service_request = &apdu[len];
 549   3                      service_request_len = apdu_len - (uint16_t) len;
 550   3                      switch (service_choice) {
 551   4                          case SERVICE_CONFIRMED_GET_ALARM_SUMMARY:
 552   4                          case SERVICE_CONFIRMED_GET_ENROLLMENT_SUMMARY:
 553   4                          case SERVICE_CONFIRMED_GET_EVENT_INFORMATION:
 554   4                              /* File Access Services */
 555   4                          case SERVICE_CONFIRMED_ATOMIC_READ_FILE:
 556   4                          case SERVICE_CONFIRMED_ATOMIC_WRITE_FILE:
 557   4                              /* Object Access Services */
 558   4                          case SERVICE_CONFIRMED_CREATE_OBJECT:
 559   4                          case SERVICE_CONFIRMED_READ_PROPERTY:
 560   4                          case SERVICE_CONFIRMED_READ_PROP_CONDITIONAL:
 561   4                          case SERVICE_CONFIRMED_READ_PROP_MULTIPLE:
 562   4                          case SERVICE_CONFIRMED_READ_RANGE:
 563   4                          case SERVICE_CONFIRMED_PRIVATE_TRANSFER:
 564   4                              /* Virtual Terminal Services */
 565   4                          case SERVICE_CONFIRMED_VT_OPEN:
 566   4                          case SERVICE_CONFIRMED_VT_DATA:
 567   4                              /* Security Services */
 568   4                          case SERVICE_CONFIRMED_AUTHENTICATE:
 569   4                              if (Confirmed_ACK_Function[service_choice] != NULL) {
 570   5                                  (Confirmed_ACK_Function[service_choice])
 571   5                                      (service_request, service_request_len, src,
*** ERROR C211 IN LINE 571 OF ..\src\bacnet\apdu.c: call not to a function
*** ERROR C208 IN LINE 571 OF ..\src\bacnet\apdu.c: 'function': too many actual parameters
 572   5                                      &service_ack_data);
 573   5                              }
 574   4                              tsm_free_invoke_id(invoke_id);
 575   4                              break;
 576   4                          default:
 577   4                              break;
 578   4                      }
 579   3                      break;
 580   3                  case PDU_TYPE_SEGMENT_ACK:
 581   3                      /* FIXME: what about a denial of service attack here?
 582   3                         we could check src to see if that matched the tsm */
 583   3                      tsm_free_invoke_id(invoke_id);
 584   3                      break;
 585   3                  case PDU_TYPE_ERROR:
 586   3                      invoke_id = apdu[1];
 587   3                      service_choice = apdu[2];
 588   3                      len = 3;
 589   3      
 590   3                      /* FIXME: Currently special case for C_P_T but there are others which may
 591   3                         need consideration such as ChangeList-Error, CreateObject-Error,
 592   3                         WritePropertyMultiple-Error and VTClose_Error but they may be left as
 593   3                         is for now until support for these services is added */
 594   3      
 595   3                      if (service_choice == SERVICE_CONFIRMED_PRIVATE_TRANSFER) {     /* skip over opening tag 0
             - */
 596   4                          if (decode_is_opening_tag_number(&apdu[len], 0)) {
 597   5                              len++;  /* a tag number of 0 is not extended so only one octet */
 598   5                          }
 599   4                      }
 600   3                      len +=
C51 COMPILER V9.06   APDU                                                                  03/28/2013 13:47:36 PAGE 11  

 601   3                          decode_tag_number_and_value(&apdu[len], &tag_number,
 602   3                          &len_value);
 603   3                      /* FIXME: we could validate that the tag is enumerated... */
 604   3                      len += decode_enumerated(&apdu[len], len_value, &error_class);
 605   3                      len +=
 606   3                          decode_tag_number_and_value(&apdu[len], &tag_number,
 607   3                          &len_value);
 608   3                      /* FIXME: we could validate that the tag is enumerated... */
 609   3                      len += decode_enumerated(&apdu[len], len_value, &error_code);
 610   3      
 611   3                      if (service_choice == SERVICE_CONFIRMED_PRIVATE_TRANSFER) {     /* skip over closing tag 0
             - */
 612   4                          if (decode_is_closing_tag_number(&apdu[len], 0)) {
 613   5                              len++;  /* a tag number of 0 is not extended so only one octet */
 614   5                          }
 615   4                      }
 616   3                      if (service_choice < MAX_BACNET_CONFIRMED_SERVICE) {
 617   4                          if (Error_Function[service_choice])
 618   4                              Error_Function[service_choice] (src, invoke_id,
 619   4                                  (BACNET_ERROR_CLASS) error_class,
 620   4                                  (BACNET_ERROR_CODE) error_code);
 621   4                      }
 622   3                      tsm_free_invoke_id(invoke_id);
 623   3                      break;
 624   3                  case PDU_TYPE_REJECT:
 625   3                      invoke_id = apdu[1];
 626   3                      reason = apdu[2];
 627   3                      if (Reject_Function)
 628   3                          Reject_Function(src, invoke_id, reason);
 629   3                      tsm_free_invoke_id(invoke_id);
 630   3                      break;
 631   3                  case PDU_TYPE_ABORT:
 632   3                      server = apdu[0] & 0x01;
 633   3                      invoke_id = apdu[1];
 634   3                      reason = apdu[2];
 635   3                      if (Abort_Function)
 636   3                          Abort_Function(src, invoke_id, reason, server);
 637   3                      tsm_free_invoke_id(invoke_id);
 638   3                      break;
 639   3                  default:
 640   3                      break;
 641   3              }
 642   2          }
 643   1          return;
 644   1      }

C51 COMPILATION COMPLETE.  1 WARNING(S),  6 ERROR(S)
