C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE BACAPP
OBJECT MODULE PLACED IN .\bacapp.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\bacapp.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020)
                    - INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;
                    -..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\
                    -buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;.
                    -.\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\bacapp.lst) OBJECT(.\bacap
                    -p.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2005 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          #include <stdint.h>
  35          #include <stdbool.h>
  36          #include <string.h>
  37          #include <stdio.h>
  38          #include <stdlib.h>
  39          #include <ctype.h>
  40          #include "../include/bacenum.h"
  41          #include "../include/bacdcode.h"
  42          #include "../include/bacint.h"
  43          #include "../include/bacreal.h"
  44          #include "../include/bacdef.h"
  45          #include "../include/bacapp.h"
  46          #include "../include/bactext.h"
  47          #include "../include/datetime.h"
  48          #include "../include/bacstr.h"
  49          
  50          /** @file bacapp.c  Utilities for the BACnet_Application_Data_Value */
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 2   

  51          
  52          #if defined(_MSC_VER)
              #define snprintf _snprintf
              #endif
  55          
  56          int bacapp_encode_application_data(
  57              uint8_t * apdu,
  58              BACNET_APPLICATION_DATA_VALUE * value)
  59          {
  60   1          int apdu_len = 0;   /* total length of the apdu, return value */
  61   1      
  62   1          if (value && apdu) {
  63   2              switch (value->tag) {
  64   3      #if defined (BACAPP_NULL)
  65   3                  case BACNET_APPLICATION_TAG_NULL:
  66   3                      apdu[0] = value->tag;
  67   3                      apdu_len++;
  68   3                      break;
  69   3      #endif
  70   3      #if defined (BACAPP_BOOLEAN)
  71   3                  case BACNET_APPLICATION_TAG_BOOLEAN:
  72   3                      apdu_len =
  73   3                          encode_application_boolean(&apdu[0], value->type.Boolean);
  74   3                      break;
  75   3      #endif
  76   3      #if defined (BACAPP_UNSIGNED)
  77   3                  case BACNET_APPLICATION_TAG_UNSIGNED_INT:
  78   3                      apdu_len =
  79   3                          encode_application_unsigned(&apdu[0],
  80   3                          value->type.Unsigned_Int);
  81   3                      break;
  82   3      #endif
  83   3      #if defined (BACAPP_SIGNED)
  84   3                  case BACNET_APPLICATION_TAG_SIGNED_INT:
  85   3                      apdu_len =
  86   3                          encode_application_signed(&apdu[0],
  87   3                          value->type.Signed_Int);
  88   3                      break;
  89   3      #endif
  90   3      #if defined (BACAPP_REAL)
  91   3                  case BACNET_APPLICATION_TAG_REAL:
  92   3                      apdu_len = encode_application_real(&apdu[0], value->type.Real);
  93   3                      break;
  94   3      #endif
  95   3      #if defined (BACAPP_DOUBLE)
  96   3                  case BACNET_APPLICATION_TAG_DOUBLE:
  97   3                      apdu_len =
  98   3                          encode_application_double(&apdu[0], value->type.Double);
  99   3                      break;
 100   3      #endif
 101   3      #if defined (BACAPP_OCTET_STRING)
 102   3                  case BACNET_APPLICATION_TAG_OCTET_STRING:
 103   3                      apdu_len =
 104   3                          encode_application_octet_string(&apdu[0],
 105   3                          &value->type.Octet_String);
 106   3                      break;
 107   3      #endif
 108   3      #if defined (BACAPP_CHARACTER_STRING)
 109   3                  case BACNET_APPLICATION_TAG_CHARACTER_STRING:
 110   3                      apdu_len =
 111   3                          encode_application_character_string(&apdu[0],
 112   3                          &value->type.Character_String);
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 3   

 113   3                      break;
 114   3      #endif
 115   3      #if defined (BACAPP_BIT_STRING)
 116   3                  case BACNET_APPLICATION_TAG_BIT_STRING:
 117   3                      apdu_len =
 118   3                          encode_application_bitstring(&apdu[0],
 119   3                          &value->type.Bit_String);
 120   3                      break;
 121   3      #endif
 122   3      #if defined (BACAPP_ENUMERATED)
 123   3                  case BACNET_APPLICATION_TAG_ENUMERATED:
 124   3                      apdu_len =
 125   3                          encode_application_enumerated(&apdu[0],
 126   3                          value->type.Enumerated);
 127   3                      break;
 128   3      #endif
 129   3      #if defined (BACAPP_DATE)
 130   3                  case BACNET_APPLICATION_TAG_DATE:
 131   3                      apdu_len =
 132   3                          encode_application_date(&apdu[0], &value->type.Date);
 133   3                      break;
 134   3      #endif
 135   3      #if defined (BACAPP_TIME)
 136   3                  case BACNET_APPLICATION_TAG_TIME:
 137   3                      apdu_len =
 138   3                          encode_application_time(&apdu[0], &value->type.Time);
 139   3                      break;
 140   3      #endif
 141   3      #if defined (BACAPP_OBJECT_ID)
 142   3                  case BACNET_APPLICATION_TAG_OBJECT_ID:
 143   3                      apdu_len =
 144   3                          encode_application_object_id(&apdu[0],
 145   3                          (int) value->type.Object_Id.type,
 146   3                          value->type.Object_Id.instance);
 147   3                      break;
 148   3      #endif
 149   3                  default:
 150   3                      break;
 151   3              }
 152   2          }
 153   1      
 154   1          return apdu_len;
 155   1      }
 156          
 157          /* decode the data and store it into value.
 158             Return the number of octets consumed. */
 159          int bacapp_decode_data(
 160              uint8_t * apdu,
 161              uint8_t tag_data_type,
 162              uint32_t len_value_type,
 163              BACNET_APPLICATION_DATA_VALUE * value)
 164          {
 165   1          int len = 0;
 166   1      
 167   1          if (apdu && value) {
 168   2              switch (tag_data_type) {
 169   3      #if defined (BACAPP_NULL)
 170   3                  case BACNET_APPLICATION_TAG_NULL:
 171   3                      /* nothing else to do */
 172   3                      break;
 173   3      #endif
 174   3      #if defined (BACAPP_BOOLEAN)
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 4   

 175   3                  case BACNET_APPLICATION_TAG_BOOLEAN:
 176   3                      value->type.Boolean = decode_boolean(len_value_type);
 177   3                      break;
 178   3      #endif
 179   3      #if defined (BACAPP_UNSIGNED)
 180   3                  case BACNET_APPLICATION_TAG_UNSIGNED_INT:
 181   3                      len =
 182   3                          decode_unsigned(&apdu[0], len_value_type,
 183   3                          &value->type.Unsigned_Int);
 184   3                      break;
 185   3      #endif
 186   3      #if defined (BACAPP_SIGNED)
 187   3                  case BACNET_APPLICATION_TAG_SIGNED_INT:
 188   3                      len =
 189   3                          decode_signed(&apdu[0], len_value_type,
 190   3                          &value->type.Signed_Int);
 191   3                      break;
 192   3      #endif
 193   3      #if defined (BACAPP_REAL)
 194   3                  case BACNET_APPLICATION_TAG_REAL:
 195   3                      len =
 196   3                          decode_real_safe(&apdu[0], len_value_type,
 197   3                          &(value->type.Real));
 198   3                      break;
 199   3      #endif
 200   3      #if defined (BACAPP_DOUBLE)
 201   3                  case BACNET_APPLICATION_TAG_DOUBLE:
 202   3                      len =
 203   3                          decode_double_safe(&apdu[0], len_value_type,
 204   3                          &(value->type.Double));
 205   3                      break;
 206   3      #endif
 207   3      #if defined (BACAPP_OCTET_STRING)
 208   3                  case BACNET_APPLICATION_TAG_OCTET_STRING:
 209   3                      len =
 210   3                          decode_octet_string(&apdu[0], len_value_type,
 211   3                          &value->type.Octet_String);
 212   3                      break;
 213   3      #endif
 214   3      #if defined (BACAPP_CHARACTER_STRING)
 215   3                  case BACNET_APPLICATION_TAG_CHARACTER_STRING:
 216   3                      len =
 217   3                          decode_character_string(&apdu[0], len_value_type,
 218   3                          &value->type.Character_String);
 219   3                      break;
 220   3      #endif
 221   3      #if defined (BACAPP_BIT_STRING)
 222   3                  case BACNET_APPLICATION_TAG_BIT_STRING:
 223   3                      len =
 224   3                          decode_bitstring(&apdu[0], len_value_type,
 225   3                          &value->type.Bit_String);
 226   3                      break;
 227   3      #endif
 228   3      #if defined (BACAPP_ENUMERATED)
 229   3                  case BACNET_APPLICATION_TAG_ENUMERATED:
 230   3                      len =
 231   3                          decode_enumerated(&apdu[0], len_value_type,
 232   3                          &value->type.Enumerated);
 233   3                      break;
 234   3      #endif
 235   3      #if defined (BACAPP_DATE)
 236   3                  case BACNET_APPLICATION_TAG_DATE:
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 5   

 237   3                      len =
 238   3                          decode_date_safe(&apdu[0], len_value_type,
 239   3                          &value->type.Date);
 240   3                      break;
 241   3      #endif
 242   3      #if defined (BACAPP_TIME)
 243   3                  case BACNET_APPLICATION_TAG_TIME:
 244   3                      len =
 245   3                          decode_bacnet_time_safe(&apdu[0], len_value_type,
 246   3                          &value->type.Time);
 247   3                      break;
 248   3      #endif
 249   3      #if defined (BACAPP_OBJECT_ID)
 250   3                  case BACNET_APPLICATION_TAG_OBJECT_ID:
 251   3                      {
 252   4                          uint16_t object_type = 0;
 253   4                          uint32_t instance = 0;
 254   4                          len =
 255   4                              decode_object_id_safe(&apdu[0], len_value_type,
 256   4                              &object_type, &instance);
 257   4                          value->type.Object_Id.type = object_type;
 258   4                          value->type.Object_Id.instance = instance;
 259   4                      }
 260   3                      break;
 261   3      #endif
 262   3                  default:
 263   3                      break;
 264   3              }
 265   2          }
 266   1      
 267   1          if ((len == 0) && (tag_data_type != BACNET_APPLICATION_TAG_NULL) &&
 268   1              (tag_data_type != BACNET_APPLICATION_TAG_BOOLEAN) &&
 269   1              (tag_data_type != BACNET_APPLICATION_TAG_OCTET_STRING)) {
 270   2              /* indicate that we were not able to decode the value */
 271   2              value->tag = MAX_BACNET_APPLICATION_TAG;
 272   2          }
 273   1          return len;
 274   1      }
 275          
 276          int bacapp_decode_application_data(
 277              uint8_t * apdu,
 278              unsigned max_apdu_len,
 279              BACNET_APPLICATION_DATA_VALUE * value)
 280          {
 281   1          int len = 0;
 282   1          int tag_len = 0;
 283   1          int decode_len = 0;
 284   1          uint8_t tag_number = 0;
 285   1          uint32_t len_value_type = 0;
 286   1      
 287   1          /* FIXME: use max_apdu_len! */
 288   1          max_apdu_len = max_apdu_len;
 289   1          if (apdu && value && !IS_CONTEXT_SPECIFIC(*apdu)) {
 290   2              value->context_specific = false;
 291   2              tag_len =
 292   2                  decode_tag_number_and_value(&apdu[0], &tag_number,
 293   2                  &len_value_type);
 294   2              if (tag_len) {
 295   3                  len += tag_len;
 296   3                  value->tag = tag_number;
 297   3                  decode_len =
 298   3                      bacapp_decode_data(&apdu[len], tag_number, len_value_type,
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 6   

 299   3                      value);
 300   3                  if (value->tag != MAX_BACNET_APPLICATION_TAG) {
 301   4                      len += decode_len;
 302   4                  } else {
 303   4                      len = BACNET_STATUS_ERROR;
 304   4                  }
 305   3              }
 306   2              value->next = NULL;
 307   2          }
 308   1      
 309   1          return len;
 310   1      }
 311          
 312          /*
 313          ** Usage: Similar to strtok. Call function the first time with new_apdu and new_adu_len set to apdu buffer
 314          ** to be processed. Subsequent calls should pass in NULL.
 315          **
 316          ** Returns true if a application message is correctly parsed.
 317          ** Returns false if no more application messages are available.
 318          **
 319          ** This function is NOT thread safe.
 320          **
 321          ** Notes: The _safe suffix is there because the function should be relatively safe against buffer overruns
             -.
 322          **
 323          */
 324          
 325          bool bacapp_decode_application_data_safe(
 326              uint8_t * new_apdu,
 327              uint32_t new_apdu_len,
 328              BACNET_APPLICATION_DATA_VALUE * value)
 329          {
 330   1          /* The static variables that store the apdu buffer between function calls */
 331   1          static uint8_t *apdu = NULL;
 332   1          static uint32_t apdu_len_remaining = 0;
 333   1          static uint32_t apdu_len = 0;
 334   1          int len = 0;
 335   1          int tag_len = 0;
 336   1          uint8_t tag_number = 0;
 337   1          uint32_t len_value_type = 0;
 338   1      
 339   1          bool ret = false;
 340   1      
 341   1          if (new_apdu != NULL) {
 342   2              apdu = new_apdu;
 343   2              apdu_len_remaining = new_apdu_len;
 344   2              apdu_len = 0;
 345   2          }
 346   1      
 347   1          if (value && apdu_len_remaining > 0 &&
 348   1              !IS_CONTEXT_SPECIFIC(apdu[apdu_len])) {
 349   2              value->context_specific = false;
 350   2              tag_len =
 351   2                  decode_tag_number_and_value_safe(&apdu[apdu_len],
 352   2                  apdu_len_remaining, &tag_number, &len_value_type);
 353   2              /* If tag_len is zero, then the tag information is truncated */
 354   2              if (tag_len) {
 355   3                  apdu_len += tag_len;
 356   3                  apdu_len_remaining -= tag_len;
 357   3                  /* The tag is boolean then len_value_type is interpreted as value, not length, so dont bother
 358   3                   ** checking with apdu_len_remaining */
 359   3                  if (tag_number == BACNET_APPLICATION_TAG_BOOLEAN ||
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 7   

 360   3                      len_value_type <= apdu_len_remaining) {
 361   4                      value->tag = tag_number;
 362   4                      len =
 363   4                          bacapp_decode_data(&apdu[apdu_len], tag_number,
 364   4                          len_value_type, value);
 365   4                      apdu_len += len;
 366   4                      apdu_len_remaining -= len;
 367   4      
 368   4                      ret = true;
 369   4                  }
 370   3              }
 371   2              value->next = NULL;
 372   2          }
 373   1      
 374   1      
 375   1          return ret;
 376   1      }
 377          
 378          /* Decode the data and
 379             return the number of octets consumed. */
 380          int bacapp_decode_data_len(
 381              uint8_t * apdu,
 382              uint8_t tag_data_type,
 383              uint32_t len_value_type)
 384          {
 385   1          int len = 0;
 386   1      
 387   1          if (apdu) {
 388   2              switch (tag_data_type) {
 389   3                  case BACNET_APPLICATION_TAG_NULL:
 390   3                      break;
 391   3                  case BACNET_APPLICATION_TAG_BOOLEAN:
 392   3                      break;
 393   3                  case BACNET_APPLICATION_TAG_UNSIGNED_INT:
 394   3                  case BACNET_APPLICATION_TAG_SIGNED_INT:
 395   3                  case BACNET_APPLICATION_TAG_REAL:
 396   3                  case BACNET_APPLICATION_TAG_DOUBLE:
 397   3                  case BACNET_APPLICATION_TAG_OCTET_STRING:
 398   3                  case BACNET_APPLICATION_TAG_CHARACTER_STRING:
 399   3                  case BACNET_APPLICATION_TAG_BIT_STRING:
 400   3                  case BACNET_APPLICATION_TAG_ENUMERATED:
 401   3                  case BACNET_APPLICATION_TAG_DATE:
 402   3                  case BACNET_APPLICATION_TAG_TIME:
 403   3                  case BACNET_APPLICATION_TAG_OBJECT_ID:
 404   3                      len = (int) len_value_type;
 405   3                      break;
 406   3                  default:
 407   3                      break;
 408   3              }
 409   2          }
 410   1      
 411   1          return len;
 412   1      }
 413          
 414          int bacapp_decode_application_data_len(
 415              uint8_t * apdu,
 416              unsigned max_apdu_len)
 417          {
 418   1          int len = 0;
 419   1          int tag_len = 0;
 420   1          int decode_len = 0;
 421   1          uint8_t tag_number = 0;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 8   

 422   1          uint32_t len_value_type = 0;
 423   1      
 424   1          /* FIXME: use max_apdu_len! */
 425   1          max_apdu_len = max_apdu_len;
 426   1          if (apdu && !IS_CONTEXT_SPECIFIC(*apdu)) {
 427   2              tag_len =
 428   2                  decode_tag_number_and_value(&apdu[0], &tag_number,
 429   2                  &len_value_type);
 430   2              if (tag_len) {
 431   3                  len += tag_len;
 432   3                  decode_len =
 433   3                      bacapp_decode_data_len(&apdu[len], tag_number, len_value_type);
 434   3                  len += decode_len;
 435   3              }
 436   2          }
 437   1      
 438   1          return len;
 439   1      }
 440          
 441          int bacapp_encode_context_data_value(
 442              uint8_t * apdu,
 443              uint8_t context_tag_number,
 444              BACNET_APPLICATION_DATA_VALUE * value)
 445          {
 446   1          int apdu_len = 0;   /* total length of the apdu, return value */
 447   1      
 448   1          if (value && apdu) {
 449   2              switch (value->tag) {
 450   3      #if defined (BACAPP_NULL)
 451   3                  case BACNET_APPLICATION_TAG_NULL:
 452   3                      apdu_len = encode_context_null(&apdu[0], context_tag_number);
 453   3                      break;
 454   3      #endif
 455   3      #if defined (BACAPP_BOOLEAN)
 456   3                  case BACNET_APPLICATION_TAG_BOOLEAN:
 457   3                      apdu_len =
 458   3                          encode_context_boolean(&apdu[0], context_tag_number,
 459   3                          value->type.Boolean);
 460   3                      break;
 461   3      #endif
 462   3      #if defined (BACAPP_UNSIGNED)
 463   3                  case BACNET_APPLICATION_TAG_UNSIGNED_INT:
 464   3                      apdu_len =
 465   3                          encode_context_unsigned(&apdu[0], context_tag_number,
 466   3                          value->type.Unsigned_Int);
 467   3                      break;
 468   3      #endif
 469   3      #if defined (BACAPP_SIGNED)
 470   3                  case BACNET_APPLICATION_TAG_SIGNED_INT:
 471   3                      apdu_len =
 472   3                          encode_context_signed(&apdu[0], context_tag_number,
 473   3                          value->type.Signed_Int);
 474   3                      break;
 475   3      #endif
 476   3      #if defined (BACAPP_REAL)
 477   3                  case BACNET_APPLICATION_TAG_REAL:
 478   3                      apdu_len =
 479   3                          encode_context_real(&apdu[0], context_tag_number,
 480   3                          value->type.Real);
 481   3                      break;
 482   3      #endif
 483   3      #if defined (BACAPP_DOUBLE)
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 9   

 484   3                  case BACNET_APPLICATION_TAG_DOUBLE:
 485   3                      apdu_len =
 486   3                          encode_context_double(&apdu[0], context_tag_number,
 487   3                          value->type.Double);
 488   3                      break;
 489   3      #endif
 490   3      #if defined (BACAPP_OCTET_STRING)
 491   3                  case BACNET_APPLICATION_TAG_OCTET_STRING:
 492   3                      apdu_len =
 493   3                          encode_context_octet_string(&apdu[0], context_tag_number,
 494   3                          &value->type.Octet_String);
 495   3                      break;
 496   3      #endif
 497   3      #if defined (BACAPP_CHARACTER_STRING)
 498   3                  case BACNET_APPLICATION_TAG_CHARACTER_STRING:
 499   3                      apdu_len =
 500   3                          encode_context_character_string(&apdu[0],
 501   3                          context_tag_number, &value->type.Character_String);
 502   3                      break;
 503   3      #endif
 504   3      #if defined (BACAPP_BIT_STRING)
 505   3                  case BACNET_APPLICATION_TAG_BIT_STRING:
 506   3                      apdu_len =
 507   3                          encode_context_bitstring(&apdu[0], context_tag_number,
 508   3                          &value->type.Bit_String);
 509   3                      break;
 510   3      #endif
 511   3      #if defined (BACAPP_ENUMERATED)
 512   3                  case BACNET_APPLICATION_TAG_ENUMERATED:
 513   3                      apdu_len =
 514   3                          encode_context_enumerated(&apdu[0], context_tag_number,
 515   3                          value->type.Enumerated);
 516   3                      break;
 517   3      #endif
 518   3      #if defined (BACAPP_DATE)
 519   3                  case BACNET_APPLICATION_TAG_DATE:
 520   3                      apdu_len =
 521   3                          encode_context_date(&apdu[0], context_tag_number,
 522   3                          &value->type.Date);
 523   3                      break;
 524   3      #endif
 525   3      #if defined (BACAPP_TIME)
 526   3                  case BACNET_APPLICATION_TAG_TIME:
 527   3                      apdu_len =
 528   3                          encode_context_time(&apdu[0], context_tag_number,
 529   3                          &value->type.Time);
 530   3                      break;
 531   3      #endif
 532   3      #if defined (BACAPP_OBJECT_ID)
 533   3                  case BACNET_APPLICATION_TAG_OBJECT_ID:
 534   3                      apdu_len =
 535   3                          encode_context_object_id(&apdu[0], context_tag_number,
 536   3                          (int) value->type.Object_Id.type,
 537   3                          value->type.Object_Id.instance);
 538   3                      break;
 539   3      #endif
 540   3                  default:
 541   3                      break;
 542   3              }
 543   2          }
 544   1      
 545   1          return apdu_len;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 10  

 546   1      }
 547          
 548          /* returns the fixed tag type for certain context tagged properties */
 549          BACNET_APPLICATION_TAG bacapp_context_tag_type(
 550              BACNET_PROPERTY_ID property,
 551              uint8_t tag_number)
 552          {
 553   1          BACNET_APPLICATION_TAG tag = MAX_BACNET_APPLICATION_TAG;
 554   1      
 555   1          switch (property) {
 556   2              case PROP_ACTUAL_SHED_LEVEL:
 557   2              case PROP_REQUESTED_SHED_LEVEL:
 558   2              case PROP_EXPECTED_SHED_LEVEL:
 559   2                  switch (tag_number) {
 560   3                      case 0:
 561   3                      case 1:
 562   3                          tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
 563   3                          break;
 564   3                      case 2:
 565   3                          tag = BACNET_APPLICATION_TAG_REAL;
 566   3                          break;
 567   3                      default:
 568   3                          break;
 569   3                  }
 570   2                  break;
 571   2              case PROP_ACTION:
 572   2                  switch (tag_number) {
 573   3                      case 0:
 574   3                      case 1:
 575   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
 576   3                          break;
 577   3                      case 2:
 578   3                          tag = BACNET_APPLICATION_TAG_ENUMERATED;
 579   3                          break;
 580   3                      case 3:
 581   3                      case 5:
 582   3                      case 6:
 583   3                          tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
 584   3                          break;
 585   3                      case 7:
 586   3                      case 8:
 587   3                          tag = BACNET_APPLICATION_TAG_BOOLEAN;
 588   3                          break;
 589   3                      case 4:        /* propertyValue: abstract syntax */
 590   3                      default:
 591   3                          break;
 592   3                  }
 593   2                  break;
 594   2              case PROP_LIST_OF_GROUP_MEMBERS:
 595   2                  /* Sequence of ReadAccessSpecification */
 596   2                  switch (tag_number) {
 597   3                      case 0:
 598   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
 599   3                          break;
 600   3                      default:
 601   3                          break;
 602   3                  }
 603   2                  break;
 604   2              case PROP_EXCEPTION_SCHEDULE:
 605   2                  switch (tag_number) {
 606   3                      case 1:
 607   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 11  

 608   3                          break;
 609   3                      case 3:
 610   3                          tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
 611   3                          break;
 612   3                      case 0:        /* calendarEntry: abstract syntax + context */
 613   3                      case 2:        /* list of BACnetTimeValue: abstract syntax */
 614   3                      default:
 615   3                          break;
 616   3                  }
 617   2                  break;
 618   2              case PROP_LOG_DEVICE_OBJECT_PROPERTY:
 619   2                  switch (tag_number) {
 620   3                      case 0:        /* Object ID */
 621   3                      case 3:        /* Device ID */
 622   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
 623   3                          break;
 624   3                      case 1:        /* Property ID */
 625   3                          tag = BACNET_APPLICATION_TAG_ENUMERATED;
 626   3                          break;
 627   3                      case 2:        /* Array index */
 628   3                          tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
 629   3                          break;
 630   3                      default:
 631   3                          break;
 632   3                  }
 633   2                  break;
 634   2              case PROP_SUBORDINATE_LIST:
 635   2                  /* BACnetARRAY[N] of BACnetDeviceObjectReference */
 636   2                  switch (tag_number) {
 637   3                      case 0:        /* Optional Device ID */
 638   3                      case 1:        /* Object ID */
 639   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
 640   3                          break;
 641   3                      default:
 642   3                          break;
 643   3                  }
 644   2                  break;
 645   2      
 646   2              case PROP_RECIPIENT_LIST:
 647   2                  /* List of BACnetDestination */
 648   2                  switch (tag_number) {
 649   3                      case 0:        /* Device Object ID */
 650   3                          tag = BACNET_APPLICATION_TAG_OBJECT_ID;
 651   3                          break;
 652   3                      default:
 653   3                          break;
 654   3                  }
 655   2                  break;
 656   2              case PROP_ACTIVE_COV_SUBSCRIPTIONS:
 657   2                  /* BACnetCOVSubscription */
 658   2                  switch (tag_number) {
 659   3                      case 0:        /* BACnetRecipientProcess */
 660   3                      case 1:        /* BACnetObjectPropertyReference */
 661   3                          break;
 662   3                      case 2:        /* issueConfirmedNotifications */
 663   3                          tag = BACNET_APPLICATION_TAG_BOOLEAN;
 664   3                          break;
 665   3                      case 3:        /* timeRemaining */
 666   3                          tag = BACNET_APPLICATION_TAG_UNSIGNED_INT;
 667   3                          break;
 668   3                      case 4:        /* covIncrement */
 669   3                          tag = BACNET_APPLICATION_TAG_REAL;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 12  

 670   3                          break;
 671   3                      default:
 672   3                          break;
 673   3                  }
 674   2                  break;
 675   2              default:
 676   2                  break;
 677   2          }
 678   1      
 679   1          return tag;
 680   1      }
 681          
 682          int bacapp_encode_context_data(
 683              uint8_t * apdu,
 684              BACNET_APPLICATION_DATA_VALUE * value,
 685              BACNET_PROPERTY_ID property)
 686          {
 687   1          int apdu_len = 0;
 688   1          BACNET_APPLICATION_TAG tag_data_type;
 689   1      
 690   1          if (value && apdu) {
 691   2              tag_data_type = bacapp_context_tag_type(property, value->context_tag);
 692   2              if (tag_data_type < MAX_BACNET_APPLICATION_TAG) {
 693   3                  apdu_len =
 694   3                      bacapp_encode_context_data_value(&apdu[0], value->context_tag,
 695   3                      value);
 696   3              } else {
 697   3                  /* FIXME: what now? */
 698   3                  apdu_len = 0;
 699   3              }
 700   2              value->next = NULL;
 701   2          }
 702   1      
 703   1          return apdu_len;
 704   1      }
 705          
 706          int bacapp_decode_context_data(
 707              uint8_t * apdu,
 708              unsigned max_apdu_len,
 709              BACNET_APPLICATION_DATA_VALUE * value,
 710              BACNET_PROPERTY_ID property)
 711          {
 712   1          int apdu_len = 0, len = 0;
 713   1          int tag_len = 0;
 714   1          uint8_t tag_number = 0;
 715   1          uint32_t len_value_type = 0;
 716   1      
 717   1          if (apdu && value && IS_CONTEXT_SPECIFIC(*apdu)) {
 718   2              value->context_specific = true;
 719   2              value->next = NULL;
 720   2              tag_len =
 721   2                  decode_tag_number_and_value(&apdu[0], &tag_number,
 722   2                  &len_value_type);
 723   2              apdu_len = tag_len;
 724   2              /* Empty construct : (closing tag) => returns NULL value */
 725   2              if (tag_len && ((unsigned) tag_len <= max_apdu_len) &&
 726   2                  !decode_is_closing_tag_number(&apdu[0], tag_number)) {
 727   3                  value->context_tag = tag_number;
 728   3                  value->tag = bacapp_context_tag_type(property, tag_number);
 729   3                  if (value->tag < MAX_BACNET_APPLICATION_TAG) {
 730   4                      len =
 731   4                          bacapp_decode_data(&apdu[apdu_len], value->tag,
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 13  

 732   4                          len_value_type, value);
 733   4                      apdu_len += len;
 734   4                  } else if (len_value_type) {
 735   4                      /* Unknown value : non null size (elementary type) */
 736   4                      apdu_len += len_value_type;
 737   4                      /* SHOULD NOT HAPPEN, EXCEPTED WHEN READING UNKNOWN CONTEXTUAL PROPERTY */
 738   4                  } else {
 739   4                      apdu_len = BACNET_STATUS_ERROR;
 740   4                  }
 741   3              } else if (tag_len == 1)        /* and is a Closing tag */
 742   2                  apdu_len = 0;       /* Don't advance over that closing tag. */
 743   2          }
 744   1      
 745   1          return apdu_len;
 746   1      }
 747          
 748          int bacapp_decode_context_data_len(
 749              uint8_t * apdu,
 750              unsigned max_apdu_len,
 751              BACNET_PROPERTY_ID property)
 752          {
 753   1          int apdu_len = 0, len = 0;
 754   1          int tag_len = 0;
 755   1          uint8_t tag_number = 0;
 756   1          uint32_t len_value_type = 0;
 757   1          uint8_t tag = 0;
 758   1      
 759   1          /* FIXME: use max_apdu_len! */
 760   1          max_apdu_len = max_apdu_len;
 761   1          if (apdu && IS_CONTEXT_SPECIFIC(*apdu)) {
 762   2              tag_len =
 763   2                  decode_tag_number_and_value(&apdu[0], &tag_number,
 764   2                  &len_value_type);
 765   2              if (tag_len) {
 766   3                  apdu_len = tag_len;
 767   3                  tag = bacapp_context_tag_type(property, tag_number);
 768   3                  if (tag < MAX_BACNET_APPLICATION_TAG) {
 769   4                      len =
 770   4                          bacapp_decode_data_len(&apdu[apdu_len], tag,
 771   4                          len_value_type);
 772   4                      apdu_len += len;
 773   4                  } else {
 774   4                      apdu_len += len_value_type;
 775   4                  }
 776   3              }
 777   2          }
 778   1      
 779   1          return apdu_len;
 780   1      }
 781          
 782          int bacapp_encode_data(
 783              uint8_t * apdu,
 784              BACNET_APPLICATION_DATA_VALUE * value)
 785          {
 786   1          int apdu_len = 0;   /* total length of the apdu, return value */
 787   1      
 788   1          if (value && apdu) {
 789   2              if (value->context_specific) {
 790   3                  apdu_len =
 791   3                      bacapp_encode_context_data_value(&apdu[0], value->context_tag,
 792   3                      value);
 793   3              } else {
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 14  

 794   3                  apdu_len = bacapp_encode_application_data(&apdu[0], value);
 795   3              }
 796   2          }
 797   1      
 798   1          return apdu_len;
 799   1      }
 800          
 801          
 802          bool bacapp_copy(
 803              BACNET_APPLICATION_DATA_VALUE * dest_value,
 804              BACNET_APPLICATION_DATA_VALUE * src_value)
 805          {
 806   1          bool status = true; /*return value */
 807   1      
 808   1          if (dest_value && src_value) {
 809   2              dest_value->tag = src_value->tag;
 810   2              switch (src_value->tag) {
 811   3      #if defined (BACAPP_NULL)
 812   3                  case BACNET_APPLICATION_TAG_NULL:
 813   3                      break;
 814   3      #endif
 815   3      #if defined (BACAPP_BOOLEAN)
 816   3                  case BACNET_APPLICATION_TAG_BOOLEAN:
 817   3                      dest_value->type.Boolean = src_value->type.Boolean;
 818   3                      break;
 819   3      #endif
 820   3      #if defined (BACAPP_UNSIGNED)
 821   3                  case BACNET_APPLICATION_TAG_UNSIGNED_INT:
 822   3                      dest_value->type.Unsigned_Int = src_value->type.Unsigned_Int;
 823   3                      break;
 824   3      #endif
 825   3      #if defined (BACAPP_SIGNED)
 826   3                  case BACNET_APPLICATION_TAG_SIGNED_INT:
 827   3                      dest_value->type.Signed_Int = src_value->type.Signed_Int;
 828   3                      break;
 829   3      #endif
 830   3      #if defined (BACAPP_REAL)
 831   3                  case BACNET_APPLICATION_TAG_REAL:
 832   3                      dest_value->type.Real = src_value->type.Real;
 833   3                      break;
 834   3      #endif
 835   3      #if defined (BACAPP_DOUBLE)
 836   3                  case BACNET_APPLICATION_TAG_DOUBLE:
 837   3                      dest_value->type.Double = src_value->type.Double;
 838   3                      break;
 839   3      #endif
 840   3      #if defined (BACAPP_OCTET_STRING)
 841   3                  case BACNET_APPLICATION_TAG_OCTET_STRING:
 842   3                      octetstring_copy(&dest_value->type.Octet_String,
 843   3                          &src_value->type.Octet_String);
 844   3                      break;
 845   3      #endif
 846   3      #if defined (BACAPP_CHARACTER_STRING)
 847   3                  case BACNET_APPLICATION_TAG_CHARACTER_STRING:
 848   3                      characterstring_copy(&dest_value->type.Character_String,
 849   3                          &src_value->type.Character_String);
 850   3                      break;
 851   3      #endif
 852   3      #if defined (BACAPP_BIT_STRING)
 853   3                  case BACNET_APPLICATION_TAG_BIT_STRING:
 854   3                      bitstring_copy(&dest_value->type.Bit_String,
 855   3                          &src_value->type.Bit_String);
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 15  

 856   3                      break;
 857   3      #endif
 858   3      #if defined (BACAPP_ENUMERATED)
 859   3                  case BACNET_APPLICATION_TAG_ENUMERATED:
 860   3                      dest_value->type.Enumerated = src_value->type.Enumerated;
 861   3                      break;
 862   3      #endif
 863   3      #if defined (BACAPP_DATE)
 864   3                  case BACNET_APPLICATION_TAG_DATE:
 865   3                      datetime_copy_date(&dest_value->type.Date,
 866   3                          &src_value->type.Date);
 867   3                      break;
 868   3      #endif
 869   3      #if defined (BACAPP_TIME)
 870   3                  case BACNET_APPLICATION_TAG_TIME:
 871   3                      datetime_copy_time(&dest_value->type.Time,
 872   3                          &src_value->type.Time);
 873   3                      break;
 874   3      #endif
 875   3      #if defined (BACAPP_OBJECT_ID)
 876   3                  case BACNET_APPLICATION_TAG_OBJECT_ID:
 877   3                      dest_value->type.Object_Id.type =
 878   3                          src_value->type.Object_Id.type;
 879   3                      dest_value->type.Object_Id.instance =
 880   3                          src_value->type.Object_Id.instance;
 881   3                      break;
 882   3      #endif
 883   3                  default:
 884   3                      status = false;
 885   3                      break;
 886   3              }
 887   2              dest_value->next = src_value->next;
 888   2          }
 889   1      
 890   1          return status;
 891   1      }
 892          
 893          /* returns the length of data between an opening tag and a closing tag.
 894             Expects that the first octet contain the opening tag.
 895             Include a value property identifier for context specific data
 896             such as the value received in a WriteProperty request */
 897          int bacapp_data_len(
 898              uint8_t * apdu,
 899              unsigned max_apdu_len,
 900              BACNET_PROPERTY_ID property)
 901          {
 902   1          int len = 0;
 903   1          int total_len = 0;
 904   1          int apdu_len = 0;
 905   1          uint8_t tag_number = 0;
 906   1          uint8_t opening_tag_number = 0;
 907   1          uint8_t opening_tag_number_counter = 0;
 908   1          uint32_t value = 0;
 909   1      
 910   1          if (IS_OPENING_TAG(apdu[0])) {
 911   2              len =
 912   2                  decode_tag_number_and_value(&apdu[apdu_len], &tag_number, &value);
 913   2              apdu_len += len;
 914   2              opening_tag_number = tag_number;
 915   2              opening_tag_number_counter = 1;
 916   2              while (opening_tag_number_counter) {
 917   3                  if (IS_OPENING_TAG(apdu[apdu_len])) {
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 16  

 918   4                      len =
 919   4                          decode_tag_number_and_value(&apdu[apdu_len], &tag_number,
 920   4                          &value);
 921   4                      if (tag_number == opening_tag_number)
 922   4                          opening_tag_number_counter++;
 923   4                  } else if (IS_CLOSING_TAG(apdu[apdu_len])) {
 924   4                      len =
 925   4                          decode_tag_number_and_value(&apdu[apdu_len], &tag_number,
 926   4                          &value);
 927   4                      if (tag_number == opening_tag_number)
 928   4                          opening_tag_number_counter--;
 929   4                  } else if (IS_CONTEXT_SPECIFIC(apdu[apdu_len])) {
 930   4                      /* context-specific tagged data */
 931   4                      len =
 932   4                          bacapp_decode_context_data_len(&apdu[apdu_len],
 933   4                          max_apdu_len - apdu_len, property);
 934   4                  } else {
 935   4                      /* application tagged data */
 936   4                      len =
 937   4                          bacapp_decode_application_data_len(&apdu[apdu_len],
 938   4                          max_apdu_len - apdu_len);
 939   4                  }
 940   3                  apdu_len += len;
 941   3                  if (opening_tag_number_counter) {
 942   4                      if (len > 0) {
 943   5                          total_len += len;
 944   5                      } else {
 945   5                          /* error: len is not incrementing */
 946   5                          total_len = BACNET_STATUS_ERROR;
 947   5                          break;
 948   5                      }
 949   4                  }
 950   3                  if ((unsigned) apdu_len > max_apdu_len) {
 951   4                      /* error: exceeding our buffer limit */
 952   4                      total_len = BACNET_STATUS_ERROR;
 953   4                      break;
 954   4                  }
 955   3              }
 956   2          }
 957   1      
 958   1          return total_len;
 959   1      }
 960          
 961          #ifdef BACAPP_SNPRINTF_ENABLED
              static bool append_str(
                  char **str,
                  size_t * rem_str_len,
                  const char *add_str)
              {
                  bool retval;
                  int bytes_written;
              
                  bytes_written = snprintf(*str, *rem_str_len, "%s", add_str);
                  if ((bytes_written < 0) || (bytes_written >= *rem_str_len)) {
                      /* If there was an error or output was truncated, return error */
                      retval = false;
                  } else {
                      /* Successfully wrote the contents to the string. Let's advance the
                       * string pointer to the end, and account for the used space */
                      *str += bytes_written;
                      *rem_str_len -= bytes_written;
                      retval = true;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 17  

                  }
              
                  return retval;
              }
              
              /* Extract the value into a string
               *  Inputs:  str - the buffer to store the extracted value.
               *           str_len - the size of the buffer
               *           object_value - ptr to BACnet object value from which to extract str
               *  Return:  number of bytes (excluding terminating NULL byte) that were stored
               *           to the output string. If output was truncated due to string size,
               *           then the returned value is greater than str_len (a la snprintf() ).
               */
              int bacapp_snprintf_value(
                  char *str,
                  size_t str_len,
                  BACNET_OBJECT_PROPERTY_VALUE * object_value)
              {
                  size_t len = 0, i = 0;
                  char *char_str;
                  uint8_t *octet_str;
                  BACNET_APPLICATION_DATA_VALUE *value;
                  BACNET_PROPERTY_ID property = PROP_ALL;
                  BACNET_OBJECT_TYPE object_type = MAX_BACNET_OBJECT_TYPE;
                  int ret_val = -1;
                  char *p_str = str;
                  size_t rem_str_len = str_len;
                  char temp_str[32];
              
                  if (object_value && object_value->value) {
                      value = object_value->value;
                      property = object_value->object_property;
                      object_type = object_value->object_type;
                      switch (value->tag) {
                          case BACNET_APPLICATION_TAG_NULL:
                              ret_val = snprintf(str, str_len, "Null");
                              break;
                          case BACNET_APPLICATION_TAG_BOOLEAN:
                              ret_val =
                                  (value->type.Boolean) ? snprintf(str, str_len,
                                  "TRUE") : snprintf(str, str_len, "FALSE");
                              break;
                          case BACNET_APPLICATION_TAG_UNSIGNED_INT:
                              ret_val =
                                  snprintf(str, str_len, "%lu",
                                  (unsigned long) value->type.Unsigned_Int);
                              break;
                          case BACNET_APPLICATION_TAG_SIGNED_INT:
                              ret_val =
                                  snprintf(str, str_len, "%ld",
                                  (long) value->type.Signed_Int);
                              break;
                          case BACNET_APPLICATION_TAG_REAL:
                              ret_val =
                                  snprintf(str, str_len, "%f", (double) value->type.Real);
                              break;
              #if defined (BACAPP_DOUBLE)
                          case BACNET_APPLICATION_TAG_DOUBLE:
                              ret_val = snprintf(str, str_len, "%f", value->type.Double);
                              break;
              #endif
                          case BACNET_APPLICATION_TAG_OCTET_STRING:
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 18  

                              len = octetstring_length(&value->type.Octet_String);
                              octet_str = octetstring_value(&value->type.Octet_String);
                              for (i = 0; i < len; i++) {
                                  snprintf(temp_str, sizeof(temp_str), "%02X", *octet_str);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                                  octet_str++;
                              }
                              if (i == len) {
                                  /* Everything went fine */
                                  ret_val = str_len - rem_str_len;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_CHARACTER_STRING:
                              len = characterstring_length(&value->type.Character_String);
                              char_str =
                                  characterstring_value(&value->type.Character_String);
                              if (!append_str(&p_str, &rem_str_len, "\""))
                                  break;
                              for (i = 0; i < len; i++) {
                                  if (isprint(*((unsigned char *) char_str))) {
                                      snprintf(temp_str, sizeof(temp_str), "%c", *char_str);
                                  } else {
                                      snprintf(temp_str, sizeof(temp_str), "%c", '.');
                                  }
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                                  char_str++;
                              }
                              if ((i == len) && append_str(&p_str, &rem_str_len, "\"")
                                  ) {
                                  /* Everything is fine. Indicate how many bytes were */
                                  /* written */
                                  ret_val = str_len - rem_str_len;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_BIT_STRING:
                              len = bitstring_bits_used(&value->type.Bit_String);
                              if (!append_str(&p_str, &rem_str_len, "{"))
                                  break;
                              for (i = 0; i < len; i++) {
                                  snprintf(temp_str, sizeof(temp_str), "%s",
                                      bitstring_bit(&value->type.Bit_String,
                                          (uint8_t) i) ? "true" : "false");
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                                  if (i < len - 1) {
                                      if (!append_str(&p_str, &rem_str_len, ","))
                                          break;
                                  }
                              }
                              if ((i == len) && append_str(&p_str, &rem_str_len, "}")
                                  ) {
                                  /* Everything is fine. Indicate how many bytes were */
                                  /* written */
                                  ret_val = str_len - rem_str_len;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_ENUMERATED:
                              switch (property) {
                                  case PROP_OBJECT_TYPE:
                                      if (value->type.Enumerated < MAX_ASHRAE_OBJECT_TYPE) {
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 19  

                                          ret_val =
                                              snprintf(str, str_len, "%s",
                                              bactext_object_type_name(value->
                                                  type.Enumerated));
                                      } else if (value->type.Enumerated < 128) {
                                          ret_val =
                                              snprintf(str, str_len, "reserved %lu",
                                              (unsigned long) value->type.Enumerated);
                                      } else {
                                          ret_val =
                                              snprintf(str, str_len, "proprietary %lu",
                                              (unsigned long) value->type.Enumerated);
                                      }
                                      break;
                                  case PROP_EVENT_STATE:
                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_event_state_name(value->type.Enumerated));
                                      break;
                                  case PROP_UNITS:
                                      if (value->type.Enumerated < 256) {
                                          ret_val =
                                              snprintf(str, str_len, "%s",
                                              bactext_engineering_unit_name(value->type.
                                                  Enumerated));
                                      } else {
                                          ret_val =
                                              snprintf(str, str_len, "proprietary %lu",
                                              (unsigned long) value->type.Enumerated);
                                      }
                                      break;
                                  case PROP_POLARITY:
                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_binary_polarity_name(value->type.
                                              Enumerated));
                                      break;
                                  case PROP_PRESENT_VALUE:
                                  case PROP_RELINQUISH_DEFAULT:
                                      if (object_type < PROPRIETARY_BACNET_OBJECT_TYPE) {
                                          ret_val =
                                              snprintf(str, str_len, "%s",
                                              bactext_binary_present_value_name(value->
                                                  type.Enumerated));
                                      } else {
                                          ret_val =
                                              snprintf(str, str_len, "%lu",
                                              (unsigned long) value->type.Enumerated);
                                      }
                                      break;
                                  case PROP_RELIABILITY:
                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_reliability_name(value->type.Enumerated));
                                      break;
                                  case PROP_SYSTEM_STATUS:
                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_device_status_name(value->type.
                                              Enumerated));
                                      break;
                                  case PROP_SEGMENTATION_SUPPORTED:
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 20  

                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_segmentation_name(value->type.Enumerated));
                                      break;
                                  case PROP_NODE_TYPE:
                                      ret_val =
                                          snprintf(str, str_len, "%s",
                                          bactext_node_type_name(value->type.Enumerated));
                                      break;
                                  default:
                                      ret_val =
                                          snprintf(str, str_len, "%lu",
                                          (unsigned long) value->type.Enumerated);
                                      break;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_DATE:
                              if (!append_str(&p_str, &rem_str_len,
                                      bactext_day_of_week_name(value->type.Date.wday)
                                  )
                                  )
                                  break;
                              if (!append_str(&p_str, &rem_str_len, ", "))
                                  break;
              
                              if (!append_str(&p_str, &rem_str_len,
                                      bactext_month_name(value->type.Date.month)
                                  )
                                  )
                                  break;
                              if (value->type.Date.day == 255) {
                                  if (!append_str(&p_str, &rem_str_len, " (unspecified), "))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), " %u, ",
                                      (unsigned) value->type.Date.day);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              if (value->type.Date.year == 2155) {
                                  if (!append_str(&p_str, &rem_str_len, "(unspecified)"))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), "%u",
                                      (unsigned) value->type.Date.year);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              /* If we get here, then everything is OK. Indicate how many */
                              /* bytes were written. */
                              ret_val = str_len - rem_str_len;
                              break;
                          case BACNET_APPLICATION_TAG_TIME:
                              if (value->type.Time.hour == 255) {
                                  if (!append_str(&p_str, &rem_str_len, "**:"))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), "%02u:",
                                      (unsigned) value->type.Time.hour);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 21  

                              if (value->type.Time.min == 255) {
                                  if (!append_str(&p_str, &rem_str_len, "**:"))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), "%02u:",
                                      (unsigned) value->type.Time.min);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              if (value->type.Time.sec == 255) {
                                  if (!append_str(&p_str, &rem_str_len, "**."))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), "%02u.",
                                      (unsigned) value->type.Time.sec);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              if (value->type.Time.hundredths == 255) {
                                  if (!append_str(&p_str, &rem_str_len, "**"))
                                      break;
                              } else {
                                  snprintf(temp_str, sizeof(temp_str), "%02u",
                                      (unsigned) value->type.Time.hundredths);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              /* If we get here, then everything is OK. Indicate how many */
                              /* bytes were written. */
                              ret_val = str_len - rem_str_len;
                              break;
                          case BACNET_APPLICATION_TAG_OBJECT_ID:
                              if (!append_str(&p_str, &rem_str_len, "("))
                                  break;
                              if (value->type.Object_Id.type < MAX_ASHRAE_OBJECT_TYPE) {
                                  if (!append_str(&p_str, &rem_str_len,
                                          bactext_object_type_name(value->type.Object_Id.
                                              type)
                                      )
                                      )
                                      break;
                                  snprintf(temp_str, sizeof(temp_str), ", %lu",
                                      (unsigned long) value->type.Object_Id.instance);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              } else if (value->type.Object_Id.type < 128) {
                                  if (!append_str(&p_str, &rem_str_len, "reserved "))
                                      break;
                                  snprintf(temp_str, sizeof(temp_str), "%u, ",
                                      (unsigned) value->type.Object_Id.type);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                                  snprintf(temp_str, sizeof(temp_str), "%lu",
                                      (unsigned long) value->type.Object_Id.instance);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              } else {
                                  if (!append_str(&p_str, &rem_str_len, "proprietary "))
                                      break;
                                  snprintf(temp_str, sizeof(temp_str), "%u, ",
                                      (unsigned) value->type.Object_Id.type);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 22  

                                      break;
                                  snprintf(temp_str, sizeof(temp_str), "%lu",
                                      (unsigned long) value->type.Object_Id.instance);
                                  if (!append_str(&p_str, &rem_str_len, temp_str))
                                      break;
                              }
                              if (!append_str(&p_str, &rem_str_len, ")"))
                                  break;
                              /* If we get here, then everything is OK. Indicate how many */
                              /* bytes were written. */
                              ret_val = str_len - rem_str_len;
                              break;
                          default:
                              ret_val = 0;
                              break;
                      }
                  }
              
                  return ret_val;
              }
              #endif /* BACAPP_SNPRINTF_ENABLED */
1311          
1312          #ifdef BACAPP_PRINT_ENABLED
              /* Print the extracted value from the requested BACnet object property to the
               * specified stream. If stream is NULL, do not print anything. If extraction
               * failed, do not print anything. Return the status of the extraction.
               */
              bool bacapp_print_value(
                  FILE * stream,
                  BACNET_OBJECT_PROPERTY_VALUE * object_value)
              {
                  char *str;
                  bool retval = false;
                  size_t str_len = 32;
                  int status;
              
                  while (true) {
                      /* Try to allocate memory for the output string. Give up if unable. */
                      str = (char *) calloc(sizeof(char), str_len);
                      if (!str)
                          break;
              
                      /* Try to extract the value into allocated memory. If unable, try again */
                      /* another time with a string that is twice as large. */
                      status = bacapp_snprintf_value(str, str_len, object_value);
                      if ((status < 0) || (status >= str_len)) {
                          free(str);
                          str_len *= 2;
                      } else if (status == 0) {
                          free(str);
                          break;
                      } else {
                          if (stream)
                              fprintf(stream, "%s", str);
                          free(str);
                          retval = true;
                          break;
                      }
                  }
                  return retval;
              }
              #endif
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 23  

1352          
1353          #ifdef BACAPP_PRINT_ENABLED
              /* used to load the app data struct with the proper data
                 converted from a command line argument */
              bool bacapp_parse_application_data(
                  BACNET_APPLICATION_TAG tag_number,
                  const char *argv,
                  BACNET_APPLICATION_DATA_VALUE * value)
              {
                  int hour, min, sec, hundredths;
                  int year, month, day, wday;
                  int object_type = 0;
                  uint32_t instance = 0;
                  bool status = false;
                  long long_value = 0;
                  unsigned long unsigned_long_value = 0;
                  double double_value = 0.0;
                  int count = 0;
              
                  if (value && (tag_number < MAX_BACNET_APPLICATION_TAG)) {
                      status = true;
                      value->tag = tag_number;
                      switch (tag_number) {
                          case BACNET_APPLICATION_TAG_BOOLEAN:
                              long_value = strtol(argv, NULL, 0);
                              if (long_value)
                                  value->type.Boolean = true;
                              else
                                  value->type.Boolean = false;
                              break;
                          case BACNET_APPLICATION_TAG_UNSIGNED_INT:
                              unsigned_long_value = strtoul(argv, NULL, 0);
                              value->type.Unsigned_Int = unsigned_long_value;
                              break;
                          case BACNET_APPLICATION_TAG_SIGNED_INT:
                              long_value = strtol(argv, NULL, 0);
                              value->type.Signed_Int = long_value;
                              break;
                          case BACNET_APPLICATION_TAG_REAL:
                              double_value = strtod(argv, NULL);
                              value->type.Real = (float) double_value;
                              break;
              #if defined (BACAPP_DOUBLE)
                          case BACNET_APPLICATION_TAG_DOUBLE:
                              double_value = strtod(argv, NULL);
                              value->type.Double = double_value;
                              break;
              #endif
                          case BACNET_APPLICATION_TAG_OCTET_STRING:
              #if PRINT_ENABLED       /* Apparently ain't necessarily so. */
                              status =
                                  octetstring_init_ascii_hex(&value->type.Octet_String,
                                  argv);
              #endif
                              break;
                          case BACNET_APPLICATION_TAG_CHARACTER_STRING:
                              status =
                                  characterstring_init_ansi(&value->type.Character_String,
                                  (char *) argv);
                              break;
                          case BACNET_APPLICATION_TAG_BIT_STRING:
                              /* FIXME: how to parse a bit string? */
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 24  

                              status = false;
                              bitstring_init(&value->type.Bit_String);
                              break;
                          case BACNET_APPLICATION_TAG_ENUMERATED:
                              unsigned_long_value = strtoul(argv, NULL, 0);
                              value->type.Enumerated = unsigned_long_value;
                              break;
                          case BACNET_APPLICATION_TAG_DATE:
                              count =
                                  sscanf(argv, "%4d/%3d/%3d:%3d", &year, &month, &day,
                                  &wday);
                              if (count == 3) {
                                  datetime_set_date(&value->type.Date, (uint16_t) year,
                                      (uint8_t) month, (uint8_t) day);
                              } else if (count == 4) {
                                  value->type.Date.year = (uint16_t) year;
                                  value->type.Date.month = (uint8_t) month;
                                  value->type.Date.day = (uint8_t) day;
                                  value->type.Date.wday = (uint8_t) wday;
                              } else {
                                  status = false;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_TIME:
                              count =
                                  sscanf(argv, "%3d:%3d:%3d.%3d", &hour, &min, &sec,
                                  &hundredths);
                              if (count == 4) {
                                  value->type.Time.hour = (uint8_t) hour;
                                  value->type.Time.min = (uint8_t) min;
                                  value->type.Time.sec = (uint8_t) sec;
                                  value->type.Time.hundredths = (uint8_t) hundredths;
                              } else if (count == 3) {
                                  value->type.Time.hour = (uint8_t) hour;
                                  value->type.Time.min = (uint8_t) min;
                                  value->type.Time.sec = (uint8_t) sec;
                                  value->type.Time.hundredths = 0;
                              } else if (count == 2) {
                                  value->type.Time.hour = (uint8_t) hour;
                                  value->type.Time.min = (uint8_t) min;
                                  value->type.Time.sec = 0;
                                  value->type.Time.hundredths = 0;
                              } else {
                                  status = false;
                              }
                              break;
                          case BACNET_APPLICATION_TAG_OBJECT_ID:
                              count = sscanf(argv, "%4d:%7d", &object_type, &instance);
                              if (count == 2) {
                                  value->type.Object_Id.type = (uint16_t) object_type;
                                  value->type.Object_Id.instance = instance;
                              } else {
                                  status = false;
                              }
                              break;
                          default:
                              break;
                      }
                      value->next = NULL;
                  }
              
                  return status;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 25  

              }
              #endif
1478          
1479          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include "ctest.h"
              
              
              #include <assert.h>
              
              /* generic - can be used by other unit tests
                 returns true if matching or same, false if different */
              bool bacapp_same_value(
                  BACNET_APPLICATION_DATA_VALUE * value,
                  BACNET_APPLICATION_DATA_VALUE * test_value)
              {
                  bool status = false;        /*return value */
              
                  /* does the tag match? */
                  if (test_value->tag == value->tag)
                      status = true;
                  if (status) {
                      /* second test for same-ness */
                      status = false;
                      /* does the value match? */
                      switch (test_value->tag) {
              #if defined (BACAPP_NULL)
                          case BACNET_APPLICATION_TAG_NULL:
                              status = true;
                              break;
              #endif
              #if defined (BACAPP_BOOLEAN)
                          case BACNET_APPLICATION_TAG_BOOLEAN:
                              if (test_value->type.Boolean == value->type.Boolean)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_UNSIGNED)
                          case BACNET_APPLICATION_TAG_UNSIGNED_INT:
                              if (test_value->type.Unsigned_Int == value->type.Unsigned_Int)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_SIGNED)
                          case BACNET_APPLICATION_TAG_SIGNED_INT:
                              if (test_value->type.Signed_Int == value->type.Signed_Int)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_REAL)
                          case BACNET_APPLICATION_TAG_REAL:
                              if (test_value->type.Real == value->type.Real)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_DOUBLE)
                          case BACNET_APPLICATION_TAG_DOUBLE:
                              if (test_value->type.Double == value->type.Double)
                                  status = true;
                              break;
              #endif
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 26  

              #if defined (BACAPP_ENUMERATED)
                          case BACNET_APPLICATION_TAG_ENUMERATED:
                              if (test_value->type.Enumerated == value->type.Enumerated)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_DATE)
                          case BACNET_APPLICATION_TAG_DATE:
                              if (datetime_compare_date(&test_value->type.Date,
                                      &value->type.Date) == 0)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_TIME)
                          case BACNET_APPLICATION_TAG_TIME:
                              if (datetime_compare_time(&test_value->type.Time,
                                      &value->type.Time) == 0)
                                  status = true;
                              break;
              #endif
              #if defined (BACAPP_OBJECT_ID)
                          case BACNET_APPLICATION_TAG_OBJECT_ID:
                              if ((test_value->type.Object_Id.type ==
                                      value->type.Object_Id.type) &&
                                  (test_value->type.Object_Id.instance ==
                                      value->type.Object_Id.instance)) {
                                  status = true;
                              }
                              break;
              #endif
              #if defined (BACAPP_CHARACTER_STRING)
                          case BACNET_APPLICATION_TAG_CHARACTER_STRING:
                              status =
                                  characterstring_same(&value->type.Character_String,
                                  &test_value->type.Character_String);
                              break;
              #endif
              #if defined (BACAPP_OCTET_STRING)
                          case BACNET_APPLICATION_TAG_OCTET_STRING:
                              status =
                                  octetstring_value_same(&value->type.Octet_String,
                                  &test_value->type.Octet_String);
                              break;
              #endif
              #if defined (BACAPP_BIT_STRING)
                          case BACNET_APPLICATION_TAG_BIT_STRING:
                              status =
                                  bitstring_same(&value->type.Bit_String,
                                  &test_value->type.Bit_String);
                              break;
              #endif
              
                          default:
                              status = false;
                              break;
                      }
                  }
                  return status;
              }
              
              void testBACnetApplicationData_Safe(
                  Test * pTest)
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 27  

              {
                  int i;
                  uint8_t apdu[MAX_APDU];
                  int len = 0;
                  int apdu_len;
                  BACNET_APPLICATION_DATA_VALUE input_value[13];
                  uint32_t len_segment[13];
                  uint32_t single_length_segment;
                  BACNET_APPLICATION_DATA_VALUE value;
              
              
                  for (i = 0; i < 13; i++) {
                      input_value[i].tag = (BACNET_APPLICATION_TAG) i;
                      input_value[i].context_specific = 0;
                      input_value[i].context_tag = 0;
                      input_value[i].next = NULL;
                      switch (input_value[i].tag) {
                          case BACNET_APPLICATION_TAG_NULL:
                              /* NULL: no data */
                              break;
              
                          case BACNET_APPLICATION_TAG_BOOLEAN:
                              input_value[i].type.Boolean = true;
                              break;
              
                          case BACNET_APPLICATION_TAG_UNSIGNED_INT:
                              input_value[i].type.Unsigned_Int = 0xDEADBEEF;
                              break;
              
                          case BACNET_APPLICATION_TAG_SIGNED_INT:
                              input_value[i].type.Signed_Int = 0x00C0FFEE;
                              break;
                          case BACNET_APPLICATION_TAG_REAL:
                              input_value[i].type.Real = 3.141592654f;
                              break;
                          case BACNET_APPLICATION_TAG_DOUBLE:
                              input_value[i].type.Double = 2.32323232323;
                              break;
              
                          case BACNET_APPLICATION_TAG_OCTET_STRING:
                              {
                                  uint8_t test_octet[5] = { "Karg" };
                                  octetstring_init(&input_value[i].type.Octet_String,
                                      test_octet, sizeof(test_octet));
                              }
                              break;
              
                          case BACNET_APPLICATION_TAG_CHARACTER_STRING:
                              characterstring_init_ansi(&input_value[i].
                                  type.Character_String, "Hello There!");
                              break;
              
                          case BACNET_APPLICATION_TAG_BIT_STRING:
                              bitstring_init(&input_value[i].type.Bit_String);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 0, true);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 1, false);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 2, false);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 3, true);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 4, false);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 5, true);
                              bitstring_set_bit(&input_value[i].type.Bit_String, 6, true);
                              break;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 28  

              
                          case BACNET_APPLICATION_TAG_ENUMERATED:
                              input_value[i].type.Enumerated = 0x0BADF00D;
                              break;
              
                          case BACNET_APPLICATION_TAG_DATE:
                              input_value[i].type.Date.day = 10;
                              input_value[i].type.Date.month = 9;
                              input_value[i].type.Date.wday = 3;
                              input_value[i].type.Date.year = 1998;
                              break;
              
                          case BACNET_APPLICATION_TAG_TIME:
                              input_value[i].type.Time.hour = 12;
                              input_value[i].type.Time.hundredths = 56;
                              input_value[i].type.Time.min = 20;
                              input_value[i].type.Time.sec = 41;
                              break;
              
                          case BACNET_APPLICATION_TAG_OBJECT_ID:
                              input_value[i].type.Object_Id.instance = 1234;
                              input_value[i].type.Object_Id.type = 12;
                              break;
              
                          default:
                              break;
                      }
                      single_length_segment =
                          bacapp_encode_data(&apdu[len], &input_value[i]);;
                      assert(single_length_segment > 0);
                      /* len_segment is accumulated length */
                      if (i == 0) {
                          len_segment[i] = single_length_segment;
                      } else {
                          len_segment[i] = single_length_segment + len_segment[i - 1];
                      }
                      len = len_segment[i];
                  }
                  /*
                   ** Start processing packets at processivly truncated lengths
                   */
              
                  for (apdu_len = len; apdu_len >= 0; apdu_len--) {
                      bool status;
                      bool expected_status;
                      for (i = 0; i < 14; i++) {
                          if (i == 13) {
                              expected_status = false;
                          } else {
              
                              if (apdu_len < len_segment[i]) {
                                  expected_status = false;
                              } else {
                                  expected_status = true;
                              }
                          }
                          status =
                              bacapp_decode_application_data_safe(i == 0 ? apdu : NULL,
                              apdu_len, &value);
              
                          ct_test(pTest, status == expected_status);
                          if (status) {
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 29  

                              ct_test(pTest, value.tag == i);
                              ct_test(pTest, bacapp_same_value(&input_value[i], &value));
                              ct_test(pTest, !value.context_specific);
                              ct_test(pTest, value.next == NULL);
                          } else {
                              break;
                          }
                      }
                  }
              }
              
              
              void testBACnetApplicationDataLength(
                  Test * pTest)
              {
                  int apdu_len = 0;   /* total length of the apdu, return value */
                  int len = 0;        /* total length of the apdu, return value */
                  int test_len = 0;   /* length of the data */
                  uint8_t apdu[480] = { 0 };
                  BACNET_TIME local_time;
                  BACNET_DATE local_date;
              
                  /* create some constructed data */
                  /* 1. zero elements */
                  test_len = 0;
                  apdu_len = 0;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  /* verify the length of the data inside the opening/closing tags */
                  len =
                      bacapp_data_len(&apdu[0], apdu_len,
                      PROP_LIST_OF_OBJECT_PROPERTY_REFERENCES);
                  ct_test(pTest, test_len == len);
              
                  /* 2. application tagged data, one element */
                  test_len = 0;
                  apdu_len = 0;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  len = encode_application_unsigned(&apdu[apdu_len], 4194303);
                  test_len += len;
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  /* verify the length of the data inside the opening/closing tags */
                  len = bacapp_data_len(&apdu[0], apdu_len, PROP_OBJECT_IDENTIFIER);
                  ct_test(pTest, test_len == len);
              
                  /* 3. application tagged data, multiple elements */
                  test_len = 0;
                  apdu_len = 0;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_unsigned(&apdu[apdu_len], 1);
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 30  

                  test_len += len;
                  apdu_len += len;
                  len = encode_application_unsigned(&apdu[apdu_len], 42);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_unsigned(&apdu[apdu_len], 91);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_application_null(&apdu[apdu_len]);
                  test_len += len;
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  /* verify the length of the data inside the opening/closing tags */
                  len = bacapp_data_len(&apdu[0], apdu_len, PROP_PRIORITY_ARRAY);
                  ct_test(pTest, test_len == len);
              
                  /* 4. complex datatype - one element */
                  test_len = 0;
                  apdu_len = 0;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  test_len += len;
                  apdu_len += len;
                  local_date.year = 2006;     /* AD */
                  local_date.month = 4;       /* 1=Jan */
                  local_date.day = 1; /* 1..31 */
                  local_date.wday = 6;        /* 1=Monday */
                  len = encode_application_date(&apdu[apdu_len], &local_date);
                  test_len += len;
                  apdu_len += len;
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 31  

                  local_time.hour = 7;
                  local_time.min = 0;
                  local_time.sec = 3;
                  local_time.hundredths = 1;
                  len = encode_application_time(&apdu[apdu_len], &local_time);
                  test_len += len;
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  test_len += len;
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  /* verify the length of the data inside the opening/closing tags */
                  len = bacapp_data_len(&apdu[0], apdu_len, PROP_START_TIME);
                  ct_test(pTest, test_len == len);
              
                  /* 5. complex datatype - multiple elements */
              
              
              
                  /* 6. context tagged data, one element */
                  test_len = 0;
                  apdu_len = 0;
                  len = encode_opening_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  len = encode_context_unsigned(&apdu[apdu_len], 1, 91);
                  test_len += len;
                  apdu_len += len;
                  len = encode_closing_tag(&apdu[apdu_len], 3);
                  apdu_len += len;
                  /* verify the length of the data inside the opening/closing tags */
                  len = bacapp_data_len(&apdu[0], apdu_len, PROP_REQUESTED_SHED_LEVEL);
                  ct_test(pTest, test_len == len);
              }
              
              static bool testBACnetApplicationDataValue(
                  BACNET_APPLICATION_DATA_VALUE * value)
              {
                  uint8_t apdu[480] = { 0 };
                  int len = 0;
                  int apdu_len = 0;
                  BACNET_APPLICATION_DATA_VALUE test_value;
              
                  apdu_len = bacapp_encode_application_data(&apdu[0], value);
                  len = bacapp_decode_application_data(&apdu[0], apdu_len, &test_value);
              
                  return bacapp_same_value(value, &test_value);
              }
              
              void testBACnetApplicationData(
                  Test * pTest)
              {
                  BACNET_APPLICATION_DATA_VALUE value;
                  bool status = false;
              
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_NULL, NULL,
                      &value);
                  ct_test(pTest, status == true);
                  status = testBACnetApplicationDataValue(&value);
                  ct_test(pTest, status == true);
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 32  

              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_BOOLEAN, "1",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Boolean == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_BOOLEAN, "0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Boolean == false);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_UNSIGNED_INT, "0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Unsigned_Int == 0);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_UNSIGNED_INT,
                      "0xFFFF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Unsigned_Int == 0xFFFF);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_UNSIGNED_INT,
                      "0xFFFFFFFF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Unsigned_Int == 0xFFFFFFFF);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_SIGNED_INT, "0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Signed_Int == 0);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_SIGNED_INT, "-1",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Signed_Int == -1);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_SIGNED_INT,
                      "32768", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Signed_Int == 32768);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_SIGNED_INT,
                      "-32768", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Signed_Int == -32768);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_REAL, "0.0",
                      &value);
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 33  

                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_REAL, "-1.0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_REAL, "1.0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_REAL, "3.14159",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_REAL, "-3.14159",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_ENUMERATED, "0",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Enumerated == 0);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_ENUMERATED,
                      "0xFFFF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Enumerated == 0xFFFF);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_ENUMERATED,
                      "0xFFFFFFFF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Enumerated == 0xFFFFFFFF);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_DATE,
                      "2005/5/22:1", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Date.year == 2005);
                  ct_test(pTest, value.type.Date.month == 5);
                  ct_test(pTest, value.type.Date.day == 22);
                  ct_test(pTest, value.type.Date.wday == 1);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  /* Happy Valentines Day! */
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_DATE, "2007/2/14",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Date.year == 2007);
                  ct_test(pTest, value.type.Date.month == 2);
                  ct_test(pTest, value.type.Date.day == 14);
                  ct_test(pTest, value.type.Date.wday == BACNET_WEEKDAY_WEDNESDAY);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 34  

              
                  /* Wildcard Values */
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_DATE,
                      "2155/255/255:255", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Date.year == 2155);
                  ct_test(pTest, value.type.Date.month == 255);
                  ct_test(pTest, value.type.Date.day == 255);
                  ct_test(pTest, value.type.Date.wday == 255);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_TIME,
                      "23:59:59.12", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Time.hour == 23);
                  ct_test(pTest, value.type.Time.min == 59);
                  ct_test(pTest, value.type.Time.sec == 59);
                  ct_test(pTest, value.type.Time.hundredths == 12);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_TIME, "23:59:59",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Time.hour == 23);
                  ct_test(pTest, value.type.Time.min == 59);
                  ct_test(pTest, value.type.Time.sec == 59);
                  ct_test(pTest, value.type.Time.hundredths == 0);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_TIME, "23:59",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Time.hour == 23);
                  ct_test(pTest, value.type.Time.min == 59);
                  ct_test(pTest, value.type.Time.sec == 0);
                  ct_test(pTest, value.type.Time.hundredths == 0);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  /* Wildcard Values */
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_TIME,
                      "255:255:255.255", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Time.hour == 255);
                  ct_test(pTest, value.type.Time.min == 255);
                  ct_test(pTest, value.type.Time.sec == 255);
                  ct_test(pTest, value.type.Time.hundredths == 255);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_OBJECT_ID,
                      "0:100", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, value.type.Object_Id.type == 0);
                  ct_test(pTest, value.type.Object_Id.instance == 100);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 35  

                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_CHARACTER_STRING,
                      "Karg!", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  /* test empty string */
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_CHARACTER_STRING,
                      "", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_OCTET_STRING,
                      "1234567890ABCDEF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_OCTET_STRING,
                      "12-34-56-78-90-AB-CD-EF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_OCTET_STRING,
                      "12 34 56 78 90 AB CD EF", &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
                  /* test empty string */
                  status =
                      bacapp_parse_application_data(BACNET_APPLICATION_TAG_OCTET_STRING, "",
                      &value);
                  ct_test(pTest, status == true);
                  ct_test(pTest, testBACnetApplicationDataValue(&value));
              
                  return;
              }
              
              
              #ifdef TEST_BACNET_APPLICATION_DATA
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACnet Application Data", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testBACnetApplicationData);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetApplicationDataLength);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetApplicationData_Safe);
                  assert(rc);
              
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_BACNET_APPLICATION_DATA */
              #endif /* TEST */
C51 COMPILER V9.06   BACAPP                                                                03/13/2013 09:32:37 PAGE 36  



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6878    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11     185
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
