C51 COMPILER V9.06   HEAP_1                                                                03/13/2013 09:32:28 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE HEAP_1
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\portable\MemMang\heap_1.c LARGE OMF2 ROM(D16M)
                    - BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..
                    -\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i
                    -2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource
                    -\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\h
                    -eap_1.lst) SRC(.\heap_1.SRC)

line level    source

   1          /*
   2                  FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
   3          
   4                  This file is part of the FreeRTOS distribution.
   5          
   6                  FreeRTOS is free software; you can redistribute it and/or modify
   7                  it under the terms of the GNU General Public License as published by
   8                  the Free Software Foundation; either version 2 of the License, or
   9                  (at your option) any later version.
  10          
  11                  FreeRTOS is distributed in the hope that it will be useful,
  12                  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14                  GNU General Public License for more details.
  15          
  16                  You should have received a copy of the GNU General Public License
  17                  along with FreeRTOS; if not, write to the Free Software
  18                  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  19          
  20                  A special exception to the GPL can be applied should you wish to distribute
  21                  a combined work that includes FreeRTOS, without being obliged to provide
  22                  the source code for any proprietary components.  See the licensing section 
  23                  of http://www.FreeRTOS.org for full details of how and when the exception
  24                  can be applied.
  25          
  26                  ***************************************************************************
  27                  See http://www.FreeRTOS.org for documentation, latest information, license 
  28                  and contact details.  Please ensure to read the configuration and relevant 
  29                  port sections of the online documentation.
  30                  ***************************************************************************
  31          */
  32          
  33          /* 
  34          
  35          Changes between V2.5.1 and V2.5.1
  36          
  37                  + The memory pool has been defined within a struct to ensure correct memory
  38                    alignment on 32bit systems.
  39          */
  40          
  41          
  42          /*
  43           * The simplest possible implementation of pvPortMalloc().  Note that this
  44           * implementation does NOT allow allocated memory to be freed again.
  45           *
  46           * See heap_2.c and heap_3.c for alternative implementations, and the memory
  47           * management pages of http://www.FreeRTOS.org for more information.
  48           */
  49          #include <stdlib.h>
  50          #include "projdefs.h"
C51 COMPILER V9.06   HEAP_1                                                                03/13/2013 09:32:28 PAGE 2   

  51          #include "portable.h"
  52          #include "task.h"
  53          
  54          /* Setup the correct byte alignment mask for the defined byte alignment. */
  55          #if portBYTE_ALIGNMENT == 4
                      #define heapBYTE_ALIGNMENT_MASK ( ( unsigned portSHORT ) 0x0003 )
              #endif
  58          
  59          #if portBYTE_ALIGNMENT == 2
                      #define heapBYTE_ALIGNMENT_MASK ( ( unsigned portSHORT ) 0x0001 )
              #endif
  62          
  63          #if portBYTE_ALIGNMENT == 1 
  64                  #define heapBYTE_ALIGNMENT_MASK ( ( unsigned portSHORT ) 0x0000 )
  65          #endif
  66          
  67          #ifndef heapBYTE_ALIGNMENT_MASK
                      #error "Invalid portBYTE_ALIGNMENT definition"
              #endif
  70          
  71          /* Allocate the memory for the heap.  The struct is used to force byte
  72          alignment without using any non-portable code. */
  73          static struct xRTOS_HEAP
  74          {
  75                  unsigned portLONG ulDummy;
  76                  unsigned portCHAR ucHeap[ portTOTAL_HEAP_SIZE ];
  77          } xHeap;
  78          
  79          static unsigned portSHORT usNextFreeByte = ( unsigned portSHORT ) 0;
  80          /*-----------------------------------------------------------*/
  81          
  82          void *pvPortMalloc( unsigned portSHORT usWantedSize ) reentrant
  83          {
  84   1      void *pvReturn = NULL;
  85   1      
  86   1              /* Ensure that blocks are always aligned to the required number of bytes. */
  87   1              if( usWantedSize & heapBYTE_ALIGNMENT_MASK )
  88   1              {
  89   2                      /* Byte alignment required. */
  90   2                      usWantedSize += ( portBYTE_ALIGNMENT - ( usWantedSize & heapBYTE_ALIGNMENT_MASK ) );
  91   2              }
  92   1      
  93   1              vTaskSuspendAll();
  94   1              {
  95   2                      /* Check there is enough room left for the allocation. */
  96   2                      if( ( usNextFreeByte + usWantedSize ) < portTOTAL_HEAP_SIZE )
  97   2                      {
  98   3                              /* Return the next free byte then increment the index past this
  99   3                              block. */
 100   3                              pvReturn = &( xHeap.ucHeap[ usNextFreeByte ] );
 101   3                              usNextFreeByte += usWantedSize;                 
 102   3                      }       
 103   2              }
 104   1              cTaskResumeAll();
 105   1      
 106   1              return pvReturn;
 107   1      }
 108          /*-----------------------------------------------------------*/
 109          
 110          void vPortFree( void *pv ) reentrant
 111          {
 112   1              /* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
C51 COMPILER V9.06   HEAP_1                                                                03/13/2013 09:32:28 PAGE 3   

 113   1              for alternative implementations, and the memory management pages of 
 114   1              http://www.FreeRTOS.org for more information. */
 115   1              pv = pv;
 116   1      }
 117          /*-----------------------------------------------------------*/
 118          
 119          void vPortInitialiseBlocks( void ) reentrant
 120          {
 121   1              /* Only required when static memory is not cleared. */
 122   1              usNextFreeByte = ( unsigned portSHORT ) 0;
 123   1      }
 124          
 125          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    218    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =  15366    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
