C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE I2CAPI
OBJECT MODULE PLACED IN .\i2capi.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\i2c\i2capi.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) IN
                    -CDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\
                    -SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buf
                    -fer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\S
                    -rc\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\s
                    -rc\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\i2capi.lst) O
                    -BJECT(.\i2capi.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : i2capi.c
  13           * Purpose     : API functions invovle I2C driver functions.
  14           *               To transmit and to reveive packet by these functions.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-10
  17           * Notes       :
  18           * $Log: i2capi.c,v $
  19           * Revision 1.1  2006/04/07 11:38:34  robin6633
  20           * no message
  21           *
  22           *================================================================================
  23           */
  24          
  25          /* INCLUDE FILE DECLARATIONS */
  26          #include        <stdio.h>
  27          #include        "reg80390.h"
  28          #include        "types.h"
  29          #include        "buffer.h"
  30          #include        "i2c.h"
  31          #include        "i2capi.h"
  32          
  33          
  34          /* STATIC VARIABLE DECLARATIONS */
  35          
  36          
  37          /* LOCAL SUBPROGRAM DECLARATIONS */
  38          
  39          
  40          /* LOCAL SUBPROGRAM BODIES */
  41          
  42          
  43          /* EXPORTED SUBPROGRAM BODIES */
  44          
  45          /*
  46           *--------------------------------------------------------------------------------
  47           * BOOL I2C_ByteWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T byteData, U8_T endCond)
  48           * Purpose : i2c master send a packet for write one data to a device
  49           * Params  : addrOfDev : id address of a device
C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 2   

  50           *           addrOfMem : address for accessing in a device
  51           *           byteData  : data for writing
  52           *           endCond   : packet condition after transmitting
  53           * Returns : TRUE : this accessing is successful
  54           *           FALSE: this accessing is failed
  55           * Note    :
  56           *--------------------------------------------------------------------------------
  57           */
  58          BOOL I2C_ByteWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T byteData, U8_T endCond)
  59          {
  60   1              I2C_BUF         *ptTxPkt = NULL;
  61   1              U8_T            addrMode = 0;
  62   1      
  63   1              /* Get buffer of this packet */
  64   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
  65   1              /* The end condition after transfer complete */
  66   1              ptTxPkt->I2cEnd = endCond;
  67   1              /* Indicate the packet's direction to master transmit */
  68   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
  69   1              /* Data length exclude device address */
  70   1              ptTxPkt->DataLen = 0x02;
  71   1      
  72   1              /* Device Address with 10-bit or 7-bit */
  73   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
  74   1              if (addrMode & I2C_10BIT)
  75   1              {
  76   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
  77   2              }
  78   1              else
  79   1              {
  80   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
  81   2              }
  82   1              /* Register word Address */
  83   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
  84   1              /* Access Data */
  85   1              ptTxPkt->I2cData[1] = byteData;
  86   1      
  87   1              /* To send packet and i2c bus will be busy for this transfer */
  88   1              I2C_FlagEnb(I2C_BUSY);
  89   1              I2C_PktBuf(ptTxPkt);
  90   1              /* Waiting for transfer completely */
  91   1              while (I2C_FlagChk(I2C_BUSY)) {}
  92   1              /* If the packet does not have any ACK echoed, this transfer fail */
  93   1              if (I2C_FlagChk(I2C_NACK))
  94   1              {
  95   2                      I2C_FlagClr(I2C_NACK);
  96   2                      return FALSE;
  97   2              }
  98   1      
  99   1              return TRUE;
 100   1      }
 101          
 102          /*
 103           *--------------------------------------------------------------------------------
 104           * BOOL I2C_PageWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T*ptPageData, U16_T writeLen, U8_T endCond)
 105           * Purpose : i2c master send a packet for writing more data to a device
 106           * Params  : addrOfDev : id address of a device
 107           *           addrOfMem : address for accessing in a device
 108           *           ptPageData: data string for writing
 109           *           writeLen  : data length for transmitting include addrOfMem and data string
 110           *           endCond   : packet condition after transmitting
 111           * Returns : TRUE : this accessing is successful
C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 3   

 112           *           FALSE: this accessing is failed
 113           * Note    :
 114           *--------------------------------------------------------------------------------
 115           */
 116          BOOL I2C_PageWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T *ptPageData, U16_T writeLen, U8_T endCond)
 117          {
 118   1              
 119   1              I2C_BUF XDATA   *ptTxPkt = NULL;
 120   1              U16_T                   i;
 121   1              U8_T XDATA              addrMode = 0;
 122   1              
 123   1              /* Get buffer of this packet */
 124   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
 125   1              /* The end condition after transfer complete */
 126   1              ptTxPkt->I2cEnd = endCond;
 127   1              /* Indicate the packet's direction to master transmit */
 128   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
 129   1              /* Data length exclude device address */
 130   1              ptTxPkt->DataLen = writeLen + 1;
 131   1              /* Device Address with 10-bit or 7-bit */
 132   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 133   1              if (addrMode & I2C_10BIT)
 134   1              {
 135   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 136   2              }
 137   1              else
 138   1              {
 139   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 140   2              }
 141   1              /* Register word Address */
 142   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
 143   1              /* Access Data */
 144   1              for (i = 0 ; i < writeLen ; i ++)
 145   1              {
 146   2                      ptTxPkt->I2cData[i + 1] = *(ptPageData + i);
 147   2              }
 148   1              /* To send packet and i2c bus will be busy for this transfer */
 149   1              I2C_FlagEnb(I2C_BUSY);
 150   1              I2C_PktBuf(ptTxPkt);
 151   1              /* Waiting for transfer completely */
 152   1              while (I2C_FlagChk(I2C_BUSY)) {}
 153   1              /* If the packet does not have any ACK echoed, this transfer fail */
 154   1              if (I2C_FlagChk(I2C_NACK))
 155   1              {
 156   2                      I2C_FlagClr(I2C_NACK);
 157   2                      return FALSE;
 158   2              }
 159   1      
 160   1              return TRUE;
 161   1      }
 162          
 163          /*
 164           *--------------------------------------------------------------------------------
 165           * BOOL I2C_RdmRead(U16_T addrOfDev, U16_T addrOfMem ,I2C_BUF *ptPktTemp, U16_T readLen, U8_T endCond)
 166           * Purpose : i2c master send a packet for reading data from a device
 167           * Params  : addrOfDev : id address of a device
 168           *           addrOfMem : address for accessing in a device
 169           *           ptPktTemp : read data buffer pointer
 170           *           readLen   : data length for reading
 171           *           endCond   : packet condition after transfer
 172           * Returns : TRUE : this accessing is successful
 173           *           FALSE: this accessing is failed
C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 4   

 174           * Note    :
 175           *--------------------------------------------------------------------------------
 176           */
 177          BOOL I2C_RdmRead(U16_T addrOfDev, U16_T addrOfMem ,I2C_BUF *ptPktTemp, U16_T readLen, U8_T endCond)
 178          {
 179   1              I2C_BUF         *ptRxPkt = NULL;
 180   1              U16_T           i;
 181   1              U8_T            addrMode = 0;
 182   1      
 183   1              /* Get buffer of this packet */
 184   1              ptRxPkt = (I2C_BUF *)GetPktBuf();
 185   1              /* The end condition after transfer complete */
 186   1              ptRxPkt->I2cEnd = I2C_STOP_COND;
 187   1              /* Indicate the packet's direction to master receive */
 188   1              ptRxPkt->I2cDir = I2C_MST_RCVR;
 189   1              /* Data length exclude device address */
 190   1              ptRxPkt->DataLen = readLen;
 191   1              /* Device Address with 10-bit or 7-bit */
 192   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 193   1              if (addrMode & I2C_10BIT)
 194   1              {
 195   2                      ptRxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 196   2              }
 197   1              else
 198   1              {
 199   2                      ptRxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 200   2              }
 201   1              /* Send a dummy packet to indicate the internal address of devices */
 202   1              if (endCond & I2C_STOP_COND)
 203   1              {
 204   2                      if (I2C_DummyWrite(addrOfDev, addrOfMem, I2C_STOP_COND))
 205   2                      {
 206   3                              /* To send packet and i2c bus will be busy for this transfer */
 207   3                              I2C_FlagEnb(I2C_BUSY);
 208   3                              I2C_PktBuf(ptRxPkt);
 209   3                              /* Waiting for transfer completely */
 210   3                              while (I2C_FlagChk(I2C_BUSY)) {}
 211   3                              /* If the packet does not have any ACK echoed, this transfer fail */
 212   3                              if (I2C_FlagChk(I2C_NACK))
 213   3                              {
 214   4                                      I2C_FlagClr(I2C_NACK);
 215   4                                      return FALSE;
 216   4                              }
 217   3                              /* Get data received in this transfer */
 218   3                              for (i=0 ; i<=readLen ; i++)
 219   3                              {
 220   4                                      ptPktTemp->I2cData[i] = ptRxPkt->I2cData[i+1];
 221   4                              }
 222   3                              return TRUE;
 223   3                      }
 224   2                      else
 225   2                              return FALSE;
 226   2              }
 227   1              else
 228   1              {
 229   2                      if (I2C_DummyWrite(addrOfDev, addrOfMem, endCond))
 230   2                      {
 231   3                              /* To check the packet has a restart condition for next access */
 232   3                              while (!I2C_FlagChk(I2C_RESTART)) {}
 233   3                              /* To send packet and i2c bus will be busy for this transfer */
 234   3                              I2C_FlagClr(I2C_RESTART);
 235   3                              I2C_FlagEnb(I2C_BUSY);
C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 5   

 236   3                              I2C_PktBuf(ptRxPkt);
 237   3                              /* Waiting for transfer completely */
 238   3                              while (I2C_FlagChk(I2C_BUSY)) {}
 239   3                              /* If the packet does not have any ACK echoed, this transfer fail */
 240   3                              if (I2C_FlagChk(I2C_NACK))
 241   3                              {
 242   4                                      I2C_FlagClr(I2C_NACK);
 243   4                                      return FALSE;
 244   4                              }
 245   3                              /* Get data received in this transfer */
 246   3                              for (i=0 ; i<=readLen ; i++)
 247   3                              {
 248   4                                      ptPktTemp->I2cData[i] = ptRxPkt->I2cData[i];
 249   4                              }
 250   3                              return TRUE;
 251   3                      }
 252   2                      else
 253   2                              return FALSE;
 254   2              }
 255   1      }
 256          
 257          /*
 258           *--------------------------------------------------------------------------------
 259           * BOOL I2C_DummyWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T endCond)
 260           * Purpose : i2c master send a dummy packet for accessing a device
 261           * Params  : addrOfDev : id address of a device
 262           *           addrOfMem : address for accessing in a device
 263           *           endCond   : packet condition after transmitting
 264           * Returns : TRUE : this accessing is successful
 265           *           FALSE: this accessing is failed
 266           * Note    : this function only transmit the address of accessing,
 267           *           it does not have any data
 268           *--------------------------------------------------------------------------------
 269           */
 270          BOOL I2C_DummyWrite(U16_T addrOfDev, U16_T addrOfMem, U8_T endCond)
 271          {
 272   1              I2C_BUF         *ptTxPkt = NULL;
 273   1              U8_T            addrMode = 0;
 274   1      
 275   1              /* Get buffer of this packet */
 276   1              ptTxPkt = (I2C_BUF *)GetPktBuf();
 277   1              /* The end condition after transfer complete */
 278   1              ptTxPkt->I2cEnd = endCond;
 279   1              /* Indicate the packet's direction to master transmit */
 280   1              ptTxPkt->I2cDir = I2C_MST_XMIT;
 281   1              /* Data length exclude device address */
 282   1              ptTxPkt->DataLen = 0x01;
 283   1              /* Device Address with 10-bit or 7-bit */
 284   1              I2C_Cmd(SI_RD, I2CCTL, &addrMode);
 285   1              if (addrMode & I2C_10BIT)
 286   1              {
 287   2                      ptTxPkt->I2cAddr.TenBitAddr = (U16_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 288   2              }
 289   1              else
 290   1              {
 291   2                      ptTxPkt->I2cAddr.SevenBitAddr = (U8_T)(addrOfDev | ((addrOfMem & 0x0700) >> 8));
 292   2              }
 293   1              /* Register word Address */
 294   1              ptTxPkt->I2cData[0] = (U8_T)(addrOfMem & 0x00FF);
 295   1              /* No Access Data */
 296   1              /* To send packet and i2c bus will be busy for this transfer */
 297   1              I2C_FlagEnb(I2C_BUSY);
C51 COMPILER V9.06   I2CAPI                                                                05/28/2013 10:15:30 PAGE 6   

 298   1              I2C_FlagClr(I2C_RESTART);
 299   1              I2C_PktBuf(ptTxPkt);
 300   1              /* Waiting for transfer completely */
 301   1              while (I2C_FlagChk(I2C_BUSY)) {}
 302   1              /* If the packet does not have any ACK echoed, this transfer fail */
 303   1              if (I2C_FlagChk(I2C_NACK))
 304   1              {
 305   2                      I2C_FlagClr(I2C_NACK);
 306   2                      return FALSE;
 307   2              }
 308   1      
 309   1              return TRUE;
 310   1      }
 311          
 312          
 313          /* End of i2capi.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1643    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      50
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
