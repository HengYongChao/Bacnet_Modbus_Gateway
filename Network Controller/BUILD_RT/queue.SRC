; .\queue.SRC generated from: ..\src\FreeRtossource\queue.c
; COMPILER INVOKED BY:
;        d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\queue.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\queue.lst) SRC(.\queue.SRC)

$MOD_CONT
$NOMOD51

NAME	QUEUE

TB08	BIT	098H.3
TB18	BIT	0C0H.3
P0	DATA	080H
SM00	BIT	098H.7
P1	DATA	090H
SM10	BIT	0C0H.7
SM01	BIT	098H.6
P2	DATA	0A0H
SM11	BIT	0C0H.6
SM02	BIT	098H.5
P3	DATA	0B0H
AC	BIT	0D0H.6
SM12	BIT	0C0H.5
T0	BIT	0B0H.4
SPIDR	DATA	0CFH
T1	BIT	0B0H.5
EA	BIT	0A8H.7
OWCIR	DATA	0D6H
CH	DATA	0C5H
DPH0	DATA	083H
IE	DATA	0A8H
DPH1	DATA	085H
CL	DATA	0C4H
P0_0	BIT	080H.0
P1_0	BIT	090H.0
P0_1	BIT	080H.1
CCAPH0	DATA	0B9H
DPL0	DATA	082H
P2_0	BIT	0A0H.0
P1_1	BIT	090H.1
P0_2	BIT	080H.2
CCAPH1	DATA	0BAH
DPL1	DATA	084H
P3_0	BIT	0B0H.0
P2_1	BIT	0A0H.1
P1_2	BIT	090H.2
P0_3	BIT	080H.3
UR2_DLH	DATA	0E2H
CCAPH2	DATA	0BBH
XMRHR	DATA	0A7H
P3_1	BIT	0B0H.1
P2_2	BIT	0A0H.2
P1_3	BIT	090H.3
P0_4	BIT	080H.4
CCAPH3	DATA	0BCH
P3_2	BIT	0B0H.2
P2_3	BIT	0A0H.3
P1_4	BIT	090H.4
P0_5	BIT	080H.5
TA	DATA	0EBH
CCAPH4	DATA	0BDH
CCAPL0	DATA	0B1H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P3_3	BIT	0B0H.3
P2_4	BIT	0A0H.4
REN0	BIT	098H.4
P1_5	BIT	090H.5
P0_6	BIT	080H.6
UR2_FCR	DATA	0E3H
CCAPM0	DATA	0D1H
T2IF	DATA	0C9H
CCAPL1	DATA	0B2H
REN1	BIT	0C0H.4
P3_4	BIT	0B0H.4
P2_5	BIT	0A0H.5
P1_6	BIT	090H.6
P0_7	BIT	080H.7
UR2_DLL	DATA	0E1H
CCAPM1	DATA	0D2H
CCAPL2	DATA	0B3H
XMRLR	DATA	0A6H
P3_5	BIT	0B0H.5
P2_6	BIT	0A0H.6
P1_7	BIT	090H.7
CCAPM2	DATA	0D3H
CCAPL3	DATA	0B4H
XMWHR	DATA	0A5H
P3_6	BIT	0B0H.6
P2_7	BIT	0A0H.7
CCAPM3	DATA	0D4H
IP	DATA	0B8H
CCAPL4	DATA	0B5H
P3_7	BIT	0B0H.7
CCAPM4	DATA	0D5H
DBAR	DATA	09AH
UR2_IER	DATA	0E2H
CY	BIT	0D0H.7
INT0	BIT	0B0H.2
UR2_LCR	DATA	0E4H
XMWLR	DATA	0A4H
INT1	BIT	0B0H.3
UR2_MCR	DATA	0E5H
DPX0	DATA	093H
I2CCIR	DATA	096H
DPX1	DATA	095H
UR2_IIR	DATA	0E3H
UR2_RBR	DATA	0E1H
ACON	DATA	09DH
DCIR	DATA	09BH
SP	DATA	081H
CCON	DATA	0C3H
CMOD	DATA	0C2H
OV	BIT	0D0H.2
WR	BIT	0B0H.6
UR2_THR	DATA	0E1H
EWDI	BIT	0E8H.5
WDIF	BIT	0D8H.3
RLDH	DATA	0CBH
EPCR	DATA	0BEH
LDHR	DATA	0AAH
UR2_LSR	DATA	0E6H
EPDR	DATA	0BFH
MCIR	DATA	0B6H
RCLK	BIT	0C8H.5
UR2_MSR	DATA	0E7H
TCLK	BIT	0C8H.4
RLDL	DATA	0CAH
LDLR	DATA	0A9H
PCON	DATA	087H
CANCIR	DATA	0DEH
TCIR	DATA	0AEH
PWDI	BIT	0F8H.5
LSCR	DATA	0A2H
TMOD	DATA	089H
TCON	DATA	088H
OWDR	DATA	0D7H
IE0	BIT	088H.1
IE1	BIT	088H.3
MXAX	DATA	0EAH
LMSR	DATA	0A1H
MD0	DATA	0F9H
B	DATA	0F0H
MD1	DATA	0FAH
LSAIER	DATA	0A1H
MD2	DATA	0FBH
WTRF	BIT	0D8H.2
MD3	DATA	0FCH
PISSR1	DATA	09EH
MD4	DATA	0FDH
LSSR	DATA	0A3H
PISSR2	DATA	09FH
MD5	DATA	0FEH
ACC	DATA	0E0H
ES0	BIT	0A8H.4
CT2	BIT	0C8H.1
ES1	BIT	0A8H.6
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RI1	BIT	0C0H.0
SPICIR	DATA	0CEH
TH0	DATA	08CH
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
TH1	DATA	08DH
TI1	BIT	0C0H.1
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
TL0	DATA	08AH
CSREPR	DATA	08FH
TL1	DATA	08BH
TL2	DATA	0CCH
PS0	BIT	0B8H.4
EIE	DATA	0E8H
WTST	DATA	092H
PS1	BIT	0B8H.6
PT0	BIT	0B8H.1
EIF	DATA	091H
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
I2CDR	DATA	097H
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DDR	DATA	09CH
DPH	DATA	083H
EIP	DATA	0F8H
DPL	DATA	082H
LCR	DATA	0A2H
SBUF0	DATA	099H
SBUF1	DATA	0C1H
EINT2	BIT	0E8H.0
EXEN2	BIT	0C8H.3
MDR	DATA	0B7H
EINT3	BIT	0E8H.1
CPRL2	BIT	0C8H.0
SCON0	DATA	098H
EINT4	BIT	0E8H.2
SCON1	DATA	0C0H
SDSTSR	DATA	094H
EINT5	BIT	0E8H.3
STATUS	DATA	0E9H
EINT6	BIT	0E8H.4
T2CON	DATA	0C8H
DPS	DATA	086H
CANDR	DATA	0DFH
TDR	DATA	0AFH
LDAHR	DATA	0A5H
DPX	DATA	093H
DMAHR	DATA	0ADH
PINT2	BIT	0F8H.0
RXD	BIT	0B0H.0
PINT3	BIT	0F8H.1
CKCON	DATA	08EH
PINT4	BIT	0F8H.2
EWT	BIT	0D8H.1
TXD	BIT	0B0H.1
LDALR	DATA	0A4H
PINT5	BIT	0F8H.3
DMALR	DATA	0ABH
LSR	DATA	0A3H
PINT6	BIT	0F8H.4
DMAMR	DATA	0ACH
ARCON	DATA	0FFH
F0	BIT	0D0H.5
F1	BIT	0D0H.1
LDCSR	DATA	0A6H
PSW	DATA	0D0H
RB08	BIT	098H.2
WDCON	DATA	0D8H
RWT	BIT	0D8H.0
RB18	BIT	0C0H.2
?PR?_?xQueueCreate?QUEUE                 SEGMENT ECODE INSEG 
?PR?_?cQueueSend?QUEUE                   SEGMENT ECODE INSEG 
?PR?_?cQueueSendFromISR?QUEUE            SEGMENT ECODE INSEG 
?PR?_?cQueueReceive?QUEUE                SEGMENT ECODE INSEG 
?PR?_?cQueueReceiveFromISR?QUEUE         SEGMENT ECODE INSEG 
?PR?_?ucQueueMessagesWaiting?QUEUE       SEGMENT ECODE INSEG 
?PR?_?vQueueDelete?QUEUE                 SEGMENT ECODE INSEG 
?PR?_?prvLockQueue?QUEUE                 SEGMENT ECODE INSEG 
?PR?_?prvUnlockQueue?QUEUE               SEGMENT ECODE INSEG 
?PR?_?prvIsQueueEmpty?QUEUE              SEGMENT ECODE INSEG 
?PR?_?prvIsQueueFull?QUEUE               SEGMENT ECODE INSEG 
	EXTRN	CODE (_?cTaskResumeAll)
	EXTRN	CODE (_?vTaskSuspendAll)
	EXTRN	CODE (_?vPortYield)
	EXTRN	CODE (_?vPortFree)
	EXTRN	CODE (_?cTaskRemoveFromEventList)
	EXTRN	CODE (_?vListInitialise)
	EXTRN	CODE (_?vTaskPlaceOnEventList)
	EXTRN	CODE (_?pvPortMalloc)
	EXTRN	CODE (?C?ADDXBP)
	EXTRN	CODE (?C?XBPOFF)
	EXTRN	DATA (?C_XBP)
	EXTRN	NUMBER (?C?XDATASEG)
	EXTRN	CODE (?C?PSTPTR)
	EXTRN	CODE (?C?PLDPTR)
	EXTRN	CODE (?C?CSTPTR)
	EXTRN	CODE (?C?IMUL)
	EXTRN	CODE (?C?ULCMP)
	EXTRN	CODE (?C?CLDPTR)
	EXTRN	CODE (?C?COPY)
	EXTRN	CODE (?C?CILDPTR)
	EXTRN	CODE (?C?IILDPTR)
	EXTRN	CODE (?C?ILDPTR)
	PUBLIC	_?vQueueDelete
	PUBLIC	_?ucQueueMessagesWaiting
	PUBLIC	_?cQueueReceiveFromISR
	PUBLIC	_?cQueueReceive
	PUBLIC	_?cQueueSendFromISR
	PUBLIC	_?cQueueSend
	PUBLIC	_?xQueueCreate
; /*
; 	FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
; 
; 	This file is part of the FreeRTOS distribution.
; 
; 	FreeRTOS is free software; you can redistribute it and/or modify
; 	it under the terms of the GNU General Public License as published by
; 	the Free Software Foundation; either version 2 of the License, or
; 	(at your option) any later version.
; 
; 	FreeRTOS is distributed in the hope that it will be useful,
; 	but WITHOUT ANY WARRANTY; without even the implied warranty of
; 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; 	GNU General Public License for more details.
; 
; 	You should have received a copy of the GNU General Public License
; 	along with FreeRTOS; if not, write to the Free Software
; 	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
; 
; 	A special exception to the GPL can be applied should you wish to distribute
; 	a combined work that includes FreeRTOS, without being obliged to provide
; 	the source code for any proprietary components.  See the licensing section 
; 	of http://www.FreeRTOS.org for full details of how and when the exception
; 	can be applied.
; 
; 	***************************************************************************
; 	See http://www.FreeRTOS.org for documentation, latest information, license 
; 	and contact details.  Please ensure to read the configuration and relevant 
; 	port sections of the online documentation.
; 	***************************************************************************
; */
; 
; /*
; Changes from V1.01
; 
; 	+ More use of 8bit data types.
; 	+ Function name prefixes changed where the data type returned has changed.
; 
; Changed from V2.0.0
; 
; 	+ Added the queue locking mechanism and make more use of the scheduler
; 	  suspension feature to minimise the time interrupts have to be disabled
; 	  when accessing a queue.
; 
; Changed from V2.2.0
; 
; 	+ Explicit use of 'signed' qualifier on portCHAR types added.
; */
; 
; #include <stdlib.h>
; #include <string.h>
; #include "projdefs.h"
; #include "portable.h"
; #include "errors.h"
; #include "task.h"
; #include "list.h"
; 
; /*-----------------------------------------------------------
;  * PUBLIC LIST API documented in list.h
;  *----------------------------------------------------------*/
; 
; /* Constants used with the cRxLock and cTxLock structure members. */
; #define queueUNLOCKED	( ( signed portCHAR ) -1 )
; 
; /*
;  * Definition of the queue used by the scheduler.
;  * Items are queued by copy, not reference.
;  */
; typedef struct QueueDefinition
; {
; 	signed portCHAR *pcHead;				/*< Points to the beginning of the queue storage area. */
; 	signed portCHAR *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
; 
; 	signed portCHAR *pcWriteTo;				/*< Points to the free next place in the storage area. */
; 	signed portCHAR *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
; 
; 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
; 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
; 
; 	unsigned portCHAR ucMessagesWaiting;	/*< The number of items currently in the queue. */
; 	unsigned portCHAR ucLength;				/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
; 	unsigned portCHAR ucItemSize;			/*< The size of each items that the queue will hold. */
; 
; 	signed portCHAR cRxLock;				/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
; 	signed portCHAR cTxLock;				/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
; } xQUEUE;
; /*-----------------------------------------------------------*/
; 
; /*
;  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
;  * To keep the definition private the API header file defines it as a
;  * pointer to void. 
;  */
; typedef xQUEUE * xQueueHandle;
; 
; /*
;  * Prototypes for public functions are included here so we don't have to
;  * include the API header file (as it defines xQueueHandle differently).  These
;  * functions are documented in the API header file. 
;  */
; xQueueHandle xQueueCreate( unsigned portCHAR ucQueueLength, unsigned portCHAR ucItemSize ) reentrant;
; signed portCHAR cQueueSend( xQueueHandle xQueue, const void * pvItemToQueue, portTickType xTicksToWait ) reentrant;
; unsigned portCHAR ucQueueMessagesWaiting( xQueueHandle pxQueue ) reentrant;
; void vQueueDelete( xQueueHandle xQueue ) reentrant;
; signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTaskPreviouslyWoken ) reentrant;
; signed portCHAR cQueueReceive( xQueueHandle pxQueue, void *pcBuffer, portTickType xTicksToWait ) reentrant;
; signed portCHAR cQueueReceiveFromISR( xQueueHandle pxQueue, void *pcBuffer, signed portCHAR *pcTaskWoken ) reentrant;
; 
; #ifdef KEIL_AX11000
; /*
;  * Mark a queue as locked.  Locking a queue prevents an ISR from 
;  * accessing the queue event lists. 
;  */
; static void prvLockQueue( xQueueHandle pxQueue ) reentrant;
; #endif
; 
; /* 
;  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not 
;  * prevent an ISR from adding or removing items to the queue, but does prevent 
;  * an ISR from removing tasks from the queue event lists.  If an ISR finds a 
;  * queue is locked it will instead increment the appropriate queue lock count 
;  * to indicate that a task may require unblocking.  When the queue in unlocked
;  * these lock counts are inspected, and the appropriate action taken.
;  */
; static signed portCHAR prvUnlockQueue( xQueueHandle pxQueue ) reentrant;
; 
; /*
;  * Uses a critical section to determine if there is any data in a queue.
;  *
;  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
;  */
; static signed portCHAR prvIsQueueEmpty( const xQueueHandle pxQueue ) reentrant;
; 
; /*
;  * Uses a critical section to determine if there is any space in a queue.
;  *
;  * @return pdTRUE if there is no space, otherwise pdFALSE;
;  */
; static signed portCHAR prvIsQueueFull( const xQueueHandle pxQueue ) reentrant;
; 
; /*
;  * Macro that copies an item into the queue.  This is done by copying the item
;  * byte for byte, not by reference.  Updates the queue state to ensure it's
;  * integrity after the copy.
;  */
; #define prvCopyQueueData( pxQueue, pvItemToQueue )												\
; 	memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->ucItemSize );	\
; 	++( pxQueue->ucMessagesWaiting );															\
; 	pxQueue->pcWriteTo += pxQueue->ucItemSize;													\
; 	if( pxQueue->pcWriteTo >= pxQueue->pcTail )													\
; 	{																							\
; 		pxQueue->pcWriteTo = pxQueue->pcHead;													\
; 	}																							\
; 
; /*-----------------------------------------------------------*/
; 
; #ifndef KEIL_AX11000
; 
; /*
;  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from 
;  * accessing the queue event lists. 
;  */
; #define prvLockQueue( pxQueue )			\
; 	taskENTER_CRITICAL();				\
; 		++( pxQueue->cRxLock );			\
; 		++( pxQueue->cTxLock );			\
; 	taskEXIT_CRITICAL();				\
; 
; /*-----------------------------------------------------------*/
; #endif
; 
; /*-----------------------------------------------------------
;  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
;  *----------------------------------------------------------*/
; 
; xQueueHandle xQueueCreate( unsigned portCHAR ucQueueLength, unsigned portCHAR ucItemSize ) reentrant

	RSEG  ?PR?_?xQueueCreate?QUEUE
_?xQueueCreate:
	USING	0
			; SOURCE LINE # 176
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
	MOV  	A,R5
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
	MOV  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFBH
	LCALL	?C?ADDXBP
; {
; xQUEUE *pxNewQueue;
; unsigned portSHORT usQueueSizeInBytes;
; 
; 	/* Allocate the new queue structure. */
; 	if( ucQueueLength > ( unsigned portCHAR ) 0 )
			; SOURCE LINE # 182
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#00H
	JNC  	$ + 5H
	AJMP 	?C0001
; 	{
			; SOURCE LINE # 183
; 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
			; SOURCE LINE # 184
	MOV  	R6,#00H
	MOV  	R7,#041H
	LCALL	_?pvPortMalloc
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 		if( pxNewQueue != NULL )
			; SOURCE LINE # 185
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0001
; 		{
			; SOURCE LINE # 186
; 			/* Create the list of pointers to queue items.  The queue is one byte 
; 			longer than asked for to make wrap checking easier/faster. */
; 			usQueueSizeInBytes = ( unsigned portSHORT ) ( ucQueueLength * ucItemSize ) + ( unsigned portSHORT ) 1;
			; SOURCE LINE # 189
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	B,R7
	MUL  	AB
	ADD  	A,#01H
	MOV  	R7,A
	CLR  	A
	ADDC 	A,B
	MOV  	R6,A
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 
; 			pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( usQueueSizeInBytes );
			; SOURCE LINE # 191
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_?pvPortMalloc
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; 			if( pxNewQueue->pcHead != NULL )
			; SOURCE LINE # 192
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0003
; 			{
			; SOURCE LINE # 193
; 				/* Initialise the queue members as described above where the 
; 				queue type is defined. */
; 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( ucQueueLength * ucItemSize );
			; SOURCE LINE # 196
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	B,R7
	MUL  	AB
	ADD  	A,R1
	MOV  	R1,A
	MOV  	A,R2
	ADDC 	A,B
	MOV  	R2,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 				pxNewQueue->ucMessagesWaiting = ( unsigned portCHAR ) 0;
			; SOURCE LINE # 197
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	CLR  	A
	LCALL	?C?CSTPTR
; 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
			; SOURCE LINE # 198
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( ucQueueLength - ( unsigned portCHAR ) 1 ) * ucItemSize );
			; SOURCE LINE # 199
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	CLR  	C
	SUBB 	A,#01H
	MOV  	R7,A
	CLR  	A
	SUBB 	A,#00H
	MOV  	R6,A
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	R4,#00H
	LCALL	?C?IMUL
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,R7
	MOV  	R1,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R2,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 				pxNewQueue->ucLength = ucQueueLength;
			; SOURCE LINE # 200
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03DH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 				pxNewQueue->ucItemSize = ucItemSize;
			; SOURCE LINE # 201
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 				pxNewQueue->cRxLock = queueUNLOCKED;
			; SOURCE LINE # 202
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CSTPTR
; 				pxNewQueue->cTxLock = queueUNLOCKED;
			; SOURCE LINE # 203
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CSTPTR
; 
; 				/* Likewise ensure the event queues start with the correct state. */
; 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
			; SOURCE LINE # 206
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListInitialise
; 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) ); 
			; SOURCE LINE # 207
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListInitialise
; 
; 				return  pxNewQueue;
			; SOURCE LINE # 209
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	SJMP 	?C0004
; 			}
			; SOURCE LINE # 210
?C0003:
; 			else
; 			{
			; SOURCE LINE # 212
; 				vPortFree( pxNewQueue );
			; SOURCE LINE # 213
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vPortFree
; 			}
			; SOURCE LINE # 214
; 		}
			; SOURCE LINE # 215
; 	}
			; SOURCE LINE # 216
?C0001:
; 
; 	/* Will only reach here if we could not allocate enough memory or no memory
; 	was required. */
; 	return NULL;
			; SOURCE LINE # 220
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#00H
; }
			; SOURCE LINE # 221
?C0004:
	MOV  	DPTR,#07H
	LJMP 	?C?ADDXBP
; END OF _?xQueueCreate

; /*-----------------------------------------------------------*/
; 
; signed portCHAR cQueueSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait ) reentrant

	RSEG  ?PR?_?cQueueSend?QUEUE
_?cQueueSend:
	USING	0
			; SOURCE LINE # 224
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cReturn;
; 
; 	/* Make sure other tasks do not access the queue. */
; 	vTaskSuspendAll();
			; SOURCE LINE # 229
	LCALL	_?vTaskSuspendAll
; 
; 	/* It is important that this is the only thread/ISR that modifies the
; 	ready or delayed lists until cTaskResumeAll() is called.  Places where 
; 	the ready/delayed lists are modified include:
; 
; 		+ vTaskDelay() -  Nothing can call vTaskDelay as the scheduler is 
; 		  suspended, vTaskDelay() cannot be called from an ISR.
; 		+ vTaskPrioritySet() - Has a critical section around the access.
; 		+ vTaskSwitchContext() - This will not get executed while the scheduler 
; 		  is suspended.
; 		+ prvCheckDelayedTasks() - This will not get executed while the 
; 		  scheduler is suspended.
; 		+ sTaskCreate() - Has a critical section around the access.
; 		+ vTaskResume() - Has a critical section around the access.
; 		+ cTaskResumeAll() - Has a critical section around the access.
; 		+ cTaskRemoveFromEventList - Checks to see if the scheduler is 
; 		  suspended.  If so then the TCB being removed from the event is 
; 		  removed from the event and added to the xPendingReadyList.
; 	*/
; 
; 	/* Make sure interrupts do not access the queue event list. */
; 	prvLockQueue( pxQueue );
			; SOURCE LINE # 251
	LCALL	L?0077
; 
; 	/* It is important that interrupts to not access the event list of the
; 	queue being modified here.  Places where the event list is modified
; 	include:
; 
; 		+ cQueueSendFromISR().  This checks the lock on the queue to see if
; 		  it has access.  If the queue is locked then the Tx lock count is 
; 		  incremented to signify that a task waiting for data can be made ready
; 		  once the queue lock is removed.  If the queue is not locked then
; 		  a task can be moved from the event list, but will not be removed
; 		  from the delayed list or placed in the ready list until the scheduler 
; 		  is unlocked.  
; 
; 		+ cQueueReceiveFromISR().  As per cQueueSendFromISR().
; 	*/
; 		
; 	/* If the queue is already full we may have to block. */
; 	if( prvIsQueueFull( pxQueue ) )
			; SOURCE LINE # 269
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?prvIsQueueFull
	MOV  	A,R7
	JZ   	?C0006
; 	{
			; SOURCE LINE # 270
; 		/* The queue is full - do we want to block or just leave without
; 		posting? */
; 		if( xTicksToWait > ( portTickType ) 0 )
			; SOURCE LINE # 273
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	SETB 	C
	LCALL	?C?ULCMP
	JC   	?C0006
; 		{
			; SOURCE LINE # 274
; 			/* We are going to place ourselves on the xTasksWaitingToSend event
; 			list, and will get woken should the delay expire, or space become
; 			available on the queue. 
; 			
; 			As detailed above we do not require mutual exclusion on the event
; 			list as nothing else can modify it or the ready lists while we
; 			have the scheduler suspended and queue locked. 
; 			
; 			It is possible that an ISR has removed data from the queue since we
; 			checked if any was available.  If this is the case then the data
; 			will have been copied from the queue, and the queue variables 
; 			updated, but the event list will not yet have been checked to see if
; 			anything is waiting as the queue is locked. */
; 			vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
			; SOURCE LINE # 288
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vTaskPlaceOnEventList
; 
; 			/* Force a context switch now as we are blocked.  We can do
; 			this from within a critical section as the task we are 
; 			switching to has its own context.  When we return here (i.e. we
; 			unblock) we will leave the critical section as normal. 
; 			
; 			It is possible that an ISR has caused an event on an unrelated and 
; 			unlocked queue.  If this was the case then the event list for that 
; 			queue will have been updated but the ready lists left unchanged -
; 			instead the readied task will have been added to the pending ready 
; 			list. */
; 			taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 			{
			; SOURCE LINE # 301
; 				/* We can safely unlock the queue and scheduler here as 
; 				interrupts are disabled.  We must not yield with anything 
; 				locked, but we can yield from within a critical section.
; 				
; 				Tasks that have been placed on the pending ready list cannot
; 				be tasks that are waiting for events on this queue.  See 
; 				in comment cTaskRemoveFromEventList(). */
; 				prvUnlockQueue( pxQueue );
			; SOURCE LINE # 309
	LCALL	L?0079
; 
; 				/* Resuming the scheduler may cause a yield.  If so then there
; 				is no point yielding again here. */
; 				if( !cTaskResumeAll() )
			; SOURCE LINE # 313
	LCALL	_?cTaskResumeAll
	MOV  	A,R7
	JNZ  	?C0008
; 				{
			; SOURCE LINE # 314
; 					taskYIELD();
			; SOURCE LINE # 315
	LCALL	_?vPortYield
; 				}
			; SOURCE LINE # 316
?C0008:
; 
; 				/* Before leaving the critical section we have to ensure
; 				exclusive access again. */
; 				vTaskSuspendAll();
			; SOURCE LINE # 320
	LCALL	_?vTaskSuspendAll
; 				prvLockQueue( pxQueue );				
			; SOURCE LINE # 321
	LCALL	L?0077
; 			}
			; SOURCE LINE # 322
; 			taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 		}
			; SOURCE LINE # 324
; 	}
			; SOURCE LINE # 325
?C0006:
; 		
; 	/* When we are here it is possible that we unlblocked as space became 
; 	available on the queue.  It is also possible that an ISR posted to the
; 	queue since we left the critical section, so it may be that again there
; 	is no space.  This would only happen if a task and ISR post onto the
; 	same queue. */
; 	taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 	{
			; SOURCE LINE # 333
; 		if( pxQueue->ucMessagesWaiting < pxQueue->ucLength )
			; SOURCE LINE # 334
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03DH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CLR  	C
	SUBB 	A,R7
	JC   	$ + 5H
	AJMP 	?C0009
; 		{
			; SOURCE LINE # 335
; 			/* There is room in the queue, copy the data into the queue. */			
; 			prvCopyQueueData( pxQueue, pvItemToQueue );		
			; SOURCE LINE # 337
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	R0,AR1
	MOV  	R4,AR2
	MOV  	R5,AR3
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?COPY
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	INC  	R1
	MOV  	A,R1
	JNZ  	?C0069
	INC  	R2
?C0069:
	CLR  	A
	MOV  	B,R7
	LCALL	?C?IILDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	CLR  	C
	POP  	DPL
	POP  	DPH
	POP  	ACC
	MOV  	A,R1
	SUBB 	A,DPL
	MOV  	A,R2
	SUBB 	A,DPH
?C0070:
	JC   	?C0010
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
?C0010:
; 			cReturn = ( signed portCHAR ) pdPASS;
			; SOURCE LINE # 338
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 
; 			/* Update the TxLock count so prvUnlockQueue knows to check for
; 			tasks waiting for data to become available in the queue. */
; 			++( pxQueue->cTxLock );
			; SOURCE LINE # 342
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 		}
			; SOURCE LINE # 343
	SJMP 	?C0011
?C0009:
; 		else
; 		{
			; SOURCE LINE # 345
; 			cReturn = errQUEUE_FULL;
			; SOURCE LINE # 346
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#0FDH
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 347
?C0011:
; 	}
			; SOURCE LINE # 348
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	/* We no longer require exclusive access to the queue.  prvUnlockQueue
; 	will remove any tasks suspended on a receive if either this function 
; 	or an ISR has posted onto the queue. */
; 	if( prvUnlockQueue( pxQueue ) )
			; SOURCE LINE # 354
	LCALL	L?0079
	MOV  	A,R7
	JZ   	?C0012
; 	{
			; SOURCE LINE # 355
; 		/* Resume the scheduler - making ready any tasks that were woken
; 		by an event while the scheduler was locked.  Resuming the 
; 		scheduler may cause a yield, in which case there is no point
; 		yielding again here. */
; 		if( !cTaskResumeAll() )
			; SOURCE LINE # 360
	LCALL	_?cTaskResumeAll
	MOV  	A,R7
	JNZ  	?C0014
; 		{
			; SOURCE LINE # 361
; 			taskYIELD();
			; SOURCE LINE # 362
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 363
; 	}
			; SOURCE LINE # 364
	SJMP 	?C0014
?C0012:
; 	else
; 	{
			; SOURCE LINE # 366
; 		/* Resume the scheduler - making ready any tasks that were woken
; 		by an event while the scheduler was locked. */
; 		cTaskResumeAll();
			; SOURCE LINE # 369
	LCALL	_?cTaskResumeAll
; 	}
			; SOURCE LINE # 370
?C0014:
; 
; 	return cReturn;
			; SOURCE LINE # 372
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 373
?C0015:
	MOV  	DPTR,#0BH
	LJMP 	?C?ADDXBP
; END OF _?cQueueSend

; 
; /*-----------------------------------------------------------*/
; //signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTaskPreviouslyWoken )
; signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTaskPreviouslyWoken ) reentrant

	RSEG  ?PR?_?cQueueSendFromISR?QUEUE
_?cQueueSendFromISR:
	USING	0
			; SOURCE LINE # 377
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	/* Similar to cQueueSend, except we don't block if there is no room in the
; 	queue.  Also we don't directly wake a task that was blocked on a queue
; 	read, instead we return a flag to say whether a context switch is required
; 	or not (i.e. has a task with a higher priority than us been woken by this
; 	post). */
; 	if( pxQueue->ucMessagesWaiting < pxQueue->ucLength )
			; SOURCE LINE # 384
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03DH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CLR  	C
	SUBB 	A,R7
	JC   	$ + 5H
	AJMP 	?C0016
; 	{
			; SOURCE LINE # 385
; 		prvCopyQueueData( pxQueue, pvItemToQueue );
			; SOURCE LINE # 386
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	R0,AR1
	MOV  	R4,AR2
	MOV  	R5,AR3
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?COPY
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	INC  	R1
	MOV  	A,R1
	JNZ  	?C0071
	INC  	R2
?C0071:
	CLR  	A
	MOV  	B,R7
	LCALL	?C?IILDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	CLR  	C
	POP  	DPL
	POP  	DPH
	POP  	ACC
	MOV  	A,R1
	SUBB 	A,DPL
	MOV  	A,R2
	SUBB 	A,DPH
?C0072:
	JC   	?C0017
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
?C0017:
; 
; 		/* If the queue is locked we do not alter the event list.  This will
; 		be done when the queue is unlocked later. */
; 		if( pxQueue->cTxLock == queueUNLOCKED )
			; SOURCE LINE # 390
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CPL  	A
	JNZ  	?C0018
; 		{
			; SOURCE LINE # 391
; 			/* We only want to wake one task per ISR, so check that a task has
; 			not already been woken. */
; 			if( !cTaskPreviouslyWoken )		
			; SOURCE LINE # 394
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	JNZ  	?C0016
; 			{
			; SOURCE LINE # 395
; 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			; SOURCE LINE # 396
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	CLR  	C
	JNZ  	?C0021
	SETB 	C
?C0021:
?C0022:
	JC   	?C0016
; 				{
			; SOURCE LINE # 397
; 					if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( signed portCHAR ) pdFALSE )
			; SOURCE LINE # 398
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?cTaskRemoveFromEventList
	MOV  	A,R7
	JZ   	?C0016
; 					{
			; SOURCE LINE # 399
; 						/* The task waiting has a higher priority so record that a 
; 						context	switch is required. */
; 						return pdTRUE;
			; SOURCE LINE # 402
	MOV  	R7,#01H
	SJMP 	?C0024
; 					}
			; SOURCE LINE # 403
; 				}
			; SOURCE LINE # 404
; 			}
			; SOURCE LINE # 405
; 		}
			; SOURCE LINE # 406
?C0018:
; 		else
; 		{
			; SOURCE LINE # 408
; 			/* Increment the lock count so the task that unlocks the queue 
; 			knows that data was posted while it was locked. */
; 			++( pxQueue->cTxLock );
			; SOURCE LINE # 411
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 		}
			; SOURCE LINE # 412
; 	}
			; SOURCE LINE # 413
?C0016:
; 
; 	return cTaskPreviouslyWoken;
			; SOURCE LINE # 415
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 416
?C0024:
	MOV  	DPTR,#07H
	LJMP 	?C?ADDXBP
; END OF _?cQueueSendFromISR

; /*-----------------------------------------------------------*/
; 
; signed portCHAR cQueueReceive( xQueueHandle pxQueue, void *pcBuffer, portTickType xTicksToWait ) reentrant

	RSEG  ?PR?_?cQueueReceive?QUEUE
_?cQueueReceive:
	USING	0
			; SOURCE LINE # 419
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cReturn;
; 
; 	/* This function is very similar to cQueueSend().  See comments within
; 	cQueueSend() for a more detailed explanation.
; 
; 	Make sure other tasks do not access the queue. */
; 	vTaskSuspendAll();
			; SOURCE LINE # 427
	LCALL	_?vTaskSuspendAll
; 
; 	/* Make sure interrupts do not access the queue. */
; 	prvLockQueue( pxQueue );
			; SOURCE LINE # 430
	LCALL	L?0078
; 
; 	/* If there are no messages in the queue we may have to block. */
; 	if( prvIsQueueEmpty( pxQueue ) )
			; SOURCE LINE # 433
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?prvIsQueueEmpty
	MOV  	A,R7
	JZ   	?C0026
; 	{
			; SOURCE LINE # 434
; 		/* There are no messages in the queue, do we want to block or just
; 		leave with nothing? */			
; 		if( xTicksToWait > ( portTickType ) 0 )
			; SOURCE LINE # 437
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	SETB 	C
	LCALL	?C?ULCMP
	JC   	?C0026
; 		{
			; SOURCE LINE # 438
; 			vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
			; SOURCE LINE # 439
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vTaskPlaceOnEventList
; 			taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 			{
			; SOURCE LINE # 441
; 				prvUnlockQueue( pxQueue );
			; SOURCE LINE # 442
	LCALL	L?0080
; 				if( !cTaskResumeAll() )
			; SOURCE LINE # 443
	LCALL	_?cTaskResumeAll
	MOV  	A,R7
	JNZ  	?C0028
; 				{
			; SOURCE LINE # 444
; 					taskYIELD();
			; SOURCE LINE # 445
	LCALL	_?vPortYield
; 				}
			; SOURCE LINE # 446
?C0028:
; 
; 				vTaskSuspendAll();
			; SOURCE LINE # 448
	LCALL	_?vTaskSuspendAll
; 				prvLockQueue( pxQueue );			
			; SOURCE LINE # 449
	LCALL	L?0078
; 			}
			; SOURCE LINE # 450
; 			taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 		}
			; SOURCE LINE # 452
; 	}
			; SOURCE LINE # 453
?C0026:
; 
; 	taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 	{
			; SOURCE LINE # 456
; 		if( pxQueue->ucMessagesWaiting > ( unsigned portCHAR ) 0 )
			; SOURCE LINE # 457
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	SETB 	C
	SUBB 	A,#00H
	JNC  	$ + 5H
	AJMP 	?C0029
; 		{
			; SOURCE LINE # 458
; 			pxQueue->pcReadFrom += pxQueue->ucItemSize;
			; SOURCE LINE # 459
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	INC  	R1
	MOV  	A,R1
	JNZ  	?C0073
	INC  	R2
?C0073:
	CLR  	A
	MOV  	B,R7
	LCALL	?C?IILDPTR
; 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
			; SOURCE LINE # 460
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	CLR  	C
	POP  	DPL
	POP  	DPH
	POP  	ACC
	MOV  	A,R1
	SUBB 	A,DPL
	MOV  	A,R2
	SUBB 	A,DPH
?C0074:
	JC   	?C0030
; 			{
			; SOURCE LINE # 461
; 				pxQueue->pcReadFrom = pxQueue->pcHead;
			; SOURCE LINE # 462
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 			}
			; SOURCE LINE # 463
?C0030:
; 			--( pxQueue->ucMessagesWaiting );
			; SOURCE LINE # 464
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CILDPTR
; 			memcpy( ( void * ) pcBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->ucItemSize );
			; SOURCE LINE # 465
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R0,A
	MOV  	R4,AR2
	MOV  	R5,AR3
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?COPY
; 
; 			/* Increment the lock count so prvUnlockQueue knows to check for
; 			tasks waiting for space to become available on the queue. */
; 			++( pxQueue->cRxLock );
			; SOURCE LINE # 469
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 			cReturn = ( signed portCHAR ) pdPASS;
			; SOURCE LINE # 470
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 471
	SJMP 	?C0031
?C0029:
; 		else
; 		{
			; SOURCE LINE # 473
; 			cReturn = ( signed portCHAR ) pdFAIL;
			; SOURCE LINE # 474
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 475
?C0031:
; 	}
			; SOURCE LINE # 476
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	/* We no longer require exclusive access to the queue. */
; 	if( prvUnlockQueue( pxQueue ) )
			; SOURCE LINE # 480
	LCALL	L?0080
	MOV  	A,R7
	JZ   	?C0032
; 	{
			; SOURCE LINE # 481
; 		if( !cTaskResumeAll() )
			; SOURCE LINE # 482
	LCALL	_?cTaskResumeAll
	MOV  	A,R7
	JNZ  	?C0034
; 		{
			; SOURCE LINE # 483
; 			taskYIELD();
			; SOURCE LINE # 484
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 485
; 	}
			; SOURCE LINE # 486
	SJMP 	?C0034
?C0032:
; 	else
; 	{
			; SOURCE LINE # 488
; 		cTaskResumeAll();
			; SOURCE LINE # 489
	LCALL	_?cTaskResumeAll
; 	}
			; SOURCE LINE # 490
?C0034:
; 
; 	return cReturn;
			; SOURCE LINE # 492
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 493
?C0035:
	MOV  	DPTR,#0BH
	LJMP 	?C?ADDXBP
; END OF _?cQueueReceive

; /*-----------------------------------------------------------*/
; 
; signed portCHAR cQueueReceiveFromISR( xQueueHandle pxQueue, void *pcBuffer, signed portCHAR *pcTaskWoken ) reentrant

	RSEG  ?PR?_?cQueueReceiveFromISR?QUEUE
_?cQueueReceiveFromISR:
	USING	0
			; SOURCE LINE # 496
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cReturn;
; 
; 	/* We cannot block from an ISR, so check there is data available. */
; 	if( pxQueue->ucMessagesWaiting > ( unsigned portCHAR ) 0 )
			; SOURCE LINE # 501
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	SETB 	C
	SUBB 	A,#00H
	JNC  	$ + 5H
	AJMP 	?C0036
; 	{
			; SOURCE LINE # 502
; 		/* Copy the data from the queue. */
; 		pxQueue->pcReadFrom += pxQueue->ucItemSize;
			; SOURCE LINE # 504
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	INC  	R1
	MOV  	A,R1
	JNZ  	?C0075
	INC  	R2
?C0075:
	CLR  	A
	MOV  	B,R7
	LCALL	?C?IILDPTR
; 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
			; SOURCE LINE # 505
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	CLR  	C
	POP  	DPL
	POP  	DPH
	POP  	ACC
	MOV  	A,R1
	SUBB 	A,DPL
	MOV  	A,R2
	SUBB 	A,DPH
?C0076:
	JC   	?C0037
; 		{
			; SOURCE LINE # 506
; 			pxQueue->pcReadFrom = pxQueue->pcHead;
			; SOURCE LINE # 507
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 		}
			; SOURCE LINE # 508
?C0037:
; 		--( pxQueue->ucMessagesWaiting );
			; SOURCE LINE # 509
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CILDPTR
; 		memcpy( ( void * ) pcBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->ucItemSize );
			; SOURCE LINE # 510
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03EH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#09H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R0,A
	MOV  	R4,AR2
	MOV  	R5,AR3
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?COPY
; 
; 		/* If the queue is locked we will not modify the event list.  Instead
; 		we update the lock count so the task that unlocks the queue will know
; 		that an ISR has removed data while the queue was locked. */
; 		if( pxQueue->cRxLock == queueUNLOCKED )
			; SOURCE LINE # 515
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CPL  	A
	JNZ  	?C0038
; 		{
			; SOURCE LINE # 516
; 			/* We only want to wake one task per ISR, so check that a task has
; 			not already been woken. */
; 			if( !( *pcTaskWoken ) )
			; SOURCE LINE # 519
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?CLDPTR
	JNZ  	?C0044
; 			{
			; SOURCE LINE # 520
; 				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			; SOURCE LINE # 521
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	CLR  	C
	JNZ  	?C0041
	SETB 	C
?C0041:
?C0042:
	JC   	?C0044
; 				{
			; SOURCE LINE # 522
; 					if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( signed portCHAR ) pdFALSE )
			; SOURCE LINE # 523
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?cTaskRemoveFromEventList
	MOV  	A,R7
	JZ   	?C0044
; 					{
			; SOURCE LINE # 524
; 						/* The task waiting has a higher priority than us so
; 						force a context switch. */
; 						*pcTaskWoken = ( signed portCHAR ) pdTRUE;
			; SOURCE LINE # 527
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	A,#01H
	LCALL	?C?CSTPTR
; 					}
			; SOURCE LINE # 528
; 				}
			; SOURCE LINE # 529
; 			}
			; SOURCE LINE # 530
; 		}
			; SOURCE LINE # 531
	SJMP 	?C0044
?C0038:
; 		else
; 		{
			; SOURCE LINE # 533
; 			/* Increment the lock count so the task that unlocks the queue 
; 			knows that data was removed while it was locked. */
; 			++( pxQueue->cRxLock );
			; SOURCE LINE # 536
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 		}
			; SOURCE LINE # 537
?C0044:
; 
; 		cReturn = ( signed portCHAR ) pdPASS;
			; SOURCE LINE # 539
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 540
	SJMP 	?C0045
?C0036:
; 	else
; 	{
			; SOURCE LINE # 542
; 		cReturn = ( signed portCHAR ) pdFAIL;
			; SOURCE LINE # 543
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 544
?C0045:
; 
; 	return cReturn;
			; SOURCE LINE # 546
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 547
?C0046:
	MOV  	DPTR,#0AH
	LJMP 	?C?ADDXBP
; END OF _?cQueueReceiveFromISR

; /*-----------------------------------------------------------*/
; 
; unsigned portCHAR ucQueueMessagesWaiting( xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?ucQueueMessagesWaiting?QUEUE
_?ucQueueMessagesWaiting:
	USING	0
			; SOURCE LINE # 550
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; unsigned portCHAR ucReturn;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	taskENTER_CRITICAL();
; 		ucReturn = pxQueue->ucMessagesWaiting;
			; SOURCE LINE # 555
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	@DPTR,A
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return ucReturn;
			; SOURCE LINE # 558
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 559
?C0047:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?ucQueueMessagesWaiting

; /*-----------------------------------------------------------*/
; 
; void vQueueDelete( xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?vQueueDelete?QUEUE
_?vQueueDelete:
	USING	0
			; SOURCE LINE # 562
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	vPortFree( pxQueue->pcHead );
			; SOURCE LINE # 564
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	LCALL	_?vPortFree
; 	vPortFree( pxQueue );
			; SOURCE LINE # 565
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vPortFree
; }
			; SOURCE LINE # 566
	MOV  	DPTR,#03H
	LJMP 	?C?ADDXBP
; END OF _?vQueueDelete

; /*-----------------------------------------------------------*/
; 
; #ifdef KEIL_AX11000
; /*
;  * Mark a queue as locked.  Locking a queue prevents an ISR from 
;  * accessing the queue event lists. 
;  */
; static void prvLockQueue( xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?prvLockQueue?QUEUE
L?0077:
	USING	0
L?0078:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
_?prvLockQueue:
	USING	0
			; SOURCE LINE # 574
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 	++( pxQueue->cRxLock );
			; SOURCE LINE # 577
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 	++( pxQueue->cTxLock );
			; SOURCE LINE # 578
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#01H
	LCALL	?C?CILDPTR
; 	taskEXIT_CRITICAL();	
	 DB 0D0H, 0D0H, 092H, 0AFH;	
; }
			; SOURCE LINE # 580
	MOV  	DPTR,#03H
	LJMP 	?C?ADDXBP
; END OF _?prvLockQueue

; #endif
; /*-----------------------------------------------------------*/
; 
; static signed portCHAR prvUnlockQueue( xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?prvUnlockQueue?QUEUE
L?0079:
	USING	0
L?0080:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
_?prvUnlockQueue:
	USING	0
			; SOURCE LINE # 584
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cYieldRequired = ( signed portCHAR ) pdFALSE;
			; SOURCE LINE # 586
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
; 
; 	/* The lock counts contains the number of extra data items placed or 
; 	removed from the queue while the queue was locked.  When a queue is
; 	locked items can be added or removed, but the event lists cannot be
; 	updated. */
; 	taskENTER_CRITICAL();
; 	{
			; SOURCE LINE # 595
; 		--( pxQueue->cTxLock );
			; SOURCE LINE # 596
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CILDPTR
; 
; 		/* See if data was added to the queue while it was locked. */
; 		if( pxQueue->cTxLock > queueUNLOCKED )
			; SOURCE LINE # 599
	LCALL	?C?CLDPTR
	SETB 	C
	XRL  	A,#080H
	SUBB 	A,#07FH
	JC   	?C0050
; 		{
			; SOURCE LINE # 600
; 			pxQueue->cTxLock = queueUNLOCKED;
			; SOURCE LINE # 601
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#040H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CSTPTR
; 
; 			/* Data was posted while the queue was locked.  Are any tasks
; 			blocked waiting for data to become available? */
; 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
			; SOURCE LINE # 605
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	CLR  	C
	JNZ  	?C0052
	SETB 	C
?C0052:
?C0053:
	JC   	?C0050
; 			{
			; SOURCE LINE # 606
; 				/* Tasks that are removed from the event list will get added to
; 				the pending ready list as the scheduler is still suspended. */
; 				if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( signed portCHAR ) pdFALSE )
			; SOURCE LINE # 609
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#024H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?cTaskRemoveFromEventList
	MOV  	A,R7
	JZ   	?C0050
; 				{
			; SOURCE LINE # 610
; 					/* The task waiting has a higher priority so record that a 
; 					context	switch is required. */
; 					cYieldRequired = ( signed portCHAR ) pdTRUE;
			; SOURCE LINE # 613
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 				}
			; SOURCE LINE # 614
; 			}			
			; SOURCE LINE # 615
; 		}
			; SOURCE LINE # 616
?C0050:
; 	}
			; SOURCE LINE # 617
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	/* Do the same for the Rx lock. */
; 	taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 	{
			; SOURCE LINE # 622
; 		--( pxQueue->cRxLock );
			; SOURCE LINE # 623
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CILDPTR
; 
; 		if( pxQueue->cRxLock > queueUNLOCKED )
			; SOURCE LINE # 625
	LCALL	?C?CLDPTR
	SETB 	C
	XRL  	A,#080H
	SUBB 	A,#07FH
	JC   	?C0055
; 		{
			; SOURCE LINE # 626
; 			pxQueue->cRxLock = queueUNLOCKED;
			; SOURCE LINE # 627
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03FH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,#0FFH
	LCALL	?C?CSTPTR
; 
; 			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
			; SOURCE LINE # 629
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	CLR  	C
	JNZ  	?C0057
	SETB 	C
?C0057:
?C0058:
	JC   	?C0055
; 			{
			; SOURCE LINE # 630
; 				if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( signed portCHAR ) pdFALSE )
			; SOURCE LINE # 631
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?cTaskRemoveFromEventList
	MOV  	A,R7
	JZ   	?C0055
; 				{
			; SOURCE LINE # 632
; 					cYieldRequired = ( signed portCHAR ) pdTRUE;
			; SOURCE LINE # 633
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 				}
			; SOURCE LINE # 634
; 			}			
			; SOURCE LINE # 635
; 		}
			; SOURCE LINE # 636
?C0055:
; 	}
			; SOURCE LINE # 637
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return cYieldRequired;
			; SOURCE LINE # 640
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 641
?C0060:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?prvUnlockQueue

; /*-----------------------------------------------------------*/
; 
; static signed portCHAR prvIsQueueEmpty( const xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?prvIsQueueEmpty?QUEUE
_?prvIsQueueEmpty:
	USING	0
			; SOURCE LINE # 644
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cReturn;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	taskENTER_CRITICAL();
; 		cReturn = ( pxQueue->ucMessagesWaiting == ( unsigned portCHAR ) 0 );
			; SOURCE LINE # 649
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,#00H
	JNZ  	?C0061
	MOV  	R7,#01H
?C0061:
?C0062:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return cReturn;
			; SOURCE LINE # 652
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 653
?C0063:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?prvIsQueueEmpty

; /*-----------------------------------------------------------*/
; 
; static signed portCHAR prvIsQueueFull( const xQueueHandle pxQueue ) reentrant

	RSEG  ?PR?_?prvIsQueueFull?QUEUE
_?prvIsQueueFull:
	USING	0
			; SOURCE LINE # 656
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
; {
; signed portCHAR cReturn;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	taskENTER_CRITICAL();
; 		cReturn = ( pxQueue->ucMessagesWaiting == pxQueue->ucLength );
			; SOURCE LINE # 661
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03DH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03CH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CJNE 	A,AR7,?C0064
	MOV  	R7,#01H
	SJMP 	?C0065
?C0064:
	MOV  	R7,#00H
?C0065:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return cReturn;
			; SOURCE LINE # 664
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 665
?C0066:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?prvIsQueueFull

	END
