C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE HSUART
OBJECT MODULE PLACED IN .\hsuart.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\hsur\hsuart.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\hsuart.lst) OBJECT(.\hsuart.
                    -obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : hsuart.c
  13           * Purpose     : The High Speed UART module driver. It manages the character
  14           *               buffer and handles the ISR.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-09
  17           * Notes       : None.
  18           * $Log: hsuart.c,v $
  19           * Revision 1.20  2006/07/25 03:41:23  robin6633
  20           * 1.Add Xon/Xoff counter for debugging.
  21           *
  22           * Revision 1.19  2006/07/24 06:40:51  robin6633
  23           * 1.Fixed the XON/XOFF ASCII is put into hardware transmitting register driectly.
  24           *
  25           * Revision 1.18  2006/07/21 11:24:55  robin6633
  26           * 1.Add flow control check in hsurFlowOn==1.
  27           *
  28           * Revision 1.17  2006/07/19 08:51:24  robin6633
  29           * 1.Fixed Hardware flow control function.
  30           * 2.Extern a function HSUR_GetLineStatus() to get UR2_LSR.
  31           *
  32           * Revision 1.16  2006/07/18 08:03:59  robin6633
  33           * 1.Fixed Tx flow control in software flow control mode.
  34           *
  35           * Revision 1.15  2006/06/30 06:17:01  robin6633
  36           * 1.Fixed software flow control in first initial.
  37           *
  38           * Revision 1.14  2006/06/27 10:45:24  robin6633
  39           * 1.Add flow control for transmitting.
  40           *
  41           * Revision 1.13  2006/06/19 14:20:57  robin6633
  42           * 1.Protect transmit counter and pointer.
  43           * 2.Force transmit more data if transmit fifo empty.
  44           *
  45           * Revision 1.12  2006/06/11 02:18:49  robin6633
  46           * 1.Add Xon/Xoff.
  47           *
  48           * Revision 1.11  2006/06/05 06:21:43  robin6633
  49           * 1.Fixed function declaration.
  50           *    U8_T HSUR_RxBufFlowControl(void) -> void HSUR_RxBufFlowControl(void)
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 2   

  51           * 2.Fixed hsur_ReadLsr() & hsur_ReadMsr().
  52           *
  53           * Revision 1.10  2006/06/05 01:30:44  robin6633
  54           * 1.Fixed software flow control and prevented the hardware FIFO overrun.
  55           *
  56           * Revision 1.9  2006/05/24 05:40:34  robin6633
  57           * 1.Add flow control water mark.
  58           *
  59           * Revision 1.8  2006/05/23 11:07:51  robin6633
  60           * 1.Enable flow control code.
  61           *
  62           * Revision 1.7  2006/05/22 13:23:42  robin6633
  63           * 1.Fixed buffer overwrite.
  64           *
  65           * Revision 1.6  2006/05/22 07:39:28  robin6633
  66           * 1.Disable flow control.
  67           *
  68           * Revision 1.5  2006/05/19 06:37:13  robin6633
  69           * 1.Fixed the baudrate setup for default configuration.
  70           *
  71           * Revision 1.4  2006/05/19 03:48:37  robin6633
  72           * 1.Add Xon/Xoff flow control.
  73           * 2.Expand an external function HSUR_ChangeBaud(U8_T baud).
  74           *
  75           * Revision 1.3  2006/05/18 09:57:55  Louis
  76           * no message
  77           *
  78           * Revision 1.2  2006/05/18 02:27:56  robin6633
  79           * 1.Removed printf in UART2.
  80           *
  81           * Revision 1.1  2006/05/15 03:06:52  robin6633
  82           * no message
  83           *
  84           * Revision 1.3  2006/05/03 02:42:30  robin6633
  85           * Changed the the function name HSUR_GetBufCount()
  86           * to HSUR_GetRxBufCount() .
  87           *
  88           * Revision 1.2  2006/05/02 01:44:07  robin6633
  89           * Add an expanding function to get the counter value of UART2 software buffer.
  90           *
  91           * Revision 1.1  2006/04/07 11:38:18  robin6633
  92           * no message
  93           *
  94           *================================================================================
  95           */
  96          
  97          /* INCLUDE FILE DECLARATIONS */
  98          #include        "reg80390.h"
  99          #include        "types.h"
 100          #include        "uart.h"
 101          #include        "mstimer.h"
 102          #include        "hsuart.h"
 103          #include        "string.h"
 104          
 105          
 106          /* STATIC VARIABLE DECLARATIONS */
 107          
 108          U8_T far hsurRxBuffer[UR2_MAX_RX_SIZE];
 109          static U8_T     far     hsurTxBuffer[UR2_MAX_TX_SIZE];
 110          static U16_T far        hsurRxBufNum = 0;
 111          static U16_T far        hsurTxBufNum = 0;
 112          static U8_T      far    hsurRxTrigLvl = 0;
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 3   

 113          U16_T   far hsurRxCount = 0;
 114          static S16_T far        hsurTxCount = 0;
 115          static U16_T far        hsurGetPtr = 0;
 116          static U16_T far        hsurPutPtr = 0;
 117          static U8_T      far    hsurFlowCtrl = 0;
 118          static U8_T      far    hsurFlowOn = 0;
 119          static U8_T      far    hsurTxTransmit = 0;
 120          static U8_T      far    hsurTxFlag = 0;
 121          static U8_T      far    hsurTxState = 0;
 122          static U16_T far        hsurErrorCount = 0;
 123          static U32_T far        hsurErrTimeStart = 0;
 124          static U32_T far        hsurErrTimeStop = 0;
 125          static U8_T      far    hsurErrBlocking = 0;
 126          static U16_T far        hsurBaudRateDivisor = 0;
 127          static U8_T      far    hsurLineStatusValue = 0;
 128          static U8_T      far    hsurModemStatusValue = 0;       
 129          static U8_T      far    hsurLineControlValue = 0;
 130          static U8_T      far    hsurModemControlValue = 0;
 131          static U8_T      far    hsurFifoControlValue = 0;
 132          static U8_T      far    hsurAppFlowOn = 0;
 133          static U8_T     far  hsurFlowCtrlXoff = FALSE;
 134          static U8_T    far  hsurFlowCtrlXon = FALSE;
 135          static U8_T      far    hsurFlowCtrlHwCTSon = FALSE;
 136          
 137          U8_T far uart2_timeout = UART2_TIMEOUT;
 138          
 139          /* LOCAL SUBPROGRAM DECLARATIONS */
 140          static void             hsur_ReadLsr(void);
 141          static void             hsur_RcvrTrig(void);
 142          static void             hsur_Rcvr(void);
 143          static void             hsur_Xmit(void);
 144          static void             hsur_ReadMsr(void);
 145          
 146          extern void     test_run(U8_T dat);
 147          extern volatile U32_T xTickCount;
 148          /* LOCAL SUBPROGRAM BODIES */
 149          
 150          /*
 151           *--------------------------------------------------------------------------------
 152           * static void hsur_ReadLsr(void)
 153           * Purpose : Read Line Status Register and display.
 154           * Params  : None
 155           * Returns : None
 156           * Note    : None
 157           *--------------------------------------------------------------------------------
 158           */
 159          static void hsur_ReadLsr(void)
 160          {
 161   1              hsurLineStatusValue = UR2_LSR;
 162   1      
 163   1              if (hsurLineStatusValue & UR2_OE)
 164   1              {
 165   2                      // Overrun Error
 166   2                      hsurErrorCount ++;
 167   2      //              P3 = BIT0;
 168   2              }
 169   1              if (hsurLineStatusValue & UR2_PE)
 170   1              {
 171   2                      // Parity Error
 172   2                      hsurErrorCount ++;
 173   2      //              P3 = BIT1;
 174   2              }
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 4   

 175   1              if (hsurLineStatusValue & UR2_FE)
 176   1              {
 177   2                      // Framing Error
 178   2                      hsurErrorCount ++;
 179   2      //              P3 = BIT2;
 180   2              }
 181   1              if (hsurLineStatusValue & UR2_BI)
 182   1              {
 183   2                      // Break Interrupt Occured
 184   2                      hsurErrorCount ++;
 185   2      //              P3 = BIT3;
 186   2              }
 187   1              if (hsurLineStatusValue & UR2_FRAME_ERR)
 188   1              {
 189   2                      // Mixing Error
 190   2                      hsurErrorCount ++;
 191   2      //              P3 = BIT4;
 192   2              }
 193   1      
 194   1              if (hsurErrorCount)
 195   1              {
 196   2                      UR2_FCR |= UR2_RXFIFO_RST;
 197   2      
 198   2                      if (hsurErrorCount >=30)
 199   2                      {
 200   3                              hsurErrTimeStop = xTickCount;
 201   3                              if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) <= 2000)
 202   3                              {
 203   4                                      UR2_IER = 0;
 204   4                                      hsurErrBlocking = 1;
 205   4                              }
 206   3                              else
 207   3                              {
 208   4                                      hsurErrBlocking = 0;
 209   4                                      hsurErrTimeStart = 0;
 210   4                                      hsurErrorCount = 0;
 211   4                              }
 212   3                      }
 213   2                      else// if (hsurErrorCount < 30)
 214   2                      {
 215   3                              U8_T trash;
 216   3      
 217   3                              while (UR2_LSR & UR2_DR)
 218   3                              {
 219   4                                      trash = UR2_RBR;
 220   4                              }
 221   3      
 222   3                              if ((hsurErrTimeStart == 0) && (hsurErrorCount < 5))
 223   3                              {
 224   4                                      hsurErrTimeStart = xTickCount;
 225   4                              }
 226   3                              else
 227   3                              {
 228   4                                      hsurErrTimeStop = xTickCount;
 229   4                                      if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) > 2000)
 230   4                                      {
 231   5                                              hsurErrBlocking = 0;
 232   5                                              hsurErrTimeStart = 0;
 233   5                                              hsurErrorCount = 0;
 234   5                                      }
 235   4                              }
 236   3                      }
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 5   

 237   2              }
 238   1      
 239   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 240   1              {
 241   2                      UR2_THR = FLOW_SW_ERROR;
 242   2              }       
 243   1      }
 244          
 245          /*
 246           *--------------------------------------------------------------------------------
 247           * static void hsur_RcvrTrig(void)
 248           * Purpose : Get data and put into the receiver buffer continuously until trigger bytes
 249           * Params  : None
 250           * Returns : None
 251           * Note    : None
 252           *--------------------------------------------------------------------------------
 253           */
 254          static void hsur_RcvrTrig(void)
 255          {
 256   1              U8_T    c;
 257   1              U16_T   i;
 258   1      
 259   1              if (hsurRxCount >= UR2_MAX_RX_SIZE - hsurRxTrigLvl) // buffer full
 260   1                      return;
 261   1      
 262   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 263   1              {
 264   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 265   2                      {
 266   3                              c = UR2_RBR;
 267   3                              if (hsurTxState == 1)
 268   3                              {
 269   4                                      EA = 0;
 270   4                                      hsurTxFlag = c;
 271   4                                      hsurTxState = 0;
 272   4                                      EA = 1;
 273   4                              }
 274   3                              else
 275   3                              {
 276   4                                      hsurRxBuffer[hsurRxCount++] = c;
 277   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 278   4                                              hsurRxCount = 0;
 279   4                              }
 280   3                      }
 281   2              }
 282   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 283   1              {
 284   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 285   2                      {
 286   3                              hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 287   3                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 288   3                                      hsurRxCount = 0;        
 289   3                      }
 290   2              }
 291   1              else
 292   1              {
 293   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 294   2                      {
 295   3                              c = UR2_RBR;
 296   3                              if (c != ASCII_XOFF && c != ASCII_XON)
 297   3                              {
 298   4                                      hsurRxBuffer[hsurRxCount++] = c;
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 6   

 299   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 300   4                                              hsurRxCount = 0;
 301   4                              }
 302   3                              else
 303   3                              {
 304   4                                      if (c == ASCII_XOFF)
 305   4                                              hsurFlowCtrlXoff = TRUE;
 306   4                                      else if (c == ASCII_XON)
 307   4                                              hsurFlowCtrlXon = TRUE;
 308   4                              }
 309   3                      }
 310   2              }
 311   1      
 312   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 313   1              {
 314   2                      HSUR_RxBufFlowControl();
 315   2      
 316   2                      if (hsurFlowOn == FALSE)
 317   2                      {
 318   3                              if (hsurRxCount >= UR2_FLOW_HI_WATERMARK) // check software buffer status
 319   3                              {
 320   4                                      hsurFlowOn = TRUE;
 321   4                      }
 322   3                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 323   3                              {
 324   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 325   4                              }                       
 326   3                      }       
 327   2              }
 328   1      }
 329          
 330          /*
 331           *--------------------------------------------------------------------------------
 332           * static void hsur_Rcvr(void)
 333           * Purpose : Receiving the byte data from hardware register into software buffer.
 334           * Params  : None
 335           * Returns : None
 336           * Note    : None
 337           *--------------------------------------------------------------------------------
 338           */
 339          static void hsur_Rcvr(void)
 340          {
 341   1              U8_T    far lineStatus = 0;
 342   1      
 343   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 344   1              {
 345   2                      while (1)
 346   2                      {
 347   3                              lineStatus = UR2_LSR;
 348   3                              hsurLineStatusValue = lineStatus;
 349   3              
 350   3                              if (lineStatus & UR2_DR)
 351   3                              {
 352   4                                      if (hsurTxState == 1)
 353   4                                      {
 354   5                                              EA = 0;
 355   5                                              hsurTxFlag = UR2_RBR;
 356   5                                              hsurTxState = 0;
 357   5                                              EA = 1;
 358   5                                      }
 359   4                                      else
 360   4                                      {
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 7   

 361   5                                              hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 362   5                                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 363   5                                              {
 364   6                                                      hsurRxCount = 0;
 365   6                                                      break;
 366   6                                              }
 367   5                                      }
 368   4                              }
 369   3                              else
 370   3                                      break;
 371   3                      }
 372   2              }
 373   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 374   1              {
 375   2                      while (1)
 376   2                      {
 377   3                              lineStatus = UR2_LSR;
 378   3                              hsurLineStatusValue = lineStatus;
 379   3              
 380   3                              if (lineStatus & UR2_DR)
 381   3                              {
 382   4                                      hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 383   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 384   4                                      {
 385   5                                              hsurRxCount = 0;
 386   5                                              break;
 387   5                                      }
 388   4                              }
 389   3                              else                            
 390   3                                      break;
 391   3                      }               
 392   2              }
 393   1              else 
 394   1              {
 395   2                      U8_T    c = 0;
 396   2      
 397   2                      while (1)
 398   2                      {
 399   3                              lineStatus = UR2_LSR;
 400   3                              hsurLineStatusValue = lineStatus;
 401   3              
 402   3                              if (lineStatus & UR2_DR)
 403   3                              {
 404   4                                      c = UR2_RBR;
 405   4      
 406   4                                      if (c != ASCII_XOFF && c != ASCII_XON)
 407   4                                      {
 408   5                                              hsurRxBuffer[hsurRxCount++] = c;
 409   5                                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 410   5                                              {
 411   6                                                      hsurRxCount = 0;
 412   6                                                      break;
 413   6                                              }
 414   5                                      }
 415   4                                      else
 416   4                                      {
 417   5                                              if (c == ASCII_XOFF)
 418   5                                                      hsurFlowCtrlXoff = TRUE;
 419   5                                              else if (c == ASCII_XON)
 420   5                                                      hsurFlowCtrlXon = TRUE;
 421   5                                      }
 422   4                              }
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 8   

 423   3                              else
 424   3                                      break;
 425   3                      }
 426   2              }
 427   1      
 428   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 429   1                      HSUR_RxBufFlowControl();
 430   1      }
 431          
 432          /*
 433           *--------------------------------------------------------------------------------
 434           * static void hsur_Xmit(void)
 435           * Purpose : Transmitting the byte data from software buffer into hardware register.
 436           * Params  : None
 437           * Returns : None
 438           * Note    : None
 439           *--------------------------------------------------------------------------------
 440           */
 441          static void hsur_Xmit(void)
 442          {
 443   1              U8_T far        i = 0;
 444   1      
 445   1              for (i=0 ; i<UR2_TX_BUF_LEVEL ; i++)
 446   1              {
 447   2                      if (hsurTxCount > 0)
 448   2                      {
 449   3                              UR2_THR = hsurTxBuffer[hsurTxBufNum];
 450   3                              hsurTxBufNum ++;
 451   3                              hsurTxCount --;
 452   3      
 453   3                              if (hsurTxBufNum == UR2_MAX_TX_SIZE)
 454   3                                      hsurTxBufNum = 0; 
 455   3      
 456   3                              if ((hsurFlowCtrl == UR2_FLOW_CTRL_HW) || (hsurFlowCtrl == UR2_FLOW_CTRL_X))
 457   3                              {
 458   4                                      HSUR_TxBufFlowControl();
 459   4                              }
 460   3                      
 461   3                              if (hsurTxCount <= 0)
 462   3                              {               
 463   4                                      UR2_IER &= ~UR2_THRI_ENB;
 464   4                                      return;
 465   4                              }
 466   3                      }
 467   2                      else
 468   2                      {
 469   3                              UR2_IER &= ~UR2_THRI_ENB;
 470   3                              return;
 471   3                      }
 472   2              }
 473   1      }
 474          
 475          /*
 476           *--------------------------------------------------------------------------------
 477           * static void hsur_ReadMsr(void)
 478           * Purpose : Reading the modem status register.
 479           * Params  : None
 480           * Returns : None
 481           * Note    : None
 482           *--------------------------------------------------------------------------------
 483           */
 484          static void hsur_ReadMsr(void)
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 9   

 485          {
 486   1              hsurModemStatusValue = UR2_MSR;
 487   1      
 488   1              if (hsurModemStatusValue & UR2_DCTS)
 489   1              {
 490   2                      if (hsurModemStatusValue & UR2_CTS)
 491   2                      {
 492   3                              HSUR_SetRTS();
 493   3                              hsurFlowCtrlHwCTSon = TRUE;
 494   3                      }
 495   2                      else
 496   2                      {
 497   3                              HSUR_ClearRTS();
 498   3                              hsurFlowCtrlHwCTSon = FALSE;
 499   3                      }
 500   2              }
 501   1      
 502   1              if (hsurModemStatusValue & UR2_DDSR)
 503   1              {
 504   2                      if (hsurModemStatusValue & UR2_DSR)
 505   2                      {
 506   3                              HSUR_SetDTR();
 507   3                      }
 508   2                      else
 509   2                      {
 510   3                              HSUR_ClearDTR();
 511   3                      }
 512   2              }
 513   1      
 514   1              if (hsurModemStatusValue & UR2_TERI)
 515   1              {
 516   2                      if (hsurModemStatusValue & UR2_RI)
 517   2                      {
 518   3                              UR2_MCR |= UR2_OUT1;
 519   3                              hsurModemControlValue |= UR2_OUT1;
 520   3                      }
 521   2                      else
 522   2                      {
 523   3                              UR2_MCR &= ~UR2_OUT1;
 524   3                              hsurModemControlValue &= ~UR2_OUT1;
 525   3                      }
 526   2              }
 527   1      
 528   1              if (hsurModemStatusValue & UR2_DDCD)
 529   1              {
 530   2                      if (hsurModemStatusValue & UR2_DCD)
 531   2                      {
 532   3                              UR2_MCR |= UR2_OUT2;
 533   3                              hsurModemControlValue |= UR2_OUT2;
 534   3                      }
 535   2                      else
 536   2                      {
 537   3                              UR2_MCR &= ~UR2_OUT2;
 538   3                              hsurModemControlValue &= ~UR2_OUT2;
 539   3                      }
 540   2              }
 541   1      }
 542          
 543          
 544          /* EXPORTED SUBPROGRAM BODIES */
 545          
 546          /*
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 10  

 547           *--------------------------------------------------------------------------------
 548           * void HSUR_Func(void)
 549           * Purpose : HSUR interrupt function which checks interrupt status.
 550           * Params  : None.
 551           * Returns : None.
 552           * Note    : None.
 553           *--------------------------------------------------------------------------------
 554           */
 555          void HSUR_Func(void)  
 556          {
 557   1              U8_T far intrStatus = 0;
 558   1      
 559   1              intrStatus = UR2_IIR & 0x0F;
 560   1      
 561   1              if (intrStatus == UR2_RLS_INTR)
 562   1              {
 563   2                      hsur_ReadLsr();
 564   2              }
 565   1              else if (intrStatus == UR2_RD_TRIG_INTR)
 566   1              {
 567   2                      UR2_IER &= ~UR2_RDI_ENB;
 568   2                      hsur_RcvrTrig();
 569   2                      uart2_timeout = UART2_TIMEOUT;
 570   2                      UR2_IER |= UR2_RDI_ENB;
 571   2              }
 572   1              else if (intrStatus == UR2_RD_TI_INTR)
 573   1              {
 574   2                      UR2_IER &= ~UR2_RDI_ENB;
 575   2                      hsur_Rcvr();
 576   2                      uart2_timeout = UART2_TIMEOUT;
 577   2                      UR2_IER |= UR2_RDI_ENB;
 578   2              }
 579   1              else if (intrStatus == UR2_THRE_INTR)
 580   1              {
 581   2                      if (hsurFlowCtrl != UR2_FLOW_CTRL_SW )
 582   2                      {
 583   3                              hsur_Xmit();
 584   3                      }
 585   2                      else
 586   2                      {
 587   3                              EA = 0;
 588   3                              hsurTxTransmit = 1;
 589   3                              hsurTxFlag = 0;
 590   3                              UR2_IER &= ~UR2_THRI_ENB;
 591   3                              EA = 1;
 592   3                      }
 593   2              }
 594   1              else if (intrStatus == UR2_MS_INTR)
 595   1              {
 596   2                      hsur_ReadMsr();
 597   2              }
 598   1      }
 599          
 600          /*
 601           *--------------------------------------------------------------------------------
 602           * void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 603           * Purpose : Setup the HSUR mode. Before using the HSUR of AX11000, this function
 604           *           must be executed to initiate.
 605           * Params  : divisor - A divisor value used to calculate the baud rate of HSUR.
 606           *           lCtrl - Line control register value.
 607           *           intEnb - Interrupt enable register value.
 608           *           fCtrl - FIFO control register value.
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 11  

 609           *           mCtrl - Modem control register value.
 610           * Returns : None.
 611           * Note    : None.
 612           *--------------------------------------------------------------------------------
 613           */
 614          void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 615          {
 616   1              U16_T    i;               /*far*/
 617   1      
 618   1      
 619   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 620   1              {
 621   2                      hsurRxBuffer[i] = 0;
 622   2              }
 623   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 624   1              {
 625   2                      hsurTxBuffer[i] = 0;
 626   2              }
 627   1      
 628   1      
 629   1              hsurRxBufNum = 0;
 630   1              hsurTxBufNum = 0;
 631   1              hsurRxCount = 0;
 632   1              hsurTxCount = 0;
 633   1              hsurGetPtr = 0;
 634   1              hsurPutPtr = 0;
 635   1      
 636   1              switch (fCtrl & 0xC0)
 637   1              {
 638   2                      case UR2_TRIG_01 :
 639   2                              hsurRxTrigLvl = 1;
 640   2                              break;
 641   2                      case UR2_TRIG_04 :
 642   2                              hsurRxTrigLvl = 4;
 643   2                              break;
 644   2                      case UR2_TRIG_08 :
 645   2                              hsurRxTrigLvl = 8;
 646   2                              break;
 647   2                      case UR2_TRIG_14 :
 648   2                              hsurRxTrigLvl = 14;
 649   2                              break;
 650   2              }
 651   1              
 652   1      
 653   1              UR2_LCR = UR2_DLAB_ENB;
 654   1              UR2_DLL = (U8_T)(divisor & 0x00FF);
 655   1              UR2_DLH = (U8_T)((divisor & 0xFF00) >> 8);
 656   1              UR2_LCR &= ~UR2_DLAB_ENB;
 657   1              UR2_LCR = lCtrl;
 658   1              UR2_FCR = fCtrl;
 659   1      
 660   1               
 661   1      
 662   1      #if   HSUR_RS485_ENABLE
 663   1              UR2_MCR = (mCtrl | UR2_RS485_RECEIVE);
 664   1      #else
                      UR2_MCR = mCtrl;
              #endif
 667   1      
 668   1      
 669   1               
 670   1      
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 12  

 671   1              UR2_IER  =  intEnb;                     /* ! */
 672   1      
 673   1      //      test_run(10);
 674   1              
 675   1      
 676   1              hsurLineControlValue = lCtrl;
 677   1              hsurFifoControlValue = fCtrl;
 678   1              hsurModemControlValue = mCtrl;
 679   1      
 680   1              
 681   1      
 682   1      }
 683          /*
 684           *--------------------------------------------------------------------------------
 685           * S8_T HSUR_GetChar(void)
 686           * Purpose : Getting one byte data from the software receiver buffer,
 687           *           which stores data received from a serial bus.
 688           * Params  : None.
 689           * Returns : ch - one byte character in buffer.
 690           * Note    : None.
 691           *--------------------------------------------------------------------------------
 692           */
 693          S8_T HSUR_GetChar(void)
 694          {
 695   1              U8_T    far ch = 0;
 696   1          
 697   1              while (hsurRxCount == 0) ;
 698   1              
 699   1              ch = hsurRxBuffer[hsurGetPtr];
 700   1              EA = 0;
 701   1              hsurGetPtr ++;
 702   1              hsurRxCount --;
 703   1              if (hsurGetPtr == UR2_MAX_RX_SIZE)
 704   1                      hsurGetPtr = 0;
 705   1              EA = 1;
 706   1      
 707   1              if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 708   1              {
 709   2                      if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 710   2                      {
 711   3                              hsurFlowOn = FALSE;
 712   3      
 713   3                              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 714   3                              {
 715   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 716   4                              }
 717   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 718   3                              {
 719   4                                      HSUR_SetRTS();
 720   4                              }
 721   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 722   3                              {
 723   4                                      UR2_THR = ASCII_XON;
 724   4                              }
 725   3                      }
 726   2              }
 727   1      
 728   1              return ch;
 729   1      }
 730          
 731          /*
 732           *--------------------------------------------------------------------------------
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 13  

 733           * S8_T HSUR_PutChar(S8_T ch)
 734           * Purpose : Putting  one byte data into the software transmitter buffer,
 735           *           which stores data that be sent to a serial bus.
 736           * Params  : ch - one byte data will be put into buffer.
 737           * Returns : ch - the same data value will be returned.
 738           * Note    : None.
 739           *--------------------------------------------------------------------------------
 740           */
 741          S8_T HSUR_PutChar(S8_T ch)
 742          {
 743   1              U16_T   far tIdleStart = 0;
 744   1              U16_T   far tIdleStop = 0;
 745   1      
 746   1              if (hsurTxCount >= UR2_MAX_TX_SIZE)
 747   1              {
 748   2      //              printd("U2-TX-Full\r\n");
 749   2                      return FALSE;
 750   2              }
 751   1      
 752   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 753   1              {
 754   2                      UR2_THR = ch;
 755   2                      hsurTxState = 1;
 756   2      
 757   2                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 758   2                      {
 759   3                              tIdleStart = xTickCount;
 760   3                              while (hsurTxTransmit == 0)
 761   3                              {
 762   4                                      tIdleStop =xTickCount;
 763   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 764   4                                      {
 765   5      //                                      PRINTD(DEBUG_MSG, ("Can not transmit in UR2_FLOW_CTRL_SW because of no UR2_THRI_INTR\n\r"));
 766   5                                      }
 767   4                              }
 768   3                      
 769   3                              tIdleStart = xTickCount;
 770   3                              while (hsurTxState == 1)
 771   3                              {
 772   4                                      tIdleStop = xTickCount;
 773   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 774   4                                      {
 775   5      //                                      PRINTD(DEBUG_MSG, ("Do not receive any flow control character in UR2_FLOW_CTRL_SW\n\r"));
 776   5                                      }
 777   4                              }
 778   3              
 779   3                              HSUR_TxBufFlowControl();
 780   3                              hsurTxTransmit = 0;
 781   3                      }
 782   2              }
 783   1              else
 784   1              {
 785   2                      UR2_IER &= ~UR2_THRI_ENB;               
 786   2                      hsurTxBuffer[hsurPutPtr] = ch;
 787   2                      hsurPutPtr ++;
 788   2                      hsurTxCount ++;
 789   2      
 790   2                      if (hsurPutPtr == UR2_MAX_TX_SIZE)
 791   2                              hsurPutPtr = 0;
 792   2              }
 793   1      
 794   1              UR2_IER |= UR2_THRI_ENB;    /* trigger hardware interrupt if hw FIFO empty */
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 14  

 795   1      
 796   1      #if UR2_APP_FLOW_CTRL
 797   1              if (hsurTxCount >= UR2_FLOW_HI_WATERMARK)
 798   1                      return FALSE;
 799   1              else
 800   1                      return TRUE;
 801   1      #else
                      return ch;
              #endif
 804   1      }
 805          
 806          /*
 807          * -----------------------------------------------------------------------------
 808           * void HSUR_InitValue(void)
 809           * Purpose : Initiating all globe value in this driver function.
 810           * Params  : None.
 811           * Returns : None.
 812           * Note    : None.
 813           * ----------------------------------------------------------------------------
 814           */
 815          void HSUR_InitValue(void)
 816          {
 817   1              U8_T    far sysClk = 0;
 818   1              U16_T   far i;
 819   1      
 820   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 821   1              {
 822   2                      hsurRxBuffer[i] = 0;
 823   2              }
 824   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 825   1              {
 826   2                      hsurTxBuffer[i] = 0;
 827   2              }
 828   1      
 829   1              hsurRxBufNum = 0;
 830   1              hsurTxBufNum = 0;
 831   1              hsurRxCount = 0;
 832   1              hsurTxCount = 0;
 833   1              hsurGetPtr = 0;
 834   1              hsurPutPtr = 0;
 835   1      
 836   1                               /* what's it? */
 837   1              sysClk = CSREPR & 0xC0;
 838   1              switch (sysClk)
 839   1              {
 840   2                      case SCS_100M :
 841   2      //                      P3 = 0x10;
 842   2                              break;
 843   2                      case SCS_50M :
 844   2      //                      P3 = 0x50;
 845   2                              break;
 846   2                      case SCS_25M :
 847   2      //                      P3 = 0x25;
 848   2                              break;
 849   2                      default :
 850   2      //                      P3 = 0xAA;
 851   2                              break;
 852   2              }
 853   1      
 854   1      
 855   1      
 856   1      } /* End of UART_Init */
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 15  

 857          
 858          /*
 859           *--------------------------------------------------------------------------------
 860           * S8_T HSUR_GetCharNb(void)
 861           * Purpose : Getting data from the software receiver buffer, which stores data 
 862           *           received from a serial bus. This function is similar to HSUR_GetChar,
 863           *           but this function only check buffer one time.
 864           * Params  : None.
 865           * Returns : ch - one byte data in buffer will be returned if having.
 866           * Note    : None.
 867           *--------------------------------------------------------------------------------
 868           */
 869          //S16_T HSUR_GetCharNb(void)
 870          S8_T HSUR_GetCharNb(void)
 871          {
 872   1              S8_T far ch = 0;
 873   1      
 874   1              UR2_IER &= ~UR2_RDI_ENB;
 875   1       
 876   1              if (hsurRxCount > 0)
 877   1              {
 878   2                      ch = hsurRxBuffer[hsurGetPtr];          
 879   2                      hsurGetPtr++;
 880   2                      hsurRxCount --;
 881   2                      if (hsurGetPtr == UR2_MAX_RX_SIZE)
 882   2                              hsurGetPtr = 0;
 883   2      
 884   2                      if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 885   2                      {
 886   3                              if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 887   3                              {
 888   4                                      hsurFlowOn = FALSE;
 889   4      
 890   4                                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 891   4                                      {
 892   5                                              UR2_THR = FLOW_SW_CONTINUOUS;
 893   5                                      }
 894   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 895   4                                      {
 896   5                                              HSUR_SetRTS();
 897   5                                      }
 898   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 899   4                                      {
 900   5                                              UR2_THR = ASCII_XON;
 901   5                                      }
 902   4                              }
 903   3                      }
 904   2      
 905   2                      UR2_IER |= UR2_RDI_ENB;
 906   2                      return ch;
 907   2              }
 908   1              else
 909   1              {
 910   2                      UR2_IER |= UR2_RDI_ENB;
 911   2              
 912   2                      return -1;
 913   2             // return 1000;
 914   2              }
 915   1      }
 916          
 917          /*
 918           * ----------------------------------------------------------------------------
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 16  

 919           * U16_T HSUR_GetRxBufCount(void)
 920           * Purpose : Getting the remain character number in UART2 Rx buffer.
 921           * Params  : none
 922           * Returns : hsurRxCount - the number of remain character in UART2 Rx buffer.
 923           * Note    : none
 924           * ----------------------------------------------------------------------------
 925           */
 926          U16_T HSUR_GetRxBufCount(void)
 927          {
 928   1              return hsurRxCount;
 929   1      }
 930          
 931          /*
 932           * ----------------------------------------------------------------------------
 933           * void HSUR_SetFlowControl(U8_T mode)
 934           * Purpose : Setting the UART2 flow control mode.
 935           * Params  : mode - flow control mode.
 936           * Returns : none
 937           * Note    : none
 938           * ----------------------------------------------------------------------------
 939           */
 940          void HSUR_SetFlowControl(U8_T mode)
 941          {
 942   1              hsurFlowCtrl = mode;
 943   1      
 944   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 945   1              {
 946   2                      hsurTxTransmit = 0;
 947   2                      hsurTxFlag = 0;
 948   2                      hsurFlowOn = 0;
 949   2              }
 950   1      }
 951          
 952          /*
 953           * ----------------------------------------------------------------------------
 954           * BOOL HSUR_CheckTxComplete(void)
 955           * Purpose : Check the hardware FIFO empty and software Tx buffer empty
 956           * Params  : none
 957           * Returns : TRUE - both empty.
 958           * Note    : none
 959           * ----------------------------------------------------------------------------
 960           */
 961          BOOL HSUR_CheckTxComplete(void)
 962          {
 963   1              if ((UR2_LSR & UR2_THRE) && (hsurTxCount == 0))
 964   1                      return TRUE;
 965   1              else
 966   1                      return FALSE;
 967   1      }
 968          
 969          
 970          /*
 971           * ----------------------------------------------------------------------------
 972           * void HSUR_RxBufFlowControl(void)
 973           * Purpose : Check the receiving buffer space and return the flow control character.
 974           * Params  : none
 975           * Returns : none
 976           * Note    : none
 977           * ----------------------------------------------------------------------------
 978           */
 979          void HSUR_RxBufFlowControl(void)
 980          {
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 17  

 981   1              U8_T    far charFlowCtrl = 0;
 982   1      
 983   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 984   1              {
 985   2                      if (hsurRxCount >= UR2_MAX_RX_SIZE)
 986   2                      {
 987   3                              charFlowCtrl = FLOW_SW_ERROR;
 988   3                      }
 989   2                      else if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
 990   2                      {
 991   3                              hsurFlowOn = TRUE;
 992   3                              charFlowCtrl = FLOW_SW_WAIT;
 993   3                      }
 994   2                      else if ((hsurFlowOn) && (hsurRxCount > UR2_FLOW_LO_WATERMARK))
 995   2                      {
 996   3                              charFlowCtrl = FLOW_SW_WAIT;
 997   3                      }
 998   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
 999   2                      {
1000   3                              hsurFlowOn = FALSE;
1001   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
1002   3                      }
1003   2                      else if (hsurFlowOn == FALSE)
1004   2                      {
1005   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
1006   3                      }
1007   2                      else
1008   2                      {
1009   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
1010   3                      }
1011   2      
1012   2                      UR2_THR = charFlowCtrl;
1013   2              }
1014   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1015   1              {
1016   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
1017   2                      {
1018   3                              hsurFlowOn = TRUE;
1019   3                              UR2_MCR &= ~UR2_RTS;
1020   3                      }
1021   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1022   2                      {
1023   3                              hsurFlowOn = FALSE;
1024   3                              UR2_MCR |= UR2_RTS;
1025   3                      }
1026   2              }
1027   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1028   1              {
1029   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
1030   2                      {
1031   3                              hsurFlowOn = TRUE;
1032   3                              UR2_THR = ASCII_XOFF;
1033   3                      }
1034   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1035   2                      {
1036   3                              hsurFlowOn = FALSE;
1037   3                              UR2_THR = ASCII_XON;
1038   3                      }
1039   2              }
1040   1      }
1041          
1042          /*
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 18  

1043           * ----------------------------------------------------------------------------
1044           * void HSUR_TxBufFlowControl(void)
1045           * Purpose : Check the transmitting flow control character.
1046           * Params  : none
1047           * Returns : none
1048           * Note    : none
1049           * ----------------------------------------------------------------------------
1050           */
1051          void HSUR_TxBufFlowControl(void)
1052          {
1053   1              U8_T    far charFlowCtrl = 0;
1054   1              U16_T   far tIdleStart = 0;
1055   1              U16_T   far tIdleStop = 0;
1056   1              
1057   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1058   1              {
1059   2                      if (hsurFlowCtrlHwCTSon == TRUE)
1060   2                      {
1061   3                              return;
1062   3                      }
1063   2      
1064   2                      tIdleStart = xTickCount;
1065   2                      while (1)
1066   2                      {
1067   3                              if (hsurFlowCtrlHwCTSon == TRUE)
1068   3                              {
1069   4                                      return;
1070   4                              }
1071   3                              else
1072   3                              {
1073   4                                      tIdleStop = xTickCount;
1074   4      
1075   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 1)
1076   4                                      {
1077   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_HW\n\r"));
1078   5                                      }
1079   4                              }
1080   3                      }
1081   2              }
1082   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1083   1              {
1084   2                      if (hsurFlowCtrlXoff == TRUE)
1085   2                      {
1086   3                              hsurFlowCtrlXoff = FALSE;
1087   3              
1088   3                              tIdleStart = xTickCount;
1089   3                              while (1)
1090   3                              {
1091   4                                      if (hsurFlowCtrlXon == TRUE)
1092   4                                      {
1093   5                                              hsurFlowCtrlXon = FALSE;
1094   5      
1095   5                                              break;
1096   5                                      }
1097   4                                      else
1098   4                                      {
1099   5                                              tIdleStop = xTickCount;
1100   5                                              if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1101   5                                              {
1102   6      //                                              PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_X\n\r"));
1103   6                                              }
1104   5                                      }
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 19  

1105   4                              }
1106   3                      }
1107   2              }
1108   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
1109   1              {
1110   2                      tIdleStart = xTickCount;
1111   2                      while (1)
1112   2                      {
1113   3                              charFlowCtrl = hsurTxFlag;
1114   3                              if (charFlowCtrl == FLOW_SW_CONTINUOUS)
1115   3                                      break;
1116   3                              else if (charFlowCtrl == FLOW_SW_ERROR)
1117   3                                      UR2_IER &= ~UR2_THRI_ENB;
1118   3                              else
1119   3                              {
1120   4                                      tIdleStop =xTickCount;
1121   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1122   4                                      {
1123   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_SW\n\r"));
1124   5                                      }
1125   4                              }
1126   3                      }
1127   2              }
1128   1      }
1129          
1130          /*
1131           * ----------------------------------------------------------------------------
1132           * void HSUR_ErrorRecovery(void)
1133           * Purpose : Checking the HSUR Line Status Register value of errors and
1134           *           re-enable interrupt of receiving and line status.
1135           * Params  : none
1136           * Returns : none
1137           * Note    : none
1138           * ----------------------------------------------------------------------------
1139           */
1140          void HSUR_ErrorRecovery(void)
1141          {
1142   1              if (hsurErrBlocking)
1143   1              {
1144   2                      U8_T    far lsrVal = UR2_LSR;
1145   2                      U8_T    far trash = 0;
1146   2      
1147   2      //              printd("hsurErrBlocking = 1\n\r");
1148   2                      if (lsrVal & UR2_DR)
1149   2                      {
1150   3                              trash = UR2_RBR;
1151   3                      }
1152   2                      else if (!(lsrVal & UR2_DR) && (hsurErrorCount >= 30))
1153   2                      {
1154   3      //                      printd("clear hsurErrBlocking = 0\n\r");
1155   3                              EA = 0;
1156   3                              UR2_IER |= (UR2_RDI_ENB | UR2_RLSI_ENB | UR2_MSI_ENB);
1157   3                              hsurErrBlocking = 0;
1158   3                              hsurErrorCount = 0;
1159   3                              EA = 1;
1160   3                      }
1161   2              }
1162   1      }
1163          
1164          /*
1165           * ----------------------------------------------------------------------------
1166           * BOOL HSUR_SetBaudRate(U16_T divBaudRate)
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 20  

1167           * Purpose : Setting the HSUR baudrate.
1168           * Params  : divBaudRate - divisor of the baudrate.
1169           * Returns : TRUE - setting complete.
1170           * Note    : none
1171           * ----------------------------------------------------------------------------
1172           */
1173          BOOL HSUR_SetBaudRate(U16_T divBaudRate)
1174          {
1175   1              U8_T    far recIntrEnb = UR2_IER;
1176   1      
1177   1              UR2_IER = 0;
1178   1              UR2_LCR |= UR2_DLAB_ENB;
1179   1              UR2_DLL = (U8_T)(divBaudRate & 0x00FF);
1180   1              UR2_DLH = (U8_T)((divBaudRate & 0xFF00) >> 8);
1181   1              UR2_LCR &= ~UR2_DLAB_ENB;
1182   1      
1183   1              hsurBaudRateDivisor = divBaudRate;
1184   1      
1185   1              switch (CSREPR & 0xC0)
1186   1              {
1187   2                      case SCS_100M :
1188   2      //                      P3 = 0x10;
1189   2                              break;
1190   2                      case SCS_50M :
1191   2      //                      P3 = 0x50;
1192   2                              break;
1193   2                      case SCS_25M :
1194   2      //                      P3 = 0x25;
1195   2                              break;
1196   2              }
1197   1      
1198   1              UR2_FCR |= UR2_RXFIFO_RST | UR2_TXFIFO_RST;
1199   1              UR2_IER = recIntrEnb;
1200   1      
1201   1              return TRUE;
1202   1      }
1203          
1204          /*
1205           * ----------------------------------------------------------------------------
1206           * void HSUR_SetLineControl(U8_T value)
1207           * Purpose : Setting the HSUR Line control register with "value".
1208           * Params  : value - variable to be set.
1209           * Returns : none
1210           * Note    : none
1211           * ----------------------------------------------------------------------------
1212           */
1213          void HSUR_SetLineControl(U8_T value)
1214          {
1215   1              U8_T    recIntrEnb = UR2_IER;
1216   1      
1217   1              UR2_IER = 0;
1218   1              UR2_LCR = value;
1219   1              hsurLineControlValue = value;
1220   1              UR2_IER = recIntrEnb;
1221   1      }
1222          
1223          /*
1224           * ----------------------------------------------------------------------------
1225           * void HSUR_SetFifoControl(U8_T value)
1226           * Purpose : Setting the HSUR FIFO control register with "value".
1227           * Params  : value - variable to be set.
1228           * Returns : none
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 21  

1229           * Note    : none
1230           * ----------------------------------------------------------------------------
1231           */
1232          void HSUR_SetFifoControl(U8_T value)
1233          {
1234   1              U8_T    far recIntrEnb = UR2_IER;
1235   1      
1236   1              UR2_IER = 0;
1237   1              UR2_FCR = value;
1238   1              hsurFifoControlValue = value;
1239   1              UR2_IER = recIntrEnb;
1240   1      }
1241          
1242          /*
1243           * ----------------------------------------------------------------------------
1244           * void HSUR_SetModemControl(U8_T value)
1245           * Purpose : Setting the HSUR Modem control register with "value".
1246           * Params  : value - variable to be set.
1247           * Returns : none
1248           * Note    : none
1249           * ----------------------------------------------------------------------------
1250           */
1251          void HSUR_SetModemControl(U8_T value)
1252          {
1253   1              U8_T    far recIntrEnb = UR2_IER;
1254   1      
1255   1              UR2_IER = 0;
1256   1              UR2_MCR = value;
1257   1              hsurModemControlValue = value;
1258   1              UR2_IER = recIntrEnb;
1259   1      }
1260          
1261          /*
1262           * ----------------------------------------------------------------------------
1263           * void HSUR_SetRTS(void)
1264           * Purpose : Only setting the HSUR RTS bit of Modem control register.
1265           * Params  : none
1266           * Returns : none
1267           * Note    : none
1268           * ----------------------------------------------------------------------------
1269           */
1270          void HSUR_SetRTS(void)
1271          {
1272   1              U8_T    far recIntrEnb = UR2_IER;
1273   1      
1274   1              UR2_IER = 0;
1275   1              UR2_MCR |= UR2_RTS;
1276   1              hsurModemControlValue |= UR2_RTS;
1277   1              UR2_IER = recIntrEnb;
1278   1      }
1279          
1280          /*
1281           * ----------------------------------------------------------------------------
1282           * void HSUR_SetDTR(void)
1283           * Purpose : Only setting the HSUR DTR bit of Modem control register.
1284           * Params  : none
1285           * Returns : none
1286           * Note    : none
1287           * ----------------------------------------------------------------------------
1288           */
1289          void HSUR_SetDTR(void)
1290          {
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 22  

1291   1              U8_T    far recIntrEnb = UR2_IER;
1292   1      
1293   1              UR2_IER = 0;
1294   1              UR2_MCR |= UR2_DTR;
1295   1              hsurModemControlValue |= UR2_DTR;
1296   1              UR2_IER = recIntrEnb;
1297   1      }
1298          
1299          /*
1300           * ----------------------------------------------------------------------------
1301           * void HSUR_ClearRTS(void)
1302           * Purpose : Only clear the HSUR RTS bit of Modem control register.
1303           * Params  : none
1304           * Returns : none
1305           * Note    : none
1306           * ----------------------------------------------------------------------------
1307           */
1308          void HSUR_ClearRTS(void)
1309          {
1310   1              UR2_MCR &= ~UR2_RTS;
1311   1              hsurModemControlValue &= ~UR2_RTS;
1312   1      }
1313          
1314          /*
1315           * ----------------------------------------------------------------------------
1316           * void HSUR_ClearDTR(void)
1317           * Purpose : Only clear the HSUR DTR bit of Modem control register.
1318           * Params  : none
1319           * Returns : none
1320           * Note    : none
1321           * ----------------------------------------------------------------------------
1322           */
1323          void HSUR_ClearDTR(void)
1324          {
1325   1              UR2_MCR &= ~UR2_DTR;
1326   1              hsurModemControlValue &= ~UR2_DTR;
1327   1      }
1328          
1329          /*
1330           * ----------------------------------------------------------------------------
1331           * U16_T HSUR_GetBaudRate(void)
1332           * Purpose : Getting the HSUR baudrate divisor.
1333           * Params  : none
1334           * Returns : divBaudRate - baudrate divisor.
1335           * Note    : none
1336           * ----------------------------------------------------------------------------
1337           */
1338          U16_T HSUR_GetBaudRate(void)
1339          {
1340   1              U16_T   far divBaudRate = 0;
1341   1      
1342   1              switch (CSREPR & 0xC0)
1343   1              {
1344   2                      case SCS_100M :
1345   2      //                      P3 = 0x10;
1346   2                              UR2_LCR |= UR2_DLAB_ENB;
1347   2                              switch (hsurBaudRateDivisor)
1348   2                              {
1349   3                                      case UR2_BR100_921600 :
1350   3                                              divBaudRate = UR2_BR100_921600;
1351   3                                              break;
1352   3                                      case UR2_BR100_115200 :
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 23  

1353   3                                              divBaudRate = UR2_BR100_115200;
1354   3                                              break;
1355   3                                      case UR2_BR100_57600 :
1356   3                                              divBaudRate = UR2_BR100_57600;
1357   3                                              break;
1358   3                                      case UR2_BR100_38400 :
1359   3                                              divBaudRate = UR2_BR100_38400;
1360   3                                              break;
1361   3                                      case UR2_BR100_19200 :
1362   3                                              divBaudRate = UR2_BR100_19200;
1363   3                                              break;
1364   3                                      case UR2_BR100_9600 :
1365   3                                              divBaudRate = UR2_BR100_9600;
1366   3                                              break;
1367   3                                      case UR2_BR100_7200 :
1368   3                                              divBaudRate = UR2_BR100_7200;
1369   3                                              break;
1370   3                                      case UR2_BR100_4800 :
1371   3                                              divBaudRate = UR2_BR100_4800;
1372   3                                              break;
1373   3                                      case UR2_BR100_3600 :
1374   3                                              divBaudRate = UR2_BR100_3600;
1375   3                                              break;
1376   3                                      case UR2_BR100_2400 :
1377   3                                              divBaudRate = UR2_BR100_2400;
1378   3                                              break;
1379   3                                      case UR2_BR100_1200 :
1380   3                                              divBaudRate = UR2_BR100_1200;
1381   3                                              break;
1382   3                              }
1383   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1384   2                              break;
1385   2                      case SCS_50M :
1386   2      //                      P3 = 0x50;
1387   2                              UR2_LCR |= UR2_DLAB_ENB;
1388   2                              switch (hsurBaudRateDivisor)
1389   2                              {
1390   3                                      case UR2_BR50_921600 :
1391   3                                              divBaudRate = UR2_BR50_921600;
1392   3                                              break;
1393   3                                      case UR2_BR50_115200 :
1394   3                                              divBaudRate = UR2_BR50_115200;
1395   3                                              break;
1396   3                                      case UR2_BR50_57600 :
1397   3                                              divBaudRate = UR2_BR50_57600;
1398   3                                              break;
1399   3                                      case UR2_BR50_38400 :
1400   3                                              divBaudRate = UR2_BR50_38400;
1401   3                                              break;
1402   3                                      case UR2_BR50_19200 :
1403   3                                              divBaudRate = UR2_BR50_19200;
1404   3                                              break;
1405   3                                      case UR2_BR50_9600 :
1406   3                                              divBaudRate = UR2_BR50_9600;
1407   3                                              break;
1408   3                                      case UR2_BR50_7200 :
1409   3                                              divBaudRate = UR2_BR50_7200;
1410   3                                              break;
1411   3                                      case UR2_BR50_4800 :
1412   3                                              divBaudRate = UR2_BR50_4800;
1413   3                                              break;
1414   3                                      case UR2_BR50_3600 :
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 24  

1415   3                                              divBaudRate = UR2_BR50_3600;
1416   3                                              break;
1417   3                                      case UR2_BR50_2400 :
1418   3                                              divBaudRate = UR2_BR50_2400;
1419   3                                              break;
1420   3                                      case UR2_BR50_1200 :
1421   3                                              divBaudRate = UR2_BR50_1200;
1422   3                                              break;
1423   3                              }
1424   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1425   2                              break;
1426   2                      case SCS_25M :
1427   2      //                      P3 = 0x25;
1428   2                              UR2_LCR |= UR2_DLAB_ENB;
1429   2                              switch (hsurBaudRateDivisor)
1430   2                              {
1431   3                                      case UR2_BR25_921600 :
1432   3                                              divBaudRate = UR2_BR25_921600;
1433   3                                              break;
1434   3                                      case UR2_BR25_115200 :
1435   3                                              divBaudRate = UR2_BR25_115200;
1436   3                                              break;
1437   3                                      case UR2_BR25_57600 :
1438   3                                              divBaudRate = UR2_BR25_57600;
1439   3                                              break;
1440   3                                      case UR2_BR25_38400 :
1441   3                                              divBaudRate = UR2_BR25_38400;
1442   3                                              break;
1443   3                                      case UR2_BR25_19200 :
1444   3                                              divBaudRate = UR2_BR25_19200;
1445   3                                              break;
1446   3                                      case UR2_BR25_9600 :
1447   3                                              divBaudRate = UR2_BR25_9600;
1448   3                                              break;
1449   3                                      case UR2_BR25_7200 :
1450   3                                              divBaudRate = UR2_BR25_7200;
1451   3                                              break;
1452   3                                      case UR2_BR25_4800 :
1453   3                                              divBaudRate = UR2_BR25_4800;
1454   3                                              break;
1455   3                                      case UR2_BR25_3600 :
1456   3                                              divBaudRate = UR2_BR25_3600;
1457   3                                              break;
1458   3                                      case UR2_BR25_2400 :
1459   3                                              divBaudRate = UR2_BR25_2400;
1460   3                                              break;
1461   3                                      case UR2_BR25_1200 :
1462   3                                              divBaudRate = UR2_BR25_1200;
1463   3                                              break;
1464   3                              }
1465   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1466   2                              break;
1467   2              }
1468   1              
1469   1              return TRUE;
1470   1      }
1471          
1472          /*
1473           * ----------------------------------------------------------------------------
1474           * U8_T HSUR_GetLineControl(void)
1475           * Purpose : Getting the HSUR Line Control register variables.
1476           * Params  : none
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 25  

1477           * Returns : varLineCtrl.
1478           * Note    : none
1479           * ----------------------------------------------------------------------------
1480           */
1481          U8_T HSUR_GetLineControl(void)
1482          {
1483   1              U8_T    far varLineCtrl = 0;
1484   1      
1485   1              varLineCtrl = UR2_LCR;
1486   1      
1487   1              return varLineCtrl;
1488   1      }
1489          
1490          /*
1491           * ----------------------------------------------------------------------------
1492           * U8_T HSUR_GetFifoControl(void)
1493           * Purpose : Getting the HSUR FIFO Control register variables.
1494           * Params  : none
1495           * Returns : hsurFifoControlValue.
1496           * Note    : none
1497           * ----------------------------------------------------------------------------
1498           */
1499          U8_T HSUR_GetFifoControl(void)
1500          {
1501   1              return hsurFifoControlValue;
1502   1      }
1503          
1504          /*
1505           * ----------------------------------------------------------------------------
1506           * U8_T HSUR_GetModemControl(void)
1507           * Purpose : Getting the HSUR Modem Control register variables.
1508           * Params  : none
1509           * Returns : hsurModemControlValue.
1510           * Note    : none
1511           * ----------------------------------------------------------------------------
1512           */
1513          U8_T HSUR_GetModemControl(void)
1514          {
1515   1              return hsurModemControlValue;
1516   1      }
1517          
1518          /*
1519           * ----------------------------------------------------------------------------
1520           * U8_T HSUR_GetLineStatus(U8_T intrSynth)
1521           * Purpose : Getting the HSUR Line Status .
1522           * Params  : intrSynth - 1: Get LSR according to an interrupt trigger.
1523           *                       0: Get LSR by directly reading the register.
1524           * Returns : varLineStatus - Line status register variable.
1525           * Note    : none
1526           * ----------------------------------------------------------------------------
1527           */
1528          U8_T HSUR_GetLineStatus(U8_T intrSynth)
1529          {
1530   1              U8_T    far varLineStatus = 0;
1531   1      
1532   1              if (intrSynth == TRUE)
1533   1                      varLineStatus = hsurLineStatusValue;
1534   1              else if (intrSynth == FALSE)
1535   1                      varLineStatus = UR2_LSR;
1536   1      
1537   1              return varLineStatus;
1538   1      }
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 26  

1539          
1540          /*
1541           * ----------------------------------------------------------------------------
1542           * U8_T HSUR_GetModemStatus(U8_T intrSynth)
1543           * Purpose : Getting the HSUR Modem Status .
1544           * Params  : intrSynth - 1: Get MSR according to an interrupt trigger.
1545           *                       0: Get MSR by directly reading the register.
1546           * Returns : varModemStatus - Modem status register variable.
1547           * Note    : none
1548           * ----------------------------------------------------------------------------
1549           */
1550          U8_T HSUR_GetModemStatus(U8_T intrSynth)
1551          {
1552   1              U8_T    far varModemStatus = 0;
1553   1      
1554   1              if (intrSynth == TRUE)
1555   1                      varModemStatus = hsurModemStatusValue;
1556   1              else if (intrSynth == FALSE)
1557   1                      varModemStatus = UR2_MSR;
1558   1      
1559   1              return varModemStatus;
1560   1      }
1561          
1562          /*
1563           * ----------------------------------------------------------------------------
1564           * BOOL HSUR_XonByApp(void)
1565           * Purpose : Application issue flow control characters Xon to driver for
1566           *           stopping or starting the current transfer.
1567           * Params  : none
1568           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1569           *           FLASE - driver is not in Xon/Xoff flow control.
1570           * Note    : none
1571           * ----------------------------------------------------------------------------
1572           */
1573          BOOL HSUR_XonToApp(void)
1574          {
1575   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1576   1              {
1577   2                      return FALSE;
1578   2              }
1579   1      
1580   1              hsurAppFlowOn = TRUE;
1581   1      
1582   1              return TRUE;
1583   1      }
1584          
1585          /*
1586           * ----------------------------------------------------------------------------
1587           * BOOL HSUR_XoffByApp(void)
1588           * Purpose : Application issue flow control characters Xoff to driver for
1589           *           stopping or starting the current transfer.
1590           * Params  : none
1591           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1592           *           FLASE - driver is not in Xon/Xoff flow control.
1593           * Note    : none
1594           * ----------------------------------------------------------------------------
1595           */
1596          BOOL HSUR_XoffByApp(void)
1597          {
1598   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1599   1              {
1600   2                      return FALSE;
C51 COMPILER V9.06   HSUART                                                                03/13/2013 09:32:23 PAGE 27  

1601   2              }
1602   1      
1603   1              hsurAppFlowOn = FALSE;
1604   1      
1605   1              return TRUE;
1606   1      }
1607          /* End of hsuart.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4487    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1095    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
