C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE HSUART
OBJECT MODULE PLACED IN .\hsuart.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\hsur\hsuart.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\
                    -src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\hsuart.lst) 
                    -OBJECT(.\hsuart.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : hsuart.c
  13           * Purpose     : The High Speed UART module driver. It manages the character
  14           *               buffer and handles the ISR.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-09
  17           * Notes       : None.
  18           * $Log: hsuart.c,v $
  19           * Revision 1.20  2006/07/25 03:41:23  robin6633
  20           * 1.Add Xon/Xoff counter for debugging.
  21           *
  22           * Revision 1.19  2006/07/24 06:40:51  robin6633
  23           * 1.Fixed the XON/XOFF ASCII is put into hardware transmitting register driectly.
  24           *
  25           * Revision 1.18  2006/07/21 11:24:55  robin6633
  26           * 1.Add flow control check in hsurFlowOn==1.
  27           *
  28           * Revision 1.17  2006/07/19 08:51:24  robin6633
  29           * 1.Fixed Hardware flow control function.
  30           * 2.Extern a function HSUR_GetLineStatus() to get UR2_LSR.
  31           *
  32           * Revision 1.16  2006/07/18 08:03:59  robin6633
  33           * 1.Fixed Tx flow control in software flow control mode.
  34           *
  35           * Revision 1.15  2006/06/30 06:17:01  robin6633
  36           * 1.Fixed software flow control in first initial.
  37           *
  38           * Revision 1.14  2006/06/27 10:45:24  robin6633
  39           * 1.Add flow control for transmitting.
  40           *
  41           * Revision 1.13  2006/06/19 14:20:57  robin6633
  42           * 1.Protect transmit counter and pointer.
  43           * 2.Force transmit more data if transmit fifo empty.
  44           *
  45           * Revision 1.12  2006/06/11 02:18:49  robin6633
  46           * 1.Add Xon/Xoff.
  47           *
  48           * Revision 1.11  2006/06/05 06:21:43  robin6633
  49           * 1.Fixed function declaration.
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 2   

  50           *    U8_T HSUR_RxBufFlowControl(void) -> void HSUR_RxBufFlowControl(void)
  51           * 2.Fixed hsur_ReadLsr() & hsur_ReadMsr().
  52           *
  53           * Revision 1.10  2006/06/05 01:30:44  robin6633
  54           * 1.Fixed software flow control and prevented the hardware FIFO overrun.
  55           *
  56           * Revision 1.9  2006/05/24 05:40:34  robin6633
  57           * 1.Add flow control water mark.
  58           *
  59           * Revision 1.8  2006/05/23 11:07:51  robin6633
  60           * 1.Enable flow control code.
  61           *
  62           * Revision 1.7  2006/05/22 13:23:42  robin6633
  63           * 1.Fixed buffer overwrite.
  64           *
  65           * Revision 1.6  2006/05/22 07:39:28  robin6633
  66           * 1.Disable flow control.
  67           *
  68           * Revision 1.5  2006/05/19 06:37:13  robin6633
  69           * 1.Fixed the baudrate setup for default configuration.
  70           *
  71           * Revision 1.4  2006/05/19 03:48:37  robin6633
  72           * 1.Add Xon/Xoff flow control.
  73           * 2.Expand an external function HSUR_ChangeBaud(U8_T baud).
  74           *
  75           * Revision 1.3  2006/05/18 09:57:55  Louis
  76           * no message
  77           *
  78           * Revision 1.2  2006/05/18 02:27:56  robin6633
  79           * 1.Removed printf in UART2.
  80           *
  81           * Revision 1.1  2006/05/15 03:06:52  robin6633
  82           * no message
  83           *
  84           * Revision 1.3  2006/05/03 02:42:30  robin6633
  85           * Changed the the function name HSUR_GetBufCount()
  86           * to HSUR_GetRxBufCount() .
  87           *
  88           * Revision 1.2  2006/05/02 01:44:07  robin6633
  89           * Add an expanding function to get the counter value of UART2 software buffer.
  90           *
  91           * Revision 1.1  2006/04/07 11:38:18  robin6633
  92           * no message
  93           *
  94           *================================================================================
  95           */
  96          
  97          /* INCLUDE FILE DECLARATIONS */
  98          #include        "reg80390.h"
  99          #include        "types.h"
 100          #include        "uart.h"
 101          #include        "mstimer.h"
 102          #include        "hsuart.h"
 103          #include        "string.h"
 104          
 105          
 106          /* STATIC VARIABLE DECLARATIONS */
 107          
 108          U8_T far hsurRxBuffer[UR2_MAX_RX_SIZE];
 109          static U8_T     far     hsurTxBuffer[UR2_MAX_TX_SIZE];
 110          static U16_T far        hsurRxBufNum = 0;
 111          static U16_T far        hsurTxBufNum = 0;
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 3   

 112          static U8_T      far    hsurRxTrigLvl = 0;
 113          U16_T   far hsurRxCount = 0;
 114          static S16_T far        hsurTxCount = 0;
 115          static U16_T far        hsurGetPtr = 0;
 116          static U16_T far        hsurPutPtr = 0;
 117          static U8_T      far    hsurFlowCtrl = 0;
 118          static U8_T      far    hsurFlowOn = 0;
 119          static U8_T      far    hsurTxTransmit = 0;
 120          static U8_T      far    hsurTxFlag = 0;
 121          static U8_T      far    hsurTxState = 0;
 122          static U16_T far        hsurErrorCount = 0;
 123          static U32_T far        hsurErrTimeStart = 0;
 124          static U32_T far        hsurErrTimeStop = 0;
 125          static U8_T      far    hsurErrBlocking = 0;
 126          static U16_T far        hsurBaudRateDivisor = 0;
 127          static U8_T      far    hsurLineStatusValue = 0;
 128          static U8_T      far    hsurModemStatusValue = 0;       
 129          static U8_T      far    hsurLineControlValue = 0;
 130          static U8_T      far    hsurModemControlValue = 0;
 131          static U8_T      far    hsurFifoControlValue = 0;
 132          static U8_T      far    hsurAppFlowOn = 0;
 133          static U8_T     far  hsurFlowCtrlXoff = FALSE;
 134          static U8_T    far  hsurFlowCtrlXon = FALSE;
 135          static U8_T      far    hsurFlowCtrlHwCTSon = FALSE;
 136          
 137          U8_T far uart2_timeout = UART2_TIMEOUT;
 138          
 139          /* LOCAL SUBPROGRAM DECLARATIONS */
 140          static void             hsur_ReadLsr(void);
 141          static void             hsur_RcvrTrig(void);
 142          static void             hsur_Rcvr(void);
 143          static void             hsur_Xmit(void);
 144          static void             hsur_ReadMsr(void);
 145          
 146          
 147          extern volatile U32_T xTickCount;
 148          /* LOCAL SUBPROGRAM BODIES */
 149          
 150          /*
 151           *--------------------------------------------------------------------------------
 152           * static void hsur_ReadLsr(void)
 153           * Purpose : Read Line Status Register and display.
 154           * Params  : None
 155           * Returns : None
 156           * Note    : None
 157           *--------------------------------------------------------------------------------
 158           */
 159          static void hsur_ReadLsr(void)
 160          {
 161   1              hsurLineStatusValue = UR2_LSR;
 162   1      
 163   1              if (hsurLineStatusValue & UR2_OE)
 164   1              {
 165   2                      // Overrun Error
 166   2                      hsurErrorCount ++;
 167   2      //              P3 = BIT0;
 168   2              }
 169   1              if (hsurLineStatusValue & UR2_PE)
 170   1              {
 171   2                      // Parity Error
 172   2                      hsurErrorCount ++;
 173   2      //              P3 = BIT1;
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 4   

 174   2              }
 175   1              if (hsurLineStatusValue & UR2_FE)
 176   1              {
 177   2                      // Framing Error
 178   2                      hsurErrorCount ++;
 179   2      //              P3 = BIT2;
 180   2              }
 181   1              if (hsurLineStatusValue & UR2_BI)
 182   1              {
 183   2                      // Break Interrupt Occured
 184   2                      hsurErrorCount ++;
 185   2      //              P3 = BIT3;
 186   2              }
 187   1              if (hsurLineStatusValue & UR2_FRAME_ERR)
 188   1              {
 189   2                      // Mixing Error
 190   2                      hsurErrorCount ++;
 191   2      //              P3 = BIT4;
 192   2              }
 193   1      
 194   1              if (hsurErrorCount)
 195   1              {
 196   2                      UR2_FCR |= UR2_RXFIFO_RST;
 197   2      
 198   2                      if (hsurErrorCount >=30)
 199   2                      {
 200   3                              hsurErrTimeStop = xTickCount;
 201   3                              if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) <= 2000)
 202   3                              {
 203   4                                      UR2_IER = 0;
 204   4                                      hsurErrBlocking = 1;
 205   4                              }
 206   3                              else
 207   3                              {
 208   4                                      hsurErrBlocking = 0;
 209   4                                      hsurErrTimeStart = 0;
 210   4                                      hsurErrorCount = 0;
 211   4                              }
 212   3                      }
 213   2                      else// if (hsurErrorCount < 30)
 214   2                      {
 215   3                              U8_T trash;
 216   3      
 217   3                              while (UR2_LSR & UR2_DR)
 218   3                              {
 219   4                                      trash = UR2_RBR;
 220   4                              }
 221   3      
 222   3                              if ((hsurErrTimeStart == 0) && (hsurErrorCount < 5))
 223   3                              {
 224   4                                      hsurErrTimeStart = xTickCount;
 225   4                              }
 226   3                              else
 227   3                              {
 228   4                                      hsurErrTimeStop = xTickCount;
 229   4                                      if (((hsurErrTimeStop - hsurErrTimeStart) * SWTIMER_INTERVAL) > 2000)
 230   4                                      {
 231   5                                              hsurErrBlocking = 0;
 232   5                                              hsurErrTimeStart = 0;
 233   5                                              hsurErrorCount = 0;
 234   5                                      }
 235   4                              }
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 5   

 236   3                      }
 237   2              }
 238   1      
 239   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 240   1              {
 241   2                      UR2_THR = FLOW_SW_ERROR;
 242   2              }       
 243   1      }
 244          
 245          /*
 246           *--------------------------------------------------------------------------------
 247           * static void hsur_RcvrTrig(void)
 248           * Purpose : Get data and put into the receiver buffer continuously until trigger bytes
 249           * Params  : None
 250           * Returns : None
 251           * Note    : None
 252           *--------------------------------------------------------------------------------
 253           */
 254          static void hsur_RcvrTrig(void)
 255          {
 256   1              U8_T    c;
 257   1              U16_T   i;
 258   1      
 259   1              if (hsurRxCount >= UR2_MAX_RX_SIZE - hsurRxTrigLvl) // buffer full
 260   1                      return;
 261   1      
 262   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 263   1              {
 264   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 265   2                      {
 266   3                              c = UR2_RBR;
 267   3                              if (hsurTxState == 1)
 268   3                              {
 269   4                                      EA = 0;
 270   4                                      hsurTxFlag = c;
 271   4                                      hsurTxState = 0;
 272   4                                      EA = 1;
 273   4                              }
 274   3                              else
 275   3                              {
 276   4                                      hsurRxBuffer[hsurRxCount++] = c;
 277   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 278   4                                              hsurRxCount = 0;
 279   4                              }
 280   3                      }
 281   2              }
 282   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 283   1              {
 284   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 285   2                      {
 286   3                              hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 287   3                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 288   3                                      hsurRxCount = 0;        
 289   3                      }
 290   2              }
 291   1              else
 292   1              {
 293   2                      for (i=0 ; i<hsurRxTrigLvl ; i++)
 294   2                      {
 295   3                              c = UR2_RBR;
 296   3                              if (c != ASCII_XOFF && c != ASCII_XON)
 297   3                              {
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 6   

 298   4                                      hsurRxBuffer[hsurRxCount++] = c;
 299   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 300   4                                              hsurRxCount = 0;
 301   4                              }
 302   3                              else
 303   3                              {
 304   4                                      if (c == ASCII_XOFF)
 305   4                                              hsurFlowCtrlXoff = TRUE;
 306   4                                      else if (c == ASCII_XON)
 307   4                                              hsurFlowCtrlXon = TRUE;
 308   4                              }
 309   3                      }
 310   2              }
 311   1      
 312   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 313   1              {
 314   2                      HSUR_RxBufFlowControl();
 315   2      
 316   2                      if (hsurFlowOn == FALSE)
 317   2                      {
 318   3                              if (hsurRxCount >= UR2_FLOW_HI_WATERMARK) // check software buffer status
 319   3                              {
 320   4                                      hsurFlowOn = TRUE;
 321   4                      }
 322   3                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 323   3                              {
 324   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 325   4                              }                       
 326   3                      }       
 327   2              }
 328   1      }
 329          
 330          /*
 331           *--------------------------------------------------------------------------------
 332           * static void hsur_Rcvr(void)
 333           * Purpose : Receiving the byte data from hardware register into software buffer.
 334           * Params  : None
 335           * Returns : None
 336           * Note    : None
 337           *--------------------------------------------------------------------------------
 338           */
 339          static void hsur_Rcvr(void)
 340          {
 341   1              U8_T    far lineStatus = 0;
 342   1      
 343   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 344   1              {
 345   2                      while (1)
 346   2                      {
 347   3                              lineStatus = UR2_LSR;
 348   3                              hsurLineStatusValue = lineStatus;
 349   3              
 350   3                              if (lineStatus & UR2_DR)
 351   3                              {
 352   4                                      if (hsurTxState == 1)
 353   4                                      {
 354   5                                              EA = 0;
 355   5                                              hsurTxFlag = UR2_RBR;
 356   5                                              hsurTxState = 0;
 357   5                                              EA = 1;
 358   5                                      }
 359   4                                      else
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 7   

 360   4                                      {
 361   5                                              hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 362   5                                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 363   5                                              {
 364   6                                                      hsurRxCount = 0;
 365   6                                                      break;
 366   6                                              }
 367   5                                      }
 368   4                              }
 369   3                              else
 370   3                                      break;
 371   3                      }
 372   2              }
 373   1              else if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
 374   1              {
 375   2                      while (1)
 376   2                      {
 377   3                              lineStatus = UR2_LSR;
 378   3                              hsurLineStatusValue = lineStatus;
 379   3              
 380   3                              if (lineStatus & UR2_DR)
 381   3                              {
 382   4                                      hsurRxBuffer[hsurRxCount++] = UR2_RBR;
 383   4                                      if (hsurRxCount == UR2_MAX_RX_SIZE)
 384   4                                      {
 385   5                                              hsurRxCount = 0;
 386   5                                              break;
 387   5                                      }
 388   4                              }
 389   3                              else                            
 390   3                                      break;
 391   3                      }               
 392   2              }
 393   1              else 
 394   1              {
 395   2                      U8_T    c = 0;
 396   2      
 397   2                      while (1)
 398   2                      {
 399   3                              lineStatus = UR2_LSR;
 400   3                              hsurLineStatusValue = lineStatus;
 401   3              
 402   3                              if (lineStatus & UR2_DR)
 403   3                              {
 404   4                                      c = UR2_RBR;
 405   4      
 406   4                                      if (c != ASCII_XOFF && c != ASCII_XON)
 407   4                                      {
 408   5                                              hsurRxBuffer[hsurRxCount++] = c;
 409   5                                              if (hsurRxCount == UR2_MAX_RX_SIZE)
 410   5                                              {
 411   6                                                      hsurRxCount = 0;
 412   6                                                      break;
 413   6                                              }
 414   5                                      }
 415   4                                      else
 416   4                                      {
 417   5                                              if (c == ASCII_XOFF)
 418   5                                                      hsurFlowCtrlXoff = TRUE;
 419   5                                              else if (c == ASCII_XON)
 420   5                                                      hsurFlowCtrlXon = TRUE;
 421   5                                      }
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 8   

 422   4                              }
 423   3                              else
 424   3                                      break;
 425   3                      }
 426   2              }
 427   1      
 428   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_NO)
 429   1                      HSUR_RxBufFlowControl();
 430   1      }
 431          
 432          /*
 433           *--------------------------------------------------------------------------------
 434           * static void hsur_Xmit(void)
 435           * Purpose : Transmitting the byte data from software buffer into hardware register.
 436           * Params  : None
 437           * Returns : None
 438           * Note    : None
 439           *--------------------------------------------------------------------------------
 440           */
 441          static void hsur_Xmit(void)
 442          {
 443   1              U8_T far        i = 0;
 444   1      
 445   1              for (i=0 ; i<UR2_TX_BUF_LEVEL ; i++)
 446   1              {
 447   2                      if (hsurTxCount > 0)
 448   2                      {
 449   3                              UR2_THR = hsurTxBuffer[hsurTxBufNum];
 450   3                              hsurTxBufNum ++;
 451   3                              hsurTxCount --;
 452   3      
 453   3                              if (hsurTxBufNum == UR2_MAX_TX_SIZE)
 454   3                                      hsurTxBufNum = 0; 
 455   3      
 456   3                              if ((hsurFlowCtrl == UR2_FLOW_CTRL_HW) || (hsurFlowCtrl == UR2_FLOW_CTRL_X))
 457   3                              {
 458   4                                      HSUR_TxBufFlowControl();
 459   4                              }
 460   3                      
 461   3                              if (hsurTxCount <= 0)
 462   3                              {               
 463   4                                      UR2_IER &= ~UR2_THRI_ENB;
 464   4                                      return;
 465   4                              }
 466   3                      }
 467   2                      else
 468   2                      {
 469   3                              UR2_IER &= ~UR2_THRI_ENB;
 470   3                              return;
 471   3                      }
 472   2              }
 473   1      }
 474          
 475          /*
 476           *--------------------------------------------------------------------------------
 477           * static void hsur_ReadMsr(void)
 478           * Purpose : Reading the modem status register.
 479           * Params  : None
 480           * Returns : None
 481           * Note    : None
 482           *--------------------------------------------------------------------------------
 483           */
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 9   

 484          static void hsur_ReadMsr(void)
 485          {
 486   1              hsurModemStatusValue = UR2_MSR;
 487   1      
 488   1              if (hsurModemStatusValue & UR2_DCTS)
 489   1              {
 490   2                      if (hsurModemStatusValue & UR2_CTS)
 491   2                      {
 492   3                              HSUR_SetRTS();
 493   3                              hsurFlowCtrlHwCTSon = TRUE;
 494   3                      }
 495   2                      else
 496   2                      {
 497   3                              HSUR_ClearRTS();
 498   3                              hsurFlowCtrlHwCTSon = FALSE;
 499   3                      }
 500   2              }
 501   1      
 502   1              if (hsurModemStatusValue & UR2_DDSR)
 503   1              {
 504   2                      if (hsurModemStatusValue & UR2_DSR)
 505   2                      {
 506   3                              HSUR_SetDTR();
 507   3                      }
 508   2                      else
 509   2                      {
 510   3                              HSUR_ClearDTR();
 511   3                      }
 512   2              }
 513   1      
 514   1              if (hsurModemStatusValue & UR2_TERI)
 515   1              {
 516   2                      if (hsurModemStatusValue & UR2_RI)
 517   2                      {
 518   3                              UR2_MCR |= UR2_OUT1;
 519   3                              hsurModemControlValue |= UR2_OUT1;
 520   3                      }
 521   2                      else
 522   2                      {
 523   3                              UR2_MCR &= ~UR2_OUT1;
 524   3                              hsurModemControlValue &= ~UR2_OUT1;
 525   3                      }
 526   2              }
 527   1      
 528   1              if (hsurModemStatusValue & UR2_DDCD)
 529   1              {
 530   2                      if (hsurModemStatusValue & UR2_DCD)
 531   2                      {
 532   3                              UR2_MCR |= UR2_OUT2;
 533   3                              hsurModemControlValue |= UR2_OUT2;
 534   3                      }
 535   2                      else
 536   2                      {
 537   3                              UR2_MCR &= ~UR2_OUT2;
 538   3                              hsurModemControlValue &= ~UR2_OUT2;
 539   3                      }
 540   2              }
 541   1      }
 542          
 543          
 544          /* EXPORTED SUBPROGRAM BODIES */
 545          
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 10  

 546          /*
 547           *--------------------------------------------------------------------------------
 548           * void HSUR_Func(void)
 549           * Purpose : HSUR interrupt function which checks interrupt status.
 550           * Params  : None.
 551           * Returns : None.
 552           * Note    : None.
 553           *--------------------------------------------------------------------------------
 554           */
 555          void HSUR_Func(void)  
 556          {
 557   1              U8_T far intrStatus = 0;
 558   1      
 559   1              intrStatus = UR2_IIR & 0x0F;
 560   1      
 561   1              if (intrStatus == UR2_RLS_INTR)
 562   1              {
 563   2                      hsur_ReadLsr();
 564   2              }
 565   1              else if (intrStatus == UR2_RD_TRIG_INTR)
 566   1              {
 567   2                      UR2_IER &= ~UR2_RDI_ENB;
 568   2                      hsur_RcvrTrig();
 569   2                      uart2_timeout = UART2_TIMEOUT;
 570   2                      UR2_IER |= UR2_RDI_ENB;
 571   2              }
 572   1              else if (intrStatus == UR2_RD_TI_INTR)
 573   1              {
 574   2                      UR2_IER &= ~UR2_RDI_ENB;
 575   2                      hsur_Rcvr();
 576   2                      uart2_timeout = UART2_TIMEOUT;
 577   2                      UR2_IER |= UR2_RDI_ENB;
 578   2              }
 579   1              else if (intrStatus == UR2_THRE_INTR)
 580   1              {
 581   2                      if (hsurFlowCtrl != UR2_FLOW_CTRL_SW )
 582   2                      {
 583   3                              hsur_Xmit();
 584   3                      }
 585   2                      else
 586   2                      {
 587   3                              EA = 0;
 588   3                              hsurTxTransmit = 1;
 589   3                              hsurTxFlag = 0;
 590   3                              UR2_IER &= ~UR2_THRI_ENB;
 591   3                              EA = 1;
 592   3                      }
 593   2              }
 594   1              else if (intrStatus == UR2_MS_INTR)
 595   1              {
 596   2                      hsur_ReadMsr();
 597   2              }
 598   1      }
 599          
 600          /*
 601           *--------------------------------------------------------------------------------
 602           * void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 603           * Purpose : Setup the HSUR mode. Before using the HSUR of AX11000, this function
 604           *           must be executed to initiate.
 605           * Params  : divisor - A divisor value used to calculate the baud rate of HSUR.
 606           *           lCtrl - Line control register value.
 607           *           intEnb - Interrupt enable register value.
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 11  

 608           *           fCtrl - FIFO control register value.
 609           *           mCtrl - Modem control register value.
 610           * Returns : None.
 611           * Note    : None.
 612           *--------------------------------------------------------------------------------
 613           */
 614          void HSUR_Setup(U16_T divisor, U8_T lCtrl, U8_T intEnb, U8_T fCtrl, U8_T mCtrl)
 615          {
 616   1              U16_T   far i;
 617   1      
 618   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 619   1              {
 620   2                      hsurRxBuffer[i] = 0;
 621   2              }
 622   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 623   1              {
 624   2                      hsurTxBuffer[i] = 0;
 625   2              }
 626   1      
 627   1              hsurRxBufNum = 0;
 628   1              hsurTxBufNum = 0;
 629   1              hsurRxCount = 0;
 630   1              hsurTxCount = 0;
 631   1              hsurGetPtr = 0;
 632   1              hsurPutPtr = 0;
 633   1      
 634   1              switch (fCtrl & 0xC0)
 635   1              {
 636   2                      case UR2_TRIG_01 :
 637   2                              hsurRxTrigLvl = 1;
 638   2                              break;
 639   2                      case UR2_TRIG_04 :
 640   2                              hsurRxTrigLvl = 4;
 641   2                              break;
 642   2                      case UR2_TRIG_08 :
 643   2                              hsurRxTrigLvl = 8;
 644   2                              break;
 645   2                      case UR2_TRIG_14 :
 646   2                              hsurRxTrigLvl = 14;
 647   2                              break;
 648   2              }
 649   1      
 650   1              UR2_LCR = UR2_DLAB_ENB;
 651   1              UR2_DLL = (U8_T)(divisor & 0x00FF);
 652   1              UR2_DLH = (U8_T)((divisor & 0xFF00) >> 8);
 653   1              UR2_LCR &= ~UR2_DLAB_ENB;
 654   1              UR2_LCR = lCtrl;
 655   1              UR2_FCR = fCtrl;
 656   1      #if   HSUR_RS485_ENABLE
 657   1              UR2_MCR = (mCtrl | UR2_RS485_RECEIVE);
 658   1      #else
                      UR2_MCR = mCtrl;
              #endif
 661   1              UR2_IER = intEnb;
 662   1      
 663   1              hsurLineControlValue = lCtrl;
 664   1              hsurFifoControlValue = fCtrl;
 665   1              hsurModemControlValue = mCtrl;
 666   1      }
 667          /*
 668           *--------------------------------------------------------------------------------
 669           * S8_T HSUR_GetChar(void)
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 12  

 670           * Purpose : Getting one byte data from the software receiver buffer,
 671           *           which stores data received from a serial bus.
 672           * Params  : None.
 673           * Returns : ch - one byte character in buffer.
 674           * Note    : None.
 675           *--------------------------------------------------------------------------------
 676           */
 677          S8_T HSUR_GetChar(void)
 678          {
 679   1              U8_T    far ch = 0;
 680   1          
 681   1              while (hsurRxCount == 0) ;
 682   1              
 683   1              ch = hsurRxBuffer[hsurGetPtr];
 684   1              EA = 0;
 685   1              hsurGetPtr ++;
 686   1              hsurRxCount --;
 687   1              if (hsurGetPtr == UR2_MAX_RX_SIZE)
 688   1                      hsurGetPtr = 0;
 689   1              EA = 1;
 690   1      
 691   1              if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 692   1              {
 693   2                      if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 694   2                      {
 695   3                              hsurFlowOn = FALSE;
 696   3      
 697   3                              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 698   3                              {
 699   4                                      UR2_THR = FLOW_SW_CONTINUOUS;
 700   4                              }
 701   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 702   3                              {
 703   4                                      HSUR_SetRTS();
 704   4                              }
 705   3                              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 706   3                              {
 707   4                                      UR2_THR = ASCII_XON;
 708   4                              }
 709   3                      }
 710   2              }
 711   1      
 712   1              return ch;
 713   1      }
 714          
 715          /*
 716           *--------------------------------------------------------------------------------
 717           * S8_T HSUR_PutChar(S8_T ch)
 718           * Purpose : Putting  one byte data into the software transmitter buffer,
 719           *           which stores data that be sent to a serial bus.
 720           * Params  : ch - one byte data will be put into buffer.
 721           * Returns : ch - the same data value will be returned.
 722           * Note    : None.
 723           *--------------------------------------------------------------------------------
 724           */
 725          S8_T HSUR_PutChar(S8_T ch)
 726          {
 727   1              U16_T   far tIdleStart = 0;
 728   1              U16_T   far tIdleStop = 0;
 729   1      
 730   1              if (hsurTxCount >= UR2_MAX_TX_SIZE)
 731   1              {
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 13  

 732   2      //              printd("U2-TX-Full\r\n");
 733   2                      return FALSE;
 734   2              }
 735   1      
 736   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 737   1              {
 738   2                      UR2_THR = ch;
 739   2                      hsurTxState = 1;
 740   2      
 741   2                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 742   2                      {
 743   3                              tIdleStart = xTickCount;
 744   3                              while (hsurTxTransmit == 0)
 745   3                              {
 746   4                                      tIdleStop =xTickCount;
 747   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 748   4                                      {
 749   5      //                                      PRINTD(DEBUG_MSG, ("Can not transmit in UR2_FLOW_CTRL_SW because of no UR2_THRI_INTR\n\r"));
 750   5                                      }
 751   4                              }
 752   3                      
 753   3                              tIdleStart = xTickCount;
 754   3                              while (hsurTxState == 1)
 755   3                              {
 756   4                                      tIdleStop = xTickCount;
 757   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
 758   4                                      {
 759   5      //                                      PRINTD(DEBUG_MSG, ("Do not receive any flow control character in UR2_FLOW_CTRL_SW\n\r"));
 760   5                                      }
 761   4                              }
 762   3              
 763   3                              HSUR_TxBufFlowControl();
 764   3                              hsurTxTransmit = 0;
 765   3                      }
 766   2              }
 767   1              else
 768   1              {
 769   2                      UR2_IER &= ~UR2_THRI_ENB;               
 770   2                      hsurTxBuffer[hsurPutPtr] = ch;
 771   2                      hsurPutPtr ++;
 772   2                      hsurTxCount ++;
 773   2      
 774   2                      if (hsurPutPtr == UR2_MAX_TX_SIZE)
 775   2                              hsurPutPtr = 0;
 776   2              }
 777   1      
 778   1              UR2_IER |= UR2_THRI_ENB;    /* trigger hardware interrupt if hw FIFO empty */
 779   1      
 780   1      #if UR2_APP_FLOW_CTRL
 781   1              if (hsurTxCount >= UR2_FLOW_HI_WATERMARK)
 782   1                      return FALSE;
 783   1              else
 784   1                      return TRUE;
 785   1      #else
                      return ch;
              #endif
 788   1      }
 789          
 790          /*
 791          * -----------------------------------------------------------------------------
 792           * void HSUR_InitValue(void)
 793           * Purpose : Initiating all globe value in this driver function.
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 14  

 794           * Params  : None.
 795           * Returns : None.
 796           * Note    : None.
 797           * ----------------------------------------------------------------------------
 798           */
 799          void HSUR_InitValue(void)
 800          {
 801   1              U8_T    far sysClk = 0;
 802   1              U16_T   far i;
 803   1      
 804   1              for (i=0 ; i<UR2_MAX_RX_SIZE ; i++)
 805   1              {
 806   2                      hsurRxBuffer[i] = 0;
 807   2              }
 808   1              for (i=0 ; i<UR2_MAX_TX_SIZE ; i++)
 809   1              {
 810   2                      hsurTxBuffer[i] = 0;
 811   2              }
 812   1      
 813   1              hsurRxBufNum = 0;
 814   1              hsurTxBufNum = 0;
 815   1              hsurRxCount = 0;
 816   1              hsurTxCount = 0;
 817   1              hsurGetPtr = 0;
 818   1              hsurPutPtr = 0;
 819   1      
 820   1              sysClk = CSREPR & 0xC0;
 821   1              switch (sysClk)
 822   1              {
 823   2                      case SCS_100M :
 824   2      //                      P3 = 0x10;
 825   2                              break;
 826   2                      case SCS_50M :
 827   2      //                      P3 = 0x50;
 828   2                              break;
 829   2                      case SCS_25M :
 830   2      //                      P3 = 0x25;
 831   2                              break;
 832   2                      default :
 833   2      //                      P3 = 0xAA;
 834   2                              break;
 835   2              }
 836   1      
 837   1      } /* End of UART_Init */
 838          
 839          /*
 840           *--------------------------------------------------------------------------------
 841           * S8_T HSUR_GetCharNb(void)
 842           * Purpose : Getting data from the software receiver buffer, which stores data 
 843           *           received from a serial bus. This function is similar to HSUR_GetChar,
 844           *           but this function only check buffer one time.
 845           * Params  : None.
 846           * Returns : ch - one byte data in buffer will be returned if having.
 847           * Note    : None.
 848           *--------------------------------------------------------------------------------
 849           */
 850          //S16_T HSUR_GetCharNb(void)
 851          S8_T HSUR_GetCharNb(void)
 852          {
 853   1              S8_T far ch = 0;
 854   1      
 855   1              UR2_IER &= ~UR2_RDI_ENB;
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 15  

 856   1       
 857   1              if (hsurRxCount > 0)
 858   1              {
 859   2                      ch = hsurRxBuffer[hsurGetPtr];          
 860   2                      hsurGetPtr++;
 861   2                      hsurRxCount --;
 862   2                      if (hsurGetPtr == UR2_MAX_RX_SIZE)
 863   2                              hsurGetPtr = 0;
 864   2      
 865   2                      if ((hsurFlowCtrl != UR2_FLOW_CTRL_NO) && (hsurFlowOn))
 866   2                      {
 867   3                              if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
 868   3                              {
 869   4                                      hsurFlowOn = FALSE;
 870   4      
 871   4                                      if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 872   4                                      {
 873   5                                              UR2_THR = FLOW_SW_CONTINUOUS;
 874   5                                      }
 875   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 876   4                                      {
 877   5                                              HSUR_SetRTS();
 878   5                                      }
 879   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
 880   4                                      {
 881   5                                              UR2_THR = ASCII_XON;
 882   5                                      }
 883   4                              }
 884   3                      }
 885   2      
 886   2                      UR2_IER |= UR2_RDI_ENB;
 887   2                      return ch;
 888   2              }
 889   1              else
 890   1              {
 891   2                      UR2_IER |= UR2_RDI_ENB;
 892   2              
 893   2                      return -1;
 894   2             // return 1000;
 895   2              }
 896   1      }
 897          
 898          /*
 899           * ----------------------------------------------------------------------------
 900           * U16_T HSUR_GetRxBufCount(void)
 901           * Purpose : Getting the remain character number in UART2 Rx buffer.
 902           * Params  : none
 903           * Returns : hsurRxCount - the number of remain character in UART2 Rx buffer.
 904           * Note    : none
 905           * ----------------------------------------------------------------------------
 906           */
 907          U16_T HSUR_GetRxBufCount(void)
 908          {
 909   1              return hsurRxCount;
 910   1      }
 911          
 912          /*
 913           * ----------------------------------------------------------------------------
 914           * void HSUR_SetFlowControl(U8_T mode)
 915           * Purpose : Setting the UART2 flow control mode.
 916           * Params  : mode - flow control mode.
 917           * Returns : none
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 16  

 918           * Note    : none
 919           * ----------------------------------------------------------------------------
 920           */
 921          void HSUR_SetFlowControl(U8_T mode)
 922          {
 923   1              hsurFlowCtrl = mode;
 924   1      
 925   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 926   1              {
 927   2                      hsurTxTransmit = 0;
 928   2                      hsurTxFlag = 0;
 929   2                      hsurFlowOn = 0;
 930   2              }
 931   1      }
 932          
 933          /*
 934           * ----------------------------------------------------------------------------
 935           * BOOL HSUR_CheckTxComplete(void)
 936           * Purpose : Check the hardware FIFO empty and software Tx buffer empty
 937           * Params  : none
 938           * Returns : TRUE - both empty.
 939           * Note    : none
 940           * ----------------------------------------------------------------------------
 941           */
 942          BOOL HSUR_CheckTxComplete(void)
 943          {
 944   1              if ((UR2_LSR & UR2_THRE) && (hsurTxCount == 0))
 945   1                      return TRUE;
 946   1              else
 947   1                      return FALSE;
 948   1      }
 949          
 950          
 951          /*
 952           * ----------------------------------------------------------------------------
 953           * void HSUR_RxBufFlowControl(void)
 954           * Purpose : Check the receiving buffer space and return the flow control character.
 955           * Params  : none
 956           * Returns : none
 957           * Note    : none
 958           * ----------------------------------------------------------------------------
 959           */
 960          void HSUR_RxBufFlowControl(void)
 961          {
 962   1              U8_T    far charFlowCtrl = 0;
 963   1      
 964   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
 965   1              {
 966   2                      if (hsurRxCount >= UR2_MAX_RX_SIZE)
 967   2                      {
 968   3                              charFlowCtrl = FLOW_SW_ERROR;
 969   3                      }
 970   2                      else if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
 971   2                      {
 972   3                              hsurFlowOn = TRUE;
 973   3                              charFlowCtrl = FLOW_SW_WAIT;
 974   3                      }
 975   2                      else if ((hsurFlowOn) && (hsurRxCount > UR2_FLOW_LO_WATERMARK))
 976   2                      {
 977   3                              charFlowCtrl = FLOW_SW_WAIT;
 978   3                      }
 979   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 17  

 980   2                      {
 981   3                              hsurFlowOn = FALSE;
 982   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
 983   3                      }
 984   2                      else if (hsurFlowOn == FALSE)
 985   2                      {
 986   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
 987   3                      }
 988   2                      else
 989   2                      {
 990   3                              charFlowCtrl = FLOW_SW_CONTINUOUS;
 991   3                      }
 992   2      
 993   2                      UR2_THR = charFlowCtrl;
 994   2              }
 995   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
 996   1              {
 997   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
 998   2                      {
 999   3                              hsurFlowOn = TRUE;
1000   3                              UR2_MCR &= ~UR2_RTS;
1001   3                      }
1002   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1003   2                      {
1004   3                              hsurFlowOn = FALSE;
1005   3                              UR2_MCR |= UR2_RTS;
1006   3                      }
1007   2              }
1008   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1009   1              {
1010   2                      if (hsurRxCount >= UR2_FLOW_HI_WATERMARK)
1011   2                      {
1012   3                              hsurFlowOn = TRUE;
1013   3                              UR2_THR = ASCII_XOFF;
1014   3                      }
1015   2                      else if ((hsurFlowOn) && (hsurRxCount <= UR2_FLOW_LO_WATERMARK))
1016   2                      {
1017   3                              hsurFlowOn = FALSE;
1018   3                              UR2_THR = ASCII_XON;
1019   3                      }
1020   2              }
1021   1      }
1022          
1023          /*
1024           * ----------------------------------------------------------------------------
1025           * void HSUR_TxBufFlowControl(void)
1026           * Purpose : Check the transmitting flow control character.
1027           * Params  : none
1028           * Returns : none
1029           * Note    : none
1030           * ----------------------------------------------------------------------------
1031           */
1032          void HSUR_TxBufFlowControl(void)
1033          {
1034   1              U8_T    far charFlowCtrl = 0;
1035   1              U16_T   far tIdleStart = 0;
1036   1              U16_T   far tIdleStop = 0;
1037   1              
1038   1              if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1039   1              {
1040   2                      if (hsurFlowCtrlHwCTSon == TRUE)
1041   2                      {
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 18  

1042   3                              return;
1043   3                      }
1044   2      
1045   2                      tIdleStart = xTickCount;
1046   2                      while (1)
1047   2                      {
1048   3                              if (hsurFlowCtrlHwCTSon == TRUE)
1049   3                              {
1050   4                                      return;
1051   4                              }
1052   3                              else
1053   3                              {
1054   4                                      tIdleStop = xTickCount;
1055   4      
1056   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 1)
1057   4                                      {
1058   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_HW\n\r"));
1059   5                                      }
1060   4                              }
1061   3                      }
1062   2              }
1063   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1064   1              {
1065   2                      if (hsurFlowCtrlXoff == TRUE)
1066   2                      {
1067   3                              hsurFlowCtrlXoff = FALSE;
1068   3              
1069   3                              tIdleStart = xTickCount;
1070   3                              while (1)
1071   3                              {
1072   4                                      if (hsurFlowCtrlXon == TRUE)
1073   4                                      {
1074   5                                              hsurFlowCtrlXon = FALSE;
1075   5      
1076   5                                              break;
1077   5                                      }
1078   4                                      else
1079   4                                      {
1080   5                                              tIdleStop = xTickCount;
1081   5                                              if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1082   5                                              {
1083   6      //                                              PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_X\n\r"));
1084   6                                              }
1085   5                                      }
1086   4                              }
1087   3                      }
1088   2              }
1089   1              else if (hsurFlowCtrl == UR2_FLOW_CTRL_SW)
1090   1              {
1091   2                      tIdleStart = xTickCount;
1092   2                      while (1)
1093   2                      {
1094   3                              charFlowCtrl = hsurTxFlag;
1095   3                              if (charFlowCtrl == FLOW_SW_CONTINUOUS)
1096   3                                      break;
1097   3                              else if (charFlowCtrl == FLOW_SW_ERROR)
1098   3                                      UR2_IER &= ~UR2_THRI_ENB;
1099   3                              else
1100   3                              {
1101   4                                      tIdleStop =xTickCount;
1102   4                                      if (((tIdleStop - tIdleStart) / SWTIMER_COUNT_SECOND) >= 3)
1103   4                                      {
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 19  

1104   5      //                                      PRINTD(DEBUG_MSG, ("Do not match any flow control character in UR2_FLOW_CTRL_SW\n\r"));
1105   5                                      }
1106   4                              }
1107   3                      }
1108   2              }
1109   1      }
1110          
1111          /*
1112           * ----------------------------------------------------------------------------
1113           * void HSUR_ErrorRecovery(void)
1114           * Purpose : Checking the HSUR Line Status Register value of errors and
1115           *           re-enable interrupt of receiving and line status.
1116           * Params  : none
1117           * Returns : none
1118           * Note    : none
1119           * ----------------------------------------------------------------------------
1120           */
1121          void HSUR_ErrorRecovery(void)
1122          {
1123   1              if (hsurErrBlocking)
1124   1              {
1125   2                      U8_T    far lsrVal = UR2_LSR;
1126   2                      U8_T    far trash = 0;
1127   2      
1128   2      //              printd("hsurErrBlocking = 1\n\r");
1129   2                      if (lsrVal & UR2_DR)
1130   2                      {
1131   3                              trash = UR2_RBR;
1132   3                      }
1133   2                      else if (!(lsrVal & UR2_DR) && (hsurErrorCount >= 30))
1134   2                      {
1135   3      //                      printd("clear hsurErrBlocking = 0\n\r");
1136   3                              EA = 0;
1137   3                              UR2_IER |= (UR2_RDI_ENB | UR2_RLSI_ENB | UR2_MSI_ENB);
1138   3                              hsurErrBlocking = 0;
1139   3                              hsurErrorCount = 0;
1140   3                              EA = 1;
1141   3                      }
1142   2              }
1143   1      }
1144          
1145          /*
1146           * ----------------------------------------------------------------------------
1147           * BOOL HSUR_SetBaudRate(U16_T divBaudRate)
1148           * Purpose : Setting the HSUR baudrate.
1149           * Params  : divBaudRate - divisor of the baudrate.
1150           * Returns : TRUE - setting complete.
1151           * Note    : none
1152           * ----------------------------------------------------------------------------
1153           */
1154          BOOL HSUR_SetBaudRate(U16_T divBaudRate)
1155          {
1156   1              U8_T    far recIntrEnb = UR2_IER;
1157   1      
1158   1              UR2_IER = 0;
1159   1              UR2_LCR |= UR2_DLAB_ENB;
1160   1              UR2_DLL = (U8_T)(divBaudRate & 0x00FF);
1161   1              UR2_DLH = (U8_T)((divBaudRate & 0xFF00) >> 8);
1162   1              UR2_LCR &= ~UR2_DLAB_ENB;
1163   1      
1164   1              hsurBaudRateDivisor = divBaudRate;
1165   1      
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 20  

1166   1              switch (CSREPR & 0xC0)
1167   1              {
1168   2                      case SCS_100M :
1169   2      //                      P3 = 0x10;
1170   2                              break;
1171   2                      case SCS_50M :
1172   2      //                      P3 = 0x50;
1173   2                              break;
1174   2                      case SCS_25M :
1175   2      //                      P3 = 0x25;
1176   2                              break;
1177   2              }
1178   1      
1179   1              UR2_FCR |= UR2_RXFIFO_RST | UR2_TXFIFO_RST;
1180   1              UR2_IER = recIntrEnb;
1181   1      
1182   1              return TRUE;
1183   1      }
1184          
1185          /*
1186           * ----------------------------------------------------------------------------
1187           * void HSUR_SetLineControl(U8_T value)
1188           * Purpose : Setting the HSUR Line control register with "value".
1189           * Params  : value - variable to be set.
1190           * Returns : none
1191           * Note    : none
1192           * ----------------------------------------------------------------------------
1193           */
1194          void HSUR_SetLineControl(U8_T value)
1195          {
1196   1              U8_T    recIntrEnb = UR2_IER;
1197   1      
1198   1              UR2_IER = 0;
1199   1              UR2_LCR = value;
1200   1              hsurLineControlValue = value;
1201   1              UR2_IER = recIntrEnb;
1202   1      }
1203          
1204          /*
1205           * ----------------------------------------------------------------------------
1206           * void HSUR_SetFifoControl(U8_T value)
1207           * Purpose : Setting the HSUR FIFO control register with "value".
1208           * Params  : value - variable to be set.
1209           * Returns : none
1210           * Note    : none
1211           * ----------------------------------------------------------------------------
1212           */
1213          void HSUR_SetFifoControl(U8_T value)
1214          {
1215   1              U8_T    far recIntrEnb = UR2_IER;
1216   1      
1217   1              UR2_IER = 0;
1218   1              UR2_FCR = value;
1219   1              hsurFifoControlValue = value;
1220   1              UR2_IER = recIntrEnb;
1221   1      }
1222          
1223          /*
1224           * ----------------------------------------------------------------------------
1225           * void HSUR_SetModemControl(U8_T value)
1226           * Purpose : Setting the HSUR Modem control register with "value".
1227           * Params  : value - variable to be set.
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 21  

1228           * Returns : none
1229           * Note    : none
1230           * ----------------------------------------------------------------------------
1231           */
1232          void HSUR_SetModemControl(U8_T value)
1233          {
1234   1              U8_T    far recIntrEnb = UR2_IER;
1235   1      
1236   1              UR2_IER = 0;
1237   1              UR2_MCR = value;
1238   1              hsurModemControlValue = value;
1239   1              UR2_IER = recIntrEnb;
1240   1      }
1241          
1242          /*
1243           * ----------------------------------------------------------------------------
1244           * void HSUR_SetRTS(void)
1245           * Purpose : Only setting the HSUR RTS bit of Modem control register.
1246           * Params  : none
1247           * Returns : none
1248           * Note    : none
1249           * ----------------------------------------------------------------------------
1250           */
1251          void HSUR_SetRTS(void)
1252          {
1253   1              U8_T    far recIntrEnb = UR2_IER;
1254   1      
1255   1              UR2_IER = 0;
1256   1              UR2_MCR |= UR2_RTS;
1257   1              hsurModemControlValue |= UR2_RTS;
1258   1              UR2_IER = recIntrEnb;
1259   1      }
1260          
1261          /*
1262           * ----------------------------------------------------------------------------
1263           * void HSUR_SetDTR(void)
1264           * Purpose : Only setting the HSUR DTR bit of Modem control register.
1265           * Params  : none
1266           * Returns : none
1267           * Note    : none
1268           * ----------------------------------------------------------------------------
1269           */
1270          void HSUR_SetDTR(void)
1271          {
1272   1              U8_T    far recIntrEnb = UR2_IER;
1273   1      
1274   1              UR2_IER = 0;
1275   1              UR2_MCR |= UR2_DTR;
1276   1              hsurModemControlValue |= UR2_DTR;
1277   1              UR2_IER = recIntrEnb;
1278   1      }
1279          
1280          /*
1281           * ----------------------------------------------------------------------------
1282           * void HSUR_ClearRTS(void)
1283           * Purpose : Only clear the HSUR RTS bit of Modem control register.
1284           * Params  : none
1285           * Returns : none
1286           * Note    : none
1287           * ----------------------------------------------------------------------------
1288           */
1289          void HSUR_ClearRTS(void)
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 22  

1290          {
1291   1              UR2_MCR &= ~UR2_RTS;
1292   1              hsurModemControlValue &= ~UR2_RTS;
1293   1      }
1294          
1295          /*
1296           * ----------------------------------------------------------------------------
1297           * void HSUR_ClearDTR(void)
1298           * Purpose : Only clear the HSUR DTR bit of Modem control register.
1299           * Params  : none
1300           * Returns : none
1301           * Note    : none
1302           * ----------------------------------------------------------------------------
1303           */
1304          void HSUR_ClearDTR(void)
1305          {
1306   1              UR2_MCR &= ~UR2_DTR;
1307   1              hsurModemControlValue &= ~UR2_DTR;
1308   1      }
1309          
1310          /*
1311           * ----------------------------------------------------------------------------
1312           * U16_T HSUR_GetBaudRate(void)
1313           * Purpose : Getting the HSUR baudrate divisor.
1314           * Params  : none
1315           * Returns : divBaudRate - baudrate divisor.
1316           * Note    : none
1317           * ----------------------------------------------------------------------------
1318           */
1319          U16_T HSUR_GetBaudRate(void)
1320          {
1321   1              U16_T   far divBaudRate = 0;
1322   1      
1323   1              switch (CSREPR & 0xC0)
1324   1              {
1325   2                      case SCS_100M :
1326   2      //                      P3 = 0x10;
1327   2                              UR2_LCR |= UR2_DLAB_ENB;
1328   2                              switch (hsurBaudRateDivisor)
1329   2                              {
1330   3                                      case UR2_BR100_921600 :
1331   3                                              divBaudRate = UR2_BR100_921600;
1332   3                                              break;
1333   3                                      case UR2_BR100_115200 :
1334   3                                              divBaudRate = UR2_BR100_115200;
1335   3                                              break;
1336   3                                      case UR2_BR100_57600 :
1337   3                                              divBaudRate = UR2_BR100_57600;
1338   3                                              break;
1339   3                                      case UR2_BR100_38400 :
1340   3                                              divBaudRate = UR2_BR100_38400;
1341   3                                              break;
1342   3                                      case UR2_BR100_19200 :
1343   3                                              divBaudRate = UR2_BR100_19200;
1344   3                                              break;
1345   3                                      case UR2_BR100_9600 :
1346   3                                              divBaudRate = UR2_BR100_9600;
1347   3                                              break;
1348   3                                      case UR2_BR100_7200 :
1349   3                                              divBaudRate = UR2_BR100_7200;
1350   3                                              break;
1351   3                                      case UR2_BR100_4800 :
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 23  

1352   3                                              divBaudRate = UR2_BR100_4800;
1353   3                                              break;
1354   3                                      case UR2_BR100_3600 :
1355   3                                              divBaudRate = UR2_BR100_3600;
1356   3                                              break;
1357   3                                      case UR2_BR100_2400 :
1358   3                                              divBaudRate = UR2_BR100_2400;
1359   3                                              break;
1360   3                                      case UR2_BR100_1200 :
1361   3                                              divBaudRate = UR2_BR100_1200;
1362   3                                              break;
1363   3                              }
1364   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1365   2                              break;
1366   2                      case SCS_50M :
1367   2      //                      P3 = 0x50;
1368   2                              UR2_LCR |= UR2_DLAB_ENB;
1369   2                              switch (hsurBaudRateDivisor)
1370   2                              {
1371   3                                      case UR2_BR50_921600 :
1372   3                                              divBaudRate = UR2_BR50_921600;
1373   3                                              break;
1374   3                                      case UR2_BR50_115200 :
1375   3                                              divBaudRate = UR2_BR50_115200;
1376   3                                              break;
1377   3                                      case UR2_BR50_57600 :
1378   3                                              divBaudRate = UR2_BR50_57600;
1379   3                                              break;
1380   3                                      case UR2_BR50_38400 :
1381   3                                              divBaudRate = UR2_BR50_38400;
1382   3                                              break;
1383   3                                      case UR2_BR50_19200 :
1384   3                                              divBaudRate = UR2_BR50_19200;
1385   3                                              break;
1386   3                                      case UR2_BR50_9600 :
1387   3                                              divBaudRate = UR2_BR50_9600;
1388   3                                              break;
1389   3                                      case UR2_BR50_7200 :
1390   3                                              divBaudRate = UR2_BR50_7200;
1391   3                                              break;
1392   3                                      case UR2_BR50_4800 :
1393   3                                              divBaudRate = UR2_BR50_4800;
1394   3                                              break;
1395   3                                      case UR2_BR50_3600 :
1396   3                                              divBaudRate = UR2_BR50_3600;
1397   3                                              break;
1398   3                                      case UR2_BR50_2400 :
1399   3                                              divBaudRate = UR2_BR50_2400;
1400   3                                              break;
1401   3                                      case UR2_BR50_1200 :
1402   3                                              divBaudRate = UR2_BR50_1200;
1403   3                                              break;
1404   3                              }
1405   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1406   2                              break;
1407   2                      case SCS_25M :
1408   2      //                      P3 = 0x25;
1409   2                              UR2_LCR |= UR2_DLAB_ENB;
1410   2                              switch (hsurBaudRateDivisor)
1411   2                              {
1412   3                                      case UR2_BR25_921600 :
1413   3                                              divBaudRate = UR2_BR25_921600;
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 24  

1414   3                                              break;
1415   3                                      case UR2_BR25_115200 :
1416   3                                              divBaudRate = UR2_BR25_115200;
1417   3                                              break;
1418   3                                      case UR2_BR25_57600 :
1419   3                                              divBaudRate = UR2_BR25_57600;
1420   3                                              break;
1421   3                                      case UR2_BR25_38400 :
1422   3                                              divBaudRate = UR2_BR25_38400;
1423   3                                              break;
1424   3                                      case UR2_BR25_19200 :
1425   3                                              divBaudRate = UR2_BR25_19200;
1426   3                                              break;
1427   3                                      case UR2_BR25_9600 :
1428   3                                              divBaudRate = UR2_BR25_9600;
1429   3                                              break;
1430   3                                      case UR2_BR25_7200 :
1431   3                                              divBaudRate = UR2_BR25_7200;
1432   3                                              break;
1433   3                                      case UR2_BR25_4800 :
1434   3                                              divBaudRate = UR2_BR25_4800;
1435   3                                              break;
1436   3                                      case UR2_BR25_3600 :
1437   3                                              divBaudRate = UR2_BR25_3600;
1438   3                                              break;
1439   3                                      case UR2_BR25_2400 :
1440   3                                              divBaudRate = UR2_BR25_2400;
1441   3                                              break;
1442   3                                      case UR2_BR25_1200 :
1443   3                                              divBaudRate = UR2_BR25_1200;
1444   3                                              break;
1445   3                              }
1446   2                              UR2_LCR &= ~UR2_DLAB_ENB;
1447   2                              break;
1448   2              }
1449   1              
1450   1              return TRUE;
1451   1      }
1452          
1453          /*
1454           * ----------------------------------------------------------------------------
1455           * U8_T HSUR_GetLineControl(void)
1456           * Purpose : Getting the HSUR Line Control register variables.
1457           * Params  : none
1458           * Returns : varLineCtrl.
1459           * Note    : none
1460           * ----------------------------------------------------------------------------
1461           */
1462          U8_T HSUR_GetLineControl(void)
1463          {
1464   1              U8_T    far varLineCtrl = 0;
1465   1      
1466   1              varLineCtrl = UR2_LCR;
1467   1      
1468   1              return varLineCtrl;
1469   1      }
1470          
1471          /*
1472           * ----------------------------------------------------------------------------
1473           * U8_T HSUR_GetFifoControl(void)
1474           * Purpose : Getting the HSUR FIFO Control register variables.
1475           * Params  : none
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 25  

1476           * Returns : hsurFifoControlValue.
1477           * Note    : none
1478           * ----------------------------------------------------------------------------
1479           */
1480          U8_T HSUR_GetFifoControl(void)
1481          {
1482   1              return hsurFifoControlValue;
1483   1      }
1484          
1485          /*
1486           * ----------------------------------------------------------------------------
1487           * U8_T HSUR_GetModemControl(void)
1488           * Purpose : Getting the HSUR Modem Control register variables.
1489           * Params  : none
1490           * Returns : hsurModemControlValue.
1491           * Note    : none
1492           * ----------------------------------------------------------------------------
1493           */
1494          U8_T HSUR_GetModemControl(void)
1495          {
1496   1              return hsurModemControlValue;
1497   1      }
1498          
1499          /*
1500           * ----------------------------------------------------------------------------
1501           * U8_T HSUR_GetLineStatus(U8_T intrSynth)
1502           * Purpose : Getting the HSUR Line Status .
1503           * Params  : intrSynth - 1: Get LSR according to an interrupt trigger.
1504           *                       0: Get LSR by directly reading the register.
1505           * Returns : varLineStatus - Line status register variable.
1506           * Note    : none
1507           * ----------------------------------------------------------------------------
1508           */
1509          U8_T HSUR_GetLineStatus(U8_T intrSynth)
1510          {
1511   1              U8_T    far varLineStatus = 0;
1512   1      
1513   1              if (intrSynth == TRUE)
1514   1                      varLineStatus = hsurLineStatusValue;
1515   1              else if (intrSynth == FALSE)
1516   1                      varLineStatus = UR2_LSR;
1517   1      
1518   1              return varLineStatus;
1519   1      }
1520          
1521          /*
1522           * ----------------------------------------------------------------------------
1523           * U8_T HSUR_GetModemStatus(U8_T intrSynth)
1524           * Purpose : Getting the HSUR Modem Status .
1525           * Params  : intrSynth - 1: Get MSR according to an interrupt trigger.
1526           *                       0: Get MSR by directly reading the register.
1527           * Returns : varModemStatus - Modem status register variable.
1528           * Note    : none
1529           * ----------------------------------------------------------------------------
1530           */
1531          U8_T HSUR_GetModemStatus(U8_T intrSynth)
1532          {
1533   1              U8_T    far varModemStatus = 0;
1534   1      
1535   1              if (intrSynth == TRUE)
1536   1                      varModemStatus = hsurModemStatusValue;
1537   1              else if (intrSynth == FALSE)
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 26  

1538   1                      varModemStatus = UR2_MSR;
1539   1      
1540   1              return varModemStatus;
1541   1      }
1542          
1543          /*
1544           * ----------------------------------------------------------------------------
1545           * BOOL HSUR_XonByApp(void)
1546           * Purpose : Application issue flow control characters Xon to driver for
1547           *           stopping or starting the current transfer.
1548           * Params  : none
1549           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1550           *           FLASE - driver is not in Xon/Xoff flow control.
1551           * Note    : none
1552           * ----------------------------------------------------------------------------
1553           */
1554          BOOL HSUR_XonToApp(void)
1555          {
1556   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1557   1              {
1558   2                      return FALSE;
1559   2              }
1560   1      
1561   1              hsurAppFlowOn = TRUE;
1562   1      
1563   1              return TRUE;
1564   1      }
1565          
1566          /*
1567           * ----------------------------------------------------------------------------
1568           * BOOL HSUR_XoffByApp(void)
1569           * Purpose : Application issue flow control characters Xoff to driver for
1570           *           stopping or starting the current transfer.
1571           * Params  : none
1572           * Returns : TRUE - driver is already in Xon/Xoff flow control.
1573           *           FLASE - driver is not in Xon/Xoff flow control.
1574           * Note    : none
1575           * ----------------------------------------------------------------------------
1576           */
1577          BOOL HSUR_XoffByApp(void)
1578          {
1579   1              if (hsurFlowCtrl != UR2_FLOW_CTRL_X)
1580   1              {
1581   2                      return FALSE;
1582   2              }
1583   1      
1584   1              hsurAppFlowOn = FALSE;
1585   1      
1586   1              return TRUE;
1587   1      }
1588          
1589          
1590          /*
1591           *--------------------------------------------------------------------------------
1592           * U8_T HSUR_GetByteNb(U8_T* pDat)
1593           * Purpose : Getting data from the software receiver buffer, which stores data 
1594           *           received from a serial bus. This function is similar to HSUR_GetChar,
1595           *           but this function only check buffer one time.
1596           * Params  : pDat - pointer to a buffer for storing the byte data.
1597           * Returns : TRUE - success
1598           *           FALSE - fail       
1599           * Note    : None.
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 27  

1600           *--------------------------------------------------------------------------------
1601           */
1602          U8_T HSUR_GetByteNb(U8_T* pDat)
1603          { 
1604   1              if (hsurRxCount > 0)
1605   1              {
1606   2                      UR2_IER &= ~UR2_RDI_ENB;
1607   2      
1608   2                      *pDat = hsurRxBuffer[hsurGetPtr];               
1609   2                      hsurGetPtr++;
1610   2                      hsurRxCount --;
1611   2                      if (hsurGetPtr == UR2_MAX_RX_SIZE)
1612   2                              hsurGetPtr = 0;
1613   2      
1614   2                      if (hsurFlowOn)
1615   2                      {
1616   3                              if (hsurRxCount <= UR2_FLOW_LO_WATERMARK)
1617   3                              {
1618   4                                      hsurFlowOn = FALSE;
1619   4      
1620   4                                      if (hsurFlowCtrl == UR2_FLOW_CTRL_HW)
1621   4                                      {
1622   5                                              HSUR_SetRTS();
1623   5                                      }
1624   4                                      else if (hsurFlowCtrl == UR2_FLOW_CTRL_X)
1625   4                                      {
1626   5                                              UR2_THR = ASCII_XON;
1627   5                                      }
1628   4                              }
1629   3                      }
1630   2      
1631   2                      UR2_IER |= UR2_RDI_ENB;
1632   2      
1633   2                      return TRUE;
1634   2              }
1635   1              
1636   1              return FALSE;
1637   1      }
1638          
1639          /*
1640           * ----------------------------------------------------------------------------
1641           * BOOL HSUR_SetupPort(U16_T divBaudRate, U8_T lctrl)
1642           * Purpose : Setting the HSUR baudrate.
1643           * Params  : divBaudRate - divisor of the baudrate.
1644           *           lctrl - line control 
1645           * Returns : 
1646           * Note    : none
1647           * ----------------------------------------------------------------------------
1648           */
1649          void HSUR_SetupPort(U16_T divBaudRate, U8_T lctrl)
1650          {
1651   1              U8_T    recIntrEnb = UR2_IER;
1652   1      
1653   1              UR2_IER = 0;
1654   1              UR2_LCR |= UR2_DLAB_ENB;
1655   1              UR2_DLL = (U8_T)(divBaudRate & 0x00FF);
1656   1              UR2_DLH = (U8_T)((divBaudRate & 0xFF00) >> 8);
1657   1              UR2_LCR &= ~UR2_DLAB_ENB;
1658   1      
1659   1              hsurBaudRateDivisor = divBaudRate;
1660   1      
1661   1              switch (CSREPR & 0xC0)
C51 COMPILER V9.06   HSUART                                                                05/28/2013 10:15:29 PAGE 28  

1662   1              {
1663   2                      case SCS_100M :
1664   2                              P3 = 0x10;
1665   2                              break;
1666   2                      case SCS_50M :
1667   2                              P3 = 0x50;
1668   2                              break;
1669   2                      case SCS_25M :
1670   2                              P3 = 0x25;
1671   2                              break;
1672   2              }
1673   1      
1674   1              UR2_FCR |= UR2_RXFIFO_RST | UR2_TXFIFO_RST;
1675   1      
1676   1          UR2_LCR = lctrl;
1677   1              hsurLineControlValue = lctrl;
1678   1      
1679   1              UR2_IER = recIntrEnb;
1680   1      }
1681          /* End of hsuart.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4797    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1097    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
