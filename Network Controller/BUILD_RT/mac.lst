C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE MAC
OBJECT MODULE PLACED IN .\mac.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\ethernet\mac.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) 
                    -INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;.
                    -.\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\b
                    -uffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..
                    -\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\mac.lst) OBJECT(.\mac.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11          /*=============================================================================
  12           * Module Name: mac.c
  13           * Purpose:  
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: mac.c,v $
  18           * Revision 1.1.1.1  2006/06/20 05:50:28  borbin
  19           * no message
  20           *
  21           *=============================================================================
  22           */
  23          
  24          /* INCLUDE FILE DECLARATIONS */
  25          #include "reg80390.h"
  26          #include "mac.h"
  27          #include "stoe.h"
  28          #include "delay.h"
  29          #include <intrins.h>
  30          
  31          /* GLOBAL VARIABLES DECLARATIONS */
  32          static U8_T XDATA mac_InterruptStatus = 0;
  33          
  34          /* LOCAL SUBPROGRAM DECLARATIONS */
  35          static void mac_InterruptEnable(void);
  36          static void mac_InterruptDisable(void);
  37          static void mac_StartOperate(void);
  38          static void mac_StopOperate(void);
  39          
  40          /*
  41           * ----------------------------------------------------------------------------
  42           * Function Name: mac_ReadReg
  43           * Purpose:
  44           * Params:
  45           * Returns:
  46           * Note:
  47           * ----------------------------------------------------------------------------
  48           */
  49          void mac_ReadReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  50          {
  51   1              U8_T    isr;
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 2   

  52   1      
  53   1              isr = EA;
  54   1              EA = 0;
  55   1              _nop_();
  56   1              MCIR = regaddr;
  57   1              while (length--)
  58   1                      pbuf[length] = MDR;
  59   1              EA = isr;
  60   1      
  61   1      } /* End of mac_ReadReg */
  62          
  63          /*
  64           * ----------------------------------------------------------------------------
  65           * Function Name: mac_WriteReg
  66           * Purpose:
  67           * Params:
  68           * Returns:
  69           * Note:
  70           * ----------------------------------------------------------------------------
  71           */
  72          void mac_WriteReg(U8_T regaddr, U8_T XDATA* pbuf, U8_T length)
  73          {
  74   1              U8_T    isr;
  75   1      
  76   1              isr = EA;
  77   1              EA = 0;
  78   1              while (length--)
  79   1                      MDR = pbuf[length];
  80   1              MCIR = regaddr;
  81   1              EA = isr;
  82   1      
  83   1      } /* End of mac_WriteReg */
  84          
  85          /*
  86           * ----------------------------------------------------------------------------
  87           * Function Name: MAC_Init
  88           * Purpose: initial all registers and variables of MAC.
  89           * Params: network_type -0: auto- negotiation
  90           *                                              -1: fixed 100 full speed.
  91           *                                              -2: fixed 100 half speed.
  92           *                                              -3: fixed 10 full speed.
  93           *                                              -4: fixed 10 half speed.
  94           * Returns:
  95           * Note:
  96           * ----------------------------------------------------------------------------
  97           */
  98          void MAC_Init(U8_T network_type)
  99          {
 100   1              U8_T XDATA      temp[3];
 101   1      
 102   1              /* read MAC address*/
 103   1              mac_ReadReg(MAC_ADDR_REG, PNetStation->CurrStaAddr, MAC_ADDRESS_LEN);
 104   1      
 105   1              /* use embedded phy */
 106   1              temp[0] = (PHY_SELECT_EMBEDDED | PHY_INTERNAL_PHY_OPERA_STATE | BIT1);
 107   1              mac_WriteReg(MAC_PHY_CTL_REG, temp, 1);
 108   1      
 109   1              /* phy power up */
 110   1              PHY_PowerUp();
 111   1      
 112   1              /* reset embedded phy */
 113   1              temp[0] = (PHY_SELECT_EMBEDDED | BIT1);
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 3   

 114   1              mac_WriteReg(MAC_PHY_CTL_REG, temp, 1);
 115   1      
 116   1              DELAY_Ms(2);
 117   1      
 118   1              /* set embedded phy to operating mode */
 119   1              temp[0] = (PHY_SELECT_EMBEDDED | PHY_INTERNAL_PHY_OPERA_STATE | BIT1);
 120   1              mac_WriteReg(MAC_PHY_CTL_REG, temp, 1);
 121   1      
 122   1              /* stop & reset MAC operation */
 123   1              mac_StopOperate();
 124   1      
 125   1              if (network_type != FORCE_EMBEDDED_PHY_10_HALF)
 126   1              {
 127   2                      /* phy initialize. */
 128   2                      PHY_Init(network_type);
 129   2              }
 130   1      
 131   1              PBDP->MacInfo.MediumLinkType = MEDIUM_ENABLE_TX_FLOWCTRL;
 132   1              PBDP->MacInfo.FullDuplex = 1;
 133   1              switch (network_type)
 134   1              {
 135   2              default:
 136   2              case AUTO_NEGOTIATION:
 137   2                      PBDP->MacInfo.NetworkType = MAC_AUTO_NEGOTIATION;
 138   2                      PBDP->MacInfo.MediumLinkType|=(MEDIUM_FULL_DUPLEX_MODE | MEDIUM_MII_100M_MODE |
 139   2                              MEDIUM_ENABLE_RX_FLOWCTRL);
 140   2                      break;
 141   2              case FIXED_100_FULL:
 142   2                      PBDP->MacInfo.NetworkType = (MAC_LINK_100M_SPEED | MAC_LINK_FULL_DUPLEX);
 143   2                      PBDP->MacInfo.MediumLinkType|=(MEDIUM_FULL_DUPLEX_MODE | MEDIUM_MII_100M_MODE |
 144   2                              MEDIUM_ENABLE_RX_FLOWCTRL);
 145   2                      break;
 146   2              case FIXED_100_HALF:
 147   2                      PBDP->MacInfo.NetworkType = MAC_LINK_100M_SPEED;
 148   2                      PBDP->MacInfo.MediumLinkType |= MEDIUM_MII_100M_MODE;
 149   2                      break;
 150   2              case FIXED_10_FULL:
 151   2                      PBDP->MacInfo.NetworkType = (MAC_LINK_10M_SPEED | MAC_LINK_FULL_DUPLEX);
 152   2                      PBDP->MacInfo.MediumLinkType |= (MEDIUM_FULL_DUPLEX_MODE |
 153   2                              MEDIUM_ENABLE_RX_FLOWCTRL);
 154   2                      break;
 155   2              case FIXED_10_HALF:
 156   2                      PBDP->MacInfo.NetworkType = MAC_LINK_10M_SPEED;
 157   2                      break;
 158   2              case FORCE_EMBEDDED_PHY_10_HALF:
 159   2                      PBDP->MacInfo.NetworkType = MAC_FORCE_ENBEDDED_PHY_10_HALF;
 160   2                      PBDP->MacInfo.MediumLinkType = 0;
 161   2                      break;
 162   2              }
 163   1              /* set medium status */
 164   1              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
 165   1      
 166   1              /* set IPG */
 167   1              temp[0] = 0x2b;
 168   1              temp[1] = 0x16;
 169   1              temp[2] = 0x95;
 170   1              mac_WriteReg(MAC_IPG_CTL_REG, temp, 3);
 171   1      
 172   1              /* set RX filter. */
 173   1              temp[0] = BIT6;
 174   1              mac_WriteReg(MAC_RX_CTL_REG, temp, 1);
 175   1              MAC_SetRxFilter(MAC_RCV_BROADCAST);
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 4   

 176   1      
 177   1              PBDP->MacInfo.LinkSpeed = 0; // Ethernet not linkup.
 178   1      
 179   1              /* decide interrupt mask */
 180   1      #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE) 
 181   1              PBDP->MacInfo.InterruptMask = PRIMARY_LINK_CHANGE_ENABLE;
 182   1      #endif
 183   1      
 184   1      } /* End of MAC_Init() */
 185          
 186          /*
 187           * ----------------------------------------------------------------------------
 188           * Function Name: MAC_GetMacAddr
 189           * Purpose:
 190           * Params:
 191           * Returns:
 192           * Note:
 193           * ----------------------------------------------------------------------------
 194           */
 195          U8_T* MAC_GetMacAddr(void)
 196          {
 197   1              return PNetStation->CurrStaAddr;
 198   1      
 199   1      } /* End of MAC_GetMacAddr() */
 200          
 201          /*
 202           * ----------------------------------------------------------------------------
 203           * Function Name: MAC_GetMacAddr
 204           * Purpose:
 205           * Params:
 206           * Returns:
 207           * Note:
 208           * ----------------------------------------------------------------------------
 209           */
 210          void MAC_SetMacAddr(U8_T* addr)
 211          {
 212   1              U8_T i;
 213   1      
 214   1              for (i = 0; i < MAC_ADDRESS_LEN; i++)
 215   1                      PNetStation->CurrStaAddr[i] = addr[i];
 216   1                      
 217   1              mac_WriteReg(MAC_ADDR_REG, PNetStation->CurrStaAddr, MAC_ADDRESS_LEN);
 218   1      }
 219          
 220          /*
 221           * ----------------------------------------------------------------------------
 222           * Function Name: MAC_Start
 223           * Purpose:
 224           * Params:
 225           * Returns:
 226           * Note:
 227           * ----------------------------------------------------------------------------
 228           */
 229          void MAC_Start(void)
 230          {
 231   1      #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE) 
 232   1              /* clear mac interrupt status */
 233   1              mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &mac_InterruptStatus, 1);
 234   1      
 235   1              /* enable mac interrupt */
 236   1              mac_InterruptEnable();
 237   1      #endif
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 5   

 238   1      
 239   1      } /* End of MAC_Start() */
 240          
 241          /*
 242           * ----------------------------------------------------------------------------
 243           * Function Name: mac_StartOperate
 244           * Purpose:
 245           * Params:
 246           * Returns:
 247           * Note:
 248           * ----------------------------------------------------------------------------
 249           */
 250          void mac_StartOperate(void)
 251          {
 252   1              U8_T XDATA      temp;
 253   1      
 254   1              mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
 255   1      
 256   1              /* set mac register to start receive/transmit packets. */
 257   1              temp |= START_OPERATION;
 258   1              mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
 259   1      
 260   1      } /* End of mac_StartOperate */
 261          
 262          /*
 263           * ----------------------------------------------------------------------------
 264           * Function Name: mac_StopOperate
 265           * Purpose:
 266           * Params:
 267           * Returns:
 268           * Note:
 269           * ----------------------------------------------------------------------------
 270           */
 271          void mac_StopOperate(void)
 272          {
 273   1              U8_T XDATA      temp;
 274   1      
 275   1              mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
 276   1      
 277   1              temp &= ~START_OPERATION;
 278   1              mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
 279   1      
 280   1      } /* End of mac_StopOperate */
 281          
 282          /*
 283           * ----------------------------------------------------------------------------
 284           * Function Name: MAC_SetRxFilter
 285           * Purpose:
 286           * Params:
 287           * Returns:
 288           * Note:
 289           * ----------------------------------------------------------------------------
 290           */
 291          void MAC_SetRxFilter(U8_T filter)
 292          {
 293   1              U8_T XDATA      temp;
 294   1      
 295   1              mac_ReadReg(MAC_RX_CTL_REG, &temp, 1);
 296   1      
 297   1              /* set rcv filter. */
 298   1              temp &= 0xc0;
 299   1              if (filter & MAC_RCV_PROMISCUOUS)
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 6   

 300   1                      temp |= PACKET_TYPE_PROMISCOUS;
 301   1              if (filter & MAC_RCV_ALL_MULTICAST)
 302   1                      temp |= PACKET_TYPE_ALL_MULTI;
 303   1              if (filter & MAC_RCV_BROADCAST)
 304   1                      temp |= PACKET_TYPE_BROADCAST;
 305   1              if (filter & MAC_RCV_MULTICAST)
 306   1                      temp |= PACKET_TYPE_MULTICAST;
 307   1      
 308   1              mac_WriteReg(MAC_RX_CTL_REG, &temp, 1);
 309   1      
 310   1      } /* End of MAC_SetRxFilter() */
 311          
 312          #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE) 
 313          /*
 314           * ----------------------------------------------------------------------------
 315           * Function Name: mac_InterruptEnable
 316           * Purpose:
 317           * Params:
 318           * Returns:
 319           * Note:
 320           * ----------------------------------------------------------------------------
 321           */
 322          void mac_InterruptEnable(void)
 323          {
 324   1              U8_T XDATA      temp;
 325   1      
 326   1              /* set link change interrupt enable */
 327   1              temp = PBDP->MacInfo.InterruptMask;
 328   1              mac_WriteReg(MAC_LINK_CHANGE_INT_ENABLE_REG, &temp, 1);
 329   1      
 330   1      } /* End of mac_InterruptEnable */
 331          
 332          /*
 333           * ----------------------------------------------------------------------------
 334           * Function Name: mac_InterruptDisable
 335           * Purpose:
 336           * Params:
 337           * Returns:
 338           * Note:
 339           * ----------------------------------------------------------------------------
 340           */
 341          void mac_InterruptDisable(void)
 342          {
 343   1              U8_T XDATA      temp;
 344   1      
 345   1              temp = 0;
 346   1              mac_WriteReg(MAC_LINK_CHANGE_INT_ENABLE_REG, &temp, 1);
 347   1      
 348   1      } /* End of mac_InterruptDisable */
 349          
 350          /*
 351           * ----------------------------------------------------------------------------
 352           * Function Name: MAC_SetInterruptFlag
 353           * Purpose:
 354           * Params:
 355           * Returns:
 356           * Note:
 357           * ----------------------------------------------------------------------------
 358           */
 359          void MAC_SetInterruptFlag(void)
 360          {
 361   1              mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &mac_InterruptStatus, 1);
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 7   

 362   1              if (!(mac_InterruptStatus & STATUS_PRIMARY_LINK_CHANGE))
 363   1                      mac_InterruptStatus = 0;
 364   1      
 365   1      } /* End of MAC_SetInterruptFlag() */
 366          
 367          /*
 368           * ----------------------------------------------------------------------------
 369           * Function Name: MAC_GetInterruptFlag
 370           * Purpose:
 371           * Params:
 372           * Returns:
 373           * Note:
 374           * ----------------------------------------------------------------------------
 375           */
 376          U8_T MAC_GetInterruptFlag(void)
 377          {
 378   1              U8_T flag, isr;
 379   1      
 380   1              isr = EA;
 381   1              EA = 0;
 382   1              flag = mac_InterruptStatus;
 383   1              EA = isr;
 384   1      
 385   1              return flag;
 386   1      
 387   1      } /* End of MAC_GetInterruptFlag() */
 388          #endif
 389          
 390          /*
 391           * ----------------------------------------------------------------------------
 392           * Function Name: mac_GetMediaType
 393           * Purpose:
 394           * Params:
 395           * Returns:
 396           * Note:
 397           * ----------------------------------------------------------------------------
 398           */
 399          U8_T mac_GetMediaType(void)
 400          {
 401   1              U16_T   phylinkstatus;
 402   1      
 403   1              phylinkstatus = PHY_CheckMediaType();
 404   1      
 405   1              PBDP->MacInfo.FullDuplex = TRUE;
 406   1      
 407   1              PBDP->MacInfo.MediumLinkType = (MEDIUM_ENABLE_TX_FLOWCTRL | MEDIUM_ENABLE_RECEIVE);
 408   1      
 409   1              /* Determine if we're linked to 100 full duplex. */
 410   1              if (phylinkstatus & ANLPAR_100TXFD)
 411   1              {
 412   2                      PBDP->MacInfo.LinkSpeed = 100;
 413   2                      PBDP->MacInfo.MediumLinkType |=(MEDIUM_FULL_DUPLEX_MODE |MEDIUM_MII_100M_MODE);
 414   2      //              printf ("Link to 100 FULL.\n\r");
 415   2              }
 416   1              /* Determine if we're linked to 100 half duplex. */
 417   1              else if (phylinkstatus & ANLPAR_100TX)
 418   1              {
 419   2                      PBDP->MacInfo.LinkSpeed = 100;
 420   2                      PBDP->MacInfo.MediumLinkType |= MEDIUM_MII_100M_MODE;
 421   2                      PBDP->MacInfo.FullDuplex = FALSE;
 422   2      //              printf ("Link to 100 HALF.\n\r");
 423   2              } 
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 8   

 424   1              /* Determine if we're linked to 10 full duplex. */
 425   1              else if (phylinkstatus & ANLPAR_10TFD)
 426   1              {
 427   2                      PBDP->MacInfo.LinkSpeed = 10;
 428   2                      PBDP->MacInfo.MediumLinkType |= MEDIUM_FULL_DUPLEX_MODE;
 429   2      //              printf ("Link to 10 FULL.\n\r");
 430   2              }
 431   1              /* we're linked to 10 half duplex. */
 432   1              else
 433   1              {
 434   2                      PBDP->MacInfo.LinkSpeed = 10;
 435   2                      PBDP->MacInfo.FullDuplex = FALSE;
 436   2      //              printf ("Link to 10 HALF.\n\r");
 437   2              }
 438   1      
 439   1              if (PBDP->MacInfo.FullDuplex)
 440   1                      PBDP->MacInfo.MediumLinkType |= MEDIUM_ENABLE_RX_FLOWCTRL;
 441   1              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
 442   1      
 443   1              return PBDP->MacInfo.LinkSpeed;
 444   1      
 445   1      } /* End of mac_GetMediaType */
 446          
 447          #if (MAC_GET_INTSTATUS_MODE == MAC_INTERRUPT_MODE)
 448          /*
 449           * ----------------------------------------------------------------------------
 450           * Function Name: mac_LinkSpeedChk
 451           * Purpose:
 452           * Params: none
 453           * Returns:     100: Ethernet is link to 100M
 454           *                      10 : Ethernet is link to 10M
 455           *                      0  : not link
 456           * Note:
 457           * ----------------------------------------------------------------------------
 458           */
 459          U8_T mac_LinkSpeedChk(void)
 460          {
 461   1              if (mac_InterruptStatus & STATUS_PRIMARY_IS_LINK_UP)
 462   1              {
 463   2                      mac_InterruptStatus = 0;
 464   2                      if (PBDP->MacInfo.NetworkType != MAC_FORCE_ENBEDDED_PHY_10_HALF)
 465   2                      {
 466   3                              mac_GetMediaType();
 467   3                      }
 468   2                      else
 469   2                      {
 470   3                              PBDP->MacInfo.FullDuplex = 0;
 471   3                              PBDP->MacInfo.LinkSpeed = 10;
 472   3      
 473   3                              PBDP->MacInfo.MediumLinkType = MEDIUM_ENABLE_RECEIVE;
 474   3                              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
 475   3                      }
 476   2      
 477   2                      /* start operation */
 478   2                      mac_StartOperate();
 479   2                      DELAY_Ms(0x30);
 480   2              }
 481   1              else
 482   1              {
 483   2                      mac_InterruptStatus = 0;                
 484   2                      if (PBDP->MacInfo.LinkSpeed)
 485   2                      {
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 9   

 486   3                              PBDP->MacInfo.LinkSpeed = 0;
 487   3      
 488   3                              /* disable receive */
 489   3                              PBDP->MacInfo.MediumLinkType &= ~MEDIUM_ENABLE_RECEIVE;
 490   3                              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
 491   3      
 492   3                              STOE_WaitHwReleaseRcvBuf();
 493   3      
 494   3                              /* stop operation and reset Ethernet MAC packet buffer */
 495   3                              mac_StopOperate();
 496   3      
 497   3                              if (PBDP->MacInfo.NetworkType != MAC_FORCE_ENBEDDED_PHY_10_HALF)
 498   3                              {
 499   4                                      PHY_WatchDog();
 500   4                              }
 501   3                      }
 502   2              }
 503   1      
 504   1              return PBDP->MacInfo.LinkSpeed;
 505   1      
 506   1      } /* End of mac_LinkSpeedChk */
 507          
 508          /*
 509           * ----------------------------------------------------------------------------
 510           * Function Name: MAC_ProcessInterrupt
 511           * Purpose:
 512           * Params:
 513           * Returns:
 514           * Note:
 515           * ----------------------------------------------------------------------------
 516           */
 517          void MAC_ProcessInterrupt(void)
 518          {
 519   1              mac_InterruptDisable();
 520   1      
 521   1              if (mac_InterruptStatus & STATUS_PRIMARY_LINK_CHANGE)
 522   1                      mac_LinkSpeedChk();
 523   1      
 524   1              mac_InterruptEnable();
 525   1      
 526   1      } /* End of MAC_ProcessInterrupt */
 527          #else
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_LinkSpeedChk
               * Purpose:
               * Params: none
               * Returns:     100: Ethernet is link to 100M
               *                      10 : Ethernet is link to 10M
               *                      0  : not link
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T MAC_LinkSpeedChk(void)
              {
                      mac_ReadReg(MAC_WAKEUP_LINK_INT_STATUS_REG, &mac_InterruptStatus, 1);
                      if (mac_InterruptStatus & STATUS_PRIMARY_IS_LINK_UP)
                      {
                              if (PBDP->MacInfo.LinkSpeed == 0)
                              {
                                      if (PBDP->MacInfo.NetworkType != MAC_FORCE_ENBEDDED_PHY_10_HALF)
                                      {
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 10  

                                              mac_GetMediaType();
                                      }
                                      else
                                      {
                                              PBDP->MacInfo.FullDuplex = 0;
                                              PBDP->MacInfo.LinkSpeed = 10;
              
                                              PBDP->MacInfo.MediumLinkType = MEDIUM_ENABLE_RECEIVE;
                                              mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
                                      }
              
                                      /* start operation */
                                      mac_StartOperate();
                                      DELAY_Ms(0x30);
                              }
                      }
                      else
                      {
                              if (PBDP->MacInfo.LinkSpeed)
                              {
                                      PBDP->MacInfo.LinkSpeed = 0;
              
                                      /* disable receive */
                                      PBDP->MacInfo.MediumLinkType &= ~MEDIUM_ENABLE_RECEIVE;
                                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &PBDP->MacInfo.MediumLinkType, 1);
              
                                      STOE_WaitHwReleaseRcvBuf();
              
                                      /* stop operation and reset Ethernet MAC packet buffer */
                                      mac_StopOperate();
              
                                      if (PBDP->MacInfo.NetworkType != MAC_FORCE_ENBEDDED_PHY_10_HALF)
                                      {
                                              PHY_WatchDog();
                                      }
                              }
                      }
              
                      return PBDP->MacInfo.LinkSpeed;
              
              } /* End of MAC_LinkSpeedChk */
              #endif
 590          
 591          #if (MAC_REMOTE_WAKEUP == MAC_SUPPORT)
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_WakeupEnable
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void MAC_WakeupEnable(U8_T type)
              {
                      U8_T    temp = 0;
              
                      if (type & MAC_PRIMARY_PHY_LINK_WAKEUP)
                              temp |= WAKEUP_BY_PRIMARY_LINK_UP;
                      if (type & MAC_MAGIC_PACKET_WAKEUP)
                              temp |= WAKEUP_BY_MAGIC_PACKET;
                      if (type & MAC_EXTERNAL_PIN_WAKEUP)
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 11  

                              temp |= WAKEUP_BY_EXTER_PIN_TRIG;
                      if (type & MAC_MS_FRAME_WAKEUP)
                              temp |= WAKEUP_BY_MICROSOFT_FRAME;
              
                      mac_WriteReg(MAC_WAKEUP_INT_ENABLE_REG, &temp, 1);
              
              } /* End of MAC_WakeupEnable() */
              
              /*
              * -----------------------------------------------------------------------------
               * Function Name: mac_crc16
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              U16_T mac_crc16(U8_T* pbuf, U8_T len)
              {
                      U16_T   crc, carry;
                      U8_T    i, j;
                      S8_T    curByte;
              
                      crc = 0xffff;
              
                      for (i = 0; i < len; i++)
                      {
                              curByte = pbuf[i];
                              for (j = 0; j < 8; j++)
                              {
                                      carry = ((crc & 0x8000) ? 1 : 0) ^ (curByte & 0x01);
                                      crc <<= 1;
                                      curByte >>= 1;
              
                                      if (carry)
                                          crc = ((crc ^ 0x8004) | carry);
                              }
                  }
              
                      return crc;
              
              } /* End of cal_crc16 */
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: MAC_SetWakeupFrame
               * Purpose: for setting registers about wakeup frame
               * Params:      pWuf : point to MAC_WUF data structure
               * Returns:     0: setting fail.
               *                      1: setting success.
               * Note:
               * ----------------------------------------------------------------------------
               */
              U8_T MAC_SetWakeupFrame(MAC_WUF* pWuf)
              {
                      U32_T XDATA     mask0, mask1;
                      U16_T XDATA crc16;
                      U8_T XDATA*     pMask;
                      U8_T XDATA      wakeupCmd, offset0, offset1;
                      U8_T            mode, i, maskLen, x, y;
                      U8_T            frame[64];
              
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 12  

                      mode = pWuf->Mode;
                      offset0 = pWuf->Offset0;
                      offset1 = pWuf->Offset1;
                      mask0 = pWuf->Mask0;
                      mask1 = pWuf->Mask1;
              
                      mac_WriteReg(MAC_WAKEUP_FRAME_OFFSET1, &offset1, 1);
                      mac_WriteReg(MAC_WAKEUP_FRAME_OFFSET0, &offset0, 1);
                      mac_WriteReg(MAC_WAKEUP_FRAME_MASK1, (U8_T XDATA*)&mask1, 4);
                      mac_WriteReg(MAC_WAKEUP_FRAME_MASK0, (U8_T XDATA*)&mask0, 4);
              
                      if (mode < WUF_BOTH_FILTERS) /* single filter */
                      {
                              if (mode & BIT0)
                              {
                                      wakeupCmd = WAKEUP_FRAME_FILTER1_ENABLE;
                                      if (mode & BIT1)
                                              wakeupCmd |= WAKEUP_FRAME_FILTER1_UNI_ENABLE;
                              }
                              else
                              {
                                      wakeupCmd = WAKEUP_FRAME_FILTER0_ENABLE;
                                      if (mode & BIT1)
                                              wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                              }
                      }
                      else if (mode < WUF_CASCADE) /* both filter */
                      {
                              wakeupCmd = (WAKEUP_FRAME_FILTER1_ENABLE | WAKEUP_FRAME_FILTER0_ENABLE);
                              if (mode & BIT1)
                                      wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                      }
                      else /* cascade */
                      {
                              wakeupCmd = (WAKEUP_FRAME_FILTER1_ENABLE | WAKEUP_FRAME_FILTER0_ENABLE |
                                      WAKEUP_FRAME_CASCADE_ENABLE);
                              if (mode & BIT1)
                                      wakeupCmd |= WAKEUP_FRAME_FILTER0_UNI_ENABLE;
                      }
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER0_UNI_ENABLE) && (mask0 == 0))
                              return 0;
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER1_UNI_ENABLE) && (mask1 == 0))
                              return 0;
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER0_UNI_ENABLE) &&
                              !(wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE))
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask0;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset0*2) > pWuf->Length)
                                                              return 0;
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 13  

              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset0*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC0, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE0, &frame[maskLen -1], 1);
                      }
              
                      if ((wakeupCmd & WAKEUP_FRAME_FILTER1_UNI_ENABLE) &&
                              !(wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE))
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask1;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset1*2) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset1*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC1, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE1, &frame[maskLen -1], 1);
                      }
              
                      if (wakeupCmd & WAKEUP_FRAME_CASCADE_ENABLE)
                      {
                              maskLen = 0;
                              for (i = 0; i < 64; i++) /* clear buffer */
                                      frame[i] = 0;
              
                              pMask = (U8_T XDATA*)&mask0;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + offset0*2) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + offset0*2];
                                                      maskLen++;
                                              }
                                      }
                              }
              
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 14  

                              pMask = (U8_T XDATA*)&mask1;
                              for (x = 0; x < 4; x++)
                              {
                                      for (y = 0; y < 8; y++)
                                      {
                                              if (pMask[3 - x] & (1 << y))
                                              {
                                                      if ((8*x + y + (offset1 + offset0)*2 + 32) > pWuf->Length)
                                                              return 0;
              
                                                      frame[maskLen] = pWuf->Pframe[8*x + y + (offset1 + offset0)*2 + 32];
                                                      maskLen++;
                                              }
                                      }
                              }
              
                              crc16 = mac_crc16(frame, maskLen);
                              mac_WriteReg(MAC_WAKEUP_FRAME_CRC1, (U8_T XDATA*)&crc16, 2);
                              mac_WriteReg(MAC_WAKEUP_FRAME_LAST_BYTE1, &frame[maskLen -1], 1);
                      }
              
                      mac_WriteReg(MAC_WAKEUP_FRAME_COMMAND, &wakeupCmd, 1);
                      return 1;
              
              } /* End of MAC_SetWakeupFrame() */
              
              /*
              * -----------------------------------------------------------------------------
               * Function Name: MAC_SystemSleep
               * Purpose:
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void MAC_SystemSleep(void)
              {
                      U8_T XDATA      temp;
              
                      /* disable mac receive */
                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      temp &= 0xfb;
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
              
                      DELAY_Ms(500);
                      PCON = SWB_;
                      PCON |= STOP_;
              
                      DELAY_Ms(500);
              
                      /* enable mac receive */
                      mac_ReadReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
                      temp |= 4;
                      mac_WriteReg(MAC_MEDIUM_STATUS_MODE_REG, &temp, 1);
              
              } /* End of MAC_SystemSleep() */
              #endif
 853          
 854          #if (MAC_MULTICAST_FILTER == MAC_SUPPORT)
 855          /*
 856          * -----------------------------------------------------------------------------
 857           * Function Name: mac_ComputeCrc32
C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 15  

 858           * Purpose:
 859           * Params:
 860           * Returns:
 861           * Note:
 862           * ----------------------------------------------------------------------------
 863           */
 864          U32_T mac_ComputeCrc32(U16_T length, U8_T* pbuf)
 865          {
 866   1              U32_T   crc32 = 0xffffffff;
 867   1              U8_T    curByte, carry, j;
 868   1              
 869   1              for (; length; length--)
 870   1              {
 871   2                      curByte = *pbuf++;
 872   2                      for (j=0; j<8; j++)
 873   2                      {
 874   3                              carry = curByte & 1;
 875   3                              if ( crc32 & 0x80000000 )
 876   3                                      carry ^= 1;
 877   3                              crc32 <<= 1;
 878   3                              curByte >>= 1;
 879   3                              if (carry)
 880   3                                      crc32 ^= 0x04c11db7;
 881   3                      }
 882   2              }
 883   1              return crc32;
 884   1      
 885   1      } /* End of mac_ComputeCrc32() */
 886          
 887          /*
 888           * ----------------------------------------------------------------------------
 889           * Function Name: MAC_MultiFilter
 890           * Purpose:
 891           * Params:
 892           * Returns:
 893           * Note:
 894           * ----------------------------------------------------------------------------
 895           */
 896          void MAC_MultiFilter(U8_T* pbuf, U8_T len)
 897          {
 898   1              U8_T    count = len/MAC_ADDRESS_LEN;
 899   1              U8_T    index, bitNum;
 900   1              U8_T    filter[8] = {0};
 901   1      
 902   1              for (index = 0; index < count; index++)
 903   1              {
 904   2                      if (!(pbuf[0] & 1))
 905   2                              break;
 906   2      
 907   2                      bitNum = (U8_T)((mac_ComputeCrc32(MAC_ADDRESS_LEN, pbuf)>>26)&0x3f);
 908   2                      pbuf += MAC_ADDRESS_LEN;
 909   2                      filter[7 - (bitNum/8)] |= (1 << (bitNum % 8));
 910   2              }
 911   1      
 912   1              mac_WriteReg(MAC_MULTICASE_REG, filter, 8);
 913   1      
 914   1      } /* End of MAC_MultiFilter() */
 915          #endif
 916          
 917          
 918          /* End of mac.c */

C51 COMPILER V9.06   MAC                                                                   03/13/2013 09:32:20 PAGE 16  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2199    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =      1      35
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
