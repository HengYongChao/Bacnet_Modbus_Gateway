C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE GSM
OBJECT MODULE PLACED IN .\gsm.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\gsm\gsm.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDI
                    -R(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC
                    -\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer
                    -\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\
                    -FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\src\
                    -gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\gsm.lst) OBJECT(
                    -.\gsm.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include <intrins.h>
   4          #include <stdlib.h>
   5          #include "../gsm/gsm.h"
   6          #include "../main/main.h"
   7          
   8          
   9          //#define TIME_TO_WAIT          4                 // baudrate 115200
  10          #define TIME_TO_WAIT            4                 // baudrate 115200
  11          #define TIME_TO_WAIT_RSV        4
  12          //#define TIME_TO_WAIT          81        // baudrate 9600
  13          #define TIME_BETWEEN_BYTE   300
  14          #define GSM_INIT_FINISH         255
  15          
  16          #define xGSM_DEBUG_OPEN                    // 打开或关闭调试
  17          #define GSM_USE_DELAY                      // 是否用延时模式
  18          
  19          gsm_buf_t gsm_RxBuf;
  20          gsm_state g_state;
  21          U8_T init_state = 0;
  22          //U8_T gsm_flag;
  23          char phone_num[20] = {0};
  24          
  25          U8_T phoneNumber[PHONE_NUM_SIZE + 1] = "+8613917905693";
  26          
  27          U8_T gsm_timeout = GSM_TIMEOUT_VALUE;
  28          
  29          extern unsigned char  auchCRCHi[256];
  30          extern unsigned char  auchCRCLo[256];
  31          extern void InitCRC16(void);
  32          extern void CRC16_Tstat(unsigned char ch);
  33          extern  unsigned char far  CRClo;
  34          extern unsigned  char far  CRChi;
  35          
  36          U8_T buf_for_crc[6];
  37          
  38          void MicroWait( U16_T timeout)
  39          {
  40   1              while( timeout--){
  41   2                      _nop_();
  42   2              }
  43   1      }
  44          
  45          void gsm_wait_interrupt( void)
  46          {
  47   1              TR0 = 1;
  48   1              while(!TF0);
  49   1              TF0 = 0;
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 2   

  50   1      
  51   1              TH0 = 0xfd;
  52   1              TL0 = 0x75;
  53   1      
  54   1      //      TH0 = 0xFF;
  55   1      //      TL0 = 0xAF;
  56   1      //      TH0 = 0xFA;
  57   1      //      TL0 = 0xEC;
  58   1              TR0 = 0;
  59   1      }
  60          
  61          #ifdef GSM_USE_DELAY
  62          void simulate_read_byte( void) interrupt 0
  63          {
  64   1              U8_T ch = 0;
  65   1              U8_T i = 8;
  66   1      
  67   1              EA = 0;
  68   1      
  69   1              MicroWait( TIME_TO_WAIT_RSV);
  70   1      
  71   1              while ( i--)
  72   1              {
  73   2                      ch = ch>>1;
  74   2                      if( GSM_RX)
  75   2                              ch |= 0x80;
  76   2                      MicroWait( TIME_TO_WAIT_RSV);
  77   2              }
  78   1      
  79   1              gsm_RxBuf.buf[gsm_RxBuf.size++] = ch;
  80   1      
  81   1              EA = 1;
  82   1              
  83   1      }
  84          #else
              void simulate_read_byte( void) interrupt 0
              {
                      U8_T ch = 0;
                      U8_T i = 8;
              
                      EA = 0;
                      gsm_wait_interrupt();                              // 等待起始位
              
                      while ( i--)
                      {
                              ch = ch>>1;
                              if( GSM_RX)
                                      ch |= 0x80;
                              gsm_wait_interrupt();
                      }
              //      
              //      MicroWait( 1);                                                   // 加上等待时间115200下不精准
                      gsm_RxBuf.buf[gsm_RxBuf.size++] = ch;
              //      gsm_wait_interrupt();                                    // 等待停止位
              
                      EA = 1;
                      
              //      return ch;      
              }
              #endif
 110          
 111          
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 3   

 112          #ifdef GSM_USE_DELAY
 113          void simulate_write_byte( U8_T ch)
 114          {
 115   1              U8_T i = 8;
 116   1      
 117   1      //      TR0 = 1;
 118   1      
 119   1              GSM_TX = 0;
 120   1      
 121   1      //      gsm_wait_interrupt();
 122   1              MicroWait(TIME_TO_WAIT);
 123   1      
 124   1              while ( i--)
 125   1              {
 126   2                      GSM_TX = (bit) (ch & 0x01);
 127   2      //              gsm_wait_interrupt();
 128   2                      MicroWait(TIME_TO_WAIT);
 129   2                      ch = ch>>1;
 130   2              }       
 131   1      //      gsm_debug( " Send one byte done");
 132   1              GSM_TX = 1;
 133   1      
 134   1      //      TR0 = 0;
 135   1      }
 136          
 137          #else
              void simulate_write_byte( U8_T ch)
              {
                      U8_T i = 8;
              
                      GSM_TX = 0;
              
                      gsm_wait_interrupt();
                      MicroWait(TIME_TO_WAIT);
              
                      while ( i--)
                      {
                              GSM_TX = (bit) (ch & 0x01);
                              gsm_wait_interrupt();
                              ch = ch>>1;
                      }       
                      GSM_TX = 1;
              
              }
              #endif
 157          
 158          static U8_T simulate_write_string( char *str, U8_T len)
 159          {
 160   1              U8_T cnt;
 161   1      
 162   1      //      gsm_debug( "Start sending string");
 163   1              for ( cnt = 0; cnt < len; cnt ++)
 164   1              {
 165   2                      simulate_write_byte( *str++);
 166   2                      MicroWait(3000);
 167   2              }
 168   1      
 169   1              return cnt;
 170   1      }
 171          
 172          void gsm_debug( char *msg)
 173          {
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 4   

 174   1              char temp[256] = {0};
 175   1      
 176   1              sprintf( temp, "%s\r\n", msg);
 177   1      #ifdef GSM_DEBUG_OPEN
                      Uart0_Tx( temp, strlen( temp));
              #else
 180   1              // nothing
 181   1      #endif
 182   1      }
 183          
 184          void send_at_cmd ( char *cmd)
 185          {
 186   1              char temp[256] = {0};
 187   1      
 188   1              sprintf( temp, "%s\r", cmd);
 189   1      //      gsm_debug( "send AT command");
 190   1      //      gsm_debug( temp);
 191   1              simulate_write_string( temp, strlen(temp));
 192   1      }
 193          
 194          #if 0
              void GSM_ISR ( void) interrupt 0
              {
              //      U8_T ch;
              
                      EA = 0;
              
              //      ch = simulate_read_byte();
              
              //      memcpy( gsm_RxBuf.buf, "OK\r", 3);
              
                      if ( gsm_RxBuf.size >= GSM_MAX_RX_LEN)
                              gsm_RxBuf.size = 0;
                      gsm_RxBuf.buf[gsm_RxBuf.size++] = simulate_read_byte();
                      
                      gsm_timeout = GSM_TIMEOUT_VALUE;
              
                      EA = 1;                   
              }
              #endif
 214          
 215          U8_T gsm_msg_process( char *msg)
 216          {
 217   1              U8_T *temp;
 218   1      //      U8_T temp1[64];
 219   1              U8_T *sms;
 220   1              U8_T *rest;
 221   1              U8_T *mod_id;
 222   1              U8_T *reg_id;
 223   1              U8_T *setpoint;
 224   1              U8_T buf[8];
 225   1              U16_T point;
 226   1              U8_T i;
 227   1      
 228   1              if  (((GSM_INIT_DONE == g_state) || (GSM_INIT_FINISH == init_state) 
 229   1                      || (GSM_WAITING == g_state) || (SMS_SENDING == g_state)) &&  strstr ( msg, ">"))
 230   1              {
 231   2      //              gsm_debug( gsm_RxBuf.buf);
 232   2                      g_state = SMS_READY;
 233   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 234   2                      gsm_RxBuf.size = 0;
 235   2              }
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 5   

 236   1              else if ( strstr( msg, "+CMTI"))                                   // 收到短信
 237   1              {
 238   2                      gsm_debug( gsm_RxBuf.buf);
 239   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 240   2                      gsm_RxBuf.size = 0;
 241   2                      gsm_debug( "RECEIVE A MESSAGE!");
 242   2                      g_state = GET_MSG;
 243   2              }
 244   1              else if( strstr( msg, "+CMGR"))
 245   1              {
 246   2                      gsm_debug( msg);
 247   2                      gsm_debug( "DISPLAY THE MESSAGE AND DELETE IT:");
 248   2              if( sms = strstr( msg, "\r"))
 249   2                      {
 250   3                              gsm_debug( sms);
 251   3                              if ( rest = strtok(sms, ";"))
 252   3                              {
 253   4                                      gsm_debug("+++++++++MOD_ID:");
 254   4                                      gsm_debug( rest);
 255   4                                      gsm_debug("+++++++++REG_ID:");
 256   4      
 257   4                                      if (reg_id = strtok( NULL, ";")){
 258   5                                              gsm_debug( reg_id);
 259   5                                              setpoint = strtok( NULL, ";");
 260   5                                              if( setpoint){
 261   6                                                      gsm_debug("+++++++++SETPOINT:");
 262   6                                                      gsm_debug( setpoint);
 263   6                                                      point = atoi(reg_id);
 264   6      
 265   6                                                      if( strtok( rest, "\n"))
 266   6                                                      {
 267   7                                                              if(strtok( NULL, "\n"))
 268   7                                                              {
 269   8                                                                      temp = strtok( NULL, "\n");
 270   8      
 271   8                                                                      if( mod_id = strtok( temp, "\r"))
 272   8                                                                      {
 273   9                                                                              gsm_debug("--------MOD_id");
 274   9                                                                              gsm_debug( mod_id);
 275   9                                                                      }
 276   8                                                                      else
 277   8                                                                      {
 278   9                                                                              gsm_debug("no cr");
 279   9                                                                      }
 280   8                                                              }
 281   7                                                      }
 282   6                                                      else
 283   6                                                      {
 284   7                                                              gsm_debug( "can't get mod_id"); 
 285   7                                                      }
 286   6      
 287   6                                                      buf[0] = atoi(mod_id);
 288   6                                                      buf[1] = 0x06;
 289   6                                                      buf[2] = HI_U16(point);
 290   6                                                      buf[3] = LO_U16(point);
 291   6                                                      buf[4] = 0x00;
 292   6                                                      buf[5] = atoi(setpoint);
 293   6                      
 294   6                                                      InitCRC16();
 295   6                                                      for( i = 0; i < 6; i++)
 296   6                                                      {
 297   7                                                              buf_for_crc[i] = buf[i];
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 6   

 298   7                                                              CRC16_Tstat(buf_for_crc[i]);
 299   7                                                      }
 300   6                      
 301   6                                                      buf[6] = CRChi;
 302   6                                                      buf[7] = CRClo;
 303   6      
 304   6      //                                                      if( buf[0] == 0xfd)
 305   6      //                                                              gsm_debug( "!!!!!MOD ID OK");
 306   6      //                                                      else
 307   6      //                                                              gsm_debug( "!!!!!MOD ID ERROR");
 308   6      //                                                      if( ( buf[2] == 0x01) && ( buf[3] == 0x5b))
 309   6      //                                                              gsm_debug( "@@@@@REG ID OK");
 310   6      //                                                      else
 311   6      //                                                              gsm_debug( "@@@@@REG ID ERROR");
 312   6      //                                                      if( buf[5] == 0x19)
 313   6      //                                                              gsm_debug( "#####SET ID OK");
 314   6      //                                                      else
 315   6      //                                                              gsm_debug( "#####SET ID ERROR");
 316   6      //                                                      if( (buf[6] == 0x2c) && ( buf[7] == 0x13))
 317   6      //                                                              gsm_debug( "$$$$$CRC OK");
 318   6      //                                                      else
 319   6      //                                                      {
 320   6      //                                                              gsm_debug( "$$$$$CRC ERROR, BUF6:");
 321   6      //                                                              gsm_debug( &buf[6]);
 322   6      //                                                              gsm_debug( "BUF7:");
 323   6      //                                                              gsm_debug( &buf[7]);
 324   6      //                                                      }       
 325   6                                                      Tx_To_Tstat(buf, 8);
 326   6      
 327   6                                                      g_state = GSM_INIT_DONE;
 328   6                                                      rev_cnt = 0;
 329   6      
 330   6                                                      
 331   6                                                      send_at_cmd( "AT+CMGD=1");                // 删除该条短信
 332   6      
 333   6                                              }
 334   5                                              else
 335   5                                              {
 336   6                                                      gsm_debug("can not get endpoint");
 337   6                                              }
 338   5                                      }
 339   4                                      else
 340   4                                      {
 341   5                                              gsm_debug("can not get reg_id");
 342   5                                      }
 343   4                              }
 344   3                      }
 345   2                      else
 346   2                      {
 347   3                              gsm_debug( "#######strstr failed!!!");
 348   3                              g_state = GET_MSG;
 349   3                      }
 350   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 351   2                      gsm_RxBuf.size = 0;
 352   2              }
 353   1              else if ( strstr( msg, "+CMGS:"))
 354   1              {
 355   2                      gsm_debug( gsm_RxBuf.buf);
 356   2                      g_state = SMS_SEND_SUCCESS;
 357   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 358   2                      gsm_RxBuf.size = 0;
 359   2      //              gsm_debug( "SMS SEND SUCCESS!");
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 7   

 360   2              }
 361   1              else if ( (GSM_INIT_FINISH == init_state) && strstr(msg, "OK"))
 362   1              {
 363   2                      gsm_debug( gsm_RxBuf.buf);
 364   2      //              gsm_debug( "GSM WAITING FOR SOMETHING");
 365   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 366   2                      gsm_RxBuf.size = 0;
 367   2                      g_state = GSM_INIT_DONE;
 368   2              }
 369   1              else if ( (GSM_INIT_FINISH != init_state) &&  strstr ( msg, "OK"))
 370   1              {
 371   2                      gsm_debug( gsm_RxBuf.buf);
 372   2                      init_state++;
 373   2      //              gsm_debug( "GSM IS INITING");
 374   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 375   2                      gsm_RxBuf.size = 0;
 376   2              }
 377   1              else if( (GSM_INIT_FINISH == init_state) && strstr ( msg, "ERROR"))
 378   1              {
 379   2                      gsm_debug( gsm_RxBuf.buf);
 380   2      //              gsm_debug( "GSM INIT FAILED");
 381   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 382   2                      gsm_RxBuf.size = 0;
 383   2              }
 384   1              else if( (SMS_READY == g_state) && strstr( msg, "OK"))
 385   1              {
 386   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 387   2                      gsm_RxBuf.size = 0;
 388   2                      g_state = GSM_WAITING;
 389   2              }
 390   1              else if( (SMS_READY == g_state) && strstr( msg, "ER"))
 391   1              {
 392   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 393   2                      gsm_RxBuf.size = 0;
 394   2                      g_state = GSM_INIT_DONE;
 395   2      //              send_out = FALSE;
 396   2              }
 397   1              else if( (SMS_SENDING == g_state) && strstr( msg,"OK"))
 398   1              {
 399   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 400   2                      gsm_RxBuf.size = 0;
 401   2                      g_state = GSM_INIT_DONE;
 402   2                      send_out = FALSE;
 403   2              }
 404   1              else if( (SMS_SENDING == g_state) && strstr( msg,"ER"))
 405   1              {
 406   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 407   2                      gsm_RxBuf.size = 0;
 408   2                      send_out = TRUE;
 409   2              }
 410   1              else
 411   1              {
 412   2                      gsm_debug( gsm_RxBuf.buf);
 413   2                      memset( gsm_RxBuf.buf, 0, GSM_MAX_RX_LEN);
 414   2                      gsm_RxBuf.size = 0;
 415   2      //              gsm_debug( "UNKNOWN MESSAGE");
 416   2              // do nothing
 417   2              }
 418   1      
 419   1              temp = NULL;
 420   1              sms = NULL;
 421   1              rest = NULL;
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 8   

 422   1              mod_id = NULL;
 423   1              reg_id = NULL;
 424   1              setpoint = NULL;
 425   1      
 426   1              return g_state;
 427   1      }
 428          
 429          void gsm_module_init(void)
 430          {
 431   1              gsm_debug( "Start gsm module init");
 432   1              
 433   1              switch ( init_state)
 434   1              {
 435   2                      case 0:
 436   2      //                      simulate_write_byte(0x55);
 437   2                              send_at_cmd( "AT");                                        // 验证模块正常
 438   2                              gsm_debug( "Send 'AT' cmd");
 439   2      //                      g_state = GSM_INITING;
 440   2                              break;
 441   2      
 442   2                      case 1:
 443   2                              send_at_cmd( "ATE1V1"); 
 444   2      //                      gsm_debug( "Send ATE1V1");                              
 445   2                              break;
 446   2      
 447   2                      case 2:
 448   2                              send_at_cmd( "AT+IPR=0");                          // 自适应波特率
 449   2      //                      gsm_debug( "Send IPR");
 450   2                              break;
 451   2      
 452   2                      case 3:
 453   2                              send_at_cmd( "AT+CCLK?");
 454   2      //                      gsm_debug( "CCLK");
 455   2                              break;
 456   2      
 457   2                      case 4:
 458   2                              send_at_cmd( "ATD*#06#");
 459   2      //                      gsm_debug( "ATD");
 460   2                              break;
 461   2      
 462   2                      case 5:
 463   2                              send_at_cmd( "AT+CMGF=1");
 464   2      //                      gsm_debug( "CMGF");
 465   2                              break;
 466   2      
 467   2                      case 6:
 468   2                              send_at_cmd( "AT&W");
 469   2      //                      gsm_debug( "AT&W");
 470   2                              break;
 471   2      
 472   2      //              case 7:
 473   2      //                      send_at_cmd( "AT+CMGR=1");
 474   2      //                      break;
 475   2      
 476   2                      case 7:
 477   2                              send_at_cmd( "AT+CMGD=1");
 478   2                              break;
 479   2      
 480   2                      case 8:
 481   2                              init_state = GSM_INIT_FINISH;
 482   2                              break;
 483   2      
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 9   

 484   2                      default:
 485   2                              g_state = GSM_INIT_DONE;
 486   2                              break;
 487   2              }
 488   1      
 489   1      }
 490          
 491          void gsm_init(void)
 492          {
 493   1      //      gsm_debug( "Start gsm init");
 494   1      
 495   1      
 496   1      //      Uart0_Tx("gsm init",8);
 497   1      
 498   1      
 499   1              
 500   1      #ifndef GSM_USE_DELAY                                                     
              //      TMOD |= 0x02;                           // 模式1
              //      TH0 = 0xFF;                                     // 9600波特率
              //      TL0 = 0xF9;
              //      TR0 = 0;                                        // TIMER0运行控制,发送或接收时打开
              //      PT0 = 1;
              //      ET0 = 1;                                // 开启TIMER0中断
              //      TF0 = 0;                                        // TIME0标志位
              
                      TMOD |= 0x01;   // 16 bits timer
                      CKCON |= (1 << 3); // timer0 tick = Fosc / 4
              //      CKCON &= 0xf7; // timer0 tick = Fosc / 12
              
                      TH0 = 0xf9;
              //      TH0 = 0xfd;                                      //9600
              //      TL0 = 0x75;
              
              //      TH0 = 0xFF;
              //      TL0 = 0xAF;
              #endif
 520   1      
 521   1              IE0 = 0;
 522   1              IP |= 0x01;                 // 高优先级
 523   1              IT0 = 0;                                        // 触发方式,改为level triggered接收误码率小很多
 524   1              EX0 = 1;                                        // 开启INT0                     // 此语句导致跑死
 525   1              
 526   1      
 527   1      //      gsm_debug( "gsm init is still running");                
 528   1              gsm_RxBuf.size = 0;
 529   1              g_state = GSM_NONE;
 530   1      
 531   1                              
 532   1              g_state = GSM_INITING;     
 533   1      //      gsm_debug( "gsm init is still running");
 534   1      
 535   1      //      gsm_debug( "gsm init is still running after module init");
 536   1      }
 537          
 538          void gsm_send_msg ( char *msg)
 539          {
 540   1              char temp[256] = {0};
 541   1              send_at_cmd( "AT+CMGF=1");
 542   1              MicroWait( TIME_TO_WAIT);
 543   1                      
 544   1              if ( g_state == GSM_INIT_DONE || g_state == GSM_WAITING
 545   1              || g_state == SMS_READY)
C51 COMPILER V9.06   GSM                                                                   05/28/2013 10:15:34 PAGE 10  

 546   1              {
 547   2                      memcpy( phone_num, GSM_PHONE_NUM, 14);                                            // 电话号码
 548   2              }
 549   1              else
 550   1                      send_at_cmd( "AT_CMGF=1");
 551   1      
 552   1              if( strlen(phone_num) > 0)
 553   1              {
 554   2                      sprintf( temp, "AT+CMGS=\"%s\"", phone_num);                              
 555   2                      send_at_cmd( temp);
 556   2      //              gsm_debug("send the phone number");
 557   2              }
 558   1              else
 559   1              {
 560   2      //              gsm_debug("Number is invalid");
 561   2              }
 562   1              MicroWait( TIME_TO_WAIT);
 563   1      
 564   1              if ( g_state == SMS_READY)
 565   1              {
 566   2                      send_at_cmd( msg);
 567   2                      simulate_write_byte( 0x1a);                                                       // 短信发送符
 568   2              }
 569   1              else
 570   1                      send_at_cmd( temp);
 571   1      }
 572          
 573          #if 0
              void gsmTimer0_ISR(void) interrupt 1
              {
                      EA = 0;
              
              //      if( g_cnt )
                              GSM_TX = 1;
                      EA = 1;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2418    ----
   CONSTANT SIZE    =   1158    ----
   XDATA SIZE       =    345     814
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
