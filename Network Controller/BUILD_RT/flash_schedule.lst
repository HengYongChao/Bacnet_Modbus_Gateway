C51 COMPILER V9.06   FLASH_SCHEDULE                                                        05/28/2013 16:06:34 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE FLASH_SCHEDULE
OBJECT MODULE PLACED IN .\flash_schedule.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\flash\flash_schedule.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(
                    -0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC
                    -\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;
                    -..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX1
                    -1000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modb
                    -usTCP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\fla
                    -sh_schedule.lst) OBJECT(.\flash_schedule.obj)

line level    source

   1          #include "flash.h"
   2          #include "flash_schedule.h"
   3          #include "schedule.h"
   4          #include "../scan/scan.h"
   5          #include "../gsm/gsm.h"
   6          #include <string.h>
   7          
   8          STR_FLASH flash;
   9          STR_Flash_POS xdata Flash_Position[18] /*_at_ 0x800*/;
  10          
  11          static U8_T far tempbuf[1500] = {0};
  12          U8_T bacnet_id;
  13          extern U8_T far Para[400]; 
  14          
  15          /* caclulate detailed position for every table */
  16          void Flash_Inital(void)
  17          {
  18   1              U8_T loop;
  19   1              U16_T baseAddr;
  20   1              U16_T len;
  21   1              for(loop = 0; loop < T_TOTAL; loop++)
  22   1              {
  23   2                      switch(loop)
  24   2                      {
  25   3                              case T_WEEK_DES:        
  26   3                                      baseAddr = 6000;
  27   3                                      len = WR_DESCRIPTION_SIZE * MAX_WR;     // 31*20
  28   3                                      break;
  29   3                              case T_WEEK_ONTIME:
  30   3                                      baseAddr += len;
  31   3                                      len = WR_TIME_SIZE * MAX_WR;            // 72*20
  32   3                                      break;
  33   3                              case T_WEEK_OFFTIME:
  34   3                                      baseAddr += len;
  35   3                                      len = WR_TIME_SIZE * MAX_WR;            // 72*20
  36   3                                      break;
  37   3                              case T_ANNUAL_DES:
  38   3                                      baseAddr += len;
  39   3                                      len = AR_DESCRIPTION_SIZE * MAX_AR;     // 29*16
  40   3                                      break;
  41   3                              case T_ANNUAL_TIME:
  42   3                                      baseAddr += len;
  43   3                                      len = AR_TIME_SIZE * MAX_AR;            // 46*16
  44   3                                      break;
  45   3                              case T_ID:
  46   3                                      baseAddr += len;
  47   3                                      len = ID_SIZE * MAX_ID;                         // 3*254
  48   3                                      break;
  49   3                              case T_SCAN:
C51 COMPILER V9.06   FLASH_SCHEDULE                                                        05/28/2013 16:06:34 PAGE 2   

  50   3                                      baseAddr += len;
  51   3                                      len = SCAN_DB_SIZE * MAX_ID;            // 5*254
  52   3                                      break;
  53   3                                      
  54   3                              case T_BACNET:
  55   3                                      baseAddr += len;
  56   3                                      len = MAX_BACNET ;                                      //1*1   
  57   3                                      break;
  58   3                              case T_GSM:
  59   3                                      baseAddr += len;
  60   3                                      len = PHONE_NUM_SIZE;                           // 14                                           
  61   3                                      
  62   3                                                              
  63   3                              default:
  64   3                                      break;
  65   3                      }
  66   2                      Flash_Position[loop].addr = baseAddr;
  67   2                      Flash_Position[loop].len = len;
  68   2              }       
  69   1      }
  70          
  71          void Flash_Write_Schedule(void)
  72          {
  73   1              STR_flag_flash ptr_flash;
  74   1              U16_T base_addr;
  75   1              U8_T loop;
  76   1              U16_T loop1, loop2;
  77   1      
  78   1       /* only the first block, erase memory */
  79   1              IntFlashErase(ERA_RUN, 0x70000);        
  80   1              IntFlashWriteByte(0x70000 + 0xfff0, 0x55);
  81   1              MassFlashWrite(0, Para, 400); //LHN add
  82   1      
  83   1              ptr_flash.index = 0;
  84   1      
  85   1              for(loop = 0; loop < T_TOTAL; loop++)
  86   1              {
  87   2                      ptr_flash.table = loop; 
  88   2                      
  89   2                      ptr_flash.len = Flash_Position[loop].len;
  90   2                      base_addr = Flash_Position[loop].addr;
  91   2                      
  92   2                      switch(loop)
  93   2                      {                       
  94   3                              case T_WEEK_DES:
  95   3                                      for(loop1 = 0; loop1 < MAX_WR; loop1++)
  96   3                                      {
  97   4                                              memcpy(&tempbuf[WR_DESCRIPTION_SIZE * loop1], WR_Roution[loop1].UN.all, WR_DESCRIPTION_SIZE);                                   
  98   4                                      }
  99   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 100   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]); 
 101   3                                      break;
 102   3                              case T_WEEK_ONTIME:
 103   3                                      for(loop1 = 0; loop1 < MAX_WR; loop1++)
 104   3                                      {
 105   4                                              memcpy(&tempbuf[WR_TIME_SIZE * loop1], WR_Roution[loop1].OnTime, WR_TIME_SIZE);                                 
 106   4                                      }
 107   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 108   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);
 109   3                                      break;
 110   3                              case T_WEEK_OFFTIME:
 111   3                                      for(loop1 = 0;loop1 < MAX_WR;loop1++)
C51 COMPILER V9.06   FLASH_SCHEDULE                                                        05/28/2013 16:06:34 PAGE 3   

 112   3                                      {
 113   4                                              memcpy(&tempbuf[WR_TIME_SIZE * loop1], WR_Roution[loop1].OffTime, WR_TIME_SIZE);                                        
 114   4                                      }
 115   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 116   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);         
 117   3                                      break;
 118   3                              case T_ANNUAL_DES:
 119   3                                      for(loop1 = 0; loop1 < MAX_AR; loop1++)
 120   3                                      {
 121   4                                              memcpy(&tempbuf[AR_DESCRIPTION_SIZE * loop1], AR_Roution[loop1].UN.all, AR_DESCRIPTION_SIZE);                                   
 122   4                                      }
 123   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 124   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);         
 125   3                                      break;
 126   3                              case T_ANNUAL_TIME:
 127   3                                      for(loop1 = 0; loop1 < MAX_AR; loop1++)
 128   3                                      {
 129   4                                              memcpy(&tempbuf[AR_TIME_SIZE * loop1], AR_Roution[loop1].Time, AR_TIME_SIZE);                                   
 130   4                                      }
 131   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 132   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);         
 133   3                                      break;
 134   3      
 135   3                              case T_ID:
 136   3                                      for(loop1 = 0; loop1 < MAX_ID; loop1++)
 137   3                                      {
 138   4                                              memcpy(&tempbuf[ID_SIZE * loop1], ID_Config[loop1].all, ID_SIZE);                                       
 139   4                                      }
 140   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 141   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);         
 142   3                                      break;
 143   3                              case T_SCAN:
 144   3                                      for(loop1 = 0; loop1 < MAX_ID; loop1++)
 145   3                                      {
 146   4                                              memcpy(&tempbuf[SCAN_DB_SIZE * loop1], (U8_T *)&scan_db[loop1], SCAN_DB_SIZE);                                  
 147   4                                      }
 148   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 149   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);
 150   3                                      break;
 151   3                      
 152   3      /*******************************************************************************************/
 153   3                              case T_BACNET:
 154   3                                      for(loop1 = 0; loop1 < MAX_BACNET; loop1++)
 155   3                                      {
 156   4                                              memcpy(&tempbuf[BACNET_SIZE * loop1], (U8_T *)&bacnet_id, BACNET_SIZE);                                 
 157   4                                      }
 158   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 159   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);
 160   3                                      break;
 161   3      /*=========================================================================================*/
 162   3                              case T_GSM:
 163   3                                      for(loop1 = 0; loop1 < PHONE_NUM_SIZE; loop1++)
 164   3                                      {
 165   4                                              memcpy(&tempbuf[loop1], &phoneNumber[loop1], 1);
 166   4                                      }
 167   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 168   3                                              IntFlashWriteByte(0x70000 + base_addr + loop2, tempbuf[loop2]);
 169   3                                      break;
 170   3                              default:        
 171   3                                      break;
 172   3                      
 173   3                      }
C51 COMPILER V9.06   FLASH_SCHEDULE                                                        05/28/2013 16:06:34 PAGE 4   

 174   2              }
 175   1      
 176   1      }
 177          
 178          void Flash_Read_Schedule(void)
 179          {
 180   1              STR_flag_flash ptr_flash;
 181   1              U16_T base_addr;
 182   1              U8_T loop;
 183   1              U16_T loop2, loop1;
 184   1      
 185   1              ptr_flash.index = 0;
 186   1              for(loop = 0; loop < T_TOTAL; loop++)
 187   1              {
 188   2                      ptr_flash.table = loop; 
 189   2                      
 190   2                      ptr_flash.len = Flash_Position[loop].len;
 191   2                      base_addr = Flash_Position[loop].addr;
 192   2                      switch(loop)
 193   2                      {                       
 194   3                              case T_WEEK_DES:
 195   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 196   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 197   3                                      for(loop1 = 0; loop1 < MAX_WR; loop1++)
 198   3                                      {
 199   4                                              memcpy(WR_Roution[loop1].UN.all, &tempbuf[WR_DESCRIPTION_SIZE * loop1], WR_DESCRIPTION_SIZE);                                   
 200   4                                      }
 201   3                                      break;
 202   3                              case T_WEEK_ONTIME:
 203   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 204   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 205   3                                      
 206   3                                      for(loop1 = 0; loop1 < MAX_WR; loop1++)
 207   3                                      {
 208   4                                              memcpy(&WR_Roution[loop1].OnTime, &tempbuf[WR_TIME_SIZE * loop1], WR_TIME_SIZE);                                        
 209   4                                      }
 210   3                                      break;
 211   3                              case T_WEEK_OFFTIME:
 212   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 213   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 214   3                                      for(loop1 = 0; loop1 < MAX_WR; loop1++)
 215   3                                      {
 216   4                                              memcpy(WR_Roution[loop1].OffTime, &tempbuf[WR_TIME_SIZE * loop1], WR_TIME_SIZE);                                        
 217   4                                      }
 218   3                                      break;
 219   3                              case T_ANNUAL_DES:
 220   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 221   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 222   3                                      for(loop1 = 0; loop1 < MAX_AR; loop1++)
 223   3                                      {
 224   4                                              memcpy(AR_Roution[loop1].UN.all, &tempbuf[AR_DESCRIPTION_SIZE * loop1], AR_DESCRIPTION_SIZE);                                   
 225   4                                      }
 226   3                                      break;
 227   3                              case T_ANNUAL_TIME:
 228   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 229   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 230   3                                      for(loop1 = 0; loop1 < MAX_AR; loop1++)
 231   3                                      {
 232   4                                              memcpy(AR_Roution[loop1].Time, &tempbuf[AR_TIME_SIZE * loop1], AR_TIME_SIZE);                                   
 233   4                                      }
 234   3                                      break;
 235   3                              case T_ID:
C51 COMPILER V9.06   FLASH_SCHEDULE                                                        05/28/2013 16:06:34 PAGE 5   

 236   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 237   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 238   3                                      for(loop1 = 0; loop1 < MAX_ID; loop1++)
 239   3                                      {
 240   4                                              memcpy(ID_Config[loop1].all, &tempbuf[ID_SIZE * loop1], ID_SIZE);                                       
 241   4                                      }
 242   3                                      break;
 243   3                              case T_SCAN:
 244   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 245   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 246   3                                      for(loop1 = 0; loop1 < MAX_ID; loop1++)
 247   3                                      {
 248   4                                              memcpy((U8_T *)&scan_db[loop1], &tempbuf[SCAN_DB_SIZE * loop1], SCAN_DB_SIZE);                                  
 249   4                                      }
 250   3                                      break;
 251   3      
 252   3                              case T_GSM:
 253   3                                      for(loop2 = 0; loop2 < ptr_flash.len; loop2++)
 254   3                                              IntFlashReadByte(0x70000 + base_addr + loop2, &tempbuf[loop2]);
 255   3                                      for(loop1 = 0; loop1 < PHONE_NUM_SIZE; loop1++)
 256   3                                      {
 257   4                                              memcpy(&phoneNumber[loop1], &tempbuf[ loop1], 1);                                       
 258   4                                      }
 259   3                                      break;
 260   3      
 261   3      
 262   3                              default:
 263   3                                      break;
 264   3                      }
 265   2              }
 266   1      }
 267          
 268          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4524    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    147    1032
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1500    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
