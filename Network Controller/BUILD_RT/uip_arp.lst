C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE UIP_ARP
OBJECT MODULE PLACED IN .\uip_arp.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\tcpip\uip_arp.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020)
                    - INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;
                    -..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\
                    -buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;.
                    -.\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\uip_arp.lst) OBJECT(.\uip_
                    -arp.obj)

line level    source

   1          /**
   2           * \addtogroup uip
   3           * @{
   4           */
   5          
   6          /**
   7           * \defgroup uiparp uIP Address Resolution Protocol
   8           * @{
   9           * 
  10           * The Address Resolution Protocol ARP is used for mapping between IP
  11           * addresses and link level addresses such as the Ethernet MAC
  12           * addresses. ARP uses broadcast queries to ask for the link level
  13           * address of a known IP address and the host which is configured with
  14           * the IP address for which the query was meant, will respond with its
  15           * link level address.
  16           *
  17           * \note This ARP implementation only supports Ethernet.
  18           */
  19           
  20          /**
  21           * \file
  22           * Implementation of the ARP Address Resolution Protocol.
  23           * \author Adam Dunkels <adam@dunkels.com>
  24           *
  25           */
  26          
  27          /*
  28           * Copyright (c) 2001-2003, Adam Dunkels.
  29           * All rights reserved. 
  30           *
  31           * Redistribution and use in source and binary forms, with or without 
  32           * modification, are permitted provided that the following conditions 
  33           * are met: 
  34           * 1. Redistributions of source code must retain the above copyright 
  35           *    notice, this list of conditions and the following disclaimer. 
  36           * 2. Redistributions in binary form must reproduce the above copyright 
  37           *    notice, this list of conditions and the following disclaimer in the 
  38           *    documentation and/or other materials provided with the distribution. 
  39           * 3. The name of the author may not be used to endorse or promote
  40           *    products derived from this software without specific prior
  41           *    written permission.  
  42           *
  43           * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  44           * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  45           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  46           * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
  47           * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  48           * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
  49           * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  50           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 2   

  51           * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  52           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  53           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
  54           *
  55           * This file is part of the uIP TCP/IP stack.
  56           *
  57           * $Id: uip_arp.c,v$
  58           *
  59           */
  60          
  61          /*       浜様様様様様様様様様様様様様様様様様様様様様様様様様様様様融
  62                   ?   TITLE:  Keil C51 v7.00 port of Adam Dunkels' uIP v0.9 
  63                   ?REVISION:  VER 0.0                                       
  64                   ?REV.DATE:  30-01-05                                      
  65                   ? ARCHIVE:                                                
  66                   ?  AUTHOR:  Murray R. Van Luyn, 2005.                     
  67                   藩様様様様様様様様様様様様様様様様様様様様様様様様様様様様夕        */
  68          
  69          #include "uip_arp.h"
  70          #include "tcpip.h"
  71          #include "tcpip_uip.h"
  72          #include <string.h>
  73          
  74          struct arp_hdr {
  75                  struct uip_eth_hdr ethhdr;
  76                  U16_T hwtype;
  77                  U16_T protocol;
  78                  U8_T hwlen;
  79                  U8_T protolen;
  80                  U16_T opcode;
  81                  struct uip_eth_addr shwaddr;
  82                  U16_T sipaddr[2];
  83                  struct uip_eth_addr dhwaddr;
  84                  U16_T dipaddr[2]; 
  85          };
  86          
  87          struct ethip_hdr {
  88                  struct uip_eth_hdr ethhdr;
  89                  /* IP header. */
  90                  U8_T vhl,
  91                  tos,          
  92                  len[2],       
  93                  ipid[2],        
  94                  ipoffset[2],  
  95                  ttl,          
  96                  proto;     
  97                  U16_T ipchksum;
  98                  U16_T srcipaddr[2], 
  99                  destipaddr[2];
 100          };
 101          
 102          #define ARP_REQUEST 1
 103          #define ARP_REPLY   2
 104          
 105          #define ARP_HWTYPE_ETH 1
 106          
 107          struct arp_entry {
 108                  U16_T ipaddr[2];
 109                  struct uip_eth_addr ethaddr;
 110                  U8_T time;
 111          };
 112          
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 3   

 113          struct uip_eth_addr xdata uip_ethaddr = {{UIP_ETHADDR0,
 114                                                                                            UIP_ETHADDR1,
 115                                                                                            UIP_ETHADDR2,
 116                                                                                            UIP_ETHADDR3,
 117                                                                                            UIP_ETHADDR4,
 118                                                                                            UIP_ETHADDR5}};
 119          
 120          static struct arp_entry xdata arp_table[UIP_ARPTAB_SIZE];
 121          static U16_T xdata ipaddr[2];
 122          static U8_T xdata i, c;
 123          
 124          static U8_T xdata arptime;
 125          static U8_T xdata tmpage;
 126          
 127          #define BUF   ((struct arp_hdr *)&uip_buf[0])
 128          #define IPBUF ((struct ethip_hdr *)&uip_buf[0])
 129          
 130          /*-----------------------------------------------------------------------------------*/
 131          /**
 132           * Initialize the ARP module.
 133           *
 134           */
 135          /*-----------------------------------------------------------------------------------*/
 136          void uip_arp_init(void)
 137          {
 138   1              for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 139   2                      memset(arp_table[i].ipaddr, 0, 4);
 140   2              }
 141   1      }
 142          
 143          /*-----------------------------------------------------------------------------------*/
 144          /**
 145           * Periodic ARP processing function.
 146           *
 147           * This function performs periodic timer processing in the ARP module
 148           * and should be called at regular intervals. The recommended interval
 149           * is 10 seconds between the calls.
 150           *
 151           */
 152          /*-----------------------------------------------------------------------------------*/
 153          void uip_arp_timer(void)
 154          {
 155   1              struct arp_entry *tabptr;
 156   1      
 157   1              ++arptime;
 158   1              for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 159   2                      tabptr = &arp_table[i];
 160   2                      if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
 161   2                              arptime - tabptr->time >= UIP_ARP_MAXAGE)
 162   2                      {
 163   3                              memset(tabptr->ipaddr, 0, 4);
 164   3                      }
 165   2              }
 166   1      }
 167          
 168          /*-----------------------------------------------------------------------------------*/
 169          
 170          static void uip_arp_update(U16_T *ipaddr, struct uip_eth_addr *ethaddr)
 171          {
 172   1              register struct arp_entry *tabptr;
 173   1      
 174   1              /* Walk through the ARP mapping table and try to find an entry to
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 4   

 175   1                 update. If none is found, the IP -> MAC address mapping is
 176   1                 inserted in the ARP table. */
 177   1              for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 178   2                      tabptr = &arp_table[i];
 179   2                      /* Only check those entries that are actually in use. */
 180   2                      if(tabptr->ipaddr[0] != 0 && tabptr->ipaddr[1] != 0) {
 181   3                              /* Check if the source IP address of the incoming packet matches
 182   3                                 the IP address in this ARP table entry. */
 183   3                              if(ipaddr[0] == tabptr->ipaddr[0] && ipaddr[1] == tabptr->ipaddr[1]) {
 184   4                                      /* An old entry found, update this and return. */
 185   4                                      memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
 186   4                                      tabptr->time = arptime;
 187   4                                      return;
 188   4                              }
 189   3                      }
 190   2              }
 191   1      
 192   1              /* If we get here, no existing ARP table entry was found, so we create one. */
 193   1      
 194   1              /* First, we try to find an unused entry in the ARP table. */
 195   1              for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 196   2                      tabptr = &arp_table[i];
 197   2                      if(tabptr->ipaddr[0] == 0 && tabptr->ipaddr[1] == 0) {
 198   3                              break;
 199   3                      }
 200   2              }
 201   1      
 202   1              /* If no unused entry is found, we try to find the oldest entry and throw it away. */
 203   1              if(i == UIP_ARPTAB_SIZE) {
 204   2                      tmpage = 0;
 205   2                      c = 0;
 206   2                      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 207   3                              tabptr = &arp_table[i];
 208   3                              if(arptime - tabptr->time > tmpage) {
 209   4                                      tmpage = arptime - tabptr->time;
 210   4                                      c = i;
 211   4                              }
 212   3                      }
 213   2                      i = c;
 214   2              }
 215   1      
 216   1              /* Now, i is the ARP table entry which we will fill with the new information. */
 217   1              memcpy(tabptr->ipaddr, ipaddr, 4);
 218   1              memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
 219   1              tabptr->time = arptime;
 220   1      }
 221          
 222          /*-----------------------------------------------------------------------------------*/
 223          /**
 224           * ARP processing for incoming IP packets
 225           *
 226           * This function should be called by the device driver when an IP
 227           * packet has been received. The function will check if the address is
 228           * in the ARP cache, and if so the ARP cache entry will be
 229           * refreshed. If no ARP cache entry was found, a new one is created.
 230           *
 231           * This function expects an IP packet with a prepended Ethernet header
 232           * in the uip_buf[] buffer, and the length of the packet in the global
 233           * variable uip_len.
 234           */
 235          /*-----------------------------------------------------------------------------------*/
 236          void uip_arp_ipin(void)
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 5   

 237          {
 238   1              /* Only insert/update an entry if the source IP address of the
 239   1                 incoming IP packet comes from a host on the local network. */
 240   1              if((IPBUF->srcipaddr[0] & uip_arp_netmask[0]) != (uip_hostaddr[0] & uip_arp_netmask[0])) {
 241   2              return;
 242   2              }
 243   1              if((IPBUF->srcipaddr[1] & uip_arp_netmask[1]) != (uip_hostaddr[1] & uip_arp_netmask[1])) {
 244   2                  return;
 245   2              }
 246   1              uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
 247   1      
 248   1              return;
 249   1      }
 250          
 251          /*-----------------------------------------------------------------------------------*/
 252          /**
 253           * ARP processing for incoming ARP packets.
 254           *
 255           * This function should be called by the device driver when an ARP
 256           * packet has been received. The function will act differently
 257           * depending on the ARP packet type: if it is a reply for a request
 258           * that we previously sent out, the ARP cache will be filled in with
 259           * the values from the ARP reply. If the incoming ARP packet is an ARP
 260           * request for our IP address, an ARP reply packet is created and put
 261           * into the uip_buf[] buffer.
 262           *
 263           * When the function returns, the value of the global variable uip_len
 264           * indicates whether the device driver should send out a packet or
 265           * not. If uip_len is zero, no packet should be sent. If uip_len is
 266           * non-zero, it contains the length of the outbound packet that is
 267           * present in the uip_buf[] buffer.
 268           *
 269           * This function expects an ARP packet with a prepended Ethernet
 270           * header in the uip_buf[] buffer, and the length of the packet in the
 271           * global variable uip_len.
 272           */
 273          /*-----------------------------------------------------------------------------------*/
 274          void uip_arp_arpin(void)
 275          {
 276   1              if(uip_len < sizeof(struct arp_hdr)) {
 277   2                      uip_len = 0;
 278   2                      return;
 279   2              }
 280   1      
 281   1              uip_len = 0;
 282   1      
 283   1              switch(BUF->opcode)
 284   1              {
 285   2                      case HTONS(ARP_REQUEST):
 286   2                              /* ARP request. If it asked for our address, we send out a reply. */
 287   2                          if(BUF->dipaddr[0] == uip_hostaddr[0] && BUF->dipaddr[1] == uip_hostaddr[1]) {
 288   3                                      /* The reply opcode is 2. */
 289   3                                      BUF->opcode = HTONS(2);
 290   3      
 291   3                                      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
 292   3                                      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 293   3                                      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 294   3                                      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
 295   3      
 296   3                                      BUF->dipaddr[0] = BUF->sipaddr[0];
 297   3                                      BUF->dipaddr[1] = BUF->sipaddr[1];
 298   3                                      BUF->sipaddr[0] = uip_hostaddr[0];
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 6   

 299   3                                      BUF->sipaddr[1] = uip_hostaddr[1];
 300   3      
 301   3                                      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);      
 302   3                                      uip_len = sizeof(struct arp_hdr);
 303   3      
 304   3                              }
 305   2                              break;
 306   2      
 307   2                      case HTONS(ARP_REPLY):
 308   2                              /* ARP reply. We insert or update the ARP table if it was meant for us. */
 309   2                              if(BUF->dipaddr[0] == uip_hostaddr[0] && BUF->dipaddr[1] == uip_hostaddr[1]) {
 310   3                                      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
 311   3                              }
 312   2                              break;
 313   2                      default:
 314   2                              break;
 315   2              }
 316   1      
 317   1              return;
 318   1      }
 319          
 320          /*-----------------------------------------------------------------------------------*/
 321          /**
 322           * Prepend Ethernet header to an outbound IP packet and see if we need
 323           * to send out an ARP request.
 324           *
 325           * This function should be called before sending out an IP packet. The
 326           * function checks the destination IP address of the IP packet to see
 327           * what Ethernet MAC address that should be used as a destination MAC
 328           * address on the Ethernet.
 329           *
 330           * If the destination IP address is in the local network (determined
 331           * by logical ANDing of netmask and our IP address), the function
 332           * checks the ARP cache to see if an entry for the destination IP
 333           * address is found. If so, an Ethernet header is prepended and the
 334           * function returns. If no ARP cache entry is found for the
 335           * destination IP address, the packet in the uip_buf[] is replaced by
 336           * an ARP request packet for the IP address. The IP packet is dropped
 337           * and it is assumed that they higher level protocols (e.g., TCP)
 338           * eventually will retransmit the dropped packet.
 339           *
 340           * If the destination IP address is not on the local network, the IP
 341           * address of the default router is used instead.
 342           *
 343           * When the function returns, a packet is present in the uip_buf[]
 344           * buffer, and the length of the packet is in the global variable
 345           * uip_len.
 346           */
 347          /*-----------------------------------------------------------------------------------*/
 348          void uip_arp_out(void)
 349          {
 350   1              struct arp_entry *tabptr;
 351   1              /* Find the destination IP address in the ARP table and construct
 352   1                 the Ethernet header. If the destination IP addres isn't on the
 353   1                 local network, we use the default router's IP address instead.
 354   1      
 355   1                 If not ARP table entry is found, we overwrite the original IP
 356   1                 packet with an ARP request for the IP address. */
 357   1      
 358   1              if (IPBUF->destipaddr[0] == 0xffff)
 359   1              {
 360   2                      memset(BUF->ethhdr.dest.addr, 0xff, 6);
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 7   

 361   2              }
 362   1              else if (IPBUF->destipaddr[0] > 0xe000)
 363   1              {
 364   2                      BUF->ethhdr.dest.addr[0] = 1;
 365   2                      BUF->ethhdr.dest.addr[1] = 0;
 366   2                      BUF->ethhdr.dest.addr[2] = 0x5e;
 367   2                      BUF->ethhdr.dest.addr[3] = (U8_T)IPBUF->destipaddr[0] & 0x7f;
 368   2                      BUF->ethhdr.dest.addr[4] = (U8_T)(IPBUF->destipaddr[1] >> 8);
 369   2                      BUF->ethhdr.dest.addr[5] =(U8_T)IPBUF->destipaddr[1];
 370   2              }
 371   1              else
 372   1              {
 373   2                      /* Check if the destination address is on the local network. */
 374   2                      if((IPBUF->destipaddr[0] & uip_arp_netmask[0]) != (uip_hostaddr[0] & uip_arp_netmask[0]) ||
 375   2                              (IPBUF->destipaddr[1] & uip_arp_netmask[1]) != (uip_hostaddr[1] & uip_arp_netmask[1])) 
 376   2                      {
 377   3                              /* Destination address was not on the local network, so we need to
 378   3                                 use the default router's IP address instead of the destination
 379   3                                 address when determining the MAC address. */
 380   3                              ipaddr[0] = uip_arp_draddr[0];
 381   3                              ipaddr[1] = uip_arp_draddr[1];
 382   3                      } else {
 383   3                              /* Else, we use the destination IP address. */
 384   3                              ipaddr[0] = IPBUF->destipaddr[0];
 385   3                              ipaddr[1] = IPBUF->destipaddr[1];
 386   3                      }
 387   2      
 388   2                      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 389   3                              tabptr = &arp_table[i];
 390   3                              if(ipaddr[0] == tabptr->ipaddr[0] && ipaddr[1] == tabptr->ipaddr[1])
 391   3                                      break;
 392   3                      }
 393   2      
 394   2                      if(i == UIP_ARPTAB_SIZE) {
 395   3                              /* The destination address was not in our ARP table, so we
 396   3                                 overwrite the IP packet with an ARP request. */
 397   3                              memset(BUF->ethhdr.dest.addr, 0xff, 6);
 398   3                              memset(BUF->dhwaddr.addr, 0x00, 6);
 399   3                              memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 400   3                              memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 401   3      
 402   3                              BUF->dipaddr[0] = ipaddr[0];
 403   3                              BUF->dipaddr[1] = ipaddr[1];
 404   3                              BUF->sipaddr[0] = uip_hostaddr[0];
 405   3                              BUF->sipaddr[1] = uip_hostaddr[1];
 406   3                              BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
 407   3                              BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
 408   3                              BUF->protocol = HTONS(UIP_ETHTYPE_IP);
 409   3                              BUF->hwlen = 6;
 410   3                              BUF->protolen = 4;
 411   3                              BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
 412   3      
 413   3                              uip_appdata = &uip_buf[40 + TCPIP_EthHeadLen];
 414   3      
 415   3                              uip_len = sizeof(struct arp_hdr);
 416   3                              return;
 417   3                      }
 418   2                      /* Build an ethernet header. */
 419   2                      memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
 420   2              }
 421   1      
 422   1              memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
C51 COMPILER V9.06   UIP_ARP                                                               03/13/2013 09:32:23 PAGE 8   

 423   1      
 424   1              IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
 425   1      
 426   1              uip_len += sizeof(struct uip_eth_hdr);
 427   1      }
 428          /*-----------------------------------------------------------------------------------*/
 429          
 430          
 431          /** @} */
 432          /** @} */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1748    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    102      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
