C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE PPPOE
OBJECT MODULE PLACED IN .\pppoe.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\pppoe\pppoe.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\
                    -src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\pppoe.lst) O
                    -BJECT(.\pppoe.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: pppoe.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: pppoe.c,v $
  18           *=============================================================================
  19           */
  20          
  21          #include "tcpip.h"
  22          #include "pppoe.h"
  23          #include "stoe.h"
  24          #include "adapter.h"
  25          #include <stdio.h>
  26          #include <string.h>
  27          
  28          /* NAMING CONSTANT DECLARATIONS */
  29          #define UIP_ETHTYPE_PPPOE_SESSION       0x8864
  30          #define UIP_ETHTYPE_PPPOE_DISCOVERY     0x8863
  31          
  32          /* LOCAL VARIABLES DECLARATIONS */
  33          U8_T PPPOE_GetDnsFlag = 0;
  34          
  35          /* Pointer of PPPOE_INFO type */
  36          static PPPOE_INFO       pppoe_info;
  37          
  38          /* Local static variables */
  39          static U8_T             ac_cookie[32];
  40          static U8_T             service_name[32];
  41          static U16_T    as_length[2];
  42          static U8_T             host_uniq_from_PADO[8];
  43          static U16_T    session_id;
  44          static U8_T             magic_number_server[4];
  45          static U8_T             magic_number_client[4];
  46          static U8_T             pppoe_identification_1[11] = "MSRAVS5.10";
  47          static U8_T             pppoe_identification_2[13] = "MSRAV-0-ASIX";
  48          static U8_T             pppoe_username[33] = "username"; //User name
  49          static U8_T             pppoe_password[33] = "password"; //Password
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 2   

  50          static U8_T             pppoe_server_ip[4];
  51          static U8_T             pppoe_ip[4];
  52          static U8_T             pppoe_pri_dns[4];
  53          static U8_T             pppoe_sec_dns[4];
  54          static U8_T             pppoe_successful = 0;
  55          static U8_T             pppoe_server_mac[6];
  56          static U8_T             pppoe_MacAddr[6];
  57          
  58          /* LOCAL SUBPROGRAM DECLARATIONS */
  59          static void     Analysis_Tags(U8_T *tags, U16_T length);
  60          static U8_T     PPPOE_Discovery_Handle(U8_T*, U8_T state);
  61          static U8_T     PPPOE_Session_Handle(U8_T*, U16_T state);
  62          static U8_T     Check_Magic(U8_T *magic, U8_T sc);
  63          static U8_T     PPPOE_Process(U8_T *buf, U16_T length);
  64          static U8_T     Check_Echo(U8_T *buf);
  65          static U8_T     Check_Terminate(U8_T *buf);
  66          static U16_T PPPOE_Get_Session(void);
  67          
  68          /*
  69           * ----------------------------------------------------------------------------
  70           * Function Name: PPPOE_Receive
  71           * Purpose: If connection type is PPPoE, this function maintain any packets
  72           *              while receiving data.
  73           * Params:  *buf: Pointer of packet / length: Length of packet
  74           * Returns: 1: Useful packet / 0: Drop the packet
  75           * Note:
  76           * ----------------------------------------------------------------------------
  77           */
  78          U8_T PPPOE_Receive(U8_T *buf, U16_T length)
  79          {
  80   1              pppoe_hdr*      PPPOEBUF = (pppoe_hdr*)buf;
  81   1      
  82   1              if(PPPOEBUF->ether_type == 0x8863 || PPPOEBUF->ether_type == 0x8864)
  83   1              {
  84   2                      return PPPOE_Process((U8_T*)PPPOEBUF, length);
  85   2              }
  86   1              else
  87   1              {
  88   2                      return 0;
  89   2              }
  90   1      }
  91          
  92          /*
  93           * ----------------------------------------------------------------------------
  94           * Function Name: PPPOE_GetState
  95           * Purpose: Called by system, let it know if PPPoE connection is successful
  96           * Params: 
  97           * Returns: 0: Connection not successful / 1: Connection successful
  98           * Note:
  99           * ----------------------------------------------------------------------------
 100           */
 101          U8_T PPPOE_GetState(void)
 102          {
 103   1              return pppoe_successful;
 104   1      }
 105          
 106          /*
 107           * ----------------------------------------------------------------------------
 108           * Function Name: PPPOE_Send
 109           * Purpose: Called by system while packet to send in PPPoE mode
 110           * Params:
 111           * Returns:
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 3   

 112           * Note:
 113           * ----------------------------------------------------------------------------
 114           */
 115          void PPPOE_Send(U8_T* buf, U16_T length)
 116          {
 117   1              pppoe_hdr*      PPPOEBUF = (pppoe_hdr*)buf;
 118   1      
 119   1              /* Ethernet header */
 120   1              memcpy(PPPOEBUF->dest_addr, pppoe_server_mac, 6);
 121   1              memcpy(PPPOEBUF->src_addr, pppoe_MacAddr, 6);
 122   1              PPPOEBUF->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 123   1      
 124   1              /* PPPoE header */
 125   1              PPPOEBUF->vhl = 0x11;
 126   1              PPPOEBUF->pppoe_code = PPPOE_CODE_SESS;
 127   1              PPPOEBUF->session_id = session_id;
 128   1              PPPOEBUF->payload_length = length - 20;
 129   1      
 130   1              /* Point-to-Point Protocol */
 131   1              *(U16_T*)PPPOEBUF->payload_data = 0x0021;
 132   1      }
 133          
 134          /*
 135           * ----------------------------------------------------------------------------
 136           * Function Name: PPPOE_Init
 137           * Purpose: Initialize state & identifier of pppoe_info.
 138           * Params:
 139           * Returns:
 140           * Note:
 141           * ----------------------------------------------------------------------------
 142           */
 143          void PPPOE_Init(void)
 144          {
 145   1              U8_T*   point = MAC_GetMacAddr();
 146   1      
 147   1              pppoe_info.state = 0;
 148   1              pppoe_info.identifier = 0;
 149   1              pppoe_info.wait_count_master = 0;
 150   1              pppoe_info.wait_count_slave = 0;
 151   1              memcpy(pppoe_MacAddr, point, 6);
 152   1      }
 153          
 154          /*
 155           * ----------------------------------------------------------------------------
 156           * Function Name: PPPOE_Command
 157           * Purpose: Called by main() of adapter.c, this is a state machine function
 158           * Params:
 159           * Returns:
 160           * Note:
 161           * ----------------------------------------------------------------------------
 162           */
 163          void PPPOE_Command(void)
 164          {
 165   1              /* Do process by checking internal state */
 166   1              switch(pppoe_info.state)
 167   1              {
 168   2                      case 0:
 169   2                              /* Send PADI packet in discovery stage */
 170   2                              PPPOE_Discovery_Handle(TCPIP_GetXmitBuffer(), PPPOE_CODE_PADI);
 171   2                              break;
 172   2                      case PPPOE_CODE_PADI:
 173   2                              /* Send PADI every 5 seconds while no PADO received */
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 4   

 174   2                              pppoe_info.wait_count_slave++;
 175   2                              if(pppoe_info.wait_count_slave > 45644)
 176   2                              {
 177   3                                      pppoe_info.wait_count_slave = 0;
 178   3                                      pppoe_info.wait_count_master++;
 179   3                                      if(pppoe_info.wait_count_master > 4)
 180   3                                      {
 181   4                                              pppoe_info.wait_count_master = 0;
 182   4                                              PPPOE_Discovery_Handle(TCPIP_GetXmitBuffer(), PPPOE_CODE_PADI);
 183   4                                      }
 184   3                              }
 185   2                              break;
 186   2                      case PPPOE_CODE_PADS_1:
 187   2                              /* Send LCP request in session stage */
 188   2                              PPPOE_Session_Handle(TCPIP_GetXmitBuffer(), 2);
 189   2                              break;
 190   2                      case PPPOE_CODE_PADS_3:
 191   2                              /* Send Identification_1 packet */
 192   2                              PPPOE_Session_Handle(TCPIP_GetXmitBuffer(), 4);
 193   2                              /* Send Identification_2 packet */
 194   2                              PPPOE_Session_Handle(TCPIP_GetXmitBuffer(), 5);
 195   2                              /* Create Authentication packet */
 196   2                              PPPOE_Session_Handle(TCPIP_GetXmitBuffer(), 6);
 197   2                              break;
 198   2                      case PPPOE_CODE_PADS_5:
 199   2                              /* Send ICPC request */
 200   2                              PPPOE_Session_Handle(TCPIP_GetXmitBuffer(), 8);
 201   2                              break;
 202   2                      default:
 203   2                              break;
 204   2              }
 205   1      }
 206          
 207          /*
 208           * ----------------------------------------------------------------------------
 209           * Function Name: PPPOE_Process
 210           * Purpose: Called by PPPOE_Receive(), and process packet while system receive
 211           *                      packet
 212           * Params:  *buf: Pointer of packet / length: Length of the packet
 213           * Returns: 0: Not wanted packet / 1: Wanted packet, and process it
 214           * Note:
 215           * ----------------------------------------------------------------------------
 216           */
 217          U8_T PPPOE_Process(U8_T *buf, U16_T length)
 218          {
 219   1              pppoe_hdr*      PPPOEBUF = (pppoe_hdr*)buf;
 220   1      
 221   1              length = length;
 222   1      
 223   1              /* Always check Echo request first */
 224   1              if(Check_Echo((U8_T XDATA*)PPPOEBUF))
 225   1              {
 226   2                      return 1;
 227   2              }
 228   1      
 229   1              /* Check Terminate request */
 230   1              if(Check_Terminate((U8_T XDATA*)PPPOEBUF))
 231   1              {
 232   2                      return 1;
 233   2              }
 234   1      
 235   1              switch(pppoe_info.state)
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 5   

 236   1              {
 237   2                      case PPPOE_CODE_PADI:
 238   2                              /* Maintain ether type for PPPoE discovery */
 239   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_DISCOVERY && PPPOEBUF->pppoe_code == PPPOE_CODE_PADO)
 240   2                              {
 241   3                                      /* Send PADR while PADO received */
 242   3                                      return PPPOE_Discovery_Handle((U8_T*)PPPOEBUF, PPPOE_CODE_PADR);
 243   3                      }
 244   2                              return 0;
 245   2                      case PPPOE_CODE_PADR:
 246   2                              /* Wait for Confirm session */
 247   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_DISCOVERY && PPPOEBUF->pppoe_code == PPPOE_CODE_PADS)
 248   2                              {
 249   3                                      /* Check and keep session */
 250   3                                      return PPPOE_Discovery_Handle((U8_T*)PPPOEBUF, PPPOE_CODE_PADS);
 251   3                              }
 252   2                              return 0;
 253   2                      case PPPOE_CODE_PADS:
 254   2                              /* Reply LCP in session stage */
 255   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 256   2                              {
 257   3                                      return PPPOE_Session_Handle((U8_T*)PPPOEBUF, 1);
 258   3                              }
 259   2                              return 0;
 260   2                      case PPPOE_CODE_PADS_2:
 261   2                              /* Wait ACK from server */
 262   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 263   2                              {
 264   3                                      return PPPOE_Session_Handle((U8_T*)PPPOEBUF, 3);
 265   3                              }
 266   2                              return 0;
 267   2                      case PPPOE_CODE_PADS_4:
 268   2                              /* Wait ICPC request */
 269   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 270   2                              {
 271   3                                      return PPPOE_Session_Handle((U8_T*)PPPOEBUF, 7);
 272   3                              }
 273   2                              return 0;
 274   2                      case PPPOE_CODE_PADS_6:
 275   2                              /* Wait IPCP Nak packet */
 276   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 277   2                              {
 278   3                                      return PPPOE_Session_Handle((U8_T*)PPPOEBUF, 9);
 279   3                              }
 280   2                              return 0;
 281   2                      case PPPOE_CODE_PADS_7:
 282   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 283   2                              {
 284   3                                      return PPPOE_Session_Handle((U8_T*)PPPOEBUF, 10);
 285   3                              }
 286   2                              return 0;
 287   2                      case PPPOE_CODE_PADS_8:
 288   2                              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session())
 289   2                              {
 290   3                                      return 1;
 291   3                              }
 292   2                              return 0;
 293   2                      default:
 294   2                              return 0;
 295   2              }
 296   1      }
 297          
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 6   

 298          /*
 299           * ----------------------------------------------------------------------------
 300           * Function Name: PPPOE_Discovery_Handle
 301           * Purpose: Handle discovery stage of PPPoE
 302           * Params: *PPPOEBUF: Pointer of packet / state: internal state
 303           * Returns: 0: Not wanted packet / 1: Wanted packet, and process it
 304           * Note:
 305           * ----------------------------------------------------------------------------
 306           */
 307          U8_T PPPOE_Discovery_Handle(U8_T *PPPOEBUF, U8_T state)
 308          { 
 309   1              tag     *tags = (tag*)((pppoe_hdr*)PPPOEBUF)->payload_data;
 310   1              U8_T    i;
 311   1      
 312   1              switch(state)
 313   1              {
 314   2                      case PPPOE_CODE_PADI:
 315   2      
 316   2                              /* Create PADI packet */
 317   2                              for(i = 0; i < 6; i++)
 318   2                              {
 319   3                                      ((pppoe_hdr*)PPPOEBUF)->dest_addr[i] = 0xFF;
 320   3                              }
 321   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 322   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_DISCOVERY);
 323   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 324   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_PADI;
 325   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = PPPOE_CODE_SESS;
 326   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = 0x0010;
 327   2                              tags->name = PPPOE_TAG_SERVICE_NAME;
 328   2                              tags->length = 0;
 329   2                              *(U16_T*) tags->value = PPPOE_TAG_HOST_UNIQ;
 330   2                              *(U16_T*) (tags->value + 2) = 0x0008;
 331   2                              *(U32_T*) (tags->value + 4) = 0x06000000;
 332   2                              *(U32_T*) (tags->value + 8) = 0x0B000000;
 333   2      
 334   2                              /* Set Process state */
 335   2                              pppoe_info.state = PPPOE_CODE_PADI;
 336   2      
 337   2                              break;
 338   2                      case PPPOE_CODE_PADR:
 339   2                              /* Analysis PADO packet and record needed information */
 340   2                              Analysis_Tags((U8_T*)tags, ((pppoe_hdr*)PPPOEBUF)->payload_length);
 341   2      
 342   2                              if(host_uniq_from_PADO[0] != 0x06 && host_uniq_from_PADO[4] != 0x0b)
 343   2                              {
 344   3                                      return 0; /* If host uniq not for us, don't create/send PADR */
 345   3                              }
 346   2      
 347   2                              /* Keep mac of PPPoE server*/
 348   2                              memcpy(pppoe_server_mac, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 349   2      
 350   2                              /* Create PADR packet */
 351   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 352   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 353   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_DISCOVERY);
 354   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 355   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_PADR;
 356   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = PPPOE_CODE_SESS;
 357   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = (U16_T)as_length[0] + (U16_T)as_length[1] + 20;
 358   2                              tags->name = PPPOE_TAG_SERVICE_NAME;
 359   2                              tags->length = as_length[1];
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 7   

 360   2                              memcpy(tags->value, service_name, tags->length);
 361   2                              *(U16_T*) (tags->value + tags->length) = PPPOE_TAG_HOST_UNIQ;
 362   2                              *(U16_T*) (tags->value + tags->length + 2) = 0x0008;
 363   2                              *(U32_T*) (tags->value + tags->length + 4) = 0x06000000;
 364   2                              *(U32_T*) (tags->value + tags->length + 8) = 0x0C000000;
 365   2                              *(U16_T*) (tags->value + tags->length + 12) = PPPOE_TAG_AC_COOKIE;
 366   2                              *(U16_T*) (tags->value + tags->length + 14) = as_length[0];
 367   2      
 368   2                              memcpy((tags->value + tags->length + 16), ac_cookie, as_length[0]);
 369   2      
 370   2                              /* Set Process state */
 371   2                              pppoe_info.state = PPPOE_CODE_PADR;
 372   2                              break;
 373   2                      case PPPOE_CODE_PADS:
 374   2                              /* Analysis PADS packet and record needed information */
 375   2                              Analysis_Tags((U8_T*)tags, ((pppoe_hdr*)PPPOEBUF)->payload_length);
 376   2                              if(host_uniq_from_PADO[0] != 0x06 && host_uniq_from_PADO[4] != 0x0c)
 377   2                              {
 378   3                                      return 0; /* If host uniq not for us, don't process session stage */
 379   3                              }
 380   2                              /* Keep Session ID from PPPoE server */
 381   2                              session_id = ((pppoe_hdr*)PPPOEBUF)->session_id;
 382   2      
 383   2                              /* Set Process state */
 384   2                              pppoe_info.state = PPPOE_CODE_PADS;
 385   2      
 386   2                              return 1;
 387   2                      default:
 388   2                              printf("Nothing to do in Discovry of PPPoE !\r\n");
 389   2                              return 0;
 390   2              }
 391   1      
 392   1              /* Set uip length */
 393   1              TCPIP_SetXmitLength(20 + ((pppoe_hdr*)PPPOEBUF)->payload_length);
 394   1      
 395   1              /* Send packet */
 396   1              ETH_SendPkt((U8_T XDATA*)PPPOEBUF, TCPIP_GetXmitLength());
 397   1      
 398   1              return 1;
 399   1      }
 400          
 401          /*
 402           * ----------------------------------------------------------------------------
 403           * Function Name: PPPOE_Session_Handle
 404           * Purpose: Handle session stage of PPPoE
 405           * Params: *PPPOEBUF: Pointer of packet / state: internal state
 406           * Returns: 0: Not wanted packet / 1: Wanted packet, and process it
 407           * Note:
 408           * ----------------------------------------------------------------------------
 409           */
 410          U8_T PPPOE_Session_Handle(U8_T *PPPOEBUF, U16_T state)
 411          {
 412   1              ppp_handshake_session   *phs = (ppp_handshake_session*)&(((pppoe_hdr*)PPPOEBUF)->payload_data[0]);
 413   1      
 414   1              switch(state)
 415   1              {
 416   2                      case 1:
 417   2                              if(phs->protocol != LCP && phs->ppp_code == 0x01)
 418   2                              {
 419   3                                      return 0;
 420   3                              }
 421   2      
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 8   

 422   2                              /* Create LCP ACK */
 423   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 424   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 425   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 426   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 427   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 428   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 429   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 430   2                              phs->ppp_code = 0x02;
 431   2      
 432   2                              /* Save magic number from server */
 433   2                              /* Length of Hinet is 18, length of linux-pppoe is 14 */
 434   2                              if(phs->length == 14)
 435   2                              {
 436   3                                      pppoe_info.lcp_length = 14;
 437   3                                      memcpy(magic_number_server, &(phs->option[6]), 4);
 438   3                              }
 439   2                              else
 440   2                              {
 441   3                                      pppoe_info.lcp_length = 18;
 442   3                                      memcpy(magic_number_server, &(phs->option[10]), 4);
 443   3                              }
 444   2      
 445   2                              /* Copy the number to client and +1 */
 446   2                              memcpy(magic_number_client, magic_number_server, 4);
 447   2                              magic_number_client[3] += 1;
 448   2      
 449   2                              pppoe_info.state = PPPOE_CODE_PADS_1;
 450   2                          break;
 451   2                      case 2:
 452   2                              /* Create LCP request */
 453   2                              phs->protocol = LCP;
 454   2                              phs->ppp_code = 0x01;
 455   2                              phs->ppp_id = pppoe_info.identifier;
 456   2                              phs->length = 14;
 457   2                              *(U16_T*)phs->option = 0x0104;
 458   2                              *(U16_T*)(phs->option + 2) = 0x05c8;
 459   2                              if(pppoe_info.lcp_length != 14)
 460   2                              {
 461   3                                      phs->option[4] = 0x05;
 462   3                                      phs->option[5] = 0x06;
 463   3                              }
 464   2                              memcpy(phs->option + 6, magic_number_client, 4);
 465   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 466   2                              pppoe_info.state = PPPOE_CODE_PADS_2;
 467   2                              break;
 468   2                      case 3:
 469   2                              if(phs->protocol == LCP && Check_Magic(&(phs->option[6]), 1) == 1 && phs->ppp_code == 0x02 && phs->ppp_
             -id == 0)
 470   2                              {
 471   3                                      pppoe_info.state = PPPOE_CODE_PADS_3;
 472   3                                      return 1;
 473   3                              }
 474   2                              else
 475   2                              {
 476   3                                      return 0;
 477   3                              }
 478   2                      case 4:
 479   2                              /* Create identification_1 packet */
 480   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, pppoe_server_mac, 6);
 481   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 482   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 9   

 483   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 484   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 485   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 486   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = 18 + 2;
 487   2                              phs->protocol = LCP;
 488   2                              phs->ppp_code = 0x0c;
 489   2                              phs->ppp_id = ++pppoe_info.identifier;
 490   2                              phs->length = 18;
 491   2                              memcpy(phs->option, magic_number_client, 4);
 492   2                              memcpy(&(phs->option[4]), pppoe_identification_1, 10);
 493   2      
 494   2                              break;
 495   2                      case 5:
 496   2                              /* Create identification_2 packet */
 497   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, pppoe_server_mac, 6);
 498   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 499   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 500   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 501   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 502   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 503   2                              phs->protocol = LCP;
 504   2                              phs->ppp_code = 0x0c;
 505   2                              phs->ppp_id = ++pppoe_info.identifier;
 506   2                              phs->length = 20;
 507   2                              memcpy(phs->option, magic_number_client, 4);
 508   2                              memcpy(&(phs->option[4]), pppoe_identification_2, 12);
 509   2      
 510   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 511   2      
 512   2                              break;
 513   2                      case 6:
 514   2                              /* Create Authentication request packet */
 515   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, pppoe_server_mac, 6);
 516   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 517   2                              ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 518   2                              ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 519   2                              ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 520   2                              ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 521   2                              phs->protocol = PAP;
 522   2                              phs->ppp_code = 0x01;
 523   2                              phs->ppp_id = ++pppoe_info.identifier;
 524   2                              phs->length = strlen(pppoe_username) + strlen(pppoe_password) + 6;
 525   2      
 526   2                              phs->option[0] = strlen(pppoe_username);
 527   2                              memcpy(&(phs->option[1]), pppoe_username, strlen(pppoe_username));
 528   2                              phs->option[1+strlen(pppoe_username)] = strlen(pppoe_password);
 529   2                              memcpy(&(phs->option[2 + strlen(pppoe_username)]), pppoe_password, strlen(pppoe_password));
 530   2      
 531   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 532   2                              pppoe_info.state = PPPOE_CODE_PADS_4;
 533   2                              break;
 534   2                      case 7:
 535   2                              /* Check if authentication successful */
 536   2                              if(phs->protocol == PAP && phs->ppp_code == 0x03)
 537   2                              {
 538   3                                      printf("PPPoE Account or Password not correct!\r\n");
 539   3                                      return 1;
 540   3                              }
 541   2      
 542   2                              /* Check if the packet is IPCP/Request */
 543   2                              if(phs->protocol != IPCP && phs->ppp_code != 0x01)
 544   2                              {
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 10  

 545   3                                      return 0;
 546   3                              }
 547   2                              /* Create IPCP/ACK packet */
 548   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 549   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 550   2                              phs->ppp_code = 0x02;
 551   2      
 552   2                              /* Keep the IP address of PPPoE server */
 553   2                              memcpy(pppoe_server_ip, &(phs->option[2]), 4);
 554   2      
 555   2                              /* Please careful below code's sequence */
 556   2                              pppoe_info.state = PPPOE_CODE_PADS_5;
 557   2                              break;
 558   2                      case 8:
 559   2                              /* Create IPCP request packet */
 560   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, pppoe_server_mac, 6);
 561   2                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 562   2                              phs->ppp_code = 0x01;
 563   2                              phs->ppp_id = ++pppoe_info.identifier;
 564   2                              phs->length = 22;
 565   2                              ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 566   2                              *(U16_T*)(phs->option) = 0x0306;
 567   2                              *(U32_T*)(phs->option + 2) = 0;
 568   2                              *(U16_T*)(phs->option + 6) = 0x8106;
 569   2                              *(U32_T*)(phs->option + 8) = 0;
 570   2                              *(U16_T*)(phs->option + 12) = 0x8306;
 571   2                              *(U32_T*)(phs->option + 14) = 0;
 572   2      
 573   2                              pppoe_info.state = PPPOE_CODE_PADS_6;
 574   2                              break;
 575   2                      case 9:
 576   2                              if(phs->protocol == IPCP && phs->ppp_code == 0x03)
 577   2                              {
 578   3                                      /* Create IPCP request with IP packet */
 579   3                                      memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 580   3                                      memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 581   3                                      phs->ppp_code = 0x01;
 582   3                                      phs->ppp_id = ++pppoe_info.identifier;
 583   3                                      phs->length = 22;
 584   3                                      ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 585   3      
 586   3                                      /* Keep IP, Primary/Secondary DNS */
 587   3                                      memcpy(pppoe_ip, &(phs->option[2]), 4);
 588   3                                      memcpy(pppoe_pri_dns, &(phs->option[8]), 4);
 589   3                                      memcpy(pppoe_sec_dns, &(phs->option[14]), 4);
 590   3      
 591   3                                      pppoe_info.state = PPPOE_CODE_PADS_7;
 592   3                                      break;
 593   3                              }
 594   2                              return 0;
 595   2                      case 10:
 596   2                              /* Check last IPCP Ack */
 597   2                              if(phs->protocol == IPCP && phs->ppp_code == 0x02 && phs->ppp_id == pppoe_info.identifier)
 598   2                              {
 599   3                                      /* Reset identifier */
 600   3                                      pppoe_info.identifier = 0;
 601   3      
 602   3                                      /* Set IP to latest IP from PPPoE server */
 603   3                                      STOE_SetIPAddr(*(U32_T*)pppoe_ip);
 604   3                                      TCPIP_SetIPAddr(*(U32_T*)pppoe_ip);
 605   3      
 606   3                                      /* Set PPPoE connection successful */
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 11  

 607   3                                      pppoe_successful = 1;
 608   3                                      PPPOE_GetDnsFlag = 1;
 609   3      
 610   3                                      pppoe_info.state = PPPOE_CODE_PADS_8;
 611   3                                      printf("Finish the PPP handshake !! %lx\r\n", *(U32_T*)pppoe_ip);
 612   3                                      return 1;
 613   3                              }
 614   2                              return 0;
 615   2                      default:
 616   2                              return 0;
 617   2              }
 618   1      
 619   1              /* Set uip length */
 620   1              TCPIP_SetXmitLength(20 + ((pppoe_hdr*)PPPOEBUF)->payload_length);
 621   1      
 622   1              /* Send packet */
 623   1              ETH_SendPkt((U8_T XDATA*)PPPOEBUF, TCPIP_GetXmitLength());
 624   1      
 625   1              return 1;
 626   1      }
 627          
 628          /*
 629           * ----------------------------------------------------------------------------
 630           * Function Name: PPPOE_Get_Session
 631           * Purpose: Called by other process and return session_id
 632           * Params:
 633           * Returns: Session ID that got from PPPoE server
 634           * Note:
 635           * ----------------------------------------------------------------------------
 636           */
 637          U16_T PPPOE_Get_Session(void)
 638          {
 639   1              return session_id;
 640   1      }
 641          
 642          /*
 643           * ----------------------------------------------------------------------------
 644           * Function Name: Analysis_Tags
 645           * Purpose: If connection type is PPPoE, this function maintain any packets
 646           *              while receiving data.
 647           * Params:  buf = Head pointer of packet, length = Length of packet
 648           * Returns: 1: Useful packet, 0: Drop the packet
 649           * Note:
 650           * ----------------------------------------------------------------------------
 651           */
 652          void Analysis_Tags(U8_T *tags, U16_T length)
 653          {
 654   1              U8_T    i;
 655   1      
 656   1              for(i = 0; i < length; i++)
 657   1              {
 658   2                      /* Service name */
 659   2                      if((*(tags + i) == 0x01) && (*(tags + i + 1) == 0x01))
 660   2                      {
 661   3                              as_length[1] = *(U16_T*)(tags+i+2);
 662   3                              memcpy(service_name, (tags + i + 4), *(U16_T*)(tags+i+2));
 663   3                      }
 664   2      
 665   2                      /* Host-uniq */
 666   2                      if((*(tags + i) == 0x01) && (*(tags + i + 1) == 0x03))
 667   2                      {
 668   3                              memcpy(host_uniq_from_PADO, (tags + i + 4), *(U16_T*)(tags+i+2));
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 12  

 669   3                      }
 670   2      
 671   2                      /* AC-Cookie */
 672   2                      if((*(tags + i) == 0x01) && (*(tags + i + 1) == 0x04))
 673   2                      {
 674   3                              as_length[0] = *(U16_T*)(tags+i+2);
 675   3                              memcpy(ac_cookie, (tags + i + 4), *(U16_T*)(tags+i+2));
 676   3                      }
 677   2              }
 678   1      }
 679          
 680          /*
 681           * ----------------------------------------------------------------------------
 682           * Function Name: Check_Magic
 683           * Purpose: Check if magic number as same as keeped.
 684           * Params: magic:Pointer of magic number / sc: 0(server), 1(client)
 685           * Returns: 0: different / 1: Same
 686           * Note: *magic is a pointer of magic number, sc is flag for checking server 
 687           *                      or client
 688           * ----------------------------------------------------------------------------
 689           */
 690          U8_T Check_Magic(U8_T *magic, U8_T sc)
 691          {
 692   1              U8_T    i;
 693   1              
 694   1              for(i = 0; i < 4; i++)
 695   1              {
 696   2                      if(sc)
 697   2                      {
 698   3                              if(magic[i] != magic_number_client[i])
 699   3                                      return 0;
 700   3                      }
 701   2                      else
 702   2                      {
 703   3                              if(magic[i] != magic_number_server[i])
 704   3                                      return 0;
 705   3                      }
 706   2              }
 707   1              return 1;
 708   1      }
 709          
 710          /*
 711           * ----------------------------------------------------------------------------
 712           * Function Name: Check_Echo
 713           * Purpose: Check if echo request sent from PPPoE server, reply echo
 714           * Params: U8_T *buf
 715           * Returns: 0: Not echo request / 1: echo request, and reply it
 716           * Note: 
 717           * ----------------------------------------------------------------------------
 718           */
 719          U8_T Check_Echo(U8_T *buf)
 720          {
 721   1              pppoe_hdr*      PPPOEBUF = (pppoe_hdr*)buf;
 722   1              ppp_handshake_session   *phs = (ppp_handshake_session*)&(((pppoe_hdr*)PPPOEBUF)->payload_data[0]);
 723   1      
 724   1              /* See if packet is echo request of PPPoE server and for us */
 725   1              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session()
 726   1                      && phs->protocol == LCP && Check_Magic(&(phs->option[0]), 0) == 1 && phs->ppp_code == 0x09)
 727   1              {
 728   2                      /* Create echo reply */
 729   2                      memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
 730   2                      memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 13  

 731   2                      ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 732   2                      ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 733   2                      ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 734   2                      ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 735   2                      phs->ppp_code = 0x0a;
 736   2                      memcpy(phs->option, magic_number_client, 4);
 737   2                      ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 738   2      
 739   2                      /* Set uip length */
 740   2                      TCPIP_SetXmitLength(20 + ((pppoe_hdr*)PPPOEBUF)->payload_length);
 741   2      
 742   2                      /* Send packet */
 743   2                      ETH_SendPkt((U8_T XDATA*)PPPOEBUF, TCPIP_GetXmitLength());
 744   2      
 745   2                      return 1;
 746   2              }
 747   1              return 0;
 748   1      }
 749          
 750          /*
 751           * ----------------------------------------------------------------------------
 752           * Function Name: Check_Terminate
 753           * Purpose: Check if terminate request sent from PPPoE server, reply terminate
 754           *                      ack
 755           * Params: U8_T *buf
 756           * Returns: 0: Not terminate request / 1: terminate request, and reply ack
 757           * Note: 
 758           * ----------------------------------------------------------------------------
 759           */
 760          U8_T Check_Terminate(U8_T *buf)
 761          {
 762   1              pppoe_hdr*      PPPOEBUF = (pppoe_hdr*)buf;
 763   1              ppp_handshake_session   *phs = (ppp_handshake_session*)&(((pppoe_hdr*)PPPOEBUF)->payload_data[0]);
 764   1      
 765   1              /* See if packet is terminate request of PPPoE server and for us */
 766   1              if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_DISCOVERY && PPPOEBUF->session_id == PPPOE_Get_Session()
 767   1                      && PPPOEBUF->pppoe_code == 0xa7)        /* PADT in PPPoE */
 768   1              {
 769   2      #if 0
                              /* Create PADT packet */
                              memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
                              memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, uip_ethaddr.addr, 6);
              
                              /* Set uip length */
                              TCPIP_SetXmitLength(20 + ((pppoe_hdr*)PPPOEBUF)->payload_length);
              
                              /* Send packet */
                              ETH_SendPkt((U8_T XDATA*)PPPOEBUF, TCPIP_GetXmitLength());
              #endif
 780   2                      /* Set PPPoE connection fail */
 781   2                      pppoe_successful = 0;
 782   2      
 783   2                      /* Reset internal state of PPPoE */
 784   2                      PPPOE_Init();
 785   2      
 786   2                      return 1;
 787   2              }
 788   1              else if(PPPOEBUF->ether_type == UIP_ETHTYPE_PPPOE_SESSION && PPPOEBUF->session_id == PPPOE_Get_Session()
 789   1                              && phs->protocol == LCP && phs->ppp_code == 0x05)       /* Terminate in PPP */
 790   1              {
 791   2                      /* Create Terminate ack */
 792   2                      memcpy(((pppoe_hdr*)PPPOEBUF)->dest_addr, ((pppoe_hdr*)PPPOEBUF)->src_addr, 6);
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 14  

 793   2                      memcpy(((pppoe_hdr*)PPPOEBUF)->src_addr, pppoe_MacAddr, 6);
 794   2                      ((pppoe_hdr*)PPPOEBUF)->ether_type = htons(UIP_ETHTYPE_PPPOE_SESSION);
 795   2                      ((pppoe_hdr*)PPPOEBUF)->vhl = 0x11;
 796   2                      ((pppoe_hdr*)PPPOEBUF)->pppoe_code = PPPOE_CODE_SESS;
 797   2                      ((pppoe_hdr*)PPPOEBUF)->session_id = session_id;
 798   2                      phs->ppp_code = 0x06;
 799   2                      ((pppoe_hdr*)PPPOEBUF)->payload_length = phs->length + 2;
 800   2      
 801   2                      /* Set uip length */
 802   2                      TCPIP_SetXmitLength(20 + ((pppoe_hdr*)PPPOEBUF)->payload_length);
 803   2      
 804   2                      /* Send packet */
 805   2                      ETH_SendPkt((U8_T XDATA*)PPPOEBUF, TCPIP_GetXmitLength());
 806   2      
 807   2                      return 1;
 808   2              }
 809   1              return 0;
 810   1      }
 811          
 812          /*
 813           * ----------------------------------------------------------------------------
 814           * Function Name: PPPOE_Setup_Account
 815           * Purpose: Setup username and password in PPPoE module.
 816           * Params: U8_T *username U8_T *password
 817           * Returns:
 818           * Note: 
 819           * ----------------------------------------------------------------------------
 820           */
 821          void PPPOE_Setup_Account(U8_T *username, U8_T *password)
 822          {
 823   1              /* Update username and password by external string */
 824   1              strcpy(pppoe_username, username);
 825   1              strcpy(pppoe_password, password);
 826   1              PPPOE_Init();   
 827   1      }
 828          
 829          /*
 830           * ----------------------------------------------------------------------------
 831           * Function Name: PPPOE_Get_DNS
 832           * Purpose: Get the DNS's ip address after connection successful.
 833           * Params: U8_T *pri_dns U8_T *sec_dns
 834           * Returns:
 835           * Note: 
 836           * ----------------------------------------------------------------------------
 837           */
 838          void PPPOE_Get_DNS(U8_T *pri_dns, U8_T *sec_dns)
 839          {
 840   1              memcpy(pri_dns, pppoe_pri_dns, 4);
 841   1              memcpy(sec_dns, pppoe_sec_dns, 4);
 842   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7765    ----
   CONSTANT SIZE    =    114    ----
   XDATA SIZE       =    213      56
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.06   PPPOE                                                                 05/28/2013 10:15:30 PAGE 15  

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
