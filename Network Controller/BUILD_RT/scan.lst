C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE SCAN
OBJECT MODULE PLACED IN .\scan.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\scan\scan.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\scan.lst) OBJECT(.\scan.obj)

line level    source

   1          
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "scan.h"
   5          #include "../main/main.h"
   6          #include "../flash/flash.h"
   7          #include "../schedule/schedule.h"
   8          
   9          extern void InitCRC16(void);
  10          
  11          extern U8_T ChangeFlash;
  12          
  13          extern U8_T far CRClo;
  14          extern U8_T far CRChi;
  15          extern void CRC16_Tstat(U8_T ch);
  16          extern U8_T Sever_Order;
  17          extern U8_T far Para[400];
  18          
  19          SCAN_DB far scan_db[MAX_ID];
  20          SCAN_DB far current_db;
  21          U8_T db_ctr;
  22          
  23          
  24          
  25          U8_T far scan_state;
  26          U8_T far scan_response_state;
  27          
  28          U8_T far online[32] = {0};
  29          U8_T far occupy[32] = {0};
  30          
  31          static U8_T nc_id;
  32          static U32_T nc_sn;
  33          
  34          static U8_T scan_db_changed = FALSE;
  35          
  36          void send_scan_cmd(U8_T max_id, U8_T min_id)
  37          {       
  38   1              U8_T i, buf[6];
  39   1              
  40   1              buf[0] = 0xff;
  41   1              buf[1] = 0x19;
  42   1              buf[2] = max_id;
  43   1              buf[3] = min_id;
  44   1      
  45   1              InitCRC16();
  46   1              for(i = 0; i < 4; i++)
  47   1                      CRC16_Tstat(buf[i]);
  48   1      
  49   1              buf[4] = CRChi;
  50   1              buf[5] = CRClo;
  51   1      
C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 2   

  52   1              scan_response_state = NONE_ID;
  53   1              Sever_Order = SERVER_SCAN;
  54   1      
  55   1              Tx_To_Tstat(buf, 6);
  56   1      }
  57          
  58          #define DELAY_TICKS             50
  59          U8_T wait_response(void)
  60          {
  61   1              U8_T i;
  62   1              for(i = 0; i < DELAY_TICKS; i++)
  63   1              {
  64   2                      if(scan_response_state != NONE_ID)
  65   2                      {
  66   3                              break;
  67   3                      }
  68   2                      else
  69   2                      {
  70   3                              OSDelay(2);
  71   3                      }
  72   2              }
  73   1      
  74   1              return scan_response_state;
  75   1      }
  76          
  77          void assignment_id_with_sn(U8_T old_id, U8_T new_id, U32_T current_sn)
  78          {
  79   1              U8_T i, buf[12];
  80   1              
  81   1              buf[0] = old_id;
  82   1              buf[1] = 0x06;
  83   1              buf[2] = 0;
  84   1              buf[3] = 0x0a;  //MODBUS_ADDRESS_PLUG_N_PLAY = 10
  85   1              buf[4] = 0x55;
  86   1              buf[5] = new_id;
  87   1      
  88   1              buf[6] = (U8_T)(current_sn >> 24);
  89   1              buf[7] = (U8_T)(current_sn >> 16);
  90   1              buf[8] = (U8_T)(current_sn >> 8);
  91   1              buf[9] = (U8_T)current_sn;
  92   1      
  93   1              InitCRC16();
  94   1              for(i = 0; i < 10; i++)
  95   1                      CRC16_Tstat(buf[i]);
  96   1      
  97   1              buf[10] = CRChi;
  98   1              buf[11] = CRClo;
  99   1      
 100   1              scan_state = SCAN_ASSIGN_ID_WITH_SN;
 101   1              scan_response_state = NONE_ID;
 102   1              Sever_Order = SERVER_SCAN;
 103   1              Tx_To_Tstat(buf, 12);
 104   1      }
 105          
 106          U8_T get_idle_id(void)
 107          {
 108   1              U8_T i;
 109   1              for(i = 1; i <= MAX_ID; i++)
 110   1              {
 111   2                      if(online[(i - 1) / 8] & (1 << ((i - 1) % 8)) == 0)
 112   2                              return i;
 113   2              }
C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 3   

 114   1              return 0xff;
 115   1      }
 116          
 117          void check_id_in_database(U8_T id, U32_T sn)
 118          {
 119   1              if(online[(id - 1) / 8] & (1 << ((id - 1) % 8))) // in the database
 120   1              {
 121   2                      U8_T i;
 122   2                      for(i = 0; i < db_ctr; i++)
 123   2                      {
 124   3                              if(id == scan_db[i].id) // id already in the database
 125   3                              {
 126   4                                      if(sn != scan_db[i].sn) // if there exist the same id with defferent sn, push it into the occupy list
 127   4                                      {
 128   5                                              occupy[(id - 1) / 8] |= 1 << ((id - 1) % 8);
 129   5                                      }
 130   4                                      break;
 131   4                              }
 132   3                              // if the device is already in the database, return without doing anything
 133   3                      }
 134   2              }
 135   1              else
 136   1              {
 137   2                      online[(id - 1) / 8] |= 1 << ((id - 1) % 8);
 138   2                      scan_db[db_ctr].id = id;
 139   2                      scan_db[db_ctr].sn = sn;
 140   2                      db_ctr++;
 141   2                      scan_db_changed = TRUE;
 142   2              }
 143   1      }
 144          
 145          ////for debug
 146          //U8_T ascii[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
 147          //void debug_print_hex(U8_T *dat, U8_T length)
 148          //{
 149          //      U8_T p[20];
 150          //      U8_T i;
 151          //      U8_T ctr = 0;
 152          //
 153          //      for(i = 0; i < length; i++)
 154          //      {
 155          //              p[ctr++] = ascii[dat[i] >> 4];
 156          //              p[ctr++] = ascii[dat[i] & 0x0f];
 157          //              p[ctr++] = ' ';
 158          //      }
 159          //
 160          //      p[ctr++] = '\n';
 161          //      p[ctr++] = '\r';
 162          //
 163          //      Uart0_Tx(p, ctr);
 164          //}
 165          
 166          void bin_search(U8_T min_id, U8_T max_id) reentrant
 167          {
 168   1              if(min_id > max_id)     return;
 169   1      
 170   1              scan_state = SCAN_BINSEARCH;
 171   1              send_scan_cmd(max_id, min_id);
 172   1      
 173   1      //      debug_print_hex(&min_id, 1);
 174   1      //      debug_print_hex(&max_id, 1);
 175   1      
C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 4   

 176   1              switch(wait_response()) // wait for response from tstats scan command
 177   1              {
 178   2                      case UNIQUE_ID:
 179   2                              // unique id means it is the only id in the range.
 180   2                              // if the id is already in the database, set it occupy and then change the id with sn in the dealwith_c
             -onflict_id routine.
 181   2      //                      Uart0_Tx("\n\rUNIQUE ID!", 12);
 182   2                              check_id_in_database(current_db.id, current_db.sn);                     
 183   2                              break;
 184   2                      case MULTIPLE_ID:
 185   2                              // multiple id means there is more than one id in the range.
 186   2                              // if the min_id == max_id, there is same id, set the id occupy and return
 187   2                              // if the min_id != max_id, there is multi id in the range, divide the range and do the sub scan
 188   2      //                      Uart0_Tx("\n\rMULTIPLE ID!", 14);
 189   2                              if(min_id == max_id)
 190   2                              {
 191   3                                      occupy[(min_id - 1) / 8] |= 1 << ((min_id - 1) % 8);
 192   3                              }
 193   2                              else
 194   2                              {
 195   3                                      bin_search(min_id, (U8_T)(((U16_T)min_id + (U16_T)max_id) / 2));
 196   3                                      bin_search((U8_T)(((U16_T)min_id + (U16_T)max_id) / 2) + 1, max_id);
 197   3                              }
 198   2                              break;
 199   2                      case UNIQUE_ID_FROM_MULTIPLE:
 200   2                              // there are multiple ids in the range, but the fisrt reply is good.
 201   2      //                      Uart0_Tx("\n\rUNIQUE_ID_FROM_MULTIPLE!", 26);
 202   2                              check_id_in_database(current_db.id, current_db.sn);
 203   2                              if(min_id == max_id)
 204   2                              {
 205   3                                      occupy[(min_id - 1) / 8] |= 1 << ((min_id - 1) % 8);
 206   3                              }
 207   2                              else
 208   2                              {
 209   3                                      bin_search(min_id, (U8_T)(((U16_T)min_id + (U16_T)max_id) / 2));
 210   3                                      bin_search((U8_T)(((U16_T)min_id + (U16_T)max_id) / 2) + 1, max_id);
 211   3                              }
 212   2                              break;
 213   2                      case NONE_ID:
 214   2                              // none id means there is not id in the range
 215   2      //                      Uart0_Tx("\n\rNONE ID!", 10);
 216   2                              break;
 217   2              }
 218   1      
 219   1              return;
 220   1      }
 221          
 222          void dealwith_conflict_id(void)
 223          {
 224   1              U8_T occupy_id = 1;
 225   1              U8_T idle_id, i;
 226   1              U8_T status;
 227   1      
 228   1              while(1)
 229   1              {
 230   2                      if(occupy[(occupy_id - 1) / 8] & (1 << ((occupy_id - 1) % 8)))
 231   2                      {
 232   3                              idle_id = get_idle_id();
 233   3      
 234   3                              scan_state = SCAN_BINSEARCH;
 235   3                              send_scan_cmd(occupy_id, occupy_id); // get the seperate sn
 236   3                              status = wait_response();
C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 5   

 237   3      
 238   3                              if(status == UNIQUE_ID) // if unique, there is not occupied at this id.
 239   3                              {
 240   4                                      // tbd.
 241   4                                      occupy[(occupy_id - 1) / 8] &= ~(1 << ((occupy_id - 1) % 8));
 242   4                              }
 243   3                              else if(status == UNIQUE_ID_FROM_MULTIPLE)
 244   3                              {
 245   4                                      for(i = 0; i < db_ctr; i++)
 246   4                                      {
 247   5                                              if(current_db.id == scan_db[i].id)
 248   5                                              {
 249   6                                                      if(current_db.sn != scan_db[i].sn)      // get new device
 250   6                                                      {
 251   7                                                              assignment_id_with_sn(current_db.id, idle_id, current_db.sn); // assign idle id with sn to this occ
             -upy device.
 252   7                                                              wait_response();
 253   7                                                              if(scan_response_state == ASSIGN_ID)
 254   7                                                              {
 255   8                                                                      online[(idle_id - 1) / 8] |= 1 << ((idle_id - 1) % 8);
 256   8                                                                      scan_db_changed = TRUE;
 257   8                                                              }
 258   7                                                      }
 259   6                                                      break;
 260   6                                              }
 261   5                                      }
 262   4                                      continue;
 263   4                              }
 264   3                              else if(status == MULTIPLE_ID)
 265   3                              {
 266   4                                      continue;
 267   4                              }
 268   3                              else
 269   3                              {
 270   4                                      continue;
 271   4                              }
 272   3                      }
 273   2                      
 274   2                      occupy_id++;
 275   2                      if(occupy_id == 0xff) break;
 276   2              }
 277   1      }
 278          
 279          void scan_tstat(void)
 280          {
 281   1              bin_search(1, 254);
 282   1              dealwith_conflict_id();
 283   1              if(scan_db_changed == TRUE)
 284   1              {
 285   2                      scan_db_changed = FALSE;
 286   2                      ChangeFlash = 1;
 287   2              }
 288   1      }
 289          
 290          // read from flash to get the init online status
 291          void init_scan(void)
 292          {
 293   1              U8_T i;
 294   1              U8_T is_nc_in_db = FALSE;
 295   1              memset(online, 0, 32);
 296   1              memset(occupy, 0, 32);
 297   1              db_ctr = 0;
C51 COMPILER V9.06   SCAN                                                                  03/13/2013 09:32:29 PAGE 6   

 298   1              nc_id = Para[13];
 299   1              nc_sn = ((U32_T)Para[7] << 24) | ((U32_T)Para[5] << 16) | ((U32_T)Para[3] << 8) | Para[1];
 300   1      
 301   1              for(i = 0; i < MAX_ID; i++)
 302   1              {
 303   2                      if((scan_db[i].id != 0x00) && (scan_db[i].id != 0xff))
 304   2                      {
 305   3                              online[(scan_db[i].id - 1) / 8] |= (1 << ((scan_db[i].id - 1) % 8));
 306   3                              db_ctr++;
 307   3                              if((scan_db[i].id == nc_id) && (scan_db[i].sn == nc_sn))
 308   3                                      is_nc_in_db = TRUE;
 309   3                      }                       
 310   2                      else
 311   2                      {
 312   3                              break;
 313   3                      }
 314   2              }
 315   1      
 316   1              if((db_ctr == 0) || (is_nc_in_db == FALSE))
 317   1              {
 318   2                      scan_db[db_ctr].id = nc_id;
 319   2                      scan_db[db_ctr].sn = nc_sn;
 320   2                      online[(nc_id - 1) / 8] |= (1 << ((nc_id - 1) % 8));
 321   2                      db_ctr++;
 322   2                      ChangeFlash = 1;
 323   2              }
 324   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2313    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1341    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
