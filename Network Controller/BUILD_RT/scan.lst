C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE SCAN
OBJECT MODULE PLACED IN .\scan.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\scan\scan.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\sr
                    -c\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\scan.lst) OBJE
                    -CT(.\scan.obj)

line level    source

   1          
   2          #include <stdlib.h>
   3          #include <string.h>
   4          #include "scan.h"
   5          #include "../main/main.h"
   6          #include "../flash/flash.h"
   7          #include "../schedule/schedule.h"
   8          
   9          extern void InitCRC16(void);
  10          
  11          extern U8_T ChangeFlash;
  12          
  13          extern U8_T far CRClo;
  14          extern U8_T far CRChi;
  15          extern void CRC16_Tstat(U8_T ch);
  16          extern U8_T Sever_Order;
  17          extern U8_T far Para[400];
  18          
  19          SCAN_DB far scan_db[MAX_ID];
  20          SCAN_DB far current_db;
  21          U8_T db_ctr;
  22          
  23          U8_T far scan_state;
  24          U8_T far scan_response_state;
  25          
  26          U8_T far online[32] = {0};
  27          U8_T far occupy[32] = {0};
  28          
  29          static U8_T nc_id;
  30          static U32_T nc_sn;
  31          
  32          static U8_T scan_db_changed = FALSE;
  33          
  34          void send_scan_cmd(U8_T max_id, U8_T min_id)
  35          {       
  36   1              U8_T i, buf[6];
  37   1              
  38   1              buf[0] = 0xff;
  39   1              buf[1] = 0x19;
  40   1              buf[2] = max_id;
  41   1              buf[3] = min_id;
  42   1      
  43   1              InitCRC16();
  44   1              for(i = 0; i < 4; i++)
  45   1                      CRC16_Tstat(buf[i]);
  46   1      
  47   1              buf[4] = CRChi;
  48   1              buf[5] = CRClo;
  49   1      
C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 2   

  50   1              scan_response_state = NONE_ID;
  51   1              Sever_Order = SERVER_SCAN;
  52   1      
  53   1              Tx_To_Tstat(buf, 6);
  54   1      }
  55          
  56          #define DELAY_TICKS             50
  57          U8_T wait_response(void)
  58          {
  59   1              U8_T i;
  60   1              for(i = 0; i < DELAY_TICKS; i++)
  61   1              {
  62   2                      if(scan_response_state != NONE_ID)
  63   2                      {
  64   3                              break;
  65   3                      }
  66   2                      else
  67   2                      {
  68   3                              OSDelay(2);
  69   3                      }
  70   2              }
  71   1      
  72   1              return scan_response_state;
  73   1      }
  74          
  75          void assignment_id_with_sn(U8_T old_id, U8_T new_id, U32_T current_sn)
  76          {
  77   1              U8_T i, buf[12];
  78   1              
  79   1              buf[0] = old_id;
  80   1              buf[1] = 0x06;
  81   1              buf[2] = 0;
  82   1              buf[3] = 0x0a;  //MODBUS_ADDRESS_PLUG_N_PLAY = 10
  83   1              buf[4] = 0x55;
  84   1              buf[5] = new_id;
  85   1      
  86   1              buf[6] = (U8_T)(current_sn >> 24);
  87   1              buf[7] = (U8_T)(current_sn >> 16);
  88   1              buf[8] = (U8_T)(current_sn >> 8);
  89   1              buf[9] = (U8_T)current_sn;
  90   1      
  91   1              InitCRC16();
  92   1              for(i = 0; i < 10; i++)
  93   1                      CRC16_Tstat(buf[i]);
  94   1      
  95   1              buf[10] = CRChi;
  96   1              buf[11] = CRClo;
  97   1      
  98   1              scan_state = SCAN_ASSIGN_ID_WITH_SN;
  99   1              scan_response_state = NONE_ID;
 100   1              Sever_Order = SERVER_SCAN;
 101   1              Tx_To_Tstat(buf, 12);
 102   1      }
 103          
 104          U8_T get_idle_id(void)
 105          {
 106   1              U8_T i;
 107   1              for(i = 1; i <= MAX_ID; i++)
 108   1              {
 109   2                      if(online[(i - 1) / 8] & (1 << ((i - 1) % 8)) == 0)
 110   2                              return i;
 111   2              }
C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 3   

 112   1              return 0xff;
 113   1      }
 114          
 115          void check_id_in_database(U8_T id, U32_T sn)
 116          {
 117   1              if(online[(id - 1) / 8] & (1 << ((id - 1) % 8))) // in the database
 118   1              {
 119   2                      U8_T i;
 120   2                      for(i = 0; i < db_ctr; i++)
 121   2                      {
 122   3                              if(id == scan_db[i].id) // id already in the database
 123   3                              {
 124   4                                      if(sn != scan_db[i].sn) // if there exist the same id with defferent sn, push it into the occupy list
 125   4                                      {
 126   5                                              occupy[(id - 1) / 8] |= 1 << ((id - 1) % 8);
 127   5                                      }
 128   4                                      break;
 129   4                              }
 130   3                              // if the device is already in the database, return without doing anything
 131   3                      }
 132   2              }
 133   1              else
 134   1              {
 135   2                      online[(id - 1) / 8] |= 1 << ((id - 1) % 8);
 136   2                      scan_db[db_ctr].id = id;
 137   2                      scan_db[db_ctr].sn = sn;
 138   2                      db_ctr++;
 139   2                      scan_db_changed = TRUE;
 140   2              }
 141   1      }
 142          
 143          
 144          
 145          void bin_search(U8_T min_id, U8_T max_id) reentrant
 146          {
 147   1              
 148   1      
 149   1              if(min_id > max_id)     return;
 150   1      
 151   1              scan_state = SCAN_BINSEARCH;
 152   1              send_scan_cmd(max_id, min_id);
 153   1      
 154   1      
 155   1              switch(wait_response()) // wait for response from tstats scan command
 156   1              {
 157   2                      case UNIQUE_ID:
 158   2                              // unique id means it is the only id in the range.
 159   2                              // if the id is already in the database, set it occupy and then change the id with sn in the dealwith_c
             -onflict_id routine.
 160   2      //                      Uart0_Tx("\n\rUNIQUE ID!", 12);
 161   2                              check_id_in_database(current_db.id, current_db.sn);                     
 162   2                              break;
 163   2                      case MULTIPLE_ID:
 164   2                              // multiple id means there is more than one id in the range.
 165   2                              // if the min_id == max_id, there is same id, set the id occupy and return
 166   2                              // if the min_id != max_id, there is multi id in the range, divide the range and do the sub scan
 167   2      //                      Uart0_Tx("\n\rMULTIPLE ID!", 14);
 168   2                              if(min_id == max_id)
 169   2                              {
 170   3                                      occupy[(min_id - 1) / 8] |= 1 << ((min_id - 1) % 8);
 171   3                              }
 172   2                              else
C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 4   

 173   2                              {
 174   3                                      bin_search(min_id, (U8_T)(((U16_T)min_id + (U16_T)max_id) / 2));
 175   3                                      bin_search((U8_T)(((U16_T)min_id + (U16_T)max_id) / 2) + 1, max_id);
 176   3                              }
 177   2                              break;
 178   2                      case UNIQUE_ID_FROM_MULTIPLE:
 179   2                              // there are multiple ids in the range, but the fisrt reply is good.
 180   2      //                      Uart0_Tx("\n\rUNIQUE_ID_FROM_MULTIPLE!", 26);
 181   2                              check_id_in_database(current_db.id, current_db.sn);
 182   2                              if(min_id == max_id)
 183   2                              {
 184   3                                      occupy[(min_id - 1) / 8] |= 1 << ((min_id - 1) % 8);
 185   3                              }
 186   2                              else
 187   2                              {
 188   3                                      bin_search(min_id, (U8_T)(((U16_T)min_id + (U16_T)max_id) / 2));
 189   3                                      bin_search((U8_T)(((U16_T)min_id + (U16_T)max_id) / 2) + 1, max_id);
 190   3                              }
 191   2                              break;
 192   2                      case NONE_ID:
 193   2                              // none id means there is not id in the range
 194   2      //                      Uart0_Tx("\n\rNONE ID!", 10);
 195   2                              break;
 196   2              }
 197   1      
 198   1              return;
 199   1      }
 200          
 201          void dealwith_conflict_id(void)
 202          {
 203   1              U8_T occupy_id = 1;
 204   1              U8_T idle_id, i;
 205   1              U8_T status;
 206   1      
 207   1              while(1)
 208   1              {
 209   2                      if(occupy[(occupy_id - 1) / 8] & (1 << ((occupy_id - 1) % 8)))
 210   2                      {
 211   3                              idle_id = get_idle_id();
 212   3      
 213   3                              scan_state = SCAN_BINSEARCH;
 214   3                              send_scan_cmd(occupy_id, occupy_id); // get the seperate sn
 215   3                              status = wait_response();
 216   3      
 217   3                              if(status == UNIQUE_ID) // if unique, there is not occupied at this id.
 218   3                              {
 219   4                                      occupy[(occupy_id - 1) / 8] &= ~(1 << ((occupy_id - 1) % 8));
 220   4                              }
 221   3                              else if(status == UNIQUE_ID_FROM_MULTIPLE)
 222   3                              {
 223   4                                      for(i = 0; i < db_ctr; i++)
 224   4                                      {
 225   5                                              if(current_db.id == scan_db[i].id)
 226   5                                              {
 227   6                                                      if(current_db.sn != scan_db[i].sn)      // get new device
 228   6                                                      {
 229   7                                                              assignment_id_with_sn(current_db.id, idle_id, current_db.sn); // assign idle id with sn to this occ
             -upy device.
 230   7                                                              wait_response();
 231   7                                                              if(scan_response_state == ASSIGN_ID)
 232   7                                                              {
 233   8                                                                      online[(idle_id - 1) / 8] |= 1 << ((idle_id - 1) % 8);
C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 5   

 234   8                                                                      scan_db_changed = TRUE;
 235   8                                                              }
 236   7                                                      }
 237   6                                                      break;
 238   6                                              }
 239   5                                      }
 240   4                                      continue;
 241   4                              }
 242   3                              else if(status == MULTIPLE_ID)
 243   3                              {
 244   4                                      continue;
 245   4                              }
 246   3                              else
 247   3                              {
 248   4                                      continue;
 249   4                              }
 250   3                      }
 251   2                      
 252   2                      occupy_id++;
 253   2                      if(occupy_id == 0xff) break;
 254   2              }
 255   1      }
 256          
 257          void scan_tstat(void)
 258          {
 259   1              U8_T cnt[5];
 260   1              
 261   1              bin_search(1, 254);
 262   1              dealwith_conflict_id();
 263   1      
 264   1              cnt[0] =  db_ctr;
 265   1      //      Uart0_Tx(cnt, 1);
 266   1      
 267   1      
 268   1              if(scan_db_changed == TRUE)
 269   1              {
 270   2                      scan_db_changed = FALSE;
 271   2                      ChangeFlash = 1;
 272   2              }
 273   1      }
 274          
 275          // read from flash to get the init online status
 276          void init_scan(void)
 277          {
 278   1              U8_T i;
 279   1              U8_T is_nc_in_db = FALSE;
 280   1              memset(online, 0, 32);
 281   1              memset(occupy, 0, 32);
 282   1              db_ctr = 0;
 283   1              nc_id = Para[13];
 284   1              nc_sn = ((U32_T)Para[7] << 24) | ((U32_T)Para[5] << 16) | ((U32_T)Para[3] << 8) | Para[1];
 285   1      
 286   1              for(i = 0; i < MAX_ID; i++)
 287   1              {
 288   2                      if((scan_db[i].id != 0x00) && (scan_db[i].id != 0xff))
 289   2                      {
 290   3                              online[(scan_db[i].id - 1) / 8] |= (1 << ((scan_db[i].id - 1) % 8));
 291   3                              db_ctr++;
 292   3                              if((scan_db[i].id == nc_id) && (scan_db[i].sn == nc_sn))
 293   3                                      is_nc_in_db = TRUE;
 294   3                      }                       
 295   2                      else
C51 COMPILER V9.06   SCAN                                                                  05/28/2013 16:06:35 PAGE 6   

 296   2                      {
 297   3                              break;
 298   3                      }
 299   2              }
 300   1      
 301   1              if((db_ctr == 0) || (is_nc_in_db == FALSE))
 302   1              {
 303   2                      scan_db[db_ctr].id = nc_id;
 304   2                      scan_db[db_ctr].sn = nc_sn;
 305   2                      online[(nc_id - 1) / 8] |= (1 << ((nc_id - 1) % 8));
 306   2                      db_ctr++;
 307   2                      ChangeFlash = 1;
 308   2              }
 309   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2323    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   1341    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
