C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE GUDPBC
OBJECT MODULE PLACED IN .\gudpbc.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\management\gudpbc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6
                    -020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hs
                    -ur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\
                    -SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX1100
                    -0\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusT
                    -CP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\gudpbc.lst) OBJECT(.
                    -\gudpbc.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: gudpbc.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: gudpbc.c,v $
  18           *
  19           *=============================================================================
  20           */
  21          
  22          /* INCLUDE FILE DECLARATIONS */
  23          #include "reg80390.h"
  24          #include "adapter.h"
  25          #include "gudpbc.h"
  26          #include "tcpip.h"
  27          #include "mstimer.h"
  28          #include "stoe.h"
  29          #include "uart.h"
  30          #include "gconfig.h"
  31          #include "ax11000.h"
  32          #include "mac.h"
  33          #include "flash.h"
  34          #include "i2c.h"
  35          #include "i2capi.h"
  36          #include "printd.h"
  37          #include "main.h"
  38          #include <string.h>
  39          #include "8563.h"
  40          #include "../USB/ch375_com.h"
  41          #include "../LCD/LCD.h"
  42          
  43          /* NAMING CONSTANT DECLARATIONS */
  44          #define GS2E_ENABLE_STATE_MACHINE       0
  45          #define GUDPBC_EEPROM_CONFIG            (GCONFIG_EEPROM_CONFIG)
  46          #define GUDPBC_ENABLE_DEBUG_MSG         0 // 1: enable 0:disable
  47          
  48          #define GUDPBC_MAX_CONNS                        4
  49          #define GUDPBC_NO_NEW_CONN                      0xFF
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 2   

  50          
  51          #define GUDPBC_STATE_FREE                       0
  52          #define GUDPBC_STATE_WAIT                       1
  53          #define GUDPBC_STATE_CONNECTED          2
  54          
  55          
  56          /* GLOBAL VARIABLES DECLARATIONS */
  57          
  58          /* LOCAL VARIABLES DECLARATIONS */
  59          static GUDPBC_CONN gudpbc_Conns[GUDPBC_MAX_CONNS];
  60           U8_T gudpbc_InterAppId;
  61          static GCONFIG_CFG_PKT gudpbc_ConfigTxPkt;
  62          static GCONFIG_CFG_PKT gudpbc_ConfigRxPkt;
  63          
  64          /* LOCAL SUBPROGRAM DECLARATIONS */
  65          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id);
  66          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  67          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id);
  68          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  69          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id);
  70          #if GUDPBC_EEPROM_CONFIG
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id);
              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id);
              #endif
  74          
  75          U8_T    FlagIsp=0;
  76          U16_T UdpPort=1234;
  77          extern   U8_T  far  Para[400]; 
  78          U8_T ab[40]={0x65,0,0x0e,0};//0x0b
  79          
  80           U8_T state=1;
  81          
  82           U8_T scanstart=0;
  83          
  84          void UdpData(void)
  85           {
  86   1      
  87   1      //serial
  88   1      ab[4]=Para[1];
  89   1      ab[5]=0;
  90   1      ab[6]=Para[3];
  91   1      ab[7]=0;
  92   1      ab[8]=Para[5];
  93   1      ab[9]=0;
  94   1      ab[10]=Para[7];
  95   1      ab[11]=0;
  96   1      //nc 
  97   1      ab[12]=Para[15];
  98   1      ab[13]=0;
  99   1      //modbus address
 100   1      ab[14]=Para[13];
 101   1      ab[15]=0;
 102   1      //Ip
 103   1      ab[16]=Para[215];
 104   1      ab[17]=0;
 105   1      ab[18]=Para[217];
 106   1      ab[19]=0;
 107   1      ab[20]=Para[219];
 108   1      ab[21]=0;
 109   1      ab[22]=Para[221];
 110   1      ab[23]=0;
 111   1      //port
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 3   

 112   1      //ab[24]=(U8_T)(UdpPort);
 113   1      //ab[25]=(U8_T)(UdpPort>>8);
 114   1      ab[24]=Para[241];
 115   1      ab[25]=Para[240];
 116   1      
 117   1      ab[26]=Para[9];
 118   1      ab[27]=0;
 119   1      
 120   1      ab[28]=Para[11];
 121   1      ab[29]=0;
 122   1      
 123   1      ab[30]=Para[17];
 124   1      ab[31]=0;
 125   1      
 126   1      }
 127          
 128          #if 1  //LHN ADD for time server
 129          
 130          #define Bace_s           3439756800   //from 2009.1.1 
 131          #define Bace_Week        3            //2009.1.1 Tuesday
 132          #define Bace_year        2009  
 133          #define Bace_Time_Zone   43200        //Zone -12        
 134          #define Day_s            86400
 135          #define Hour_s           3600
 136          #define Min_s            60
 137          #define year_Day         365
 138          
 139          
 140          void TimeServer_Deal(U32_T time,U8_T time_zone)
 141          {
 142   1              U32_T time_s=0;
 143   1              U32_T time_year=0;
 144   1              U32_T time_day=0;
 145   1              U32_T time_h=0;
 146   1      
 147   1              time_s = time - Bace_s + ((U32_T)time_zone) * Hour_s - Bace_Time_Zone;
 148   1      
 149   1              if(time_s)
 150   1              {
 151   2                      time_day = time_s / Day_s ;
 152   2                      time_h = time_s % Day_s;
 153   2      
 154   2                      Time.UN.Setime[3] = (U8_T)(time_day % 7 + Bace_Week) % 7 + 1;  //Week
 155   2      
 156   2                      if( (time_day % year_Day)  >= ((time_day / year_Day ) / 4) )
 157   2                      {
 158   3                              time_year = time_day / year_Day + Bace_year;   
 159   3                              time_day = time_day % year_Day - (time_day / year_Day)/4;
 160   3                      }
 161   2                      else
 162   2                      {
 163   3                              time_year = time_day / year_Day + Bace_year - 1;
 164   3                          if((time_day / year_Day ) / 4)
 165   3                                      time_day = 366 + time_day % year_Day - (time_day / year_Day)/4; 
 166   3                              else
 167   3                                      time_day = 365 + time_day % year_Day - (time_day / year_Day)/4; 
 168   3                      }
 169   2      
 170   2                      Time.UN.Setime[0] = (U8_T)(time_year / 100);           //year high
 171   2                      Time.UN.Setime[1] = (U8_T)(time_year % 100);           //year low
 172   2      
 173   2                      if(!(time_year % 4))  //leap year
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 4   

 174   2                      {
 175   3                              if( (time_day >= 0) && (time_day <= 30) ) // january
 176   3                              {
 177   4                                      Time.UN.Setime[2] = 1;               //month                     
 178   4                                      Time.UN.Setime[4] = time_day + 1;    //day
 179   4                              }
 180   3                              else if( (time_day >= 31) && (time_day <= 59) ) // february
 181   3                              {
 182   4                                      Time.UN.Setime[2] = 2;
 183   4                                      Time.UN.Setime[4] = time_day - 31 + 1;  
 184   4                              }
 185   3                              else if( (time_day >= 60) && (time_day <= 90) ) //3
 186   3                              {
 187   4                                      Time.UN.Setime[2] = 3;
 188   4                                      Time.UN.Setime[4] = time_day - 60 + 1;  
 189   4                              }
 190   3                              else if( (time_day >= 91) && (time_day <= 120) )//4
 191   3                              {
 192   4                                      Time.UN.Setime[2] = 4;
 193   4                                      Time.UN.Setime[4] = time_day - 91 + 1;  
 194   4                              }
 195   3                              else if( (time_day >= 121) && (time_day <= 151) ) //5
 196   3                              {
 197   4                                      Time.UN.Setime[2] = 5;
 198   4                                      Time.UN.Setime[4] = time_day - 121 + 1; 
 199   4                              }
 200   3                              else if( (time_day >= 152) && (time_day <= 181) ) //6
 201   3                              {
 202   4                                      Time.UN.Setime[2] = 6;
 203   4                                      Time.UN.Setime[4] = time_day - 152 + 1; 
 204   4                              }
 205   3                              else if( (time_day >= 182) && (time_day <= 212) ) //7
 206   3                              {
 207   4                                      Time.UN.Setime[2] = 7;
 208   4                                      Time.UN.Setime[4] = time_day - 182 + 1; 
 209   4                              }
 210   3                              else if( (time_day >= 213) && (time_day <= 243) ) //8
 211   3                              {
 212   4                                      Time.UN.Setime[2] = 8;
 213   4                                      Time.UN.Setime[4] = time_day - 213 + 1; 
 214   4                              }
 215   3                              else if( (time_day >= 244) && (time_day <= 273) ) //9
 216   3                              {
 217   4                                      Time.UN.Setime[2] = 9;
 218   4                                      Time.UN.Setime[4] = time_day - 243 + 1; 
 219   4                              }
 220   3                              else if( (time_day >= 274) && (time_day <= 304) ) //10
 221   3                              {
 222   4                                      Time.UN.Setime[2] = 10;
 223   4                                      Time.UN.Setime[4] = time_day - 274 + 1; 
 224   4                              }
 225   3                              else if( (time_day >= 305) && (time_day <= 334) ) //11
 226   3                              {
 227   4                                      Time.UN.Setime[2] = 11;
 228   4                                      Time.UN.Setime[4] = time_day - 304 + 1; 
 229   4                              }
 230   3                              else if( (time_day >= 335) && (time_day <= 365) ) //12
 231   3                              {
 232   4                                      Time.UN.Setime[2] = 12;
 233   4                                      Time.UN.Setime[4] = time_day - 335 + 1; 
 234   4                              }
 235   3      
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 5   

 236   3                      }
 237   2                      else
 238   2                      {
 239   3                              if( (time_day >= 0) && (time_day <= 30) ) // january
 240   3                              {
 241   4                                      Time.UN.Setime[2] = 1;
 242   4                                      Time.UN.Setime[4] = time_day - 0 + 1;
 243   4                              }
 244   3                              else if( (time_day >= 31) && (time_day <= 58) ) // february
 245   3                              {
 246   4                                      Time.UN.Setime[2] = 2;
 247   4                                      Time.UN.Setime[4] = time_day - 31 + 1;  
 248   4                              }
 249   3                              else if( (time_day >= 59) && (time_day <= 89) ) //3
 250   3                              {
 251   4                                      Time.UN.Setime[2] = 3;
 252   4                                      Time.UN.Setime[4] = time_day - 59 + 1;  
 253   4                              }
 254   3                              else if( (time_day >= 90) && (time_day <= 119) )//4
 255   3                              {
 256   4                                      Time.UN.Setime[2] = 4;
 257   4                                      Time.UN.Setime[4] = time_day - 90 + 1;  
 258   4                              }
 259   3                              else if( (time_day >= 120) && (time_day <= 150) ) //5
 260   3                              {
 261   4                                      Time.UN.Setime[2] = 5;
 262   4                                      Time.UN.Setime[4] = time_day - 120 + 1; 
 263   4                              }
 264   3                              else if( (time_day >= 151) && (time_day <= 180) ) //6
 265   3                              {
 266   4                                      Time.UN.Setime[2] = 6;
 267   4                                      Time.UN.Setime[4] = time_day - 151 + 1; 
 268   4                              }
 269   3                              else if( (time_day >= 181) && (time_day <= 211) ) //7
 270   3                              {
 271   4                                      Time.UN.Setime[2] = 7;
 272   4                                      Time.UN.Setime[4] = time_day - 181 + 1; 
 273   4                              }
 274   3                              else if( (time_day >= 212) && (time_day <= 242) ) //8
 275   3                              {
 276   4                                      Time.UN.Setime[2] = 8;
 277   4                                      Time.UN.Setime[4] = time_day - 212 + 1; 
 278   4                              }
 279   3                              else if( (time_day >= 243) && (time_day <= 272) ) //9
 280   3                              {
 281   4                                      Time.UN.Setime[2] = 9;
 282   4                                      Time.UN.Setime[4] = time_day - 242 + 1; 
 283   4                              }
 284   3                              else if( (time_day >= 273) && (time_day <= 303) ) //10
 285   3                              {
 286   4                                      Time.UN.Setime[2] = 10;
 287   4                                      Time.UN.Setime[4] = time_day - 273 + 1; 
 288   4                              }
 289   3                              else if( (time_day >= 304) && (time_day <= 333) ) //11
 290   3                              {
 291   4                                      Time.UN.Setime[2] = 11;
 292   4                                      Time.UN.Setime[4] = time_day - 303 + 1; 
 293   4                              }
 294   3                              else if( (time_day >= 334) && (time_day <= 364) ) //12
 295   3                              {
 296   4                                      Time.UN.Setime[2] = 12;
 297   4                                      Time.UN.Setime[4] = time_day - 334 + 1; 
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 6   

 298   4                              }
 299   3              
 300   3                      }
 301   2                      Time.UN.Setime[5] = (U8_T)(time_h / Hour_s);  //Hour
 302   2                      time_h = time_h % Hour_s;
 303   2                      Time.UN.Setime[6] = (U8_T)(time_h / Min_s);  //minute
 304   2                      Time.UN.Setime[7] = (U8_T)(time_h % Min_s); //second            
 305   2                      
 306   2                      Initial_Clock();
 307   2              //      Uart0_Tx(Time.UN.Setime,8);
 308   2              }
 309   1      }
 310          
 311          #endif
 312          
 313          
 314          
 315          #if 1
 316          /*
 317           * ----------------------------------------------------------------------------
 318           * Function Name: I2C_Init
 319           * Purpose:
 320           * Params:
 321           * Returns:
 322           * Note:
 323           * ----------------------------------------------------------------------------
 324           */
 325          void I2C_Init(void)
 326          {
 327   1              switch (CSREPR & (BIT6|BIT7))
 328   1              {
 329   2                      case SYS_CLK_100M :
 330   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 100M */
 331   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0031, 0x005A);
 332   2                              break;
 333   2                      case SYS_CLK_50M :
 334   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 50M */
 335   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0018, 0x005A);
 336   2                              break;
 337   2                      case SYS_CLK_25M :
 338   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 25M */
 339   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x000c, 0x005A);
 340   2                              break;
 341   2              }
 342   1      }
 343          #endif
 344          
 345          /*
 346           * ----------------------------------------------------------------------------
 347           * Function Name: GUDPBC_Task
 348           * Purpose: 
 349           * Params:
 350           * Returns:
 351           * Note:
 352           * ----------------------------------------------------------------------------
 353           */
 354          void GUDPBC_Task(void)
 355          {
 356   1      
 357   1      } /* End of GUDPBC_Task() */
 358          
 359          /*
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 7   

 360           * ----------------------------------------------------------------------------
 361           * Function Name: GUDPBC_Init()
 362           * Purpose: Initialization
 363           * Params:
 364           * Returns:
 365           * Note:
 366           * ----------------------------------------------------------------------------
 367           */
 368          void GUDPBC_Init(U16_T localPort)
 369          {
 370   1              U8_T    i;
 371   1      
 372   1              printd("GUDPBC_Init()...\n\r");
 373   1      //      printd("NC fw69.11hw26bl14\n\r");
 374   1      //      char abc[] = {"NC fw69.11hw26bl14"};
 375   1      
 376   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 377   1                      gudpbc_Conns[i].State = GUDPBC_STATE_FREE;
 378   1      
 379   1              gudpbc_InterAppId = TCPIP_Bind(GUDPBC_NewConn, GUDPBC_Event, GUDPBC_Receive);
 380   1                      
 381   1              /* unicast packet */
 382   1      //      TCPIP_UdpListen(123, gudpbc_InterAppId);
 383   1              TCPIP_UdpListen(localPort, gudpbc_InterAppId);
 384   1              
 385   1      } /* End of GUDPBC_Init() */
 386          
 387          /*
 388           * ----------------------------------------------------------------------------
 389           * Function Name: GUDPBC_NewConn
 390           * Purpose: 
 391           * Params:
 392           * Returns:
 393           * Note:
 394           * ----------------------------------------------------------------------------
 395           */
 396          U8_T GUDPBC_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 397          {
 398   1              U8_T    i;
 399   1      
 400   1              pip = pip;
 401   1              remotePort = remotePort;
 402   1      
 403   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("GUDPBC_NewConn(remotePort=%d, socket=%d)\n\r",remotePort,socket);
              #endif  
 406   1      
 407   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 408   1              {
 409   2                      if (gudpbc_Conns[i].State == GUDPBC_STATE_FREE)
 410   2                      {
 411   3                              gudpbc_Conns[i].State = GUDPBC_STATE_CONNECTED;
 412   3      //                      gudpbc_Conns[i].Timer = (U16_T)SWTIMER_Tick();
 413   3      //                      gudpbc_Conns[i].Ip = *pip;
 414   3      //                      gudpbc_Conns[i].Port = remotePort;
 415   3                              gudpbc_Conns[i].UdpSocket = socket;
 416   3                              return i;
 417   3                      }
 418   2              }
 419   1              
 420   1              return GUDPBC_NO_NEW_CONN;
 421   1      
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 8   

 422   1      } /* End of GUDPBC_NewConn() */
 423          
 424          /*
 425           * ----------------------------------------------------------------------------
 426           * Function Name: GUDPBC_Event
 427           * Purpose: 
 428           * Params:
 429           * Returns:
 430           * Note:
 431           * ----------------------------------------------------------------------------
 432           */
 433          void GUDPBC_Event(U8_T id, U8_T event)
 434          {
 435   1              gudpbc_Conns[id].State = event;
 436   1      
 437   1      } /* End of GUDPBC_Event() */
 438          
 439          
 440          
 441          U8_T udp_receive_reboot(void)
 442          {
 443   1              U8_T   socket,id;
 444   1              U8_T    *pData;
 445   1       //evan move the bootloader jump interface from gudpc.c to http.c 
 446   1       // which webpage function have take charge that .c file.
 447   1      
 448   1                  if((pData[0] == 0xee) && (pData[1] == 0x10))
 449   1                  {   
 450   2                              gudpbc_HandleSearchReq(pData, id); 
 451   2                      IntFlashErase(ERA_RUN, 0x60000);
 452   2                      FlagIsp = 1;
 453   2                              USB_disable();
 454   2                              lcdreset();
 455   2                              Lcd_Initial();
 456   2                              Display_Updating();
 457   2                      AX11000_SoftReboot();   
 458   2                      }
 459   1      
 460   1         return       socket;
 461   1      }
 462          
 463          
 464          /*
 465           * ----------------------------------------------------------------------------
 466           * Function Name: GUDPBC_Receive
 467           * Purpose: 
 468           * Params:
 469           * Returns:
 470           * Note:
 471           * ----------------------------------------------------------------------------
 472           */
 473          void GUDPBC_Receive(U8_T XDATA* pData, U16_T length, U8_T id)
 474          {
 475   1      //      U8_T opcode = 0xFF;
 476   1      //      BOOL bValidReq = FALSE;
 477   1      //      GCONFIG_MAC_ADDR macAddr;
 478   1          U8_T  n=0;
 479   1              U32_T time_s=0;
 480   1       
 481   1          //Uart0_Tx(pData,length);
 482   1              if( (length == 48) )  //(gudpbc_Conns[id].UdpSocket == Time_Server.UdpSocket) && 
 483   1              {
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 9   

 484   2                      Para[399] = 1;
 485   2                      time_s = ( ((U32_T)pData[40]) << 24 ) | ( ((U32_T)pData[41]) << 16 ) | ( ((U32_T)pData[42]) << 8 ) |  ((
             -U32_T)pData[43]) ;
 486   2                      TimeServer_Deal(time_s,Para[23]);
 487   2                      TCPIP_UdpClose(Time_Server.UdpSocket);
 488   2              }
 489   1              else
 490   1              {
 491   2                  if((pData[0] == 100)&&(pData[1] == 0))
 492   2                  { 
 493   3                              scanstart = 1;
 494   3                      state = 1;
 495   3                  }
 496   2                  if(scanstart)
 497   2                      {  
 498   3                              for(n = 0; n < (U8_T)length/4; n++)
 499   3                      { 
 500   4                              if( (pData[4*n+1] == Para[215])&&(pData[4*n+2] == Para[217])&&(pData[4*n+3] == Para[219])&&(pDat
             -a[4*n+4] == Para[221]))
 501   4                          { 
 502   5                                              scanstart=0;
 503   5                              state=0;
 504   5                              break;
 505   5                          }
 506   4                      }
 507   3      
 508   3                      if(state)
 509   3                              {
 510   4      //                              gudpbc_HandleSearchReq(pData, id);
 511   4                                      //use broadcast when scan
 512   4                                      U8_T socket = TCPIP_UdpNew(2, 3, 0xffffffff, 0, 4321);
 513   4                                      UdpData();
 514   4                                      TCPIP_UdpSend(socket, 0, 0, ab, 40);
 515   4                                      TCPIP_UdpClose(socket);
 516   4                              }                   
 517   3                  }
 518   2                                           
 519   2                  if((pData[0] == 0xee) && (pData[1] == 0x10))
 520   2                  {   
 521   3                              gudpbc_HandleSearchReq(pData, id); 
 522   3                      IntFlashErase(ERA_RUN, 0x60000);
 523   3                      FlagIsp = 1;
 524   3                              USB_disable();
 525   3                              lcdreset();
 526   3                              Lcd_Initial();
 527   3                              Display_Updating();
 528   3                      AX11000_SoftReboot();   
 529   3                  }
 530   2              }
 531   1      } /* End of GUDPBC_Receive() */
 532          
 533          /*
 534           * ----------------------------------------------------------------------------
 535           * Function Name: gudpbc_HandleSearchReq
 536           * Purpose: 
 537           * Params:
 538           * Returns:
 539           * Note:
 540           * ----------------------------------------------------------------------------
 541           */
 542          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id)
 543          {
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 10  

 544   1              pData = pData;
 545   1              UdpData();
 546   1              TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, ab, 40);
 547   1      }/* End of gudpbc_HandleSearchReq() */
 548          
 549          /*
 550           * ----------------------------------------------------------------------------
 551           * Function Name: gudpbc_HandleSetReq
 552           * Purpose: 
 553           * Params:
 554           * Returns:
 555           * Note:
 556           * ----------------------------------------------------------------------------
 557           */
 558          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id)
 559          {
 560   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleSetReq()...\n\r");
              #endif
 563   1      
 564   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 567   1              if (1)
 568   1      #endif
 569   1              {
 570   2                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
 571   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_ACK;
 572   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 573   2              }
 574   1              else
 575   1              {
 576   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_DENY;     
 577   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);         
 578   2              }
 579   1      } /* End of gudpbc_HandleSetReq() */
 580          
 581          
 582          
 583          /*
 584           * ----------------------------------------------------------------------------
 585           * Function Name: GCONFIG_SetFirmwareUpgradeMode
 586           * Purpose: 
 587           * Params: mode = 1: enable firmware ipgrade after reboot ,  mode = 0: disable
 588           * Returns:
 589           * Note:
 590           * ----------------------------------------------------------------------------
 591           */
 592          //void GCONFIG_SetFirmwareUpgradeMode(U8_T mode)
 593          //{
 594          //      gconfig_ConfigData.FirmwareUpgradeMode = mode;
 595          //} /* End of GCONFIG_SetFirmwareUpgradeMode() */
 596          
 597          
 598          
 599          
 600          
 601          /*
 602           * ----------------------------------------------------------------------------
 603           * Function Name: gudpbc_HandleUpgradeReq
 604           * Purpose: 
 605           * Params:
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 11  

 606           * Returns:
 607           * Note:
 608           * ----------------------------------------------------------------------------
 609           */
 610          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id)
 611          {       
 612   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleUpgradeReq()...\n\r");
              #endif
 615   1      
 616   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 619   1              if (1)
 620   1      #endif
 621   1              {
 622   2      //              GCONFIG_SetFirmwareUpgradeMode(GCONFIG_FW_UPGRADE_ENABLE);
 623   2                      GCONFIG_WriteConfigData();
 624   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_ACK;
 625   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 626   2              //      FirmwareUpdate();
 627   2              }
 628   1              else
 629   1              {
 630   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_DENY;         
 631   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 632   2              }
 633   1      } /* End of gudpbc_HandleUpgradeReq() */
 634          
 635          
 636          
 637          
 638          
 639          
 640          
 641          /*
 642           * ----------------------------------------------------------------------------
 643           * Function Name: gudpbc_HandleResetReq
 644           * Purpose: 
 645           * Params:
 646           * Returns:
 647           * Note:
 648           * ----------------------------------------------------------------------------
 649           */
 650          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id)
 651          {
 652   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleResetReq()...\n\r");
              #endif
 655   1      
 656   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 659   1              if (1)
 660   1      #endif
 661   1              {
 662   2                      GCONFIG_ReadDefaultConfigData();
 663   2                      GCONFIG_WriteConfigData();
 664   2                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
 665   2                      gudpbc_ConfigRxPkt.Opcode = GCONFIG_OPCODE_RESET_ACK;
 666   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, (U8_T*) &gudpbc_ConfigRxPkt, GCONFIG_CFG_PKT_LEN);
 667   2              }
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 12  

 668   1              else
 669   1              {
 670   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 671   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 672   2              }
 673   1      } /* End of gudpbc_HandleResetReq() */
 674          
 675          /*
 676           * ----------------------------------------------------------------------------
 677           * Function Name: gudpbc_HandleRebootReq
 678           * Purpose: 
 679           * Params:
 680           * Returns:
 681           * Note:
 682           * ----------------------------------------------------------------------------
 683           */
 684          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id)
 685          {
 686   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleRebootReq()...\n\r");
              #endif
 689   1      
 690   1      #if GS2E_ENABLE_STATE_MACHINE
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 693   1              if (1)
 694   1      #endif
 695   1              {
 696   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_REBOOT_ACK;   
 697   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 698   2                      // May store current status/setting here before restart
 699   2                      lcdreset();
 700   2                      Lcd_Initial();
 701   2                      Display_Updating();
 702   2                      AX11000_SoftReboot();
 703   2              }
 704   1              else
 705   1              {
 706   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 707   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 708   2              }
 709   1      } /* End of gudpbc_HandleRebootReq() */
 710          
 711          #if GUDPBC_EEPROM_CONFIG
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromReadReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromReadReq()...\n\r");
              #endif
              
                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_READ_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
C51 COMPILER V9.06   GUDPBC                                                                05/24/2013 13:18:42 PAGE 13  

              }
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromWriteReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromWriteReq()...\n\r");
              #endif
              
                      GCONFIG_SetEpromData(&gudpbc_ConfigRxPkt);
                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_WRITE_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
              }
              #endif
 753          /* End of gudpbc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4567    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =    930      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
