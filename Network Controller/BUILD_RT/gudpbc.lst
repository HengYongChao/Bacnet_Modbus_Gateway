C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE GUDPBC
OBJECT MODULE PLACED IN .\gudpbc.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\management\gudpbc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6
                    -020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hs
                    -ur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\
                    -SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX1100
                    -0\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusT
                    -CP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\gudpbc
                    -.lst) OBJECT(.\gudpbc.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: gudpbc.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: gudpbc.c,v $
  18           *
  19           *=============================================================================
  20           */
  21          
  22          /* INCLUDE FILE DECLARATIONS */
  23          #include "reg80390.h"
  24          #include "adapter.h"
  25          #include "gudpbc.h"
  26          #include "tcpip.h"
  27          #include "mstimer.h"
  28          #include "stoe.h"
  29          #include "uart.h"
  30          #include "gconfig.h"
  31          #include "ax11000.h"
  32          #include "mac.h"
  33          #include "flash.h"
  34          #include "i2c.h"
  35          #include "i2capi.h"
  36          #include "printd.h"
  37          #include "main.h"
  38          #include <string.h>
  39          #include "8563.h"
  40          #include "../USB/ch375_com.h"
  41          #include "../LCD/LCD.h"
  42          
  43          /* NAMING CONSTANT DECLARATIONS */
  44          #define GS2E_ENABLE_STATE_MACHINE       0
  45          #define GUDPBC_EEPROM_CONFIG            (GCONFIG_EEPROM_CONFIG)
  46          #define GUDPBC_ENABLE_DEBUG_MSG         0 // 1: enable 0:disable
  47          
  48          #define GUDPBC_MAX_CONNS                        4
  49          #define GUDPBC_NO_NEW_CONN                      0xFF
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 2   

  50          
  51          #define GUDPBC_STATE_FREE                       0
  52          #define GUDPBC_STATE_WAIT                       1
  53          #define GUDPBC_STATE_CONNECTED          2
  54          
  55          
  56          /* GLOBAL VARIABLES DECLARATIONS */
  57          
  58          /* LOCAL VARIABLES DECLARATIONS */
  59          static GUDPBC_CONN gudpbc_Conns[GUDPBC_MAX_CONNS];
  60           U8_T gudpbc_InterAppId;
  61          static GCONFIG_CFG_PKT gudpbc_ConfigTxPkt;
  62          static GCONFIG_CFG_PKT gudpbc_ConfigRxPkt;
  63          
  64          /* LOCAL SUBPROGRAM DECLARATIONS */
  65          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id);
  66          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  67          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id);
  68          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id);
  69          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id);
  70          #if GUDPBC_EEPROM_CONFIG
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id);
              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id);
              #endif
  74          
  75          U8_T    FlagIsp=0;
  76          U16_T UdpPort=1234;
  77          extern   U8_T  far  Para[400]; 
  78          U8_T ab[40]={0x65,0,0x0e,0};//0x0b
  79          
  80           U8_T state=1;
  81          
  82           U8_T scanstart=0;
  83          
  84          void UdpData(void)
  85           {
  86   1      
  87   1      //serial
  88   1      ab[4]=Para[1];
  89   1      ab[5]=0;
  90   1      ab[6]=Para[3];
  91   1      ab[7]=0;
  92   1      ab[8]=Para[5];
  93   1      ab[9]=0;
  94   1      ab[10]=Para[7];
  95   1      ab[11]=0;
  96   1      //nc 
  97   1      ab[12]=Para[15];
  98   1      ab[13]=0;
  99   1      //modbus address
 100   1      ab[14]=Para[13];
 101   1      ab[15]=0;
 102   1      //Ip
 103   1      ab[16]=Para[215];
 104   1      ab[17]=0;
 105   1      ab[18]=Para[217];
 106   1      ab[19]=0;
 107   1      ab[20]=Para[219];
 108   1      ab[21]=0;
 109   1      ab[22]=Para[221];
 110   1      ab[23]=0;
 111   1      //port
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 3   

 112   1      //ab[24]=(U8_T)(UdpPort);
 113   1      //ab[25]=(U8_T)(UdpPort>>8);
 114   1      ab[24]=Para[241];
 115   1      ab[25]=Para[240];
 116   1      
 117   1      ab[26]=Para[9];
 118   1      ab[27]=0;
 119   1      
 120   1      ab[28]=Para[11];
 121   1      ab[29]=0;
 122   1      
 123   1      ab[30]=Para[17];
 124   1      ab[31]=0;
 125   1      
 126   1      }
 127          
 128          #if 1  //LHN ADD for time server
 129          
 130          #define Bace_s           3439756800   //from 2009.1.1 
 131          #define Bace_Week        3            //2009.1.1 Tuesday
 132          #define Bace_year        2009  
 133          #define Bace_Time_Zone   43200        //Zone -12        
 134          #define Day_s            86400
 135          #define Hour_s           3600
 136          #define Min_s            60
 137          #define year_Day         365
 138          
 139          
 140          void TimeServer_Deal(U32_T time,U8_T time_zone)
 141          {
 142   1              U32_T time_s=0;
 143   1              U32_T time_year=0;
 144   1              U32_T time_day=0;
 145   1              U32_T time_h=0;
 146   1      
 147   1              time_s = time - Bace_s + ((U32_T)time_zone) * Hour_s - Bace_Time_Zone;
 148   1      
 149   1              if(time_s)
 150   1              {
 151   2                      time_day = time_s / Day_s ;
 152   2                      time_h = time_s % Day_s;
 153   2      
 154   2                      Time.UN.Setime[3] = (U8_T)(time_day % 7 + Bace_Week) % 7 + 1;  //Week
 155   2      
 156   2                      if( (time_day % year_Day)  >= ((time_day / year_Day ) / 4) )
 157   2                      {
 158   3                              time_year = time_day / year_Day + Bace_year;   
 159   3                              time_day = time_day % year_Day - (time_day / year_Day)/4;
 160   3                      }
 161   2                      else
 162   2                      {
 163   3                              time_year = time_day / year_Day + Bace_year - 1;
 164   3                          if((time_day / year_Day ) / 4)
 165   3                                      time_day = 366 + time_day % year_Day - (time_day / year_Day)/4; 
 166   3                              else
 167   3                                      time_day = 365 + time_day % year_Day - (time_day / year_Day)/4; 
 168   3                      }
 169   2      
 170   2                      Time.UN.Setime[0] = (U8_T)(time_year / 100);           //year high
 171   2                      Time.UN.Setime[1] = (U8_T)(time_year % 100);           //year low
 172   2      
 173   2                      if(!(time_year % 4))  //leap year
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 4   

 174   2                      {
 175   3                              if( (time_day >= 0) && (time_day <= 30) ) // january
 176   3                              {
 177   4                                      Time.UN.Setime[2] = 1;               //month                     
 178   4                                      Time.UN.Setime[4] = time_day + 1;    //day
 179   4                              }
 180   3                              else if( (time_day >= 31) && (time_day <= 59) ) // february
 181   3                              {
 182   4                                      Time.UN.Setime[2] = 2;
 183   4                                      Time.UN.Setime[4] = time_day - 31 + 1;  
 184   4                              }
 185   3                              else if( (time_day >= 60) && (time_day <= 90) ) //3
 186   3                              {
 187   4                                      Time.UN.Setime[2] = 3;
 188   4                                      Time.UN.Setime[4] = time_day - 60 + 1;  
 189   4                              }
 190   3                              else if( (time_day >= 91) && (time_day <= 120) )//4
 191   3                              {
 192   4                                      Time.UN.Setime[2] = 4;
 193   4                                      Time.UN.Setime[4] = time_day - 91 + 1;  
 194   4                              }
 195   3                              else if( (time_day >= 121) && (time_day <= 151) ) //5
 196   3                              {
 197   4                                      Time.UN.Setime[2] = 5;
 198   4                                      Time.UN.Setime[4] = time_day - 121 + 1; 
 199   4                              }
 200   3                              else if( (time_day >= 152) && (time_day <= 181) ) //6
 201   3                              {
 202   4                                      Time.UN.Setime[2] = 6;
 203   4                                      Time.UN.Setime[4] = time_day - 152 + 1; 
 204   4                              }
 205   3                              else if( (time_day >= 182) && (time_day <= 212) ) //7
 206   3                              {
 207   4                                      Time.UN.Setime[2] = 7;
 208   4                                      Time.UN.Setime[4] = time_day - 182 + 1; 
 209   4                              }
 210   3                              else if( (time_day >= 213) && (time_day <= 243) ) //8
 211   3                              {
 212   4                                      Time.UN.Setime[2] = 8;
 213   4                                      Time.UN.Setime[4] = time_day - 213 + 1; 
 214   4                              }
 215   3                              else if( (time_day >= 244) && (time_day <= 273) ) //9
 216   3                              {
 217   4                                      Time.UN.Setime[2] = 9;
 218   4                                      Time.UN.Setime[4] = time_day - 243 + 1; 
 219   4                              }
 220   3                              else if( (time_day >= 274) && (time_day <= 304) ) //10
 221   3                              {
 222   4                                      Time.UN.Setime[2] = 10;
 223   4                                      Time.UN.Setime[4] = time_day - 274 + 1; 
 224   4                              }
 225   3                              else if( (time_day >= 305) && (time_day <= 334) ) //11
 226   3                              {
 227   4                                      Time.UN.Setime[2] = 11;
 228   4                                      Time.UN.Setime[4] = time_day - 304 + 1; 
 229   4                              }
 230   3                              else if( (time_day >= 335) && (time_day <= 365) ) //12
 231   3                              {
 232   4                                      Time.UN.Setime[2] = 12;
 233   4                                      Time.UN.Setime[4] = time_day - 335 + 1; 
 234   4                              }
 235   3      
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 5   

 236   3                      }
 237   2                      else
 238   2                      {
 239   3                              if( (time_day >= 0) && (time_day <= 30) ) // january
 240   3                              {
 241   4                                      Time.UN.Setime[2] = 1;
 242   4                                      Time.UN.Setime[4] = time_day - 0 + 1;
 243   4                              }
 244   3                              else if( (time_day >= 31) && (time_day <= 58) ) // february
 245   3                              {
 246   4                                      Time.UN.Setime[2] = 2;
 247   4                                      Time.UN.Setime[4] = time_day - 31 + 1;  
 248   4                              }
 249   3                              else if( (time_day >= 59) && (time_day <= 89) ) //3
 250   3                              {
 251   4                                      Time.UN.Setime[2] = 3;
 252   4                                      Time.UN.Setime[4] = time_day - 59 + 1;  
 253   4                              }
 254   3                              else if( (time_day >= 90) && (time_day <= 119) )//4
 255   3                              {
 256   4                                      Time.UN.Setime[2] = 4;
 257   4                                      Time.UN.Setime[4] = time_day - 90 + 1;  
 258   4                              }
 259   3                              else if( (time_day >= 120) && (time_day <= 150) ) //5
 260   3                              {
 261   4                                      Time.UN.Setime[2] = 5;
 262   4                                      Time.UN.Setime[4] = time_day - 120 + 1; 
 263   4                              }
 264   3                              else if( (time_day >= 151) && (time_day <= 180) ) //6
 265   3                              {
 266   4                                      Time.UN.Setime[2] = 6;
 267   4                                      Time.UN.Setime[4] = time_day - 151 + 1; 
 268   4                              }
 269   3                              else if( (time_day >= 181) && (time_day <= 211) ) //7
 270   3                              {
 271   4                                      Time.UN.Setime[2] = 7;
 272   4                                      Time.UN.Setime[4] = time_day - 181 + 1; 
 273   4                              }
 274   3                              else if( (time_day >= 212) && (time_day <= 242) ) //8
 275   3                              {
 276   4                                      Time.UN.Setime[2] = 8;
 277   4                                      Time.UN.Setime[4] = time_day - 212 + 1; 
 278   4                              }
 279   3                              else if( (time_day >= 243) && (time_day <= 272) ) //9
 280   3                              {
 281   4                                      Time.UN.Setime[2] = 9;
 282   4                                      Time.UN.Setime[4] = time_day - 242 + 1; 
 283   4                              }
 284   3                              else if( (time_day >= 273) && (time_day <= 303) ) //10
 285   3                              {
 286   4                                      Time.UN.Setime[2] = 10;
 287   4                                      Time.UN.Setime[4] = time_day - 273 + 1; 
 288   4                              }
 289   3                              else if( (time_day >= 304) && (time_day <= 333) ) //11
 290   3                              {
 291   4                                      Time.UN.Setime[2] = 11;
 292   4                                      Time.UN.Setime[4] = time_day - 303 + 1; 
 293   4                              }
 294   3                              else if( (time_day >= 334) && (time_day <= 364) ) //12
 295   3                              {
 296   4                                      Time.UN.Setime[2] = 12;
 297   4                                      Time.UN.Setime[4] = time_day - 334 + 1; 
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 6   

 298   4                              }
 299   3              
 300   3                      }
 301   2                      Time.UN.Setime[5] = (U8_T)(time_h / Hour_s);  //Hour
 302   2                      time_h = time_h % Hour_s;
 303   2                      Time.UN.Setime[6] = (U8_T)(time_h / Min_s);  //minute
 304   2                      Time.UN.Setime[7] = (U8_T)(time_h % Min_s); //second            
 305   2                      
 306   2                      Initial_Clock();
 307   2              //      Uart0_Tx(Time.UN.Setime,8);
 308   2              }
 309   1      }
 310          
 311          #endif
 312          
 313          
 314          
 315          #if 1
 316          /*
 317           * ----------------------------------------------------------------------------
 318           * Function Name: I2C_Init
 319           * Purpose:
 320           * Params:
 321           * Returns:
 322           * Note:
 323           * ----------------------------------------------------------------------------
 324           */
 325          void I2C_Init(void)
 326          {
 327   1              switch (CSREPR & (BIT6|BIT7))
 328   1              {
 329   2                      case SYS_CLK_100M :
 330   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 100M */
 331   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0031, 0x005A);
 332   2                              break;
 333   2                      case SYS_CLK_50M :
 334   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 50M */
 335   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x0018, 0x005A);
 336   2                              break;
 337   2                      case SYS_CLK_25M :
 338   2                              /* I2C master mode, interrupt enable, fast mode in slave, 7-bits address, 400KHz at 25M */
 339   2                              I2C_Setup(I2C_ENB|I2C_FAST|I2C_MST_IE|I2C_7BIT|I2C_MASTER_MODE, 0x000c, 0x005A);
 340   2                              break;
 341   2              }
 342   1      }
 343          #endif
 344          
 345          /*
 346           * ----------------------------------------------------------------------------
 347           * Function Name: GUDPBC_Task
 348           * Purpose: 
 349           * Params:
 350           * Returns:
 351           * Note:
 352           * ----------------------------------------------------------------------------
 353           */
 354          void GUDPBC_Task(void)
 355          {
 356   1      
 357   1      } /* End of GUDPBC_Task() */
 358          
 359          /*
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 7   

 360           * ----------------------------------------------------------------------------
 361           * Function Name: GUDPBC_Init()
 362           * Purpose: Initialization
 363           * Params:
 364           * Returns:
 365           * Note:
 366           * ----------------------------------------------------------------------------
 367           */
 368          void GUDPBC_Init(U16_T localPort)
 369          {
 370   1              U8_T    i;
 371   1      
 372   1              printd("GUDPBC_Init()...\n\r");
 373   1      //      printd("NC fw69.11hw26bl14\n\r");
 374   1      //      char abc[] = {"NC fw69.11hw26bl14"};
 375   1      
 376   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 377   1                      gudpbc_Conns[i].State = GUDPBC_STATE_FREE;
 378   1      
 379   1              gudpbc_InterAppId = TCPIP_Bind(GUDPBC_NewConn, GUDPBC_Event, GUDPBC_Receive);
 380   1                      
 381   1              /* unicast packet */
 382   1      //      TCPIP_UdpListen(123, gudpbc_InterAppId);
 383   1              TCPIP_UdpListen(localPort, gudpbc_InterAppId);
 384   1              
 385   1      } /* End of GUDPBC_Init() */
 386          
 387          /*
 388           * ----------------------------------------------------------------------------
 389           * Function Name: GUDPBC_NewConn
 390           * Purpose: 
 391           * Params:
 392           * Returns:
 393           * Note:
 394           * ----------------------------------------------------------------------------
 395           */
 396          U8_T GUDPBC_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 397          {
 398   1              U8_T    i;
 399   1      
 400   1              pip = pip;
 401   1              remotePort = remotePort;
 402   1      
 403   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("GUDPBC_NewConn(remotePort=%d, socket=%d)\n\r",remotePort,socket);
              #endif  
 406   1      
 407   1              for (i = 0; i < GUDPBC_MAX_CONNS; i++)
 408   1              {
 409   2                      if (gudpbc_Conns[i].State == GUDPBC_STATE_FREE)
 410   2                      {
 411   3                              gudpbc_Conns[i].State = GUDPBC_STATE_CONNECTED;
 412   3      //                      gudpbc_Conns[i].Timer = (U16_T)SWTIMER_Tick();
 413   3      //                      gudpbc_Conns[i].Ip = *pip;
 414   3      //                      gudpbc_Conns[i].Port = remotePort;
 415   3                              gudpbc_Conns[i].UdpSocket = socket;
 416   3                              return i;
 417   3                      }
 418   2              }
 419   1              
 420   1              return GUDPBC_NO_NEW_CONN;
 421   1      
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 8   

 422   1      } /* End of GUDPBC_NewConn() */
 423          
 424          /*
 425           * ----------------------------------------------------------------------------
 426           * Function Name: GUDPBC_Event
 427           * Purpose: 
 428           * Params:
 429           * Returns:
 430           * Note:
 431           * ----------------------------------------------------------------------------
 432           */
 433          void GUDPBC_Event(U8_T id, U8_T event)
 434          {
 435   1              gudpbc_Conns[id].State = event;
 436   1      
 437   1      } /* End of GUDPBC_Event() */
 438          
 439          
 440          
 441          U8_T udp_receive_reboot(void)
 442          {
 443   1              U8_T   socket,id;
 444   1              U8_T    *pData;
 445   1       //evan move the bootloader jump interface from gudpc.c to http.c 
 446   1       // which webpage function have take charge that .c file.
 447   1      
 448   1                  if((pData[0] == 0xee) && (pData[1] == 0x10))
 449   1                  {   
 450   2                              gudpbc_HandleSearchReq(pData, id); 
 451   2                      IntFlashErase(ERA_RUN, 0x60000);
 452   2                      FlagIsp = 1;
 453   2                              USB_disable();
 454   2                              lcdreset();
 455   2                              Lcd_Initial();
 456   2                              Display_Updating();
 457   2                      AX11000_SoftReboot();   
 458   2                      }
 459   1      
 460   1         return       socket;
 461   1      
 462   1      }
 463          
 464          
 465          
 466          /*
 467           * ----------------------------------------------------------------------------
 468           * Function Name: GUDPBC_Receive
 469           * Purpose: 
 470           * Params:
 471           * Returns:
 472           * Note:
 473           * ----------------------------------------------------------------------------
 474           */
 475          void GUDPBC_Receive(U8_T XDATA* pData, U16_T length, U8_T id)
 476          {
 477   1          U8_T  n=0;
 478   1              U32_T time_s=0;
 479   1       
 480   1              if( (length == 48) )  //(gudpbc_Conns[id].UdpSocket == Time_Server.UdpSocket) && 
 481   1              {
 482   2                      Para[399] = 1;
 483   2                      time_s = ( ((U32_T)pData[40]) << 24 ) | ( ((U32_T)pData[41]) << 16 ) | ( ((U32_T)pData[42]) << 8 ) |  ((
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 9   

             -U32_T)pData[43]) ;
 484   2                      TimeServer_Deal(time_s,Para[23]);
 485   2                      TCPIP_UdpClose(Time_Server.UdpSocket);
 486   2              }
 487   1              else
 488   1              {
 489   2                  if((pData[0] == 100)&&(pData[1] == 0))
 490   2                  { 
 491   3                              scanstart = 1;
 492   3                      state = 1;
 493   3                  }
 494   2                  if(scanstart)
 495   2                      {  
 496   3                              for(n = 0; n < (U8_T)length/4; n++)
 497   3                      { 
 498   4                              if( (pData[4*n+1] == Para[215])&&(pData[4*n+2] == Para[217])&&(pData[4*n+3] == Para[219])&&(pDat
             -a[4*n+4] == Para[221]))
 499   4                          { 
 500   5                                              scanstart=0;
 501   5                              state=0;
 502   5                              break;
 503   5                          }
 504   4                      }
 505   3      
 506   3                      if(state)
 507   3                              {
 508   4                                      U8_T socket = TCPIP_UdpNew(2, 3, 0xffffffff, 0, 4321);
 509   4                                      UdpData();
 510   4                                      TCPIP_UdpSend(socket, 0, 0, ab, 40);
 511   4                                      TCPIP_UdpClose(socket);
 512   4                              }                   
 513   3                  }
 514   2                                           
 515   2                  if((pData[0] == 0xee) && (pData[1] == 0x10))
 516   2                  {   
 517   3                              gudpbc_HandleSearchReq(pData, id); 
 518   3                      IntFlashErase(ERA_RUN, 0x60000);
 519   3                      FlagIsp = 1;
 520   3                              USB_disable();
 521   3                              lcdreset();
 522   3                              Lcd_Initial();
 523   3                              Display_Updating();
 524   3                      AX11000_SoftReboot();   
 525   3                  }
 526   2              }
 527   1      } /* End of GUDPBC_Receive() */
 528          
 529          /*
 530           * ----------------------------------------------------------------------------
 531           * Function Name: gudpbc_HandleSearchReq
 532           * Purpose: 
 533           * Params:
 534           * Returns:
 535           * Note:
 536           * ----------------------------------------------------------------------------
 537           */
 538          void gudpbc_HandleSearchReq(U8_T XDATA* pData, U8_T id)
 539          {
 540   1              pData = pData;
 541   1              UdpData();
 542   1              TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, ab, 40);
 543   1      }/* End of gudpbc_HandleSearchReq() */
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 10  

 544          
 545          /*
 546           * ----------------------------------------------------------------------------
 547           * Function Name: gudpbc_HandleSetReq
 548           * Purpose: 
 549           * Params:
 550           * Returns:
 551           * Note:
 552           * ----------------------------------------------------------------------------
 553           */
 554          void gudpbc_HandleSetReq(U8_T XDATA* pData, U16_T length, U8_T id)
 555          {
 556   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleSetReq()...\n\r");
              #endif
 559   1      
 560   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 563   1              if (1)
 564   1      #endif
 565   1              {
 566   2                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
 567   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_ACK;
 568   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 569   2              }
 570   1              else
 571   1              {
 572   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_SET_DENY;     
 573   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);         
 574   2              }
 575   1      } /* End of gudpbc_HandleSetReq() */
 576          
 577          
 578          
 579          /*
 580           * ----------------------------------------------------------------------------
 581           * Function Name: GCONFIG_SetFirmwareUpgradeMode
 582           * Purpose: 
 583           * Params: mode = 1: enable firmware ipgrade after reboot ,  mode = 0: disable
 584           * Returns:
 585           * Note:
 586           * ----------------------------------------------------------------------------
 587           */
 588          //void GCONFIG_SetFirmwareUpgradeMode(U8_T mode)
 589          //{
 590          //      gconfig_ConfigData.FirmwareUpgradeMode = mode;
 591          //} /* End of GCONFIG_SetFirmwareUpgradeMode() */
 592          
 593          
 594          /*
 595           * ----------------------------------------------------------------------------
 596           * Function Name: gudpbc_HandleUpgradeReq
 597           * Purpose: 
 598           * Params:
 599           * Returns:
 600           * Note:
 601           * ----------------------------------------------------------------------------
 602           */
 603          void gudpbc_HandleUpgradeReq(U8_T XDATA* pData, U16_T length, U8_T id)
 604          {       
 605   1      #if GUDPBC_ENABLE_DEBUG_MSG
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 11  

                      printd("gudpbc_HandleUpgradeReq()...\n\r");
              #endif
 608   1      
 609   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 612   1              if (1)
 613   1      #endif
 614   1              {
 615   2      //              GCONFIG_SetFirmwareUpgradeMode(GCONFIG_FW_UPGRADE_ENABLE);
 616   2                      GCONFIG_WriteConfigData();
 617   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_ACK;
 618   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 619   2              //      FirmwareUpdate();
 620   2              }
 621   1              else
 622   1              {
 623   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_UPGRADE_DENY;         
 624   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 625   2              }
 626   1      } /* End of gudpbc_HandleUpgradeReq() */
 627          
 628          
 629          
 630          /*
 631           * ----------------------------------------------------------------------------
 632           * Function Name: gudpbc_HandleResetReq
 633           * Purpose: 
 634           * Params:
 635           * Returns:
 636           * Note:
 637           * ----------------------------------------------------------------------------
 638           */
 639          void gudpbc_HandleResetReq(U8_T XDATA* pData, U16_T length, U8_T id)
 640          {
 641   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleResetReq()...\n\r");
              #endif
 644   1      
 645   1      #if GS2E_ENABLE_STATE_MACHINE   
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 648   1              if (1)
 649   1      #endif
 650   1              {
 651   2                      GCONFIG_ReadDefaultConfigData();
 652   2                      GCONFIG_WriteConfigData();
 653   2                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
 654   2                      gudpbc_ConfigRxPkt.Opcode = GCONFIG_OPCODE_RESET_ACK;
 655   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, (U8_T*) &gudpbc_ConfigRxPkt, GCONFIG_CFG_PKT_LEN);
 656   2              }
 657   1              else
 658   1              {
 659   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 660   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 661   2              }
 662   1      } /* End of gudpbc_HandleResetReq() */
 663          
 664          /*
 665           * ----------------------------------------------------------------------------
 666           * Function Name: gudpbc_HandleRebootReq
 667           * Purpose: 
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 12  

 668           * Params:
 669           * Returns:
 670           * Note:
 671           * ----------------------------------------------------------------------------
 672           */
 673          void gudpbc_HandleRebootReq(U8_T XDATA* pData, U16_T length, U8_T id)
 674          {
 675   1      #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleRebootReq()...\n\r");
              #endif
 678   1      
 679   1      #if GS2E_ENABLE_STATE_MACHINE
                      if (GS2E_GetTaskState() == GS2E_STATE_IDLE)
              #else
 682   1              if (1)
 683   1      #endif
 684   1              {
 685   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_REBOOT_ACK;   
 686   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 687   2                      // May store current status/setting here before restart
 688   2                      lcdreset();
 689   2                      Lcd_Initial();
 690   2                      Display_Updating();
 691   2                      AX11000_SoftReboot();
 692   2              }
 693   1              else
 694   1              {
 695   2                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_RESET_DENY;   
 696   2                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
 697   2              }
 698   1      } /* End of gudpbc_HandleRebootReq() */
 699          
 700          #if GUDPBC_EEPROM_CONFIG
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromReadReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
              void gudpbc_HandleEepromReadReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromReadReq()...\n\r");
              #endif
              
                      GCONFIG_GetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_READ_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
              }
              
              /*
               * ----------------------------------------------------------------------------
               * Function Name: gudpbc_HandleEepromWriteReq
               * Purpose: 
               * Params:
               * Returns:
               * Note:
               * ----------------------------------------------------------------------------
               */
C51 COMPILER V9.06   GUDPBC                                                                05/28/2013 10:15:30 PAGE 13  

              void gudpbc_HandleEepromWriteReq(U8_T XDATA* pData, U16_T length, U8_T id)
              {
              #if GUDPBC_ENABLE_DEBUG_MSG
                      printd("gudpbc_HandleEepromWriteReq()...\n\r");
              #endif
              
                      GCONFIG_SetEpromData(&gudpbc_ConfigRxPkt);
                      GCONFIG_SetConfigPacket(&gudpbc_ConfigRxPkt);
                      *(pData + GCONFIG_OPCODE_OFFSET) = GCONFIG_OPCODE_EEPROM_WRITE_ACK;
                      TCPIP_UdpSend(gudpbc_Conns[id].UdpSocket, 0, 0, pData, length);
              }
              #endif
 742          /* End of gudpbc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4567    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =    930      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
