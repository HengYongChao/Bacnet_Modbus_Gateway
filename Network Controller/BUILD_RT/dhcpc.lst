C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE DHCPC
OBJECT MODULE PLACED IN .\dhcpc.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\dhcp\dhcpc.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) IN
                    -CDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\
                    -SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buf
                    -fer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\S
                    -rc\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\s
                    -rc\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\dhcpc.lst) OB
                    -JECT(.\dhcpc.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005   ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : dhcpc.c
  13           * Purpose     : DHCP client module implement client function over uIP stack.
  14           *               module.
  15           * Author      : Robin Lee
  16           * Date        : 2006-04-13
  17           * Notes       :
  18           * $Log: dhcpc.c,v $
  19           * Revision 1.3  2006/08/31 07:30:05  borbin
  20           * fixed software bug for parsing received DHCP frame information.
  21           *
  22           * Revision 1.2  2006/08/31 07:30:05  borbin
  23           * no message
  24           *
  25           * Revision 1.1.1.1  2006/06/20 05:50:27  borbin
  26           * no message
  27           *
  28           *================================================================================
  29           */
  30          
  31          /* INCLUDE FILE DECLARATIONS */
  32          #include "adapter.h"
  33          #include "tcpip.h"
  34          #include "stoe.h"
  35          #include "mac.h"
  36          #include "mstimer.h"
  37          #include "dhcpc.h"
  38          #include <string.h>
  39          #include "uart.h"
  40          #if (UART0_ENABLE)
  41            #include <stdio.h>
  42          #endif
  43          
  44          /* NAMING CONSTANT DECLARATIONS */
  45          #define DHCPC_MESSAGE_NOT_FOR_ME        0
  46          #define DHCPC_MESSAGE_FAIL                      1
  47          #define DHCPC_MESSAGE_SUCCESS           2
  48          
  49          
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 2   

  50          /* STATIC VARIABLE DECLARATIONS */
  51          static DHCP_INFO        dhcpInfo;
  52          static U8_T                     dhcpConnID = 0;
  53          static DHCP_HEADER      dhcpBuffer;
  54          static U16_T            dhcp_Time = 0;
  55          static U8_T                     dhcp_Retry = 0;
  56          static U32_T            dhcpXid = 0;
  57          static U8_T                     dhcpMacAddr[6] = {0};
  58          
  59          /* LOCAL SUBPROGRAM DECLARATIONS */
  60          void dhcp_Discover(void);
  61          void dhcp_Request(void);
  62          void dhcp_OptMagicCookie(void);
  63          void dhcp_OptionsAppend(U8_T optCode, U8_T optLen, U8_T *optContent);
  64          U8_T dhcp_ReceiveMessage(void);
  65          void dhcp_OptionCheck(void);
  66          
  67          /*
  68           *--------------------------------------------------------------------------------
  69           * void Function(void)
  70           * Purpose :
  71           * Params  :
  72           * Returns :
  73           * Note    :
  74           *--------------------------------------------------------------------------------
  75           */
  76          BOOL DHCP_Init(void)
  77          {
  78   1              dhcpInfo.AppId = TCPIP_Bind(NULL, DHCP_EventHandle, DHCP_ReceiveHandle); // assigned by TCP stack
  79   1              dhcpInfo.State = DHCP_IDLE_STATE;
  80   1      
  81   1              return TRUE;
  82   1      
  83   1      } /* End of DHCP_Init() */
  84          
  85          /*
  86           *--------------------------------------------------------------------------------
  87           * void Function(void)
  88           * Purpose :
  89           * Params  :
  90           * Returns :
  91           * Note    :
  92           *--------------------------------------------------------------------------------
  93           */
  94          void DHCP_Start(void)
  95          {
  96   1              U16_T   i;
  97   1              U8_T    *point;
  98   1      
  99   1              if (dhcpInfo.State > DHCP_IDLE_STATE)
 100   1                      return;
 101   1      
 102   1              /* set uip host ip address */
 103   1              TCPIP_SetIPAddr(0);
 104   1      
 105   1              /* set stoe host ip address */
 106   1              STOE_SetIPAddr(0);
 107   1      
 108   1              dhcpInfo.pOpt = (U8_T *)(dhcpBuffer.Options);
 109   1              dhcpInfo.OptionsCounter = 0;
 110   1              dhcpInfo.Secs = 0;
 111   1              dhcpInfo.TimeoutInterval = DHCP_REQUEST_TIMEOUT;
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 3   

 112   1              for (i=0 ; i<4 ; i++)
 113   1              {
 114   2                      dhcpInfo.ServerId[i] = 0;
 115   2                      dhcpInfo.ClientOfferedIp[i] = 0;
 116   2              }
 117   1              dhcpInfo.IpAddr = 0;
 118   1              dhcpInfo.NetMask = 0;
 119   1              dhcpInfo.DnsAddr = 0;
 120   1              dhcpInfo.DefaultRouter = 0;
 121   1      
 122   1              dhcpInfo.State = DHCP_INITIAL_STATE;
 123   1              dhcp_Retry = 0;
 124   1      
 125   1              point = MAC_GetMacAddr();
 126   1              for (i=0 ; i<MAC_ADDRESS_LEN ; i++)
 127   1                      dhcpMacAddr[i] = point[i];
 128   1              /* Transaction ID assign again with the lowest two bytes of each MAC address */
 129   1              dhcpXid = DHCP_CLIENT_XID | ((U32_T)dhcpMacAddr[4] << 8) | ((U32_T)dhcpMacAddr[5]);
 130   1              
 131   1      } /* End of DHCP_Start() */
 132          
 133          /*
 134           *--------------------------------------------------------------------------------
 135           * void Function(void)
 136           * Purpose :
 137           * Params  :
 138           * Returns :
 139           * Note    :
 140           *--------------------------------------------------------------------------------
 141           */
 142          void DHCP_Send(void)
 143          {
 144   1              if (dhcpInfo.State & DHCP_INITIAL_STATE)
 145   1              {
 146   2                      dhcp_Discover();
 147   2                      dhcp_Time = (U16_T)SWTIMER_Tick();
 148   2              }
 149   1              else if (dhcpInfo.State & DHCP_RCV_OFFER_STATE)
 150   1              {
 151   2                      dhcp_Request();
 152   2                      dhcp_Time = (U16_T)SWTIMER_Tick();
 153   2              }
 154   1      
 155   1      } /* End of DHCP_Send() */
 156          
 157          /*
 158           * ----------------------------------------------------------------------------
 159           * void DHCP_EventHandle(U8_T connId, U8_T event)
 160           * Purpose: 
 161           * Params:
 162           * Returns:
 163           * Note:
 164           * ----------------------------------------------------------------------------
 165           */
 166          void DHCP_EventHandle(U8_T connId, U8_T event)
 167          {
 168   1              if (connId != 0)
 169   1                      return;
 170   1      
 171   1              if (event == TCPIP_CONNECT_CANCEL)
 172   1              {
 173   2                      dhcpInfo.State = DHCP_IDLE_STATE;
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 4   

 174   2                      TCPIP_UdpClose(dhcpInfo.SocketId);
 175   2              }
 176   1      }
 177          
 178          /*
 179           * ----------------------------------------------------------------------------
 180           * void DHCP_ReceiveHandle(U8_T XDATA* pData, U16_T length, U8_T connId)
 181           * Purpose: 
 182           * Params:
 183           * Returns:
 184           * Note:
 185           * ----------------------------------------------------------------------------
 186           */
 187          void DHCP_ReceiveHandle(U8_T XDATA *pData, U16_T length, U8_T connId)
 188          {
 189   1              U8_T    tmp;
 190   1      
 191   1              if (connId != 0)
 192   1                      return;
 193   1      
 194   1              length = length;
 195   1              if (dhcpInfo.State & DHCP_DISCOVER_STATE)
 196   1              {
 197   2                      dhcpInfo.dhcpPktPtr = (DHCP_HEADER *)pData;
 198   2      
 199   2                      tmp = dhcp_ReceiveMessage();
 200   2                      if (tmp == DHCPC_MESSAGE_SUCCESS)
 201   2                      {
 202   3                              dhcpInfo.State = DHCP_RCV_OFFER_STATE;
 203   3                              return;
 204   3                      }
 205   2                      else if (tmp == DHCPC_MESSAGE_NOT_FOR_ME)
 206   2                              return;
 207   2                      else
 208   2                              dhcpInfo.State = DHCP_INITIAL_STATE;
 209   2              }
 210   1              else if (dhcpInfo.State & DHCP_REQUEST_STATE)
 211   1              {
 212   2                      dhcpInfo.dhcpPktPtr = (DHCP_HEADER *)pData;
 213   2      
 214   2                      tmp = dhcp_ReceiveMessage();
 215   2                      if (tmp == DHCPC_MESSAGE_SUCCESS)
 216   2                              dhcpInfo.State = DHCP_IDLE_STATE;
 217   2                      else if (tmp == DHCPC_MESSAGE_NOT_FOR_ME)
 218   2                              return;
 219   2                      else
 220   2                              dhcpInfo.State = DHCP_INITIAL_STATE;
 221   2              }
 222   1              else
 223   1                      return;
 224   1      
 225   1              TCPIP_UdpClose(dhcpInfo.SocketId);
 226   1      
 227   1      } /* End of DHCP_ReceiveHandle() */
 228          
 229          /*
 230           *--------------------------------------------------------------------------------
 231           * void Function(void)
 232           * Purpose :
 233           * Params  :
 234           * Returns :
 235           * Note    :
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 5   

 236           *--------------------------------------------------------------------------------
 237           */
 238          S8_T DHCP_GetState(void)
 239          {
 240   1              if (dhcpInfo.State & (DHCP_DISCOVER_STATE | DHCP_REQUEST_STATE))
 241   1              {
 242   2                      U16_T   curTime = (U16_T)SWTIMER_Tick();
 243   2      
 244   2                      if ((curTime - dhcp_Time) >= DHCP_REQUEST_TIMEOUT) /* had timeout */
 245   2                      {
 246   3                              TCPIP_UdpClose(dhcpInfo.SocketId);
 247   3                              if (++dhcp_Retry < DHCP_MAX_RETRY)
 248   3                                      dhcpInfo.State = DHCP_INITIAL_STATE;
 249   3                              else
 250   3                                      dhcpInfo.State = DHCP_IDLE_STATE;
 251   3                      }
 252   2              }
 253   1              return dhcpInfo.State;
 254   1      }
 255          
 256          /*
 257           *--------------------------------------------------------------------------------
 258           * void Function(void)
 259           * Purpose :
 260           * Params  :
 261           * Returns :
 262           * Note    :
 263           *--------------------------------------------------------------------------------
 264           */
 265          void dhcp_Discover(void)
 266          {
 267   1              DHCP_HEADER             *pDiscover;
 268   1              U16_T                   addr[2] = {0, 0};
 269   1              U8_T                    optItem[3] = {0, 0, 0};
 270   1              U16_T                   i;
 271   1      
 272   1              /* assigned by stack */
 273   1              dhcpInfo.SocketId = TCPIP_UdpNew(dhcpInfo.AppId, dhcpConnID, DHCP_CLIENT_BROADCAST, (U16_T)DHCP_CLIENT_PO
             -RT,
 274   1                                              (U16_T)DHCP_SERVER_PORT);
 275   1              if (dhcpInfo.SocketId == TCPIP_NO_NEW_CONN)
 276   1              {
 277   2                      return;
 278   2              }
 279   1      
 280   1              pDiscover = &dhcpBuffer;
 281   1      
 282   1              pDiscover->Op = DHCP_C_TO_S;
 283   1              pDiscover->Htype = DHCP_HTYPE_ETHERNET;
 284   1              pDiscover->Hlen = DHCP_HLEN_ETHERNET;
 285   1              pDiscover->Hops = 0;
 286   1              pDiscover->Xid = dhcpXid;
 287   1              pDiscover->Seconds = dhcpInfo.Secs;
 288   1              pDiscover->Flags = 0;
 289   1              pDiscover->CiAddr = 0;
 290   1              pDiscover->YiAddr = 0;
 291   1              pDiscover->SiAddr = 0;
 292   1              pDiscover->GiAddr = 0;
 293   1      
 294   1              for (i=0 ; i<DHCP_CHADDR_LEN ; i++)
 295   1              {
 296   2                      if (i < MAC_ADDRESS_LEN)
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 6   

 297   2                              pDiscover->ChAddr[i] = dhcpMacAddr[i];
 298   2                      else
 299   2                              pDiscover->ChAddr[i] = 0;
 300   2              }
 301   1              for (i=0 ; i<DHCP_SNAME_LEN ; i++)
 302   1              {
 303   2                      pDiscover->Sname[i] = 0;
 304   2              }
 305   1              for (i=0 ; i<DHCP_FILE_LEN ; i++)
 306   1              {
 307   2                      pDiscover->File[i] = 0;
 308   2              }
 309   1      
 310   1              dhcpInfo.OptionsCounter = 0;
 311   1      
 312   1              /* Add magic cookie bytes */
 313   1              dhcpInfo.pOpt = &(pDiscover->Options);
 314   1              dhcp_OptMagicCookie();
 315   1      
 316   1              /* Add DHCP_DISCOVER option */
 317   1              optItem[0] = DHCP_DISCOVER;
 318   1              dhcp_OptionsAppend(DHCP_OPTION_MSG_TYPE, 1, optItem);
 319   1      
 320   1              /* Add DHCP_OPTION_PAR_REQ_LIST option */
 321   1              optItem[0] = DHCP_OPTION_SUBNET_MASK;
 322   1              optItem[1] = DHCP_OPTION_ROUTER;
 323   1              optItem[2] = DHCP_OPTION_DNS_SERVER;
 324   1              dhcp_OptionsAppend(DHCP_OPTION_PAR_REQ_LIST, 3, optItem);
 325   1      
 326   1              /* Add DHCP_OPTION_END option */
 327   1              optItem[0] = 0;
 328   1              dhcp_OptionsAppend(DHCP_OPTION_END, 0, optItem);
 329   1              
 330   1              while (dhcpInfo.OptionsCounter < DHCP_MIN_OPTIONS_LEN)
 331   1              {
 332   2                      pDiscover->Options[dhcpInfo.OptionsCounter ++] = 0;
 333   2              }
 334   1      
 335   1              TCPIP_UdpSend((dhcpInfo.SocketId), NULL, 0, (U8_T *)pDiscover, (U16_T)(DHCP_FIXED_LEN + dhcpInfo.OptionsC
             -ounter));
 336   1      
 337   1              dhcpInfo.State = DHCP_DISCOVER_STATE;
 338   1      }
 339          
 340          /*
 341           *--------------------------------------------------------------------------------
 342           * void Function(void)
 343           * Purpose :
 344           * Params  :
 345           * Returns :
 346           * Note    :
 347           *--------------------------------------------------------------------------------
 348           */
 349          void dhcp_Request(void)
 350          {
 351   1              DHCP_HEADER             *pRequest;
 352   1              U16_T                   uip_addr[2] = {0, 0};
 353   1              U8_T                    optItem[3] = {0, 0, 0};
 354   1              U16_T                   i;
 355   1      
 356   1              pRequest = &dhcpBuffer;
 357   1      
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 7   

 358   1              pRequest->Op = DHCP_C_TO_S;
 359   1              pRequest->Htype = DHCP_HTYPE_ETHERNET;
 360   1              pRequest->Hlen = DHCP_HLEN_ETHERNET;
 361   1              pRequest->Hops = 0;
 362   1              pRequest->Xid = dhcpXid;
 363   1              pRequest->Seconds = 0;
 364   1              pRequest->Flags = 0;
 365   1              pRequest->CiAddr = dhcpInfo.IpAddr;
 366   1              pRequest->YiAddr = 0;
 367   1              pRequest->SiAddr = 0;
 368   1              pRequest->GiAddr = 0;
 369   1      
 370   1              for (i=0 ; i<DHCP_CHADDR_LEN ; i++)
 371   1              {
 372   2                      if (i < MAC_ADDRESS_LEN)
 373   2                              pRequest->ChAddr[i] = dhcpMacAddr[i];
 374   2                      else
 375   2                              pRequest->ChAddr[i] = 0;
 376   2              }
 377   1              for (i=0 ; i<DHCP_SNAME_LEN ; i++)
 378   1              {
 379   2                      pRequest->Sname[i] = 0;
 380   2              }
 381   1              for (i=0 ; i<DHCP_FILE_LEN ; i++)
 382   1              {
 383   2                      pRequest->File[i] = 0;
 384   2              }
 385   1      
 386   1              dhcpInfo.OptionsCounter = 0;
 387   1      
 388   1              /* Add magic cookie bytes */
 389   1              dhcpInfo.pOpt = &(pRequest->Options);
 390   1              dhcp_OptMagicCookie();
 391   1      
 392   1              /* Add DHCP_REQUEST option */
 393   1              optItem[0] = DHCP_REQUEST;
 394   1              dhcp_OptionsAppend(DHCP_OPTION_MSG_TYPE, 1, optItem);
 395   1      
 396   1              /* Add DHCP_OPTION_REQ_IPADDR option */
 397   1              dhcp_OptionsAppend(DHCP_OPTION_REQ_IPADDR, 4, &(dhcpInfo.ClientOfferedIp[0]));
 398   1      
 399   1              /* Add DHCP_OPTION_SERVER_ID option */
 400   1              dhcp_OptionsAppend(DHCP_OPTION_SERVER_ID, 4, &(dhcpInfo.ServerId[0]));
 401   1      
 402   1              /* Add DHCP_OPTION_PAR_REQ_LIST option */
 403   1              optItem[0] = DHCP_OPTION_SUBNET_MASK;
 404   1              optItem[1] = DHCP_OPTION_ROUTER;
 405   1              optItem[2] = DHCP_OPTION_DNS_SERVER;
 406   1              dhcp_OptionsAppend(DHCP_OPTION_PAR_REQ_LIST, 3, optItem);
 407   1      
 408   1              /* Add DHCP_OPTION_END option */
 409   1              optItem[0] = 0;
 410   1              dhcp_OptionsAppend(DHCP_OPTION_END, 0, optItem);
 411   1              while ((dhcpInfo.OptionsCounter < DHCP_MIN_OPTIONS_LEN))
 412   1              {
 413   2                      pRequest->Options[dhcpInfo.OptionsCounter ++] = 0;
 414   2              }
 415   1      
 416   1              TCPIP_UdpSend((dhcpInfo.SocketId), NULL, 0, (U8_T *)pRequest, (U16_T)(DHCP_FIXED_LEN + dhcpInfo.OptionsCo
             -unter));
 417   1      
 418   1              dhcpInfo.State = DHCP_REQUEST_STATE;
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 8   

 419   1      }
 420          
 421          /*
 422           *--------------------------------------------------------------------------------
 423           * void Function(void)
 424           * Purpose :
 425           * Params  :
 426           * Returns :
 427           * Note    :
 428           *--------------------------------------------------------------------------------
 429           */
 430          #if 0
              void DHCP_Release(void)
              {
                      DHCP_HEADER             *pRelease;
                      U16_T                   ipAddr[2] = {0, 0};
                      U8_T                    optItem[3] = {0, 0, 0};
                      U16_T                   i;
              
                      pRelease = (DHCP_HEADER *)uip_appdata;
              
                      pRelease->Op = DHCP_C_TO_S;
                      pRelease->Htype = DHCP_HTYPE_ETHERNET;
                      pRelease->Hlen = DHCP_HLEN_ETHERNET;
                      pRelease->Hops = 0;
                      pRelease->Xid = dhcpXid;
                      pRelease->Seconds = 0;
                      pRelease->Flags = 0;
                      pRelease->CiAddr = dhcpInfo.IpAddr;
                      pRelease->YiAddr = 0;
                      pRelease->SiAddr = 0;
                      pRelease->GiAddr = 0;
                      for (i=0 ; i<DHCP_CHADDR_LEN ; i++)
                      {
                              if (i < MAC_ADDRESS_LEN)
                                      pRelease->ChAddr[i] = dhcpMacAddr[i];
                              else
                                      pRelease->ChAddr[i] = 0;
                      }
                      for (i=0 ; i<DHCP_SNAME_LEN ; i++)
                      {
                              pRelease->Sname[i] = 0;
                      }
                      for (i=0 ; i<DHCP_FILE_LEN ; i++)
                      {
                              pRelease->File[i] = 0;
                      }
              
                      dhcpInfo.OptionsCounter = 0;
              
                      /* Add magic cookie bytes */
                      dhcpInfo.pOpt = &(pRelease->Options);
                      dhcp_OptMagicCookie();
              
                      /* Add DHCP_REQUEST option */
                      optItem[0] = DHCP_RELEASE;
                      dhcp_OptionsAppend(DHCP_OPTION_MSG_TYPE, 1, optItem);
              
                      /* Add DHCP_OPTION_END option */
                      optItem[0] = 0;
                      dhcp_OptionsAppend(DHCP_OPTION_END, 0, optItem);
                      while ((dhcpInfo.OptionsCounter < DHCP_OPTIONS_LEN))
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 9   

                      {
                              pRelease->Options[dhcpInfo.OptionsCounter ++] = 0;
                      }
              
                      DHCP_TimeSet(3);
                      DHCP_TimeStart();
              }
              #endif
 489          
 490          /*
 491           *--------------------------------------------------------------------------------
 492           * void Function(void)
 493           * Purpose :
 494           * Params  :
 495           * Returns :
 496           * Note    :
 497           *--------------------------------------------------------------------------------
 498           */
 499          #if 0
              void DHCP_Decline(void)
              {
                      DHCP_HEADER             *pDecline;
                      U16_T                   ipAddr[2] = {0, 0};
                      U8_T                    optItem[3] = {0, 0, 0};
                      U16_T                   i;
              
                      pDecline = (DHCP_HEADER *)uip_appdata;
              
                      pDecline->Op = DHCP_C_TO_S;
                      pDecline->Htype = DHCP_HTYPE_ETHERNET;
                      pDecline->Hlen = DHCP_HLEN_ETHERNET;
                      pDecline->Hops = 0;
                      pDecline->Xid = dhcpXid;
                      pDecline->Seconds = 0;
                      pDecline->Flags = 0;
                      pDecline->CiAddr = 0;
                      pDecline->YiAddr = 0;
                      pDecline->SiAddr = 0;
                      pDecline->GiAddr = 0;
                      for (i=0 ; i<MAC_ADDRESS_LEN ; i++)
                      {
                              if (i < MAC_ADDRESS_LEN)
                                      pDecline->ChAddr[i] = dhcpMacAddr[i];
                              else
                                      pDecline->ChAddr[i] = 0;
                      }
                      for (i=0 ; i<DHCP_SNAME_LEN ; i++)
                      {
                              pDecline->Sname[i] = 0;
                      }
                      for (i=0 ; i<DHCP_FILE_LEN ; i++)
                      {
                              pDecline->File[i] = 0;
                      }
              
                      dhcpInfo.OptionsCounter = 0;
              
                      /* Add magic cookie bytes */
                      dhcpInfo.pOpt = &(pDecline->Options);
                      dhcp_OptMagicCookie();
              
                      /* Add DHCP_REQUEST option */
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 10  

                      optItem[0] = DHCP_DECLINE;
                      dhcp_OptionsAppend(DHCP_OPTION_MSG_TYPE, 1, optItem);
              
                      /* Add DHCP_OPTION_END option */
                      optItem[0] = 0;
                      dhcp_OptionsAppend(DHCP_OPTION_END, 0, optItem);
                      while ((dhcpInfo.OptionsCounter < DHCP_OPTIONS_LEN))
                      {
                              pDecline->Options[dhcpInfo.OptionsCounter ++] = 0;
                      }
              
                      DHCP_TimeSet(3);
                      DHCP_TimeStart();
              }
              
              #endif
 559          
 560          /*
 561           *--------------------------------------------------------------------------------
 562           * void Function(void)
 563           * Purpose :
 564           * Params  :
 565           * Returns :
 566           * Note    :
 567           *--------------------------------------------------------------------------------
 568           */
 569          U8_T dhcp_ReceiveMessage(void)
 570          {
 571   1              DHCP_HEADER             *pDhcpMsg;
 572   1              U8_T                    dhcpMsgType = 0;
 573   1              U8_T                    i, rcvChAddr[6], chkMac = 1;
 574   1      
 575   1              pDhcpMsg = (DHCP_HEADER *)dhcpInfo.dhcpPktPtr;
 576   1      
 577   1              dhcpInfo.pOpt = &(pDhcpMsg->Options[0]);
 578   1              dhcpInfo.OptionsCounter = 0;
 579   1              for (i=0 ; i<MAC_ADDRESS_LEN ; i++)
 580   1                      rcvChAddr[i] = pDhcpMsg->ChAddr[i];
 581   1      
 582   1              if (pDhcpMsg->Op == DHCP_S_TO_C)
 583   1              {
 584   2                      /* check the received MAC address within ChAddr, except 00-00-00-00-00-00 & FF-FF-FF-FF-FF-FF */
 585   2                      if ((rcvChAddr[0]==0 && rcvChAddr[1]==0 && rcvChAddr[2]==0 && rcvChAddr[3]==0 && rcvChAddr[4]==0 && rcvC
             -hAddr[5]==0)
 586   2                      || (rcvChAddr[0]==0xFF && rcvChAddr[1]==0xFF && rcvChAddr[2]==0xFF && rcvChAddr[3]==0xFF && rcvChAddr[4]
             -==0xFF && rcvChAddr[5]==0xFF))
 587   2                      {
 588   3                              chkMac = 0;
 589   3                      }
 590   2      
 591   2                      if (pDhcpMsg->Xid == dhcpXid)
 592   2                      {
 593   3                              if (chkMac)
 594   3                              {
 595   4                                      for (i=0 ; i<MAC_ADDRESS_LEN ; i++)
 596   4                                      {
 597   5                                              if (rcvChAddr[i] != dhcpMacAddr[i])
 598   5                                                      return DHCPC_MESSAGE_NOT_FOR_ME;
 599   5                                      }
 600   4                              }
 601   3                              if ((*(dhcpInfo.pOpt + 0) == 0x63) && (*(dhcpInfo.pOpt + 1) == 0x82) &&
 602   3                              (*(dhcpInfo.pOpt + 2) == 0x53) && (*(dhcpInfo.pOpt + 3) == 0x63))
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 11  

 603   3                              {
 604   4                                      dhcpInfo.OptionsCounter += 4;
 605   4                                      dhcpInfo.pOpt += dhcpInfo.OptionsCounter;
 606   4                                      
 607   4                                      while(*dhcpInfo.pOpt != DHCP_OPTION_END)
 608   4                                      {
 609   5                                              if (*dhcpInfo.pOpt == DHCP_OPTION_MSG_TYPE)
 610   5                                              {
 611   6                                                      dhcpMsgType = *(dhcpInfo.pOpt + 2);
 612   6                                                      dhcpInfo.pOpt += 3;
 613   6                                                      if (dhcpMsgType == DHCP_ACK)
 614   6                                                      {
 615   7                                                              dhcpInfo.IpAddr = (pDhcpMsg->YiAddr);
 616   7                                                              /* Set local IP address */
 617   7                                                              /* set uip host ip address */
 618   7                                                              TCPIP_SetIPAddr(dhcpInfo.IpAddr);
 619   7      
 620   7                                                              /* set stoe host ip address */
 621   7                                                              STOE_SetIPAddr((dhcpInfo.IpAddr));
 622   7                                                      }
 623   6                                                      else if (dhcpMsgType == DHCP_OFFER)
 624   6                                                      {
 625   7                                                              if (pDhcpMsg->YiAddr)
 626   7                                                                      *(U32_T*)dhcpInfo.ClientOfferedIp = pDhcpMsg->YiAddr;
 627   7                                                      }
 628   6                                                      else if (dhcpMsgType == DHCP_NAK)
 629   6                                                      {
 630   7                                                              return DHCPC_MESSAGE_FAIL;
 631   7                                                      }
 632   6                                              }
 633   5                                              else
 634   5                                              {
 635   6                                                      dhcp_OptionCheck();
 636   6                                              }
 637   5                                      }
 638   4                                      return DHCPC_MESSAGE_SUCCESS;
 639   4                              }
 640   3                              else
 641   3                                      return DHCPC_MESSAGE_FAIL;
 642   3                      }
 643   2                      else
 644   2                              return DHCPC_MESSAGE_NOT_FOR_ME;
 645   2              }
 646   1              else
 647   1                      return DHCPC_MESSAGE_NOT_FOR_ME;
 648   1      }
 649          
 650          /*
 651           *--------------------------------------------------------------------------------
 652           * void Function(void)
 653           * Purpose :
 654           * Params  :
 655           * Returns :
 656           * Note    :
 657           *--------------------------------------------------------------------------------
 658           */
 659          void dhcp_OptionCheck(void)
 660          {
 661   1      //      U16_T   uip_addr[2];
 662   1              U8_T    len;
 663   1      
 664   1              switch(*(dhcpInfo.pOpt))
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 12  

 665   1              {
 666   2                      case DHCP_OPTION_SUBNET_MASK:
 667   2                              memcpy(&(dhcpInfo.NetMask), (dhcpInfo.pOpt + 2), 4);
 668   2                              len = *(dhcpInfo.pOpt + 1) + 2;
 669   2                              dhcpInfo.pOpt += len;
 670   2                      
 671   2                              /* Set SubNet Mask address */
 672   2                              /* set uip subnet mask address */
 673   2                              TCPIP_SetSubnetMask(dhcpInfo.NetMask);
 674   2      
 675   2                              /* set stoe subnet mask address */
 676   2                              STOE_SetSubnetMask((dhcpInfo.NetMask));
 677   2                              break;
 678   2                      case DHCP_OPTION_ROUTER:
 679   2                              memcpy(&(dhcpInfo.DefaultRouter), (dhcpInfo.pOpt + 2), 4);
 680   2                              len = *(dhcpInfo.pOpt + 1) + 2;
 681   2                              dhcpInfo.pOpt += len;
 682   2      
 683   2                              /* Set Gateway address */
 684   2                              /* set uip gateway address */
 685   2                              TCPIP_SetGateway(dhcpInfo.DefaultRouter);
 686   2      
 687   2                              /* set stoe gateway address */
 688   2                              STOE_SetGateway((dhcpInfo.DefaultRouter));
 689   2                              break;
 690   2                      case DHCP_OPTION_DNS_SERVER:
 691   2                              memcpy(&(dhcpInfo.DnsAddr), (dhcpInfo.pOpt + 2), 4);
 692   2                              len = *(dhcpInfo.pOpt + 1) + 2;
 693   2                              dhcpInfo.pOpt += len;
 694   2      
 695   2                              /* Set Getway address */
 696   2                              /* set uip getway address */
 697   2                      /*      uip_ipaddr(uip_addr, (U8_T)(((dhcpInfo.DnsAddr)&0xFF000000)>>24),
 698   2                              (U8_T)(((dhcpInfo.DnsAddr)&0x00FF0000)>>16),
 699   2                              (U8_T)(((dhcpInfo.DnsAddr)&0x0000FF00)>>8),
 700   2                              (U8_T)(((dhcpInfo.DnsAddr)&0x000000FF)));
 701   2                              uip_setdraddr(uip_addr);*/
 702   2                              /* set stoe getway address */
 703   2                      /*      STOE_SetGateway((dhcpInfo.NetMask));*/
 704   2                              break;
 705   2                      case DHCP_OPTION_SERVER_ID:
 706   2                              memcpy(&(dhcpInfo.ServerId[0]), (dhcpInfo.pOpt + 2), 4);
 707   2                              len = *(dhcpInfo.pOpt + 1) + 2;
 708   2                              dhcpInfo.pOpt += len;
 709   2                              break;
 710   2                      default :
 711   2                              len = *(dhcpInfo.pOpt + 1);
 712   2                              dhcpInfo.pOpt += (len + 2);
 713   2                              break;
 714   2              }
 715   1      }
 716          
 717          /*
 718           *--------------------------------------------------------------------------------
 719           * void Function(void)
 720           * Purpose :
 721           * Params  :
 722           * Returns :
 723           * Note    :
 724           *--------------------------------------------------------------------------------
 725           */
 726          void dhcp_OptMagicCookie(void)
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 13  

 727          {
 728   1              *(dhcpInfo.pOpt + 0) = 0x63;
 729   1              *(dhcpInfo.pOpt + 1) = 0x82;
 730   1              *(dhcpInfo.pOpt + 2) = 0x53;
 731   1              *(dhcpInfo.pOpt + 3) = 0x63;
 732   1              dhcpInfo.OptionsCounter += 4;
 733   1              dhcpInfo.pOpt += dhcpInfo.OptionsCounter;
 734   1      }
 735          
 736          /*
 737           *--------------------------------------------------------------------------------
 738           * void Function(void)
 739           * Purpose :
 740           * Params  :
 741           * Returns :
 742           * Note    :
 743           *--------------------------------------------------------------------------------
 744           */
 745          void dhcp_OptionsAppend(U8_T optCode, U8_T optLen, U8_T *optContent)
 746          {
 747   1              U16_T   i;
 748   1              U16_T   count = 0;
 749   1      
 750   1              *(dhcpInfo.pOpt + 0) = optCode;
 751   1              count ++;
 752   1      
 753   1              *(dhcpInfo.pOpt + 1) = optLen;
 754   1              count ++;
 755   1      
 756   1              for (i=0 ; i<optLen ; i++)
 757   1              {
 758   2                      *(dhcpInfo.pOpt + 2 + i) = *(optContent + i);
 759   2                      count ++;
 760   2              }
 761   1              
 762   1      
 763   1              if (optCode != DHCP_OPTION_END)
 764   1              {
 765   2                      dhcpInfo.pOpt = dhcpInfo.pOpt + count;
 766   2                      dhcpInfo.OptionsCounter = dhcpInfo.OptionsCounter + count;
 767   2              }
 768   1              else
 769   1              {
 770   2                      *(dhcpInfo.pOpt) = optCode;
 771   2                      dhcpInfo.pOpt = dhcpInfo.pOpt + count;
 772   2                      dhcpInfo.OptionsCounter = dhcpInfo.OptionsCounter + count;
 773   2              }
 774   1      
 775   1      } /* End of dhcp_OptionsAppend() */
 776          
 777          
 778          /* End of dhcpc.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3614    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =    601      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.06   DHCPC                                                                 05/28/2013 10:15:29 PAGE 14  

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
