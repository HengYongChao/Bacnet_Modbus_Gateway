; .\tasks.SRC generated from: ..\src\FreeRtossource\tasks.c
; COMPILER INVOKED BY:
;        E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\tasks.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\tasks.lst) SRC(.\tasks.SRC)

$MOD_CONT
$NOMOD51

NAME	TASKS

TB08	BIT	098H.3
TB18	BIT	0C0H.3
P0	DATA	080H
SM00	BIT	098H.7
P1	DATA	090H
SM10	BIT	0C0H.7
SM01	BIT	098H.6
P2	DATA	0A0H
SM11	BIT	0C0H.6
SM02	BIT	098H.5
P3	DATA	0B0H
AC	BIT	0D0H.6
SM12	BIT	0C0H.5
T0	BIT	0B0H.4
SPIDR	DATA	0CFH
T1	BIT	0B0H.5
EA	BIT	0A8H.7
OWCIR	DATA	0D6H
CH	DATA	0C5H
DPH0	DATA	083H
IE	DATA	0A8H
DPH1	DATA	085H
CL	DATA	0C4H
P0_0	BIT	080H.0
P1_0	BIT	090H.0
P0_1	BIT	080H.1
CCAPH0	DATA	0B9H
DPL0	DATA	082H
P2_0	BIT	0A0H.0
P1_1	BIT	090H.1
P0_2	BIT	080H.2
CCAPH1	DATA	0BAH
DPL1	DATA	084H
P3_0	BIT	0B0H.0
P2_1	BIT	0A0H.1
P1_2	BIT	090H.2
P0_3	BIT	080H.3
UR2_DLH	DATA	0E2H
CCAPH2	DATA	0BBH
XMRHR	DATA	0A7H
P3_1	BIT	0B0H.1
P2_2	BIT	0A0H.2
P1_3	BIT	090H.3
P0_4	BIT	080H.4
CCAPH3	DATA	0BCH
P3_2	BIT	0B0H.2
P2_3	BIT	0A0H.3
P1_4	BIT	090H.4
P0_5	BIT	080H.5
TA	DATA	0EBH
CCAPH4	DATA	0BDH
CCAPL0	DATA	0B1H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P3_3	BIT	0B0H.3
P2_4	BIT	0A0H.4
REN0	BIT	098H.4
P1_5	BIT	090H.5
P0_6	BIT	080H.6
UR2_FCR	DATA	0E3H
CCAPM0	DATA	0D1H
T2IF	DATA	0C9H
CCAPL1	DATA	0B2H
REN1	BIT	0C0H.4
P3_4	BIT	0B0H.4
P2_5	BIT	0A0H.5
P1_6	BIT	090H.6
P0_7	BIT	080H.7
UR2_DLL	DATA	0E1H
CCAPM1	DATA	0D2H
CCAPL2	DATA	0B3H
XMRLR	DATA	0A6H
P3_5	BIT	0B0H.5
P2_6	BIT	0A0H.6
P1_7	BIT	090H.7
CCAPM2	DATA	0D3H
CCAPL3	DATA	0B4H
XMWHR	DATA	0A5H
P3_6	BIT	0B0H.6
P2_7	BIT	0A0H.7
CCAPM3	DATA	0D4H
IP	DATA	0B8H
CCAPL4	DATA	0B5H
P3_7	BIT	0B0H.7
CCAPM4	DATA	0D5H
DBAR	DATA	09AH
UR2_IER	DATA	0E2H
CY	BIT	0D0H.7
INT0	BIT	0B0H.2
UR2_LCR	DATA	0E4H
XMWLR	DATA	0A4H
INT1	BIT	0B0H.3
UR2_MCR	DATA	0E5H
DPX0	DATA	093H
I2CCIR	DATA	096H
DPX1	DATA	095H
UR2_IIR	DATA	0E3H
UR2_RBR	DATA	0E1H
ACON	DATA	09DH
DCIR	DATA	09BH
SP	DATA	081H
CCON	DATA	0C3H
CMOD	DATA	0C2H
OV	BIT	0D0H.2
WR	BIT	0B0H.6
UR2_THR	DATA	0E1H
EWDI	BIT	0E8H.5
WDIF	BIT	0D8H.3
RLDH	DATA	0CBH
EPCR	DATA	0BEH
LDHR	DATA	0AAH
UR2_LSR	DATA	0E6H
EPDR	DATA	0BFH
MCIR	DATA	0B6H
RCLK	BIT	0C8H.5
UR2_MSR	DATA	0E7H
TCLK	BIT	0C8H.4
RLDL	DATA	0CAH
LDLR	DATA	0A9H
PCON	DATA	087H
CANCIR	DATA	0DEH
TCIR	DATA	0AEH
PWDI	BIT	0F8H.5
LSCR	DATA	0A2H
TMOD	DATA	089H
TCON	DATA	088H
OWDR	DATA	0D7H
IE0	BIT	088H.1
IE1	BIT	088H.3
MXAX	DATA	0EAH
LMSR	DATA	0A1H
MD0	DATA	0F9H
B	DATA	0F0H
MD1	DATA	0FAH
LSAIER	DATA	0A1H
MD2	DATA	0FBH
WTRF	BIT	0D8H.2
MD3	DATA	0FCH
PISSR1	DATA	09EH
MD4	DATA	0FDH
LSSR	DATA	0A3H
PISSR2	DATA	09FH
MD5	DATA	0FEH
ACC	DATA	0E0H
ES0	BIT	0A8H.4
CT2	BIT	0C8H.1
ES1	BIT	0A8H.6
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RI1	BIT	0C0H.0
SPICIR	DATA	0CEH
TH0	DATA	08CH
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
TH1	DATA	08DH
TI1	BIT	0C0H.1
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
TL0	DATA	08AH
CSREPR	DATA	08FH
TL1	DATA	08BH
TL2	DATA	0CCH
PS0	BIT	0B8H.4
EIE	DATA	0E8H
WTST	DATA	092H
PS1	BIT	0B8H.6
PT0	BIT	0B8H.1
EIF	DATA	091H
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
I2CDR	DATA	097H
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DDR	DATA	09CH
DPH	DATA	083H
EIP	DATA	0F8H
DPL	DATA	082H
LCR	DATA	0A2H
SBUF0	DATA	099H
SBUF1	DATA	0C1H
EINT2	BIT	0E8H.0
EXEN2	BIT	0C8H.3
MDR	DATA	0B7H
EINT3	BIT	0E8H.1
CPRL2	BIT	0C8H.0
SCON0	DATA	098H
EINT4	BIT	0E8H.2
SCON1	DATA	0C0H
SDSTSR	DATA	094H
EINT5	BIT	0E8H.3
STATUS	DATA	0E9H
EINT6	BIT	0E8H.4
T2CON	DATA	0C8H
DPS	DATA	086H
CANDR	DATA	0DFH
TDR	DATA	0AFH
LDAHR	DATA	0A5H
DPX	DATA	093H
DMAHR	DATA	0ADH
PINT2	BIT	0F8H.0
RXD	BIT	0B0H.0
PINT3	BIT	0F8H.1
CKCON	DATA	08EH
PINT4	BIT	0F8H.2
EWT	BIT	0D8H.1
TXD	BIT	0B0H.1
LDALR	DATA	0A4H
PINT5	BIT	0F8H.3
DMALR	DATA	0ABH
LSR	DATA	0A3H
PINT6	BIT	0F8H.4
DMAMR	DATA	0ACH
ARCON	DATA	0FFH
F0	BIT	0D0H.5
F1	BIT	0D0H.1
LDCSR	DATA	0A6H
PSW	DATA	0D0H
RB08	BIT	098H.2
WDCON	DATA	0D8H
RWT	BIT	0D8H.0
RB18	BIT	0C0H.2
?PR?_?sTaskCreate?TASKS                  SEGMENT ECODE INSEG 
?XD?TASKS            SEGMENT XDATA 
?PR?_?vTaskDelayUntil?TASKS              SEGMENT ECODE INSEG 
?PR?_?vTaskDelay?TASKS                   SEGMENT ECODE INSEG 
?PR?_?vTaskSuspend?TASKS                 SEGMENT ECODE INSEG 
?PR?_?vTaskResume?TASKS                  SEGMENT ECODE INSEG 
?PR?_?vTaskStartScheduler?TASKS          SEGMENT ECODE INSEG 
?PR?_?vTaskEndScheduler?TASKS            SEGMENT ECODE INSEG 
?PR?_?vTaskSuspendAll?TASKS              SEGMENT ECODE INSEG 
?PR?_?cTaskResumeAll?TASKS               SEGMENT ECODE INSEG 
?PR?_?xTaskGetTickCount?TASKS            SEGMENT ECODE INSEG 
?PR?_?usTaskGetNumberOfTasks?TASKS       SEGMENT ECODE INSEG 
?PR?_?vTaskIncrementTick?TASKS           SEGMENT ECODE INSEG 
?PR?_?vTaskSwitchContext?TASKS           SEGMENT ECODE INSEG 
?PR?_?vTaskPlaceOnEventList?TASKS        SEGMENT ECODE INSEG 
?PR?_?cTaskRemoveFromEventList?TASKS     SEGMENT ECODE INSEG 
?PR?_?prvIdleTask?TASKS                  SEGMENT ECODE INSEG 
?PR?_?prvInitialiseTCBVariables?TASKS    SEGMENT ECODE INSEG 
?PR?_?prvInitialiseTaskLists?TASKS       SEGMENT ECODE INSEG 
?PR?_?prvCheckTasksWaitingTermination?TASKS SEGMENT ECODE INSEG 
?PR?_?prvAllocateTCBAndStack?TASKS       SEGMENT ECODE INSEG 
?PR?_?prvGetCurrentTCB_XBP?TASKS         SEGMENT ECODE INSEG 
?PR?_?prvSetCurrentTCB_XBP?TASKS         SEGMENT ECODE INSEG 
?CO?TASKS            SEGMENT CODE 
?C_INITSEG           SEGMENT CODE 
	EXTRN	CODE (_?vListRemove)
	EXTRN	DATA (C_XBP)
	EXTRN	CODE (_?vListInsert)
	EXTRN	CODE (_strncpy)
	EXTRN	XDATA (?_strncpy?BYTE)
	EXTRN	CODE (_?vPortYield)
	EXTRN	CODE (_strlen)
	EXTRN	CODE (_?pxPortInitialiseStack)
	EXTRN	CODE (_?vPortFree)
	EXTRN	CODE (_?vListInsertEnd)
	EXTRN	CODE (_?vListInitialise)
	EXTRN	CODE (_?vListInitialiseItem)
	EXTRN	CODE (_?sPortStartScheduler)
	EXTRN	CODE (_?vPortEndScheduler)
	EXTRN	IDATA (STACK_START)
	EXTRN	CODE (_?pvPortMalloc)
	EXTRN	CODE (?C?ADDXBP)
	EXTRN	CODE (?C?XBPOFF)
	EXTRN	DATA (?C_XBP)
	EXTRN	NUMBER (?C?XDATASEG)
	EXTRN	CODE (?C?ILDPTR)
	EXTRN	CODE (?C?LSTXDATA)
	EXTRN	CODE (?C?PLDPTR)
	EXTRN	CODE (?C?PSTPTR)
	EXTRN	CODE (?C?CLDPTR)
	EXTRN	CODE (?C?CSTPTR)
	EXTRN	CODE (?C?LSTPTR)
	EXTRN	CODE (?C?LLDPTR)
	EXTRN	CODE (?C?ULCMP)
	EXTRN	CODE (?C?ISTPTR)
	EXTRN	CODE (?C?STRCPY)
	EXTRN	CODE (?C?MEMSET)
	EXTRN	NUMBER (?C?XDATAMTYPE)
	PUBLIC	pxCurrentTCB
	PUBLIC	xTickCount
	PUBLIC	pxReadyTasksLists
	PUBLIC	_?prvSetCurrentTCB_XBP
	PUBLIC	_?prvGetCurrentTCB_XBP
	PUBLIC	_?cTaskRemoveFromEventList
	PUBLIC	_?vTaskPlaceOnEventList
	PUBLIC	_?vTaskSwitchContext
	PUBLIC	_?vTaskIncrementTick
	PUBLIC	_?usTaskGetNumberOfTasks
	PUBLIC	_?xTaskGetTickCount
	PUBLIC	_?cTaskResumeAll
	PUBLIC	_?vTaskSuspendAll
	PUBLIC	_?vTaskEndScheduler
	PUBLIC	_?vTaskStartScheduler
	PUBLIC	_?vTaskResume
	PUBLIC	_?vTaskSuspend
	PUBLIC	_?vTaskDelay
	PUBLIC	_?vTaskDelayUntil
	PUBLIC	_?sTaskCreate

	RSEG  ?XD?TASKS
   ucTaskNumber:   DS   1
pxReadyTasksLists:   DS   360
usCurrentNumberOfTasks:   DS   2
ucTopUsedPriority:   DS   1
     xTickCount:   DS   4
xDelayedTaskList1:   DS   24
xDelayedTaskList2:   DS   24
sUsingPreemption:   DS   2
   pxCurrentTCB:   DS   3
ucSchedulerSuspended:   DS   1
pxOverflowDelayedTaskList:   DS   3
  ucMissedTicks:   DS   1
xPendingReadyList:   DS   24
pxDelayedTaskList:   DS   3
xSuspendedTaskList:   DS   24
cSchedulerRunning:   DS   1
ucTopReadyPriority:   DS   1

	RSEG  ?CO?TASKS
?SC_0:
	DB  'I' ,'D' ,'L' ,'E' ,000H


	RSEG ?C_INITSEG

	RSEG  ?C_INITSEG
	DB	043H
	DW	pxCurrentTCB
	DB	000H,000H,000H	; ptr3

	DB	042H
	DW	sUsingPreemption
	DW	00000H

	DB	042H
	DW	usCurrentNumberOfTasks
	DW	00000H

	DB	044H
	DW	xTickCount
	DB	000H,000H,000H,000H	; long

	DB	041H
	DW	ucTopUsedPriority
	DB	000H

	DB	041H
	DW	ucTopReadyPriority
	DB	000H

	DB	041H
	DW	cSchedulerRunning
	DB	000H

	DB	041H
	DW	ucSchedulerSuspended
	DB	000H

	DB	041H
	DW	ucMissedTicks
	DB	000H

	DB	041H
	DW	ucTaskNumber
	DB	000H

; /*
; 	FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
; 
; 	This file is part of the FreeRTOS distribution.
; 
; 	FreeRTOS is free software; you can redistribute it and/or modify
; 	it under the terms of the GNU General Public License as published by
; 	the Free Software Foundation; either version 2 of the License, or
; 	(at your option) any later version.
; 
; 	FreeRTOS is distributed in the hope that it will be useful,
; 	but WITHOUT ANY WARRANTY; without even the implied warranty of
; 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; 	GNU General Public License for more details.
; 
; 	You should have received a copy of the GNU General Public License
; 	along with FreeRTOS; if not, write to the Free Software
; 	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
; 
; 	A special exception to the GPL can be applied should you wish to distribute
; 	a combined work that includes FreeRTOS, without being obliged to provide
; 	the source code for any proprietary components.  See the licensing section 
; 	of http://www.FreeRTOS.org for full details of how and when the exception
; 	can be applied.
; 
; 	***************************************************************************
; 	See http://www.FreeRTOS.org for documentation, latest information, license 
; 	and contact details.  Please ensure to read the configuration and relevant 
; 	port sections of the online documentation.
; 	***************************************************************************
; */
; 
; /*
; Changes from V1.00:
; 	
; 	+ Call to portRESTORE_CONTEXT has been removed.  The first context
; 	  switch is now performed within sPortStartScheduler().
; 
; Changes from V1.01:
; 
; 	+ More use of 8bit data types.
; 	+ Function name prefixes changed where the data type returned has changed.
; 	+ USE_TRACE_FACILITY is no longer defined by default.
; 
; Changes from V1.2.0
; 
; 	+ Introduced ucTopReadyPriority.  This tracks the highest priority ready
; 	  queue that contains a valid TCB and thus makes the context switch 
; 	  slightly faster.
; 
; 	+ prvAddTaskToReadyQueue() has been made a macro.
; 
; Changes from V1.2.6
; 
; 	+ Added conditional compilation directives.
; 	+ Extended API.
; 	+ Rearranged function order.
; 	+ Creating a task now causes a context switch if the task being created
; 	  has a higher priority than the calling task - assuming the kernel is
; 	  running.
; 	+ vTaskDelete() now only causes a context switch if the calling task is
; 	  the task being deleted.
; 
; Changes from V2.0.0
; 
; 	+ Allow the type of the tick count to be 16 or 32 bits.
; 	+ Introduce xPendingReadyList feature to allow the time interrupts have to
; 	  be disabled to be minimised.
; 	+ Remove the #if( INCLUDE_vTaskSuspendAll ) statements.  vTaskSuspendAll()
; 	  is now always included as it is used by the scheduler itself.
; 
; Changes from V2.1.0
; 
; 	+ Bug fix - pxCurrentTCB is now initialised before the call to 
; 	  prvInitialiseTaskLists().  Previously pxCurrentTCB could be accessed 
; 	  while null.
; 
; Changed from V2.1.1
; 
; 	+ Change to where lStackSize is declared within sTaskCreate() to prevent
; 	  compiler warnings with 8051 port.
; 
; Changes from V2.2.0
; 
; 	+ Explicit use of 'signed' qualifier on portCHAR types added.
; 	+ Changed odd calculation of initial pxTopOfStack value when 
; 	  portSTACK_GROWTH < 0.
; 	+ Removed pcVersionNumber definition.
; 
; Changes from V2.5.3
; 
; 	+ cTaskResumeAll() modified to ensure it can be called prior to the task
; 	  lists being initialised.
; 
; Changes from V2.5.5
; 
; 	+ Added API function vTaskDelayUntil().
; 	+ Added INCLUDE_vTaskDelay conditional compilation.
; */
; 
; #include <stdio.h>
; #include <stdlib.h>
; #include <string.h>
; 
; #include "projdefs.h"
; #include "portable.h"
; #include "task.h"
; #include "errors.h"
; extern INT8U xdata * data C_XBP;
; /*
;  * Macro to define the amount of stack available to the idle task.
;  */
; #define tskIDLE_STACK_SIZE	portMINIMAL_STACK_SIZE
; 
; /*
;  * Task control block.  A task control block (TCB) is allocated to each task,
;  * and stores the context of the task.
;  */
; typedef struct tskTaskControlBlock
; {
; 	portSTACK_TYPE		*pxTopOfStack;						/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
; 	portSTACK_TYPE		*pxStack;							/*< Points to the start of the stack. */
; 	unsigned portSHORT	usStackDepth;						/*< Total depth of the stack (when empty).  This is defined as the number of variables the stack can hold, not the number of bytes. */
; 	signed portCHAR		pcTaskName[ tskMAX_TASK_NAME_LEN ];	/*< Descriptive name given to the task when created.  Facilitates debugging only. */
; 	unsigned portCHAR	ucPriority;							/*< The priority of the task where 0 is the lowest priority. */
; 
; 	xListItem			xGenericListItem;					/*< List item used to place the TCB in ready and blocked queues. */
; 	xListItem			xEventListItem;						/*< List item used to place the TCB in event lists. */
; 
; 	unsigned portCHAR	ucTCBNumber;						/*< This is used for tracing the scheduler only. */
; } tskTCB;
; 
; /*lint -e956 */
; 
; volatile tskTCB * volatile pxCurrentTCB = NULL;					
; 
; /* Lists for ready and blocked tasks. --------------------*/
; 
;  volatile xList pxReadyTasksLists[ portMAX_PRIORITIES ];	/*< Prioratised ready tasks. */
; static volatile xList xDelayedTaskList1;						/*< Delayed tasks. */
; static volatile xList xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
; static volatile xList *pxDelayedTaskList;						/*< Points to the delayed task list currently being used. */
; static volatile xList *pxOverflowDelayedTaskList;				/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
; static volatile xList xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready queue when the scheduler is resumed. */
; 
; #if( INCLUDE_vTaskDelete == 1 )
; 
; 	static volatile xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
; 
; #endif
; 
; #if( INCLUDE_vTaskSuspend == 1 )
; 
; 	static volatile xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
; 
; #endif
; 
; /* File private variables. --------------------------------*/
; static portSHORT sUsingPreemption = pdFALSE;
; static unsigned portSHORT usCurrentNumberOfTasks = ( unsigned portSHORT ) 0;              
; volatile portTickType xTickCount = ( portTickType ) 0;				/* Modified by tick ISR. */
; static unsigned portCHAR ucTopUsedPriority = tskIDLE_PRIORITY;
; static volatile unsigned portCHAR ucTopReadyPriority = tskIDLE_PRIORITY;
; static signed portCHAR cSchedulerRunning = pdFALSE;
; static volatile unsigned portCHAR ucSchedulerSuspended = pdFALSE;
; static volatile unsigned portCHAR ucMissedTicks = ( unsigned portCHAR ) 0;
; 
; /* Debugging and trace facilities private variables and macros. ------------*/
; 
; /*
;  * The value used to fill the stack of a task when the task is created.  This
;  * is used purely for checking the high water mark for tasks.
;  */
; #define tskSTACK_FILL_BYTE	( 0xa5 )
; 
; /*
;  * Macros used by vListTask to indicate which state a task is in.
;  */
; #define tskBLOCKED_CHAR		( ( signed portCHAR ) 'B' )
; #define tskREADY_CHAR		( ( signed portCHAR ) 'R' )
; #define tskDELETED_CHAR		( ( signed portCHAR ) 'D' )
; #define tskSUSPENDED_CHAR	( ( signed portCHAR ) 'S' )
; 
; /* 
;  * Macros and private variables used by the trace facility.
;  */
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	#define tskSIZE_OF_EACH_TRACE_LINE			( sizeof( unsigned portLONG ) + sizeof( unsigned portCHAR ) )
; 	static volatile signed portCHAR * volatile pcTraceBuffer;
; 	static signed portCHAR *pcTraceBufferStart;
; 	static signed portCHAR *pcTraceBufferEnd;
; 	static signed portCHAR cTracing = ( signed portCHAR ) pdFALSE;
; 
; #endif
; 
; /*
;  * Macro that writes a trace of scheduler activity to a buffer.  This trace
;  * shows which task is running when and is very useful as a debugging tool.
;  * As this macro is called each context switch it is a good idea to undefine
;  * it if not using the facility.
;  */
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	#define vWriteTraceToBuffer()														\
; 	{																					\
; 		if( cTracing )																	\
; 		{																				\
; 			static unsigned portCHAR ucPreviousTask = 255;								\
; 																						\
; 			if( ucPreviousTask != pxCurrentTCB->ucTCBNumber )							\
; 			{																			\
; 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )	\
; 				{																		\
; 					ucPreviousTask = pxCurrentTCB->ucTCBNumber;							\
; 					*( unsigned portLONG * ) pcTraceBuffer = ( unsigned portLONG ) xTickCount;	\
; 					pcTraceBuffer += sizeof( unsigned portLONG );						\
; 					*( unsigned portCHAR * ) pcTraceBuffer = ucPreviousTask;			\
; 					pcTraceBuffer += sizeof( unsigned portCHAR );						\
; 				}																		\
; 				else																	\
; 				{																		\
; 					cTracing = ( signed portCHAR ) pdFALSE;								\
; 				}																		\
; 			}																			\
; 		}																				\
; 	}
; 
; #else
; 
; 	#define vWriteTraceToBuffer()
; 
; #endif
; 
; 
; /*
;  * Place the task represented by pxTCB into the appropriate ready queue for
;  * the task.  It is inserted at the end of the list.  One quirk of this is
;  * that if the task being inserted is at the same priority as the currently
;  * executing task, then it will only be rescheduled after the currently 
;  * executing task has been rescheduled.
;  */
; #define prvAddTaskToReadyQueue( pxTCB )																			\
; {																												\
; 	listSET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ), 0 );													\
; 	if( pxTCB->ucPriority > ucTopReadyPriority )																\
; 	{																											\
; 		ucTopReadyPriority = pxTCB->ucPriority;																	\
; 	}																											\
; 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->ucPriority ] ), &( pxTCB->xGenericListItem ) );	\
; }	
; 
; 
; /*
;  * Macro that looks at the list of tasks that are currently delayed to see if 
;  * any require waking.
;  *
;  * Tasks are stored in the queue in the order of their wake time - meaning
;  * once one tasks has been found whose timer has not expired we need not look
;  * any further down the list.
;  */
; #define prvCheckDelayedTasks()																	\
; {																								\
; register tskTCB *pxTCB;																			\
; 																								\
; 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )	\
; 	{																							\
; 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )				\
; 		{																						\
; 			break;																				\
; 		}																						\
; 		vListRemove( &( pxTCB->xGenericListItem ) );											\
; 		/* Is the task waiting on an event also? */												\
; 		if( pxTCB->xEventListItem.pvContainer )													\
; 		{																						\
; 			vListRemove( &( pxTCB->xEventListItem ) );											\
; 		}																						\
; 		prvAddTaskToReadyQueue( pxTCB );														\
; 	}																							\
; }																							
; 
; /*
;  * Several functions take an xTaskHandle parameter that can optionally be NULL,
;  * where NULL is used to indicate that the handle of the currently executing 
;  * task should be used in place of the parameter.  This macro simply checks to 
;  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
;  */
; #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) pxHandle )
; 
; 
; /* File private functions. --------------------------------*/
; 
; /*
;  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
;  * into the TCB structure.
;  */
; static void prvInitialiseTCBVariables( tskTCB *pxTCB, unsigned portSHORT usStackDepth, const signed portCHAR * const pcName, unsigned portCHAR ucPriority ) reentrant ;
; 
; /*
;  * Utility to ready all the lists used by the scheduler.  This is called 
;  * automatically upon the creation of the first task.
;  */
; static portSHORT prvInitialiseTaskLists( void ) reentrant;
; 
; /*
;  * The idle task, which as all tasks is implemented as a never ending loop.
;  * The idle task is automatically created and added to the ready lists upon
;  * creation of the first user task.
;  */
; static void prvIdleTask( void *pvParameters ) reentrant;
; 
; /*
;  * Utility to free all memory allocated by the scheduler to hold a TCB, 
;  * including the stack pointed to by the TCB.  
;  *
;  * This does not free memory allocated by the task itself (i.e. memory 
;  * allocated by calls to pvPortMalloc from within the tasks application code).
;  */
; #if( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
; 	static void prvDeleteTCB( tskTCB *pxTCB )reentrant;
; #endif
; 
; /*
;  * Used only by the idle task.  This checks to see if anything has been placed
;  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
;  * and its TCB deleted.
;  */
; static void prvCheckTasksWaitingTermination( void )reentrant;
; 
; /*
;  * Allocates memory from the heap for a TCB and associated stack.  Checks the
;  * allocation was successful.
;  */
; static tskTCB *prvAllocateTCBAndStack( unsigned portSHORT usStackDepth )reentrant;
; 
; /*
;  * Called from vTaskList.  vListTasks details all the tasks currently under
;  * control of the scheduler.  The tasks may be in one of a number of lists.
;  * prvListTaskWithinSingleList accepts a list and details the tasks from
;  * within just that list.
;  *
;  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
;  * NORMAL APPLICATION CODE.
;  */
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	static void prvListTaskWithinSingleList( signed portCHAR *pcWriteBuffer, xList *pxList, signed portCHAR cStatus )reentrant;
; #endif
; 
; 
; /*lint +e956 */
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * TASK CREATION API documented in task.h
;  *----------------------------------------------------------*/
; 
; portSHORT sTaskCreate( pdTASK_CODE pvTaskCode, const signed portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portCHAR ucPriority, xTaskHandle *pxCreatedTask )reentrant

	RSEG  ?PR?_?sTaskCreate?TASKS
_?sTaskCreate:
	USING	0
			; SOURCE LINE # 361
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFF4H
	LCALL	?C?ADDXBP
; {
; portSHORT sReturn;
; tskTCB * pxNewTCB;
; static unsigned portCHAR ucTaskNumber = 0; /*lint !e956 Static is deliberate - this is guarded before use. */
; 
; 	/* Allocate the memory required by the TCB and stack for the new task.  
; 	checking that the allocation was successful. */
; 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth );
			; SOURCE LINE # 369
	MOV  	DPTR,#012H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_?prvAllocateTCBAndStack
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 	if( pxNewTCB != NULL )
			; SOURCE LINE # 370
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0001
; 	{		
			; SOURCE LINE # 371
; 		portSTACK_TYPE *pxTopOfStack;
; 
; 		/* Setup the newly allocated TCB with the initial state of the task. */
; 		prvInitialiseTCBVariables( pxNewTCB, usStackDepth, pcName, ucPriority );
			; SOURCE LINE # 375
	MOV  	DPTR,#017H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
	MOV  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#010H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#016H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?prvInitialiseTCBVariables
; 
; 		/* Calculate the top of stack address.  This depends on whether the
; 		stack grows from high memory to low (as per the 80x86) or visa versa. 
; 		portSTACK_GROWTH is used to make the result positive or negative as
; 		required by the port. */
; 		#if portSTACK_GROWTH < 0
; 		{
			; SOURCE LINE # 382
; 			portLONG lStackSize; 
; 
; 			lStackSize = ( portLONG ) ( pxNewTCB->usStackDepth - ( unsigned portSHORT ) 1 );
			; SOURCE LINE # 385
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?ILDPTR
	CLR  	C
	SUBB 	A,#01H
	MOV  	R7,A
	MOV  	A,B
	SUBB 	A,#00H
	MOV  	R6,A
	CLR  	A
	MOV  	R4,A
	MOV  	R5,A
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	LCALL	?C?LSTXDATA
; 			pxTopOfStack = pxNewTCB->pxStack + lStackSize;
			; SOURCE LINE # 386
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,R1
	MOV  	R1,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R2,A
	MOV  	A,R3
	ADDC 	A,R5
	MOV  	R3,A
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 387
; 		#else
; 		{
; 			pxTopOfStack = pxNewTCB->pxStack;	
; 		}
; 		#endif
; 
; 		/* Initialise the TCB stack to look as if the task was already running,
; 		but had been interrupted by the scheduler.  The return address is set
; 		to the start of the task function. Once the stack has been initialised
; 		the	top of stack variable is updated. */
; 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pvTaskCode, pvParameters );
			; SOURCE LINE # 398
	MOV  	DPTR,#014H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FH
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0BH
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?pxPortInitialiseStack
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; 
; 		/* We are going to manipulate the task queues to add this task to a
; 		ready list, so must make sure no interrupts occur. */
; 		portENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 		{
			; SOURCE LINE # 403
; 			usCurrentNumberOfTasks++;
			; SOURCE LINE # 404
	MOV  	DPTR,#usCurrentNumberOfTasks+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0106
	MOV  	DPTR,#usCurrentNumberOfTasks
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0106:
; 			if( usCurrentNumberOfTasks == ( unsigned portSHORT ) 1 )
			; SOURCE LINE # 405
	MOV  	DPTR,#usCurrentNumberOfTasks
	MOVX 	A,@DPTR
	JNZ  	?C0107
	INC  	DPTR
	MOVX 	A,@DPTR
	XRL  	A,#01H
?C0107:
	JNZ  	?C0002
; 			{
			; SOURCE LINE # 406
; 				/* As this is the first task it must also be the current task. */
; 				pxCurrentTCB = ( volatile tskTCB * volatile ) pxNewTCB;
			; SOURCE LINE # 408
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#pxCurrentTCB
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 				/* This is the first task to be created so do the preliminary
; 				initialisation required.  We will not recover if this call 
; 				fails, but we will report the failure. */
; 				sReturn = prvInitialiseTaskLists();
			; SOURCE LINE # 413
	LCALL	_?prvInitialiseTaskLists
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 			}
			; SOURCE LINE # 414
	SJMP 	?C0003
?C0002:
; 			else
; 			{
			; SOURCE LINE # 416
; 				sReturn = pdPASS;
			; SOURCE LINE # 417
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
	INC  	DPTR
	INC  	A
	MOVX 	@DPTR,A
; 
; 				/* If the scheduler is not already running, make this task the
; 				current task if it is the highest priority task to be created
; 				so far. */
; 				if( cSchedulerRunning == pdFALSE )
			; SOURCE LINE # 422
	MOV  	DPTR,#cSchedulerRunning
	MOVX 	A,@DPTR
	JNZ  	?C0003
; 				{
			; SOURCE LINE # 423
; 					if( pxCurrentTCB->ucPriority <= ucPriority )
			; SOURCE LINE # 424
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#017H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JNC  	?C0003
; 					{
			; SOURCE LINE # 425
; 						pxCurrentTCB = ( volatile tskTCB * volatile ) pxNewTCB;	
			; SOURCE LINE # 426
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#pxCurrentTCB
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 					}
			; SOURCE LINE # 427
; 				}
			; SOURCE LINE # 428
; 			}				
			; SOURCE LINE # 429
?C0003:
; 
; 			/* Remember the top priority to make context switching faster.  Use
; 			the priority in pxNewTCB as this has been capped to a valid value. */
; 			if( pxNewTCB->ucPriority > ucTopUsedPriority )
			; SOURCE LINE # 433
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopUsedPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0006
; 			{
			; SOURCE LINE # 434
; 				ucTopUsedPriority = pxNewTCB->ucPriority;
			; SOURCE LINE # 435
	MOV  	A,R7
	MOVX 	@DPTR,A
; 			}
			; SOURCE LINE # 436
?C0006:
; 
; 			/* Add a counter into the TCB for tracing only. */
; 			pxNewTCB->ucTCBNumber = ucTaskNumber;
			; SOURCE LINE # 439
	MOV  	DPTR,#ucTaskNumber
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#039H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 			ucTaskNumber++;
			; SOURCE LINE # 440
	MOV  	DPTR,#ucTaskNumber
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 
; 			prvAddTaskToReadyQueue( pxNewTCB );
			; SOURCE LINE # 442
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0007
	MOV  	A,R7
	MOVX 	@DPTR,A
?C0007:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
	LCALL	_?vListInsertEnd
; 		}
			; SOURCE LINE # 443
; 		portEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 	}
			; SOURCE LINE # 445
	SJMP 	?C0008
?C0001:
; 	else
; 	{
			; SOURCE LINE # 447
; 		sReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
			; SOURCE LINE # 448
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 449
?C0008:
; 
; 	if( sReturn == pdPASS )
			; SOURCE LINE # 451
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	XRL  	A,#01H
	ORL  	A,R6
	JNZ  	?C0009
; 	{
			; SOURCE LINE # 452
; 		if( ( void * ) pxCreatedTask != NULL )
			; SOURCE LINE # 453
	MOV  	DPTR,#018H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JZ   	?C0010
; 		{
			; SOURCE LINE # 454
; 			/* Pass the TCB out - in an anonymous way.  The calling function/
; 			task can use this as a handle to delete the task later if 
; 			required.*/
; 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
			; SOURCE LINE # 458
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#018H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; 		}
			; SOURCE LINE # 459
?C0010:
; 
; 		if( cSchedulerRunning != pdFALSE )
			; SOURCE LINE # 461
	MOV  	DPTR,#cSchedulerRunning
	MOVX 	A,@DPTR
	JZ   	?C0009
; 		{
			; SOURCE LINE # 462
; 			/* If the created task is of a higher priority than the current task
; 			then it should run now. */
; 			if( pxCurrentTCB->ucPriority < ucPriority )
			; SOURCE LINE # 465
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#017H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	CLR  	C
	SUBB 	A,R6
	JNC  	?C0009
; 			{
			; SOURCE LINE # 466
; 				taskYIELD();
			; SOURCE LINE # 467
	LCALL	_?vPortYield
; 			}
			; SOURCE LINE # 468
; 		}
			; SOURCE LINE # 469
; 	}
			; SOURCE LINE # 470
?C0009:
; 
; 	return sReturn;
			; SOURCE LINE # 472
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 473
?C0013:
	MOV  	DPTR,#01BH
	LJMP 	?C?ADDXBP
; END OF _?sTaskCreate

; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskDelete == 1 )
; 
; 	void vTaskDelete( xTaskHandle pxTaskToDelete ) reentrant
; 	{
; 	tskTCB *pxTCB;
; 
; 		taskENTER_CRITICAL();
; 		{
; 			/* If null is passed in here then we are deleting ourselves. */
; 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
; 
; 			/* Remove task from the ready list and place in the	termination list.
; 			This will stop the task from be scheduled.  The idle task will check
; 			the termination list and free up any memory allocated by the 
; 			scheduler for the TCB and stack. */
; 			vListRemove( &( pxTCB->xGenericListItem ) );
; 
; 			/* Is the task waiting on an event also? */												
; 			if( pxTCB->xEventListItem.pvContainer )
; 			{
; 				vListRemove( &( pxTCB->xEventListItem ) );
; 			}
; 
; 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
; 		}
; 		taskEXIT_CRITICAL();
; 
; 		/* Force a reschedule if we have just deleted the current task. */
; 		if( ( void * ) pxTaskToDelete == NULL )
; 		{
; 			taskYIELD();
; 		}
; 	}
; 
; #endif
; 
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * TASK CONTROL API documented in task.h
;  *----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskDelayUntil == 1 )
; 	void vTaskDelayUntil( portTickType *pxPreviousWakeTime, portTickType xTimeIncrement ) reentrant

	RSEG  ?PR?_?vTaskDelayUntil?TASKS
_?vTaskDelayUntil:
	USING	0
			; SOURCE LINE # 522
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
	LCALL	?C?LSTXDATA
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFAH
	LCALL	?C?ADDXBP
; 	{
; 	portTickType xTimeToWake;
; 	portCHAR cAlreadyYielded, cShouldDelay = ( portCHAR ) pdFALSE;
			; SOURCE LINE # 525
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	CLR  	A
	MOVX 	@DPTR,A
; 
; 		vTaskSuspendAll();
			; SOURCE LINE # 527
	LCALL	_?vTaskSuspendAll
; 		{
			; SOURCE LINE # 528
; 			/* Generate the tick time at which the task wants to wake. */
; 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
			; SOURCE LINE # 530
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?LLDPTR
	MOV  	DPTR,#09H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOV  	R7,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R6,A
	MOV  	A,R1
	ADDC 	A,R5
	MOV  	R5,A
	MOV  	A,R0
	ADDC 	A,R4
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	LCALL	?C?LSTXDATA
; 
; 			if( xTickCount < *pxPreviousWakeTime )
			; SOURCE LINE # 532
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?LLDPTR
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	JNC  	?C0014
; 			{
			; SOURCE LINE # 533
; 				/* The tick count has overflowed since this function was 
; 				lasted called.  In this case the only time we should ever 
; 				actually delay is if the wake time has also	overflowed, 
; 				and the wake time is greater than the tick time.  When this 
; 				is the case it is as if neither time had overflowed. */
; 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
			; SOURCE LINE # 539
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?LLDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	JC   	$ + 5H
	AJMP 	?C0016
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	LCALL	?C?ULCMP
	JC   	?C0016
; 				{
			; SOURCE LINE # 540
; 					cShouldDelay = ( portCHAR ) pdTRUE;
			; SOURCE LINE # 541
; 				}
			; SOURCE LINE # 542
; 			}
			; SOURCE LINE # 543
	SJMP 	?C0121
?C0014:
; 			else
; 			{
			; SOURCE LINE # 545
; 				/* The tick time has not overflowed.  In this case we will
; 				delay if either the wake time has overflowed, and/or the
; 				tick time is less than the wake time. */
; 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
			; SOURCE LINE # 549
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?LLDPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	JC   	?C0018
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	SETB 	C
	LCALL	?C?ULCMP
	JC   	?C0016
?C0018:
; 				{
			; SOURCE LINE # 550
; 					cShouldDelay = ( portCHAR ) pdTRUE;
			; SOURCE LINE # 551
?C0121:
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 				}
			; SOURCE LINE # 552
; 			}
			; SOURCE LINE # 553
?C0016:
; 
; 			/* Update the wake time ready for the next call. */
; 			*pxPreviousWakeTime = xTimeToWake;
			; SOURCE LINE # 556
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?LSTPTR
; 
; 			if( cShouldDelay )
			; SOURCE LINE # 558
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	JNZ  	$ + 5H
	AJMP 	?C0019
; 			{
			; SOURCE LINE # 559
; 				/* We must remove ourselves from the ready list before adding 
; 				ourselves to the blocked list as the same list item is used for 
; 				both lists. */
; 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 563
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 
; 				/* The list item will be inserted in wake time order. */
; 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
			; SOURCE LINE # 566
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
; 
; 				if( xTimeToWake < xTickCount )
			; SOURCE LINE # 568
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	JNC  	?C0020
; 				{
			; SOURCE LINE # 569
; 					/* Wake time has overflowed.  Place this item in the 
; 					overflow list. */
; 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 572
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxOverflowDelayedTaskList
; 				}
			; SOURCE LINE # 573
	SJMP 	?C0120
?C0020:
; 				else
; 				{
			; SOURCE LINE # 575
; 					/* The wake time has not overflowed, so we can use the 
; 					current block list. */
; 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 578
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxDelayedTaskList
?C0120:
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vListInsert
; 				}
			; SOURCE LINE # 579
; 			}
			; SOURCE LINE # 580
?C0019:
; 		}
			; SOURCE LINE # 581
; 		cAlreadyYielded = cTaskResumeAll();
			; SOURCE LINE # 582
	LCALL	_?cTaskResumeAll
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOV  	A,R7
	MOVX 	@DPTR,A
; 
; 		/* Force a reschedule if cTaskResumeAll has not already done so, we may 
; 		have put ourselves to sleep. */
; 		if( !cAlreadyYielded )
			; SOURCE LINE # 586
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	JNZ  	?C0023
; 		{
			; SOURCE LINE # 587
; 			taskYIELD(); 
			; SOURCE LINE # 588
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 589
; 	}
			; SOURCE LINE # 590
?C0023:
	MOV  	DPTR,#0DH
	LJMP 	?C?ADDXBP
; END OF _?vTaskDelayUntil

; #endif
; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskDelay == 1 )
; 	void vTaskDelay( portTickType xTicksToDelay ) reentrant

	RSEG  ?PR?_?vTaskDelay?TASKS
_?vTaskDelay:
	USING	0
			; SOURCE LINE # 595
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
	LCALL	?C?LSTXDATA
	MOV  	DPTR,#0FFFBH
	LCALL	?C?ADDXBP
; 	{
; 	portTickType xTimeToWake;
; 	signed portCHAR cAlreadyYielded = pdFALSE;
			; SOURCE LINE # 598
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	CLR  	A
	MOVX 	@DPTR,A
; 
; 		/* A delay time of zero just forces a reschedule. */
; 		if( xTicksToDelay > ( portTickType ) 0 )
			; SOURCE LINE # 601
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	SETB 	C
	LCALL	?C?ULCMP
	JNC  	$ + 5H
	AJMP 	?C0024
; 		{
			; SOURCE LINE # 602
; 			vTaskSuspendAll();
			; SOURCE LINE # 603
	LCALL	_?vTaskSuspendAll
; 			{
			; SOURCE LINE # 604
; 				/* A task that is removed from the event list while the 
; 				scheduler is suspended will not get placed in the ready 
; 				list or removed from the blocked list until the scheduler 
; 				is resumed.  
; 				
; 				This task cannot be in an event list as it is the currently 
; 				executing task. */
; 
; 				/* Calculate the time to wake - this may overflow but this is 
; 				not a problem. */
; 				xTimeToWake = xTickCount + xTicksToDelay;
			; SOURCE LINE # 615
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOV  	R7,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R6,A
	MOV  	A,R1
	ADDC 	A,R5
	MOV  	R5,A
	MOV  	A,R0
	ADDC 	A,R4
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	LCALL	?C?LSTXDATA
; 
; 				/* We must remove ourselves from the ready list before adding 
; 				ourselves to the blocked list as the same list item is used for 
; 				both lists. */
; 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 620
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 
; 				/* The list item will be inserted in wake time order. */
; 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
			; SOURCE LINE # 623
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
; 
; 				if( xTimeToWake < xTickCount )
			; SOURCE LINE # 625
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	JNC  	?C0025
; 				{
			; SOURCE LINE # 626
; 					/* Wake time has overflowed.  Place this item in the 
; 					overflow list. */
; 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 629
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxOverflowDelayedTaskList
; 				}
			; SOURCE LINE # 630
	SJMP 	?C0122
?C0025:
; 				else
; 				{
			; SOURCE LINE # 632
; 					/* The wake time has not overflowed, so we can use the 
; 					current block list. */
; 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 635
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxDelayedTaskList
?C0122:
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vListInsert
; 				}
			; SOURCE LINE # 636
?C0026:
; 			}
			; SOURCE LINE # 637
; 			cAlreadyYielded = cTaskResumeAll();
			; SOURCE LINE # 638
	LCALL	_?cTaskResumeAll
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOV  	A,R7
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 639
?C0024:
; 		
; 		/* Force a reschedule if cTaskResumeAll has not already done so, we may 
; 		have put ourselves to sleep. */
; 		if( !cAlreadyYielded )
			; SOURCE LINE # 643
	MOV  	DPTR,#04H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	JNZ  	?C0028
; 		{
			; SOURCE LINE # 644
; 			taskYIELD(); 
			; SOURCE LINE # 645
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 646
; 	}
			; SOURCE LINE # 647
?C0028:
	MOV  	DPTR,#09H
	LJMP 	?C?ADDXBP
; END OF _?vTaskDelay

; #endif
; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_ucTaskPriorityGet == 1 )
; 
; 	unsigned portCHAR ucTaskPriorityGet( xTaskHandle pxTask ) reentrant
; 	{
; 	tskTCB *pxTCB;
; 	unsigned portCHAR ucReturn;
; 
; 		taskENTER_CRITICAL();
; 		{
; 			/* If null is passed in here then we are changing the
; 			priority of the calling function. */
; 			pxTCB = prvGetTCBFromHandle( pxTask );
; 			ucReturn = pxTCB->ucPriority;
; 		}
; 		taskEXIT_CRITICAL();
; 
; 		return ucReturn;
; 	}
; 
; #endif
; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskPrioritySet == 1 )
; 
; 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portCHAR ucNewPriority ) reentrant
; 	{
; 	tskTCB *pxTCB;
; 	unsigned portCHAR ucCurrentPriority;
; 
; 		/* Ensure the new priority is valid. */
; 		if( ucNewPriority >= portMAX_PRIORITIES )
; 		{
; 			ucNewPriority = portMAX_PRIORITIES - ( unsigned portCHAR ) 1;
; 		}
; 
; 		taskENTER_CRITICAL();
; 		{
; 			/* If null is passed in here then we are changing the
; 			priority of the calling function. */
; 			pxTCB = prvGetTCBFromHandle( pxTask );
; 			ucCurrentPriority = pxTCB->ucPriority;
; 
; 			if( ucCurrentPriority != ucNewPriority )
; 			{
; 				pxTCB->ucPriority = ucNewPriority;
; 
; 				/* If the task is in the blocked or suspended list we need do 
; 				nothing more than change it's priority variable. However, if 
; 				the task is in a ready list it needs to be removed and placed 
; 				in the queue appropriate to its new priority. */
; 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ ucCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
; 				{
; 					/* The task is currently in its ready list - remove before adding
; 					it to it's new ready list. */
; 					vListRemove( &( pxTCB->xGenericListItem ) );
; 					prvAddTaskToReadyQueue( pxTCB );
; 				}			
; 			}
; 		}
; 		taskEXIT_CRITICAL();
; 
; 		/* The priority change may have readied a task of higher
; 		priority than the calling task. */
; 		taskYIELD();
; 	}
; 
; #endif
; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskSuspend == 1 )
; 
; 	void vTaskSuspend( xTaskHandle pxTaskToSuspend ) reentrant

	RSEG  ?PR?_?vTaskSuspend?TASKS
_?vTaskSuspend:
	USING	0
			; SOURCE LINE # 722
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; 	{
; 	tskTCB *pxTCB;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 		taskENTER_CRITICAL();
; 		{
			; SOURCE LINE # 727
; 			/* If null is passed in here then we are suspending ourselves. */
; 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
			; SOURCE LINE # 729
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	?C0029
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	SJMP 	?C0030
?C0029:
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
?C0030:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 			/* Remove task from the ready/delayed list and place in the	suspended list. */
; 			vListRemove( &( pxTCB->xGenericListItem ) );
			; SOURCE LINE # 732
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 
; 			/* Is the task waiting on an event also? */												
; 			if( pxTCB->xEventListItem.pvContainer )
			; SOURCE LINE # 735
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#036H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R2
	ORL  	A,R1
	ORL  	A,R3
	JZ   	?C0031
; 			{
			; SOURCE LINE # 736
; 				vListRemove( &( pxTCB->xEventListItem ) );
			; SOURCE LINE # 737
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 			}
			; SOURCE LINE # 738
?C0031:
; 
; 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
			; SOURCE LINE # 740
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	R3,#MBYTE (xSuspendedTaskList)
	MOV  	R2,#HIGH (xSuspendedTaskList)
	MOV  	R1,#LOW (xSuspendedTaskList)
	LCALL	_?vListInsertEnd
; 		}
			; SOURCE LINE # 741
; 		taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 		/* We may have just suspended the current task. */
; 		if( ( void * ) pxTaskToSuspend == NULL )
			; SOURCE LINE # 745
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	?C0033
; 		{
			; SOURCE LINE # 746
; 			taskYIELD();
			; SOURCE LINE # 747
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 748
; 	}
			; SOURCE LINE # 749
?C0033:
	MOV  	DPTR,#06H
	LJMP 	?C?ADDXBP
; END OF _?vTaskSuspend

; 
; #endif
; /*-----------------------------------------------------------*/
; 
; #if( INCLUDE_vTaskSuspend == 1 )
; 
; 	void vTaskResume( xTaskHandle pxTaskToResume )reentrant

	RSEG  ?PR?_?vTaskResume?TASKS
_?vTaskResume:
	USING	0
			; SOURCE LINE # 756
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFBH
	LCALL	?C?ADDXBP
; 	{
; 	tskTCB *pxTCB;
; 	portSHORT sYieldRequired;
; 
; 		/* Remove the task from whichever list it is currently in, and place
; 		it in the ready list. */
; 		pxTCB = ( tskTCB * ) pxTaskToResume;
			; SOURCE LINE # 763
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 		/* The parameter cannot be NULL as it is impossible to resume the
; 		currently executing task. */
; 		if( pxTCB != NULL )
			; SOURCE LINE # 767
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0039
; 		{
			; SOURCE LINE # 768
; 			taskENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 			{
			; SOURCE LINE # 770
; 				sYieldRequired = ( pxTCB->ucPriority >= pxCurrentTCB->ucPriority );
			; SOURCE LINE # 771
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	CLR  	C
	SUBB 	A,R7
	MOV  	R6,#00H
	JC   	?C0035
	MOV  	R7,#01H
	SJMP 	?C0036
?C0035:
	MOV  	R7,#00H
?C0036:
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 				vListRemove( &( pxTCB->xGenericListItem ) );
			; SOURCE LINE # 772
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 				prvAddTaskToReadyQueue( pxTCB );
			; SOURCE LINE # 773
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0037
	MOV  	A,R7
	MOVX 	@DPTR,A
?C0037:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
	LCALL	_?vListInsertEnd
; 			}
			; SOURCE LINE # 774
; 			taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 			/* We may have just resumed a higher priority task. */
; 			if( sYieldRequired )
			; SOURCE LINE # 778
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R6
	JZ   	?C0039
; 			{
			; SOURCE LINE # 779
; 				/* This yield may not cause the task just resumed to run, but
; 				will leave the lists in the correct state for the next yield. */
; 				taskYIELD();
			; SOURCE LINE # 782
	LCALL	_?vPortYield
; 			}
			; SOURCE LINE # 783
; 		}
			; SOURCE LINE # 784
; 	}
			; SOURCE LINE # 785
?C0039:
	MOV  	DPTR,#08H
	LJMP 	?C?ADDXBP
; END OF _?vTaskResume

; 
; #endif
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * PUBLIC SCHEDULER CONTROL documented in task.h
;  *----------------------------------------------------------*/
; 
; 
; void vTaskStartScheduler( portSHORT sUsePreemption )reentrant

	RSEG  ?PR?_?vTaskStartScheduler?TASKS
_?vTaskStartScheduler:
	USING	0
			; SOURCE LINE # 798
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
; 	/* Check a task has been created. */
; 	if( pxCurrentTCB != NULL )
			; SOURCE LINE # 801
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JZ   	?C0043
; 	{
			; SOURCE LINE # 802
; 		sUsingPreemption = sUsePreemption;
			; SOURCE LINE # 803
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	MOV  	DPTR,#sUsingPreemption
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R3
	MOVX 	@DPTR,A
; 
; 		/* Interrupts are turned off here, to ensure a tick does not occur
; 		before or during the call to sPortStartScheduler().  The stacks of 
; 		the created tasks contain a status word with interrupts switched on
; 		so interrupts will automatically get re-enabled when the first task
; 		starts to run.
; 		
; 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
; 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
; 		portDISABLE_INTERRUPTS();
			; SOURCE LINE # 813
	CLR  	EA
; 
; 		cSchedulerRunning = pdTRUE;
			; SOURCE LINE # 815
	MOV  	DPTR,#cSchedulerRunning
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 		xTickCount = ( portTickType ) 0;
			; SOURCE LINE # 816
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#xTickCount
	LCALL	?C?LSTXDATA
; 
; 		/* Setting up the timer tick is hardware specific and thus in the 
; 		portable interface. */
; 		if( sPortStartScheduler( sUsePreemption ) )
			; SOURCE LINE # 820
	MOV  	R7,AR3
	MOV  	R6,AR2
	LCALL	_?sPortStartScheduler
; 		{
			; SOURCE LINE # 821
; 			/* Should not reach here as if the scheduler is running the
; 			function will not return. */
; 		}
			; SOURCE LINE # 824
?C0041:
; 		else
; 		{
			; SOURCE LINE # 826
; 			/* Should only reach here if a task calls sTaskEndScheduler(). */
; 		}
			; SOURCE LINE # 828
; 	}
			; SOURCE LINE # 829
; }
			; SOURCE LINE # 830
?C0043:
	MOV  	DPTR,#02H
	LJMP 	?C?ADDXBP
; END OF _?vTaskStartScheduler

; /*-----------------------------------------------------------*/
; 
; void vTaskEndScheduler( void ) reentrant

	RSEG  ?PR?_?vTaskEndScheduler?TASKS
_?vTaskEndScheduler:
	USING	0
			; SOURCE LINE # 833
; {
; 	/* Stop the scheduler interrupts and call the portable scheduler end 
; 	routine so the original ISRs can be restored if necessary.  The port
; 	layer must ensure interrupts enable	bit is left in the correct state. */
; 	portDISABLE_INTERRUPTS();
			; SOURCE LINE # 838
	CLR  	EA
; 	cSchedulerRunning = pdFALSE;
			; SOURCE LINE # 839
	CLR  	A
	MOV  	DPTR,#cSchedulerRunning
	MOVX 	@DPTR,A
; 	vPortEndScheduler();
			; SOURCE LINE # 840
	LJMP 	_?vPortEndScheduler
; END OF _?vTaskEndScheduler

; }
; /*----------------------------------------------------------*/
; 
; void vTaskSuspendAll( void ) reentrant

	RSEG  ?PR?_?vTaskSuspendAll?TASKS
_?vTaskSuspendAll:
	USING	0
			; SOURCE LINE # 844
; {
; 	portENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 		++ucSchedulerSuspended;
			; SOURCE LINE # 847
	MOV  	DPTR,#ucSchedulerSuspended
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 	portEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; }
			; SOURCE LINE # 849
	RET  	
; END OF _?vTaskSuspendAll

; /*----------------------------------------------------------*/
; 
; signed portCHAR cTaskResumeAll( void ) reentrant

	RSEG  ?PR?_?cTaskResumeAll?TASKS
_?cTaskResumeAll:
	USING	0
			; SOURCE LINE # 852
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
; {
; register tskTCB *pxTCB;
; signed portCHAR cAlreadyYielded = ( signed portCHAR ) pdFALSE;
			; SOURCE LINE # 855
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	CLR  	A
	MOVX 	@DPTR,A
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	/* It is possible that an ISR caused a task to be removed from an event
; 	list while the scheduler was suspended.  If this was the case then the
; 	removed task will have been added to the xPendingReadyList.  Once the
; 	scheduler has been resumed it is safe to move all the pending ready
; 	tasks from this list into their appropriate ready list. */
; 	portENTER_CRITICAL();
; 	{
			; SOURCE LINE # 863
; 		--ucSchedulerSuspended;
			; SOURCE LINE # 864
	MOV  	DPTR,#ucSchedulerSuspended
	MOVX 	A,@DPTR
	DEC  	A
	MOVX 	@DPTR,A
; 
; 		if( ucSchedulerSuspended == pdFALSE )
			; SOURCE LINE # 866
	MOVX 	A,@DPTR
	JZ   	$ + 5H
	AJMP 	?C0046
; 		{
			; SOURCE LINE # 867
; 			if( usCurrentNumberOfTasks > ( unsigned portSHORT ) 0 )
			; SOURCE LINE # 868
	SETB 	C
	MOV  	DPTR,#usCurrentNumberOfTasks+01H
	MOVX 	A,@DPTR
	SUBB 	A,#00H
	MOV  	DPTR,#usCurrentNumberOfTasks
	MOVX 	A,@DPTR
	SUBB 	A,#00H
	JNC  	$ + 5H
	AJMP 	?C0046
; 			{
			; SOURCE LINE # 869
?C0048:
; 				/* Move any readied tasks from the pending list into the 
; 				appropriate ready list. */
; 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
			; SOURCE LINE # 872
	MOV  	DPTR,#xPendingReadyList
	MOVX 	A,@DPTR
	JNZ  	?C0113
	INC  	DPTR
	MOVX 	A,@DPTR
?C0113:
	JZ   	?C0050
	MOV  	DPTR,#xPendingReadyList+02H
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#04H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	SJMP 	?C0051
?C0050:
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#00H
?C0051:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0049
; 				{
			; SOURCE LINE # 873
; 					vListRemove( &( pxTCB->xEventListItem ) );
			; SOURCE LINE # 874
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 					vListRemove( &( pxTCB->xGenericListItem ) );
			; SOURCE LINE # 875
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 					prvAddTaskToReadyQueue( pxTCB );
			; SOURCE LINE # 876
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0052
	MOV  	A,R7
	MOVX 	@DPTR,A
?C0052:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
	LCALL	_?vListInsertEnd
; 				}
			; SOURCE LINE # 877
	AJMP 	?C0048
?C0049:
; 
; 				/* If any ticks occurred while the scheduler was suspended then
; 				they should be processed now.  This ensures the tick count does not
; 				slip, and that any delayed tasks are resumed at the correct time. */
; 				if( ucMissedTicks > 0 )
			; SOURCE LINE # 882
	MOV  	DPTR,#ucMissedTicks
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#00H
	JC   	?C0046
; 				{
			; SOURCE LINE # 883
?C0054:
; 					while( ucMissedTicks > 0 )
			; SOURCE LINE # 884
	MOV  	DPTR,#ucMissedTicks
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#00H
	JC   	?C0055
; 					{
			; SOURCE LINE # 885
; 						vTaskIncrementTick();
			; SOURCE LINE # 886
	LCALL	_?vTaskIncrementTick
; 						--ucMissedTicks;
			; SOURCE LINE # 887
	MOV  	DPTR,#ucMissedTicks
	MOVX 	A,@DPTR
	DEC  	A
	MOVX 	@DPTR,A
; 					}
			; SOURCE LINE # 888
	SJMP 	?C0054
?C0055:
; 
; 					/* As we have processed some ticks it is appropriate to yield
; 					to ensure the highest priority task that is ready to run is
; 					the task actually running. */
; 					cAlreadyYielded = ( signed portCHAR ) pdTRUE;
			; SOURCE LINE # 893
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 					taskYIELD();
			; SOURCE LINE # 894
	LCALL	_?vPortYield
; 				}
			; SOURCE LINE # 895
; 			}
			; SOURCE LINE # 896
; 		}
			; SOURCE LINE # 897
?C0046:
; 	}
			; SOURCE LINE # 898
; 	portEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return cAlreadyYielded;
			; SOURCE LINE # 901
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 902
?C0056:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?cTaskResumeAll

; 
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * PUBLIC TASK UTILITIES documented in task.h
;  *----------------------------------------------------------*/
; 
; 
; 
; volatile portTickType xTaskGetTickCount( void ) reentrant

	RSEG  ?PR?_?xTaskGetTickCount?TASKS
_?xTaskGetTickCount:
	USING	0
			; SOURCE LINE # 915
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
; {
; portTickType xTicks;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	/* Critical section required if running on a 16 bit processor. */
; 	taskENTER_CRITICAL();
; 	{
			; SOURCE LINE # 921
; 		xTicks = xTickCount;
			; SOURCE LINE # 922
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	LCALL	?C?LSTXDATA
; 	}
			; SOURCE LINE # 923
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return xTicks;
			; SOURCE LINE # 926
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 927
?C0057:
	MOV  	DPTR,#04H
	LJMP 	?C?ADDXBP
; END OF _?xTaskGetTickCount

; /*-----------------------------------------------------------*/
; 
; unsigned portSHORT usTaskGetNumberOfTasks( void ) reentrant

	RSEG  ?PR?_?usTaskGetNumberOfTasks?TASKS
_?usTaskGetNumberOfTasks:
	USING	0
			; SOURCE LINE # 930
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
; {
; unsigned portSHORT usNumberOfTasks;
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 
; 	taskENTER_CRITICAL();
; 		usNumberOfTasks = usCurrentNumberOfTasks;
			; SOURCE LINE # 935
	MOV  	DPTR,#usCurrentNumberOfTasks
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R7
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	taskEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 
; 	return usNumberOfTasks;
			; SOURCE LINE # 938
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 939
?C0058:
	MOV  	DPTR,#02H
	LJMP 	?C?ADDXBP
; END OF _?usTaskGetNumberOfTasks

; /*-----------------------------------------------------------*/
; 
; #if( ( USE_TRACE_FACILITY == 1 ) && ( INCLUDE_vTaskDelete == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
; 
; 	void vTaskList( signed portCHAR *pcWriteBuffer ) reentrant
; 	{
; 	unsigned portSHORT usQueue;
; 
; 		/* This is a VERY costly function that should be used for debug only.
; 		It leaves interrupts disabled for a LONG time. */
; 
; 		taskENTER_CRITICAL();
; 		{
; 			/* Run through all the lists that could potentially contain a TCB and
; 			report the task name, state and stack high water mark. */
; 
; 			pcWriteBuffer[ 0 ] = ( signed portCHAR ) 0x00;
; 			strcat( pcWriteBuffer, ( const signed portCHAR * ) "\r\n" );
; 
; 			usQueue = ( unsigned portSHORT ) ucTopUsedPriority + ( unsigned portSHORT ) 1;
; 
; 			do
; 			{
; 				usQueue--;
; 
; 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
; 				{
; 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ usQueue ] ), tskREADY_CHAR );			
; 				}
; 			}while( usQueue > ( unsigned portSHORT ) tskIDLE_PRIORITY );
; 
; 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
; 			{
; 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
; 			}
; 
; 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
; 			{
; 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
; 			}
; 
; 			if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
; 			{
; 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_CHAR );
; 			}
; 
; 			if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
; 			{
; 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR );
; 			}
; 		}
; 		taskEXIT_CRITICAL();
; 	}
; 
; #endif
; /*----------------------------------------------------------*/
; 
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	void vTaskStartTrace( signed portCHAR * pcBuffer, unsigned portSHORT usBufferSize ) reentrant
; 	{
; 		portENTER_CRITICAL();
; 		{
; 			pcTraceBuffer = ( volatile signed portCHAR * volatile )pcBuffer;
; 			pcTraceBufferStart = pcBuffer;
; 			pcTraceBufferEnd = pcBuffer + usBufferSize - tskSIZE_OF_EACH_TRACE_LINE;
; 			cTracing = ( signed portCHAR ) pdTRUE;
; 		}
; 		portEXIT_CRITICAL();
; 	}
; 
; #endif
; /*----------------------------------------------------------*/
; 
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	unsigned portSHORT usTaskEndTrace( void ) reentrant
; 	{
; 	unsigned portSHORT usBufferLength;
; 
; 		portENTER_CRITICAL();
; 			cTracing = ( signed portCHAR ) pdFALSE;
; 		portEXIT_CRITICAL();
; 
; 		usBufferLength = ( unsigned portSHORT ) ( pcTraceBuffer - pcTraceBufferStart );
; 
; 		return usBufferLength;
; 	}
; 
; #endif
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
;  * documented in task.h
;  *----------------------------------------------------------*/
; 
; 
; inline void vTaskIncrementTick( void ) reentrant

	RSEG  ?PR?_?vTaskIncrementTick?TASKS
_?vTaskIncrementTick:
	USING	0
			; SOURCE LINE # 1041
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
; 	/* Called by the portable layer each time a tick interrupt occurs.
; 	Increments the tick then checks to see if the new tick value will cause any
; 	tasks to be unblocked. */
; 	if( ucSchedulerSuspended == ( unsigned portCHAR ) pdFALSE )
			; SOURCE LINE # 1046
	MOV  	DPTR,#ucSchedulerSuspended
	MOVX 	A,@DPTR
	JZ   	$ + 5H
	AJMP 	?C0059
; 	{
			; SOURCE LINE # 1047
; 		++xTickCount;
			; SOURCE LINE # 1048
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#01H
	MOV  	R7,A
	CLR  	A
	ADDC 	A,R6
	MOV  	R6,A
	CLR  	A
	ADDC 	A,R5
	MOV  	R5,A
	CLR  	A
	ADDC 	A,R4
	MOV  	R4,A
	MOV  	DPTR,#xTickCount
	LCALL	?C?LSTXDATA
; 		if( xTickCount == ( portTickType ) 0 )
			; SOURCE LINE # 1049
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	JNZ  	?C0061
; 		{
			; SOURCE LINE # 1050
; 			volatile xList *pxTemp;
; 
; 			/* Tick count has overflowed so we need to swap the delay lists.  If there are
; 			any items in pxDelayedTaskList here then there is an error! */
; 			pxTemp = pxDelayedTaskList;
			; SOURCE LINE # 1055
	MOV  	DPTR,#pxDelayedTaskList
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 			pxDelayedTaskList = pxOverflowDelayedTaskList;
			; SOURCE LINE # 1056
	MOV  	DPTR,#pxOverflowDelayedTaskList
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#pxDelayedTaskList
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 			pxOverflowDelayedTaskList = pxTemp;
			; SOURCE LINE # 1057
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#pxOverflowDelayedTaskList
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 1058
; 
; 		/* See if this tick has made a timeout expire. */
; 		prvCheckDelayedTasks();
			; SOURCE LINE # 1061
?C0061:
	MOV  	DPTR,#pxDelayedTaskList
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	JZ   	?C0063
	MOV  	A,R1
	ADD  	A,#02H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,#04H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	SJMP 	?C0064
?C0063:
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#00H
?C0064:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0069
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LLDPTR
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	JNC  	$ + 5H
	AJMP 	?C0069
?C0065:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#036H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R2
	ORL  	A,R1
	ORL  	A,R3
	JZ   	?C0066
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
?C0066:
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0067
	MOV  	A,R7
	MOVX 	@DPTR,A
?C0067:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
	LCALL	_?vListInsertEnd
	AJMP 	?C0061
; 	}
			; SOURCE LINE # 1062
?C0059:
; 	else
; 	{
			; SOURCE LINE # 1064
; 		++ucMissedTicks;
			; SOURCE LINE # 1065
	MOV  	DPTR,#ucMissedTicks
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1066
; 
; 	#if ( configUSE_TICK_HOOK == 1 )
; 	{
; 		extern void vApplicationTickHook( void );
; 
; 		vApplicationTickHook();
; 	}
; 	#endif
; 
; }
			; SOURCE LINE # 1076
?C0069:
	MOV  	DPTR,#03H
	LJMP 	?C?ADDXBP
; END OF _?vTaskIncrementTick

; /*-----------------------------------------------------------*/
; 
; #if( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
; 
; 	void vTaskCleanUpResources( void ) reentrant
; 	{
; 	unsigned portSHORT usQueue;
; 	volatile tskTCB *pxTCB;
; 
; 		usQueue = ( unsigned portSHORT ) ucTopUsedPriority + ( unsigned portSHORT ) 1;
; 
; 		/* Remove any TCB's from the ready queues. */
; 		do
; 		{
; 			usQueue--;
; 
; 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
; 			{
; 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) )
; 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
; 
; 				prvDeleteTCB( ( tskTCB * ) pxTCB );
; 			}
; 		}while( usQueue > ( unsigned portSHORT ) tskIDLE_PRIORITY );
; 
; 		/* Remove any TCB's from the delayed queue. */
; 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
; 		{
; 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
; 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
; 
; 			prvDeleteTCB( ( tskTCB * ) pxTCB );
; 		}
; 
; 		/* Remove any TCB's from the overflow delayed queue. */
; 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
; 		{
; 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
; 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
; 
; 			prvDeleteTCB( ( tskTCB * ) pxTCB );
; 		}
; 
; 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
; 		{
; 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
; 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
; 
; 			prvDeleteTCB( ( tskTCB * ) pxTCB );
; 		}		
; 
; 		while( !listLIST_IS_EMPTY( &xPendingReadyList ) )
; 		{
; 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xPendingReadyList );
; 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
; 
; 			prvDeleteTCB( ( tskTCB * ) pxTCB );
; 		}		
; 	}
; 
; #endif
; /*-----------------------------------------------------------*/
; 
; inline void vTaskSwitchContext( void ) reentrant

	RSEG  ?PR?_?vTaskSwitchContext?TASKS
_?vTaskSwitchContext:
	USING	0
			; SOURCE LINE # 1140
; {
; 	if( ucSchedulerSuspended != pdFALSE )
			; SOURCE LINE # 1142
	MOV  	DPTR,#ucSchedulerSuspended
	MOVX 	A,@DPTR
	JZ   	$ + 5H
	AJMP 	?C0071
; 	{
			; SOURCE LINE # 1143
; 		/* The scheduler is currently suspended - do not allow a context
; 		switch. */
; 		return;
; 	}
			; SOURCE LINE # 1147
?C0070:
?C0072:
; 
; 	/* Find the highest priority queue that contains ready tasks. */
; 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ ucTopReadyPriority ] ) ) )
			; SOURCE LINE # 1150
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R6
	JNZ  	?C0073
; 	{
			; SOURCE LINE # 1151
; 		--ucTopReadyPriority;
			; SOURCE LINE # 1152
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	DEC  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1153
	SJMP 	?C0072
?C0073:
; 
; 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
; 	same priority get an equal share of the processor time. */
; 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ ucTopReadyPriority ] ) );
			; SOURCE LINE # 1157
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#04H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+02H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+02H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	POP  	DPL
	POP  	DPH
	POP  	ACC
	XRL  	A,R3
	JNZ  	?C0116
	MOV  	A,R1
	XRL  	A,DPL
	JNZ  	?C0116
	MOV  	A,R2
	XRL  	A,DPH
?C0116:
	JNZ  	?C0074
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#04H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
?C0074:
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists+05H)
	MOV  	DPL,A
	MOV  	A,B
	ADDC 	A,#HIGH (pxReadyTasksLists+05H)
	MOV  	DPH,A
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	DPTR,#pxCurrentTCB
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 	vWriteTraceToBuffer();
; }
			; SOURCE LINE # 1159
?C0071:
	RET  	
; END OF _?vTaskSwitchContext

; /*-----------------------------------------------------------*/
; 
; void vTaskPlaceOnEventList( xList *pxEventList, portTickType xTicksToWait ) reentrant

	RSEG  ?PR?_?vTaskPlaceOnEventList?TASKS
_?vTaskPlaceOnEventList:
	USING	0
			; SOURCE LINE # 1162
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
	LCALL	?C?LSTXDATA
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFCH
	LCALL	?C?ADDXBP
; {
; portTickType xTimeToWake;
; 
; 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
; 	SCHEDULER SUSPENDED. */
; 
; 	/* Place the event list item of the TCB in the appropriate event list.
; 	This is placed in the list in priority order so the highest priority task
; 	is the first to be woken by the event. */
; 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
			; SOURCE LINE # 1172
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vListInsert
; 
; 	/* Calculate the time at which the task should be woken if the event does
; 	not occur.  This may overflow but this doesn't matter. */
; 	xTimeToWake = xTickCount + xTicksToWait;
			; SOURCE LINE # 1176
	MOV  	DPTR,#07H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOV  	R7,A
	MOV  	A,R2
	ADDC 	A,R6
	MOV  	R6,A
	MOV  	A,R1
	ADDC 	A,R5
	MOV  	R5,A
	MOV  	A,R0
	ADDC 	A,R4
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	LCALL	?C?LSTXDATA
; 
; 	/* We must remove ourselves from the ready list before adding ourselves
; 	to the blocked list as the same list item is used for both lists.  We have
; 	exclusive access to the ready lists as the scheduler is locked. */
; 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 1181
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 
; 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
			; SOURCE LINE # 1183
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
; 
; 	if( xTimeToWake < xTickCount )
			; SOURCE LINE # 1185
	MOV  	DPTR,#xTickCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R0,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R3,A
	CLR  	C
	LCALL	?C?ULCMP
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	JNC  	?C0075
; 	{
			; SOURCE LINE # 1186
; 		/* Wake time has overflowed.  Place this item in the overflow list. */
; 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 1188
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxOverflowDelayedTaskList
; 	}
			; SOURCE LINE # 1189
	SJMP 	?C0123
?C0075:
; 	else
; 	{
			; SOURCE LINE # 1191
; 		/* The wake time has not overflowed, so we can use the current block list. */
; 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			; SOURCE LINE # 1193
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#pxDelayedTaskList
?C0123:
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vListInsert
; 	}
			; SOURCE LINE # 1194
; }
			; SOURCE LINE # 1195
?C0077:
	MOV  	DPTR,#0BH
	LJMP 	?C?ADDXBP
; END OF _?vTaskPlaceOnEventList

; /*-----------------------------------------------------------*/
; 
; signed portCHAR cTaskRemoveFromEventList( const xList *pxEventList ) reentrant

	RSEG  ?PR?_?cTaskRemoveFromEventList?TASKS
_?cTaskRemoveFromEventList:
	USING	0
			; SOURCE LINE # 1198
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
; tskTCB *pxUnblockedTCB;
; 
; 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
; 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
; 
; 	/* The event list is sorted in priority order, so we can remove the 
; 	first in the list, remove the TCB from the delayed list, and add
; 	it to the ready list. 
; 	
; 	If an event is for a queue that is locked then this function will never
; 	get called - the lock count on the queue will get modified instead.  This
; 	means we can always expect exclusive access to the event list here. */
; 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
			; SOURCE LINE # 1212
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?ILDPTR
	ORL  	A,B
	JZ   	?C0078
	MOV  	A,R1
	ADD  	A,#02H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,#04H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	SJMP 	?C0079
?C0078:
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#00H
?C0079:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
			; SOURCE LINE # 1213
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 
; 	if( ucSchedulerSuspended == ( unsigned portCHAR ) pdFALSE )
			; SOURCE LINE # 1215
	MOV  	DPTR,#ucSchedulerSuspended
	MOVX 	A,@DPTR
	JZ   	$ + 5H
	AJMP 	?C0080
; 	{
			; SOURCE LINE # 1216
; 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
			; SOURCE LINE # 1217
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListRemove
; 		prvAddTaskToReadyQueue( pxUnblockedTCB );
			; SOURCE LINE # 1218
	CLR  	A
	MOV  	R7,A
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPTR,#ucTopReadyPriority
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	A,R7
	SETB 	C
	SUBB 	A,R6
	JC   	?C0081
	MOV  	A,R7
	MOVX 	@DPTR,A
?C0081:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
; 	}
			; SOURCE LINE # 1219
	SJMP 	?C0124
?C0080:
; 	else
; 	{
			; SOURCE LINE # 1221
; 		/* We cannot access the delayed or ready lists, so will hold this
; 		task pending until the scheduler is resumed. */
; 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
			; SOURCE LINE # 1224
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	R3,#MBYTE (xPendingReadyList)
	MOV  	R2,#HIGH (xPendingReadyList)
	MOV  	R1,#LOW (xPendingReadyList)
?C0124:
	LCALL	_?vListInsertEnd
; 	}
			; SOURCE LINE # 1225
?C0082:
; 
; 	if( pxUnblockedTCB->ucPriority > pxCurrentTCB->ucPriority )
			; SOURCE LINE # 1227
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?CLDPTR
	SETB 	C
	SUBB 	A,R7
	MOV  	R7,#00H
	JC   	?C0083
; 	{
			; SOURCE LINE # 1228
; 		/* Return true if the task removed from the event list has
; 		a higher priority than the calling task.  This allows
; 		the calling task to know if it should force a context 
; 		switch now. */
; 		return ( signed portCHAR ) pdTRUE;
			; SOURCE LINE # 1233
	MOV  	R7,#01H
; 	}
			; SOURCE LINE # 1234
?C0083:
; 	else
; 	{
			; SOURCE LINE # 1236
; 		return ( signed portCHAR ) pdFALSE;
			; SOURCE LINE # 1237
; 	}
			; SOURCE LINE # 1238
; }
			; SOURCE LINE # 1239
?C0084:
	MOV  	DPTR,#06H
	LJMP 	?C?ADDXBP
; END OF _?cTaskRemoveFromEventList

; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * The Idle task.
;  *----------------------------------------------------------*/
; 
; static void prvIdleTask( void *pvParameters ) reentrant

	RSEG  ?PR?_?prvIdleTask?TASKS
_?prvIdleTask:
	USING	0
			; SOURCE LINE # 1249
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	/* Stop warnings. */
; 	pvParameters = pvParameters;
			; SOURCE LINE # 1252
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 	for( ;; )
			; SOURCE LINE # 1254
?C0086:
; 	{
			; SOURCE LINE # 1255
; 		/* See if any tasks have been deleted. */
; 		prvCheckTasksWaitingTermination();
			; SOURCE LINE # 1257
	LCALL	_?prvCheckTasksWaitingTermination
; 
; 		if( sUsingPreemption == pdFALSE )
			; SOURCE LINE # 1259
	MOV  	DPTR,#sUsingPreemption
	MOVX 	A,@DPTR
	JNZ  	?C0117
	INC  	DPTR
	MOVX 	A,@DPTR
?C0117:
	JNZ  	?C0086
; 		{
			; SOURCE LINE # 1260
; 			/* If we are not using preemption we keep forcing a task switch to
; 			see if any other task has become available.  If we are using 
; 			preemption we don't need to do this as any task becoming available
; 			will automatically get the processor anyway. */
; 			taskYIELD();	
			; SOURCE LINE # 1265
	LCALL	_?vPortYield
; 		}
			; SOURCE LINE # 1266
; 	}
			; SOURCE LINE # 1267
	SJMP 	?C0086
; END OF _?prvIdleTask

; } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
; 
; 
; 
; 
; 
; 
; 
; /*-----------------------------------------------------------
;  * File private functions documented at the top of the file.
;  *----------------------------------------------------------*/
; 
; 
; 
; static void prvInitialiseTCBVariables( tskTCB *pxTCB, unsigned portSHORT usStackDepth, const signed portCHAR * const pcName, unsigned portCHAR ucPriority ) reentrant

	RSEG  ?PR?_?prvInitialiseTCBVariables?TASKS
_?prvInitialiseTCBVariables:
	USING	0
			; SOURCE LINE # 1282
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R4
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R5
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	pxTCB->usStackDepth = usStackDepth;
			; SOURCE LINE # 1284
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#06H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R6
	MOV  	B,R7
	LCALL	?C?ISTPTR
; 
; 	/* Make sure the name is not too long before copying it into the TCB. */
; 	if( strlen( pcName ) < ( unsigned portSHORT ) tskMAX_TASK_NAME_LEN )
			; SOURCE LINE # 1287
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_strlen
	CLR  	C
	MOV  	A,R7
	SUBB 	A,#010H
	MOV  	A,R6
	SUBB 	A,#00H
	JNC  	?C0090
; 	{
			; SOURCE LINE # 1288
; 		portENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 			strcpy( pxTCB->pcTaskName, pcName );
			; SOURCE LINE # 1290
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R0,AR1
	MOV  	R4,A
	MOV  	R5,AR3
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	?C?STRCPY
; 		portEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 	}
			; SOURCE LINE # 1292
	SJMP 	?C0091
?C0090:
; 	else
; 	{
			; SOURCE LINE # 1294
; 		portENTER_CRITICAL();
	 DB 0A2H, 0AFH, 0C2H, 0AFH, 0C0H, 0D0H;
; 			strncpy( pxTCB->pcTaskName, pcName, ( unsigned portSHORT ) tskMAX_TASK_NAME_LEN );
			; SOURCE LINE # 1296
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#08H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#05H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#?_strncpy?BYTE+03H
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	CLR  	A
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#010H
	MOVX 	@DPTR,A
	POP  	AR1
	POP  	AR2
	POP  	AR3
	LCALL	_strncpy
; 		portEXIT_CRITICAL();
	 DB 0D0H, 0D0H, 092H, 0AFH;
; 		pxTCB->pcTaskName[ ( unsigned portSHORT ) tskMAX_TASK_NAME_LEN - ( unsigned portSHORT ) 1 ] = '\0';
			; SOURCE LINE # 1298
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#017H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	CLR  	A
	LCALL	?C?CSTPTR
; 	}
			; SOURCE LINE # 1299
?C0091:
; 
; 	/* This is used as an array index so must ensure it's not too large. */
; 	if( ucPriority >= ( unsigned portCHAR ) portMAX_PRIORITIES )
			; SOURCE LINE # 1302
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	CLR  	C
	SUBB 	A,#0FH
	JC   	?C0092
; 	{
			; SOURCE LINE # 1303
; 		ucPriority = ( unsigned portCHAR ) portMAX_PRIORITIES - ( unsigned portCHAR ) 1;
			; SOURCE LINE # 1304
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	MOV  	A,#0EH
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1305
?C0092:
; 	pxTCB->ucPriority = ucPriority;
			; SOURCE LINE # 1306
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#018H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 
; 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
			; SOURCE LINE # 1308
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListInitialiseItem
; 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
			; SOURCE LINE # 1309
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	_?vListInitialiseItem
; 
; 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get 
; 	back to	the containing TCB from a generic item in a list. */
; 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
			; SOURCE LINE # 1313
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#019H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R1
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 
; 	/* Event lists are always in priority order. */
; 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) ucPriority );
			; SOURCE LINE # 1316
	MOV  	DPTR,#08H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R7,A
	CLR  	A
	MOV  	R4,A
	MOV  	R5,A
	MOV  	R6,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?LSTPTR
; 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
			; SOURCE LINE # 1317
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#029H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	MOV  	A,R1
	ADD  	A,#0AH
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; }
			; SOURCE LINE # 1318
	MOV  	DPTR,#09H
	LJMP 	?C?ADDXBP
; END OF _?prvInitialiseTCBVariables

; /*-----------------------------------------------------------*/
; 
; static portSHORT prvInitialiseTaskLists( void ) reentrant

	RSEG  ?PR?_?prvInitialiseTaskLists?TASKS
_?prvInitialiseTaskLists:
	USING	0
			; SOURCE LINE # 1321
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
; register unsigned portCHAR ucPriority;
; portSHORT sReturn;
; 
; 	for( ucPriority = ( unsigned portCHAR) 0; ucPriority < ( unsigned portCHAR ) portMAX_PRIORITIES; ucPriority++ )
			; SOURCE LINE # 1326
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
?C0094:
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
	CLR  	C
	SUBB 	A,#0FH
	JNC  	?C0095
; 	{
			; SOURCE LINE # 1327
; 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ ucPriority ] ) );
			; SOURCE LINE # 1328
	MOV  	A,R7
	MOV  	B,#018H
	MUL  	AB
	ADD  	A,#LOW (pxReadyTasksLists)
	MOV  	R1,A
	MOV  	A,#HIGH (pxReadyTasksLists)
	ADDC 	A,B
	MOV  	R2,A
	MOV  	R3,#MBYTE (pxReadyTasksLists)
	LCALL	_?vListInitialise
; 	}
			; SOURCE LINE # 1329
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	SJMP 	?C0094
?C0095:
; 
; 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
			; SOURCE LINE # 1331
	MOV  	R3,#MBYTE (xDelayedTaskList1)
	MOV  	R2,#HIGH (xDelayedTaskList1)
	MOV  	R1,#LOW (xDelayedTaskList1)
	LCALL	_?vListInitialise
; 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
			; SOURCE LINE # 1332
	MOV  	R3,#MBYTE (xDelayedTaskList2)
	MOV  	R2,#HIGH (xDelayedTaskList2)
	MOV  	R1,#LOW (xDelayedTaskList2)
	LCALL	_?vListInitialise
; 	vListInitialise( ( xList * ) &xPendingReadyList );
			; SOURCE LINE # 1333
	MOV  	R3,#MBYTE (xPendingReadyList)
	MOV  	R2,#HIGH (xPendingReadyList)
	MOV  	R1,#LOW (xPendingReadyList)
	LCALL	_?vListInitialise
; 
; 	#if( INCLUDE_vTaskDelete == 1 )
; 	{
; 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
; 	}
; 	#endif
; 
; 	#if( INCLUDE_vTaskSuspend == 1 )
; 	{
			; SOURCE LINE # 1342
; 		vListInitialise( ( xList * ) &xSuspendedTaskList );
			; SOURCE LINE # 1343
	MOV  	R3,#MBYTE (xSuspendedTaskList)
	MOV  	R2,#HIGH (xSuspendedTaskList)
	MOV  	R1,#LOW (xSuspendedTaskList)
	LCALL	_?vListInitialise
; 	}
			; SOURCE LINE # 1344
; 	#endif
; 
; 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList 
; 	using list2. */
; 	pxDelayedTaskList = &xDelayedTaskList1;
			; SOURCE LINE # 1349
	MOV  	DPTR,#pxDelayedTaskList
	MOV  	A,#MBYTE (xDelayedTaskList1)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (xDelayedTaskList1)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (xDelayedTaskList1)
	MOVX 	@DPTR,A
; 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
			; SOURCE LINE # 1350
	MOV  	DPTR,#pxOverflowDelayedTaskList
	MOV  	A,#MBYTE (xDelayedTaskList2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (xDelayedTaskList2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (xDelayedTaskList2)
	MOVX 	@DPTR,A
; 
; 	/* Add the idle task at the lowest priority. */
; 	sReturn = sTaskCreate( prvIdleTask, ( const portCHAR * const ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
			; SOURCE LINE # 1353
	MOV  	R3,#00H
	MOV  	R2,#00H
	MOV  	R1,#00H
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFFH
	LCALL	?C?ADDXBP
	CLR  	A
	MOVX 	@DPTR,A
	MOV  	R3,A
	MOV  	R2,A
	MOV  	R1,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	CLR  	C
	CLR  	A
	SUBB 	A,#LOW (STACK_START)
	MOV  	R7,A
	MOV  	A,#04H
	SUBB 	A,#HIGH (STACK_START)
	MOV  	R6,A
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
	MOV  	R3,#MBYTE (?SC_0)
	MOV  	R2,#HIGH (?SC_0)
	MOV  	R1,#LOW (?SC_0)
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	R3,#MBYTE (_?prvIdleTask)
	MOV  	R2,#HIGH (_?prvIdleTask)
	MOV  	R1,#LOW (_?prvIdleTask)
	LCALL	_?sTaskCreate
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 
; 	return sReturn;
			; SOURCE LINE # 1355
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	INC  	DPTR
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 1356
?C0097:
	MOV  	DPTR,#03H
	LJMP 	?C?ADDXBP
; END OF _?prvInitialiseTaskLists

; /*-----------------------------------------------------------*/
; 
; static void prvCheckTasksWaitingTermination( void ) reentrant

	RSEG  ?PR?_?prvCheckTasksWaitingTermination?TASKS
_?prvCheckTasksWaitingTermination:
	USING	0
			; SOURCE LINE # 1359
; {							
; 	#if( INCLUDE_vTaskDelete == 1 )
; 	{				
; 		portSHORT sListIsEmpty;
; 
; 		vTaskSuspendAll();
; 			sListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
; 		cTaskResumeAll();
; 
; 		if( !sListIsEmpty )
; 		{
; 			tskTCB *pxTCB;
; 
; 			portENTER_CRITICAL();
; 			{			
; 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
; 				vListRemove( &( pxTCB->xGenericListItem ) );
; 				--usCurrentNumberOfTasks;
; 			}
; 			portEXIT_CRITICAL();
; 
; 			prvDeleteTCB( pxTCB );
; 		}
; 	}
; 	#endif
; }
			; SOURCE LINE # 1385
	RET  	
; END OF _?prvCheckTasksWaitingTermination

; /*-----------------------------------------------------------*/
; 
; static tskTCB *prvAllocateTCBAndStack( unsigned portSHORT usStackDepth ) reentrant

	RSEG  ?PR?_?prvAllocateTCBAndStack?TASKS
_?prvAllocateTCBAndStack:
	USING	0
			; SOURCE LINE # 1388
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
; tskTCB *pxNewTCB;
; 
; 	/* Allocate space for the TCB.  Where the memory comes from depends on
; 	the implementation of the port malloc function. */
; 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
			; SOURCE LINE # 1394
	MOV  	R6,#00H
	MOV  	R7,#03AH
	LCALL	_?pvPortMalloc
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 	if( pxNewTCB != NULL )
			; SOURCE LINE # 1396
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	$ + 5H
	AJMP 	?C0099
; 	{
			; SOURCE LINE # 1397
; 		/* Allocate space for the stack used by the task being created.  
; 		The base of the stack memory stored in the TCB so the task can 
; 		be deleted later if required. */
; 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMalloc( usStackDepth * sizeof( portSTACK_TYPE ) );
			; SOURCE LINE # 1401
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_?pvPortMalloc
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PSTPTR
; 
; 		if( pxNewTCB->pxStack == NULL )
			; SOURCE LINE # 1403
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	MOV  	A,R1
	ORL  	A,R2
	ORL  	A,R3
	JNZ  	?C0100
; 		{
			; SOURCE LINE # 1404
; 			/* Could not allocate the stack.  Delete the allocated TCB. */
; 			vPortFree( pxNewTCB );			
			; SOURCE LINE # 1406
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	_?vPortFree
; 			pxNewTCB = NULL;			
			; SOURCE LINE # 1407
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 		}		
			; SOURCE LINE # 1408
	SJMP 	?C0099
?C0100:
; 		else
; 		{
			; SOURCE LINE # 1410
; 			/* Just to help debugging. */
; 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
			; SOURCE LINE # 1412
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R5,#0A5H
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	ADD  	A,#03H
	MOV  	R1,A
	CLR  	A
	ADDC 	A,R2
	MOV  	R2,A
	LCALL	?C?PLDPTR
	LCALL	?C?MEMSET
; 		}
			; SOURCE LINE # 1413
; 	}
			; SOURCE LINE # 1414
?C0099:
; 
; 	return pxNewTCB;
			; SOURCE LINE # 1416
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
; }
			; SOURCE LINE # 1417
?C0102:
	MOV  	DPTR,#05H
	LJMP 	?C?ADDXBP
; END OF _?prvAllocateTCBAndStack

; /*-----------------------------------------------------------*/
; 
; #if( USE_TRACE_FACILITY == 1 )
; 
; 	static void prvListTaskWithinSingleList( signed portCHAR *pcWriteBuffer, xList *pxList, signed portCHAR cStatus )reentrant
; 	{
; 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
; 	static signed portCHAR pcStatusString[ 50 ];
; 	unsigned portSHORT usStackRemaining;
; 
; 		/* Write the details of all the TCB's in pxList into the buffer. */
; 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
; 		do
; 		{
; 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
; 			usStackRemaining = usPortCheckFreeStackSpace( ( unsigned portCHAR * ) pxNextTCB->pxStack, tskSTACK_FILL_BYTE );
; 			sprintf( pcStatusString, "%s\t\t%c\t%u\t%u\t%d\r\n", pxNextTCB->pcTaskName, cStatus, pxNextTCB->ucPriority, usStackRemaining, pxNextTCB->ucTCBNumber );
; 			strcat( pcWriteBuffer, pcStatusString );
; 
; 		} while( pxNextTCB != pxFirstTCB );
; 	}
; 
; #endif
; /*-----------------------------------------------------------*/
; 
; #if( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
; 
; 	static void prvDeleteTCB( tskTCB *pxTCB ) reentrant
; 	{
; 		/* Free up the memory allocated by the scheduler for the task.  It is up to
; 		the task to free any memory allocated at the application level. */
; 		vPortFree( pxTCB->pxStack );
; 		vPortFree( pxTCB );
; 	}
; 
; #endif
; 
; void prvGetCurrentTCB_XBP() reentrant

	RSEG  ?PR?_?prvGetCurrentTCB_XBP?TASKS
_?prvGetCurrentTCB_XBP:
	USING	0
			; SOURCE LINE # 1455
; {
; 	pxCurrentTCB->pxTopOfStack = C_XBP;
			; SOURCE LINE # 1457
	MOV  	R2,C_XBP
	MOV  	R1,C_XBP+01H
	MOV  	R3,#?C?XDATAMTYPE
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; }
			; SOURCE LINE # 1458
	RET  	
; END OF _?prvGetCurrentTCB_XBP

; 
; 
; void prvSetCurrentTCB_XBP() reentrant

	RSEG  ?PR?_?prvSetCurrentTCB_XBP?TASKS
_?prvSetCurrentTCB_XBP:
	USING	0
			; SOURCE LINE # 1461
; {
; 	C_XBP=pxCurrentTCB->pxTopOfStack;
			; SOURCE LINE # 1463
	MOV  	DPTR,#pxCurrentTCB
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PLDPTR
	MOV  	R7,AR1
	MOV  	C_XBP,R2
	MOV  	C_XBP+01H,R7
; }
			; SOURCE LINE # 1464
	RET  	
; END OF _?prvSetCurrentTCB_XBP

	END
