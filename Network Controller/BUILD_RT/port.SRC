; .\port.SRC generated from: ..\src\FreeRtossource\portable\Keil\AX11000\port.c
; COMPILER INVOKED BY:
;        E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\portable\Keil\AX11000\port.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\port.lst) SRC(.\port.SRC)

$MOD_CONT
$NOMOD51

NAME	PORT

TB08	BIT	098H.3
TB18	BIT	0C0H.3
P0	DATA	080H
SM00	BIT	098H.7
P1	DATA	090H
SM10	BIT	0C0H.7
SM01	BIT	098H.6
P2	DATA	0A0H
SM11	BIT	0C0H.6
SM02	BIT	098H.5
P3	DATA	0B0H
AC	BIT	0D0H.6
SM12	BIT	0C0H.5
T0	BIT	0B0H.4
SPIDR	DATA	0CFH
T1	BIT	0B0H.5
EA	BIT	0A8H.7
OWCIR	DATA	0D6H
CH	DATA	0C5H
DPH0	DATA	083H
IE	DATA	0A8H
DPH1	DATA	085H
CL	DATA	0C4H
P0_0	BIT	080H.0
P1_0	BIT	090H.0
P0_1	BIT	080H.1
CCAPH0	DATA	0B9H
DPL0	DATA	082H
P2_0	BIT	0A0H.0
P1_1	BIT	090H.1
P0_2	BIT	080H.2
CCAPH1	DATA	0BAH
DPL1	DATA	084H
P3_0	BIT	0B0H.0
P2_1	BIT	0A0H.1
P1_2	BIT	090H.2
P0_3	BIT	080H.3
UR2_DLH	DATA	0E2H
CCAPH2	DATA	0BBH
XMRHR	DATA	0A7H
P3_1	BIT	0B0H.1
P2_2	BIT	0A0H.2
P1_3	BIT	090H.3
P0_4	BIT	080H.4
CCAPH3	DATA	0BCH
P3_2	BIT	0B0H.2
P2_3	BIT	0A0H.3
P1_4	BIT	090H.4
P0_5	BIT	080H.5
TA	DATA	0EBH
CCAPH4	DATA	0BDH
CCAPL0	DATA	0B1H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P3_3	BIT	0B0H.3
P2_4	BIT	0A0H.4
REN0	BIT	098H.4
P1_5	BIT	090H.5
P0_6	BIT	080H.6
UR2_FCR	DATA	0E3H
CCAPM0	DATA	0D1H
T2IF	DATA	0C9H
CCAPL1	DATA	0B2H
REN1	BIT	0C0H.4
P3_4	BIT	0B0H.4
P2_5	BIT	0A0H.5
P1_6	BIT	090H.6
P0_7	BIT	080H.7
UR2_DLL	DATA	0E1H
CCAPM1	DATA	0D2H
CCAPL2	DATA	0B3H
XMRLR	DATA	0A6H
P3_5	BIT	0B0H.5
P2_6	BIT	0A0H.6
P1_7	BIT	090H.7
CCAPM2	DATA	0D3H
CCAPL3	DATA	0B4H
XMWHR	DATA	0A5H
P3_6	BIT	0B0H.6
P2_7	BIT	0A0H.7
CCAPM3	DATA	0D4H
IP	DATA	0B8H
CCAPL4	DATA	0B5H
P3_7	BIT	0B0H.7
CCAPM4	DATA	0D5H
DBAR	DATA	09AH
UR2_IER	DATA	0E2H
CY	BIT	0D0H.7
INT0	BIT	0B0H.2
UR2_LCR	DATA	0E4H
XMWLR	DATA	0A4H
INT1	BIT	0B0H.3
UR2_MCR	DATA	0E5H
DPX0	DATA	093H
I2CCIR	DATA	096H
DPX1	DATA	095H
UR2_IIR	DATA	0E3H
UR2_RBR	DATA	0E1H
ACON	DATA	09DH
DCIR	DATA	09BH
SP	DATA	081H
CCON	DATA	0C3H
CMOD	DATA	0C2H
OV	BIT	0D0H.2
WR	BIT	0B0H.6
UR2_THR	DATA	0E1H
EWDI	BIT	0E8H.5
WDIF	BIT	0D8H.3
RLDH	DATA	0CBH
EPCR	DATA	0BEH
LDHR	DATA	0AAH
UR2_LSR	DATA	0E6H
EPDR	DATA	0BFH
MCIR	DATA	0B6H
RCLK	BIT	0C8H.5
UR2_MSR	DATA	0E7H
TCLK	BIT	0C8H.4
RLDL	DATA	0CAH
LDLR	DATA	0A9H
PCON	DATA	087H
CANCIR	DATA	0DEH
TCIR	DATA	0AEH
PWDI	BIT	0F8H.5
LSCR	DATA	0A2H
TMOD	DATA	089H
TCON	DATA	088H
OWDR	DATA	0D7H
IE0	BIT	088H.1
IE1	BIT	088H.3
MXAX	DATA	0EAH
LMSR	DATA	0A1H
MD0	DATA	0F9H
B	DATA	0F0H
MD1	DATA	0FAH
LSAIER	DATA	0A1H
MD2	DATA	0FBH
WTRF	BIT	0D8H.2
MD3	DATA	0FCH
PISSR1	DATA	09EH
MD4	DATA	0FDH
LSSR	DATA	0A3H
PISSR2	DATA	09FH
MD5	DATA	0FEH
ACC	DATA	0E0H
ES0	BIT	0A8H.4
CT2	BIT	0C8H.1
ES1	BIT	0A8H.6
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RI1	BIT	0C0H.0
SPICIR	DATA	0CEH
TH0	DATA	08CH
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
TH1	DATA	08DH
TI1	BIT	0C0H.1
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
TL0	DATA	08AH
CSREPR	DATA	08FH
TL1	DATA	08BH
TL2	DATA	0CCH
PS0	BIT	0B8H.4
EIE	DATA	0E8H
WTST	DATA	092H
PS1	BIT	0B8H.6
PT0	BIT	0B8H.1
EIF	DATA	091H
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
I2CDR	DATA	097H
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DDR	DATA	09CH
DPH	DATA	083H
EIP	DATA	0F8H
DPL	DATA	082H
LCR	DATA	0A2H
SBUF0	DATA	099H
SBUF1	DATA	0C1H
EINT2	BIT	0E8H.0
EXEN2	BIT	0C8H.3
MDR	DATA	0B7H
EINT3	BIT	0E8H.1
CPRL2	BIT	0C8H.0
SCON0	DATA	098H
EINT4	BIT	0E8H.2
SCON1	DATA	0C0H
SDSTSR	DATA	094H
EINT5	BIT	0E8H.3
STATUS	DATA	0E9H
EINT6	BIT	0E8H.4
T2CON	DATA	0C8H
DPS	DATA	086H
CANDR	DATA	0DFH
TDR	DATA	0AFH
LDAHR	DATA	0A5H
DPX	DATA	093H
Rs485_2_EN	BIT	0B0H.4
DMAHR	DATA	0ADH
PINT2	BIT	0F8H.0
RXD	BIT	0B0H.0
PINT3	BIT	0F8H.1
CKCON	DATA	08EH
PINT4	BIT	0F8H.2
EWT	BIT	0D8H.1
TXD	BIT	0B0H.1
LDALR	DATA	0A4H
PINT5	BIT	0F8H.3
DMALR	DATA	0ABH
LSR	DATA	0A3H
PINT6	BIT	0F8H.4
DMAMR	DATA	0ACH
ARCON	DATA	0FFH
F0	BIT	0D0H.5
F1	BIT	0D0H.1
LDCSR	DATA	0A6H
PSW	DATA	0D0H
RB08	BIT	098H.2
WDCON	DATA	0D8H
RWT	BIT	0D8H.0
RB18	BIT	0C0H.2
?PR?_?pxPortInitialiseStack?PORT         SEGMENT ECODE INSEG 
?PR?_?sPortStartScheduler?PORT           SEGMENT ECODE INSEG 
?PR?_?vPortEndScheduler?PORT             SEGMENT ECODE INSEG 
?PR?_?vPortContextSwitch?PORT            SEGMENT ECODE INSEG 
?PR?_?OSIntCtxSw?PORT                    SEGMENT ECODE INSEG 
?PR?_?vIntPortContextSwitch?PORT         SEGMENT ECODE INSEG 
?PR?vTimer2ISR?PORT  SEGMENT ECODE INSEG 
?XD?vTimer2ISR?PORT  SEGMENT XDATA OVERLAYABLE
?PR?prvSetupTimerInterrupt?PORT          SEGMENT ECODE INSEG 
?XD?prvSetupTimerInterrupt?PORT          SEGMENT XDATA OVERLAYABLE
?DT?PORT             SEGMENT DATA 
	EXTRN	CODE (_?prvGetCurrentTCB_XBP)
	EXTRN	CODE (_?prvSetCurrentTCB_XBP)
	EXTRN	CODE (_?LoadCtx)
	EXTRN	CODE (_?vTaskIncrementTick)
	EXTRN	HDATA (USB_timeout)
	EXTRN	HDATA (uart1_timeout)
	EXTRN	HDATA (uart2_timeout)
	EXTRN	CODE (_DMA_WriteReg)
	EXTRN	IDATA (STACK_START)
	EXTRN	CODE (_?vTaskSwitchContext)
	EXTRN	DATA (TICK_INT)
	EXTRN	CODE (?C?ADDXBP)
	EXTRN	CODE (?C?XBPOFF)
	EXTRN	DATA (?C_XBP)
	EXTRN	NUMBER (?C?XDATASEG)
	EXTRN	CODE (?C?IILDX)
	EXTRN	CODE (?C?PSTPTR)
	EXTRN	CODE (?C?ISTPTR)
	EXTRN	CODE (?C?ULSHR)
	EXTRN	CODE (?C?CSTPTR)
	PUBLIC	SaveSP
	PUBLIC	vTimer2ISR
	PUBLIC	_?vIntPortContextSwitch
	PUBLIC	_?OSIntCtxSw
	PUBLIC	_?vPortContextSwitch
	PUBLIC	_?vPortEndScheduler
	PUBLIC	_?sPortStartScheduler
	PUBLIC	_?pxPortInitialiseStack

	RSEG  ?XD?vTimer2ISR?PORT
?vTimer2ISR?BYTE:
        isr?640:   DS   1

	RSEG  ?XD?prvSetupTimerInterrupt?PORT
?prvSetupTimerInterrupt?BYTE:
       temp?741:   DS   2

	RSEG  ?DT?PORT
         SaveSP:   DS   1
; /*
; 	FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
; 
; 	This file is part of the FreeRTOS distribution.
; 
; 	FreeRTOS is free software; you can redistribute it and/or modify
; 	it under the terms of the GNU General Public License as published by
; 	the Free Software Foundation; either version 2 of the License, or
; 	(at your option) any later version.
; 
; 	FreeRTOS is distributed in the hope that it will be useful,
; 	but WITHOUT ANY WARRANTY; without even the implied warranty of
; 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; 	GNU General Public License for more details.
; 
; 	You should have received a copy of the GNU General Public License
; 	along with FreeRTOS; if not, write to the Free Software
; 	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
; 
; 	A special exception to the GPL can be applied should you wish to distribute
; 	a combined work that includes FreeRTOS, without being obliged to provide
; 	the source code for any proprietary components.  See the licensing section 
; 	of http://www.FreeRTOS.org for full details of how and when the exception
; 	can be applied.
; 
; 	***************************************************************************
; 	See http://www.FreeRTOS.org for documentation, latest information, license 
; 	and contact details.  Please ensure to read the configuration and relevant 
; 	port sections of the online documentation.
; 	***************************************************************************
; */
; 
; /*-----------------------------------------------------------
;  * Implementation of functions defined in portable.h for the Cygnal port.
;  *----------------------------------------------------------*/
; //#pragma SRC	
; /* Standard includes. */
; #include <string.h>
; 
; /* Scheduler includes. */
; #include "projdefs.h"
; #include "portable.h"
; #include "task.h"
; #include "queue.h"
; #include "mstimer.h"
; #include "interrupt.h"
; #include "dma.h"
; 
; #include "hsuart.h"
; #include "uart.h"
; #include "../../../../USB/ch375_com.h"
; 
; /* Constants required to setup timer 2 to produce the RTOS tick. */
; //#define portCLOCK_DIVISOR				( ( unsigned portLONG ) 12 )
; //#define portMAX_TIMER_VALUE				( ( unsigned portLONG ) 0xffff )
; //#define portENABLE_TIMER				( ( unsigned portCHAR ) 0x04 )
; //#define portTIMER_2_INTERRUPT_ENABLE	( ( unsigned portCHAR ) 0x20 )
; 
; /* The value used in the IE register when a task first starts. */
; #define portGLOBAL_INTERRUPT_BIT	( ( portSTACK_TYPE ) 0x80 )
; 
; /* The value used in the PSW register when a task first starts. */
; #define portINITIAL_PSW				( ( portSTACK_TYPE ) 0x00 )
; 
; /* Macro to clear the timer 2 interrupt flag. */
; #define portCLEAR_INTERRUPT_FLAG()	{					\
; 										EINT5 = 0;		\
; 										EIF &= ~INT5F;	\
; 										EINT5 = 1;		\
; 									}
; 											
; /* Used during a context switch to store the size of the stack being copied
; to or from XRAM. */
; //data static unsigned portCHAR ucStackBytes;
; //data  unsigned portCHAR ucStackBytes;
; 
; /* Used during a context switch to point to the next byte in XRAM from/to which
; a RAM byte is to be copied. */
; //xdata static portSTACK_TYPE * data pxXRAMStack;
; //static portSTACK_TYPE xdata * data pxXRAMStack;
; 
; /* Used during a context switch to point to the next byte in RAM from/to which
; an XRAM byte is to be copied. */
; //data static portSTACK_TYPE * data pxRAMStack;
; //static  portSTACK_TYPE data * data pxRAMStack;
; 
; /* We require the address of the pxCurrentTCB variable, but don't want to know
; any details of its type. */
; //typedef void tskTCB;
; //extern volatile tskTCB * volatile pxCurrentTCB;
; 
; void LoadCtx() reentrant;   /* Save the current working registers to stack, defined in OS_CPU_A.ASM */
; extern INT8U xdata * data C_XBP, TICK_INT;
; 
; 
; /*
;  * Setup the hardware to generate an interrupt off timer 2 at the required 
;  * frequency.
;  */
; static void prvSetupTimerInterrupt( void );
; 
; 
; /* 
;  * See header file for description. 
;  */
; portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters ) reentrant

	RSEG  ?PR?_?pxPortInitialiseStack?PORT
_?pxPortInitialiseStack:
	USING	0
			; SOURCE LINE # 106
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
;     portSTACK_TYPE * stk;
; 
;     stk    = (portSTACK_TYPE *) pxTopOfStack;        /* Load stack pointer                                      */
			; SOURCE LINE # 110
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 
; 	stk				-= sizeof(void *);		/* Save the pvParameters to external stack */
			; SOURCE LINE # 112
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,#0FDH
	LCALL	?C?IILDX
; 	*(void**)stk	 = pvParameters;        /*                               */
			; SOURCE LINE # 113
	MOV  	DPTR,#09H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; 
; 	stk				-= sizeof(INT16U);      					/* The value should be loaded to PC    */
			; SOURCE LINE # 115
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,#0FEH
	LCALL	?C?IILDX
; 	*(INT16U*)stk	 = (INT16U) pxCode;       					/* next time when this task is running */
			; SOURCE LINE # 116
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R6,AR2
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	A,R6
	MOV  	B,R7
	LCALL	?C?ISTPTR
; 
; 	*--stk	 		 = (portSTACK_TYPE )(((INT32U) pxCode>>16)+0x7F);      /* Third byte of PC for dallas 390 */
			; SOURCE LINE # 118
	MOV  	DPTR,#06H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	MOV  	R7,A
	MOV  	R6,AR2
	MOV  	R5,AR3
	MOV  	R4,#00H
	MOV  	R0,#010H
	LCALL	?C?ULSHR
	MOV  	A,R7
	ADD  	A,#07FH
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 
; /* Following is the registers pushed into hardware stack */
; 	*--stk			 = 'A';                 /* ACC */
			; SOURCE LINE # 121
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#041H
	LCALL	?C?CSTPTR
; 	*--stk			 = 'B';                 /* B   */
			; SOURCE LINE # 122
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#042H
	LCALL	?C?CSTPTR
; 	*--stk			 = 'X';                 /* DPX */
			; SOURCE LINE # 123
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#058H
	LCALL	?C?CSTPTR
; 	*--stk			 = 'H';                 /* DPH */
			; SOURCE LINE # 124
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#048H
	LCALL	?C?CSTPTR
; 	*--stk			 = 'L';                 /* DPL */
			; SOURCE LINE # 125
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#04CH
	LCALL	?C?CSTPTR
; //	*--stk			 = 'X';                 /* DPX1 for second DPTR */
; //	*--stk			 = 'H';                 /* DPH1 for second DPTR */
; //	*--stk			 = 'L';                 /* DPL1 for second DPTR */
; //	*--stk			 = DPS;                 /* DPS for second DPTR */
; 	*--stk			 = PSW;					/* PSW */
			; SOURCE LINE # 130
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,PSW
	LCALL	?C?CSTPTR
; 	*--stk			 = 0;                   /* R0  */
			; SOURCE LINE # 131
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	CLR  	A
	LCALL	?C?CSTPTR
; /*
; 	*--stk			 = 1;                   // should be R1
; 	*--stk			 = 2;                   // should be R2
; 	*--stk			 = 3;                   // should be R3
; */
; 	stk				-= sizeof(void *);      /* Keil C uses R1,R2,R3 to pass the */
			; SOURCE LINE # 137
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,#0FDH
	LCALL	?C?IILDX
; 	*(void**)stk	 = pvParameters;                  /* arguments of functions.          */
			; SOURCE LINE # 138
	MOV  	DPTR,#09H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	PUSH 	AR3
	PUSH 	AR2
	PUSH 	AR1
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
	LCALL	?C?PSTPTR
; 
; 	*--stk			 = 4;                   /* R4  */
			; SOURCE LINE # 140
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#04H
	LCALL	?C?CSTPTR
; 	*--stk			 = 5;                   /* R5  */
			; SOURCE LINE # 141
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#05H
	LCALL	?C?CSTPTR
; 	*--stk			 = 6;                   /* R6  */
			; SOURCE LINE # 142
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#06H
	LCALL	?C?CSTPTR
; 	*--stk			 = 7;                   /* R7  */
			; SOURCE LINE # 143
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#07H
	LCALL	?C?CSTPTR
; /* Following is the registers pushed into hardware stack manually to support the dallas 390 */
;     *--stk           = 0x80;                /* IE, EA is enabled  */
			; SOURCE LINE # 145
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,#080H
	LCALL	?C?CSTPTR
; 
; /*
;     Next is calculating the hardware stack pointer.
; */
;     *--stk			 = (INT8U) portSTACK_START-1      /* Initial value when main was called    */
			; SOURCE LINE # 150
	MOV  	A,#LOW (STACK_START)
	ADD  	A,#08H
	ADD  	A,#05H
	INC  	A
	ADD  	A,#02H
	INC  	A
	MOV  	R7,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOV  	A,#0FFH
	MOV  	B,A
	LCALL	?C?IILDX
	MOV  	R1,B
	MOV  	R2,A
	MOV  	A,R7
	LCALL	?C?CSTPTR
; 	                   +1                   /* IE */
; 	                   +8                   /* R0-R7, eight registers was saved      */
;                        +5                   /* ACC, B, DPH, DPL, PSW, five registers */
;                        +1                   /* Dallas 390 extra registers DPX1 */
; //                       +4                   /* Dallas 390 extra registers for second DPTR - DPL1 DPH1 DPX1 DPS */
;                        +sizeof(INT16U)      /* The PC value to be loaded             */
;                        +sizeof(INT8U)       /* The third byte of PC value to be loaded for dallas 390  */
; 					   ;
;     return ((void *)stk);
			; SOURCE LINE # 159
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
; 
; }
			; SOURCE LINE # 161
?C0001:
	MOV  	DPTR,#0CH
	LJMP 	?C?ADDXBP
; END OF _?pxPortInitialiseStack

; 
; /* 
;  * See header file for description. 
;  */
; portSHORT sPortStartScheduler( portSHORT sUsePreemption ) reentrant

	RSEG  ?PR?_?sPortStartScheduler?PORT
_?sPortStartScheduler:
	USING	0
			; SOURCE LINE # 166
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
; 	/* Stop compiler warnings.  This port uses a constant defined in
; 	portmacro.h to specify whether or not preemption is used. */
; 	sUsePreemption = sUsePreemption;
			; SOURCE LINE # 170
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R7,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R7
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 
; 	/* Setup timer 2 to generate the RTOS tick. */
; 	prvSetupTimerInterrupt();	
			; SOURCE LINE # 173
	LCALL	prvSetupTimerInterrupt
; 
;     prvSetCurrentTCB_XBP();
			; SOURCE LINE # 175
	LCALL	_?prvSetCurrentTCB_XBP
; 	LoadCtx();
			; SOURCE LINE # 176
	LCALL	_?LoadCtx
; 										/* Should never get here! */
; 	return pdTRUE;
			; SOURCE LINE # 178
	MOV  	R6,#00H
	MOV  	R7,#01H
; }
			; SOURCE LINE # 179
?C0002:
	MOV  	DPTR,#02H
	LJMP 	?C?ADDXBP
; END OF _?sPortStartScheduler

; 
; /*-----------------------------------------------------------*/
; 
; void vPortEndScheduler(void) reentrant

	RSEG  ?PR?_?vPortEndScheduler?PORT
_?vPortEndScheduler:
	USING	0
			; SOURCE LINE # 183
; {
; 
; 	/* Not implemented for this port. */
; }
			; SOURCE LINE # 187
	RET  	
; END OF _?vPortEndScheduler

; /*-----------------------------------------------------------*/
; 
; 
; /**********************************************************************************************************
; * C_OSCtxSw is the c part of OSCtxSw.
; * When control passes to this function, the processor registers have been saved in external stack
; ***********************************************************************************************************/
; void vPortContextSwitch(void) reentrant

	RSEG  ?PR?_?vPortContextSwitch?PORT
_?vPortContextSwitch:
	USING	0
			; SOURCE LINE # 195
; {
; 
; /*	Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  */
; 
; /*	Save the current task's stack pointer into the current task's OS_TCB:  
; 		prvGetCurrentTCB_XBP();
; 	Call vTaskSwitchContext();                                    
; 	Get the stack pointer of the task to resume:                           
; 		prvSetCurrentTCB_XBP;
; 	Restore all processor registers from the new task's stack;             
; 	Execute a return from interrupt instruction;                           */
;     prvGetCurrentTCB_XBP();
			; SOURCE LINE # 207
	LCALL	_?prvGetCurrentTCB_XBP
;     
; 	vTaskSwitchContext();
			; SOURCE LINE # 209
	LCALL	_?vTaskSwitchContext
; 
;     prvSetCurrentTCB_XBP();
			; SOURCE LINE # 211
	LCALL	_?prvSetCurrentTCB_XBP
;     LoadCtx();
			; SOURCE LINE # 212
	LJMP 	_?LoadCtx
; END OF _?vPortContextSwitch

; 
; }
; 
; 
; INT8U data SaveSP;
; 
; void OSIntCtxSw(void) reentrant

	RSEG  ?PR?_?OSIntCtxSw?PORT
_?OSIntCtxSw:
	USING	0
			; SOURCE LINE # 219
; {
; 
; 	EA=0;
			; SOURCE LINE # 222
	CLR  	EA
;     SP=SaveSP;
			; SOURCE LINE # 223
	MOV  	SP,SaveSP
; 
;     prvSetCurrentTCB_XBP();
			; SOURCE LINE # 225
	LCALL	_?prvSetCurrentTCB_XBP
; 
; #pragma ASM
; 	EXTRN   CODE(_?KCOSCtxSw)
	  EXTRN   code(_?KCOSCtxSw)
; 	MOV		A, #BYTE0( _?KCOSCtxSw)
	  MOV		A, #BYTE0( _?KCOSCtxSw)
; 	PUSH	ACC
	  PUSH	ACC
; 	MOV		A, #BYTE1(_?KCOSCtxSw)
	  MOV		A, #BYTE1(_?KCOSCtxSw)
; 	PUSH	ACC
	  PUSH	ACC
; 	MOV		A, #BYTE2(_?KCOSCtxSw)
	  MOV		A, #BYTE2(_?KCOSCtxSw)
; 	PUSH	ACC
	  PUSH	ACC
; 	RETI
	  RETI
; #pragma ENDASM
; 
; }
			; SOURCE LINE # 238
	RET  	
; END OF _?OSIntCtxSw

; 
; 
; void vIntPortContextSwitch(void) reentrant

	RSEG  ?PR?_?vIntPortContextSwitch?PORT
_?vIntPortContextSwitch:
	USING	0
			; SOURCE LINE # 241
; {
; 
; /*	Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  */
; 
; /*	Save the current task's stack pointer into the current task's OS_TCB:  
; 		prvGetCurrentTCB_XBP();
; 	Call vTaskSwitchContext();                                    
; 	Get the stack pointer of the task to resume:                           
; 		prvSetCurrentTCB_XBP;
; 	Restore all processor registers from the new task's stack;             
; 	Execute a return from interrupt instruction;                           */
;     prvGetCurrentTCB_XBP();
			; SOURCE LINE # 253
	LCALL	_?prvGetCurrentTCB_XBP
; 
; 	if ( TICK_INT == 1 )
			; SOURCE LINE # 255
	MOV  	A,TICK_INT
	CJNE 	A,#01H,?C0006
; 	{
			; SOURCE LINE # 256
; 		vTaskIncrementTick();
			; SOURCE LINE # 257
	LCALL	_?vTaskIncrementTick
; 		TICK_INT = 0;
			; SOURCE LINE # 258
	CLR  	A
	MOV  	TICK_INT,A
; 	}
			; SOURCE LINE # 259
?C0006:
; 	vTaskSwitchContext();
			; SOURCE LINE # 260
	LCALL	_?vTaskSwitchContext
; 		
; 	portCLEAR_INTERRUPT_FLAG();
			; SOURCE LINE # 262
	CLR  	EINT5
	ANL  	EIF,#0F7H
	SETB 	EINT5
; 
;     prvSetCurrentTCB_XBP();
			; SOURCE LINE # 264
	LCALL	_?prvSetCurrentTCB_XBP
;     LoadCtx();
			; SOURCE LINE # 265
	LCALL	_?LoadCtx
; 	return;
; 
; }
			; SOURCE LINE # 268
?C0007:
	RET  	
; END OF _?vIntPortContextSwitch

CSEG	AT	06073H
	LJMP	vTimer2ISR

; 
; /*-----------------------------------------------------------*/
; 
; #if portUSE_PREEMPTION == 1
; 
; /*-----------------------------------------------------------*/
; 
; void vTimer2ISR( void ) interrupt 10

	RSEG  ?PR?vTimer2ISR?PORT
	USING	0
vTimer2ISR:
	PUSH 	ACC
	PUSH 	B
	PUSH 	DPX
	PUSH 	DPH
	PUSH 	DPL
	PUSH 	PSW
	MOV  	PSW,#00H
	PUSH 	AR0
	PUSH 	AR1
	PUSH 	AR2
	PUSH 	AR3
	PUSH 	AR4
	PUSH 	AR5
	PUSH 	AR6
	PUSH 	AR7
	USING	0
			; SOURCE LINE # 276
; {
; 	unsigned portCHAR	isr;
; #pragma ASM
; 		PUSH IE
	  PUSH IE
; #pragma ENDASM
; 		isr = EA;
			; SOURCE LINE # 282
	MOV  	C,EA
	CLR  	A
	RLC  	A
	MOV  	DPTR,#isr?640
	MOVX 	@DPTR,A
; 		EA = 0;
			; SOURCE LINE # 283
	CLR  	EA
; 		if(uart2_timeout)
			; SOURCE LINE # 284
	MOV  	DPTR,#uart2_timeout
	MOVX 	A,@DPTR
	JZ   	?C0008
; 			uart2_timeout--;
			; SOURCE LINE # 285
	DEC  	A
	MOVX 	@DPTR,A
?C0008:
; 		if(uart1_timeout)
			; SOURCE LINE # 286
	MOV  	DPTR,#uart1_timeout
	MOVX 	A,@DPTR
	JZ   	?C0009
; 		{ uart1_timeout--;  }
			; SOURCE LINE # 287
	DEC  	A
	MOVX 	@DPTR,A
?C0009:
; 		if(USB_timeout)
			; SOURCE LINE # 288
	MOV  	DPTR,#USB_timeout
	MOVX 	A,@DPTR
	JZ   	?C0010
; 			USB_timeout--;
			; SOURCE LINE # 289
	DEC  	A
	MOVX 	@DPTR,A
?C0010:
; 		TICK_INT = 1;
			; SOURCE LINE # 290
	MOV  	TICK_INT,#01H
; 		SaveSP=SP;
			; SOURCE LINE # 291
	MOV  	SaveSP,SP
;         prvGetCurrentTCB_XBP();
			; SOURCE LINE # 292
	LCALL	_?prvGetCurrentTCB_XBP
; 		EA=isr;
			; SOURCE LINE # 293
	MOV  	DPTR,#isr?640
	MOVX 	A,@DPTR
	ADD  	A,#0FFH
	MOV  	EA,C
; 
; 		OSIntCtxSw();
			; SOURCE LINE # 295
	LCALL	_?OSIntCtxSw
; }
			; SOURCE LINE # 296
	POP  	AR7
	POP  	AR6
	POP  	AR5
	POP  	AR4
	POP  	AR3
	POP  	AR2
	POP  	AR1
	POP  	AR0
	POP  	PSW
	POP  	DPL
	POP  	DPH
	POP  	DPX
	POP  	B
	POP  	ACC
	RETI 	
; END OF vTimer2ISR

; 
; #endif
; 
; /*-----------------------------------------------------------*/
; static void prvSetupTimerInterrupt( void )

	RSEG  ?PR?prvSetupTimerInterrupt?PORT
prvSetupTimerInterrupt:
	USING	0
			; SOURCE LINE # 301
; {
			; SOURCE LINE # 302
; 	/* using MS_TIMER */
; 	U8_T XDATA	temp[2];
; 
; 	/* set software timer */
; 	temp[1] = (U8_T)SWTIMER_INTERVAL;
			; SOURCE LINE # 307
	MOV  	DPTR,#temp?741+01H
	MOV  	A,#0AH
	MOVX 	@DPTR,A
; 	temp[0] = (U8_T)(SWTIMER_INTERVAL >> 8) + SWTIMER_START + SWTIMER_INT_ENABLE;
			; SOURCE LINE # 308
	MOV  	DPTR,#temp?741
	MOV  	A,#090H
	MOVX 	@DPTR,A
; 	DMA_WriteReg(SWTIMER_REG, temp, 2);
			; SOURCE LINE # 309
	MOV  	R4,#HIGH (temp?741)
	MOV  	R5,#LOW (temp?741)
	MOV  	R3,#02H
	MOV  	R7,#0CH
	LCALL	_DMA_WriteReg
; 
; 	EXTINT5(ON);	/* Enable INT5 interrupt for software timer. */
			; SOURCE LINE # 311
	SETB 	EINT5
; 
; }
			; SOURCE LINE # 313
	RET  	
; END OF prvSetupTimerInterrupt

	END
