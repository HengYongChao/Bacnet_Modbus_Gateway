C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\i2c.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\i2c\i2c.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDI
                    -R(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC
                    -\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer
                    -\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\
                    -FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\src\
                    -gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\i2c.lst) OBJECT(
                    -.\i2c.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : i2c.c
  13           * Purpose     : This module handles the I2C serial interface driver.
  14           * Author      : Robin Lee
  15           * Date        : 2005-01-10
  16           * Notes       :
  17           * $Log: i2c.c,v $
  18           * Revision 1.2  2006/04/14 00:56:42  robin6633
  19           * Fixed the function name error "I2cCmd() -> I2C_Cmd()".
  20           *
  21           * Revision 1.1  2006/04/07 11:38:34  robin6633
  22           * no message
  23           *
  24           *================================================================================
  25           */
  26          
  27          /* INCLUDE FILE DECLARATIONS */
  28          #include        <stdio.h>
  29          #include        "reg80390.h"
  30          #include        "types.h"
  31          #include        "i2c.h"
  32          #if I2C_SLAVE_ENABLE
              #include        "console_debug.h"       
              #endif
  35          #include        "printd.h"
  36          
  37          /* STATIC VARIABLE DECLARATIONS */
  38          static U8_T             i2cCtrl = 0;
  39          static U8_T             i2cEndCond = 0;
  40          static U8_T             i2cActF = 0;    // indicate the condition of a transfer
  41          static U16_T    i2cDataLen = 0; // The I2cPktLen includes address and data
  42          static U16_T    i2cDataLenCnt = 0;      // Packet's counter of transferring 
  43          static U8_T             i2cPktDir = 0;  // Packet's direction
  44          static I2C_BUF  *ptI2cTxBuf = 0;
  45          static I2C_BUF  *ptI2cRxBuf = 0;
  46          static U8_T             i2cState = 0;   // I2C master state flag
  47          static U8_T             i2cSlvRxPkt[SLV_MAX_PKT_NUM];
  48          static U8_T             i2cSlvTxPkt[SLV_MAX_PKT_NUM];
  49          
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 2   

  50          
  51          /* LOCAL SUBPROGRAM DECLARATIONS */
  52          static void i2c_MstStatus(U8_T i2cStatus);
  53          static void i2c_SlvStatus(U8_T i2cStatus);
  54          static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd);
  55          static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd);
  56          static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd);
  57          static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd);
  58          
  59          #if I2C_SLAVE_ENABLE
              static void i2c_SlvRxProcess(void);
              #endif
  62          
  63          
  64          /* LOCAL SUBPROGRAM BODIES */
  65          
  66          /*
  67           *--------------------------------------------------------------------------------
  68           * static void i2c_MstStatus(U8_T i2cStatus)
  69           * Purpose : Checks the interrupt status of I2C master mode.
  70           * Params  : i2cStatus - master status when interrupt occured.
  71           * Returns : none
  72           * Note    : none
  73           *--------------------------------------------------------------------------------
  74           */
  75          static void i2c_MstStatus(U8_T i2cStatus)
  76          {
  77   1              if (i2cPktDir == I2C_MST_XMIT)
  78   1              {
  79   2                      /* Check the current byte ack */
  80   2                      if ((!(i2cStatus & I2C_NO_ACK)) && (i2cStatus & I2C_INTR_FLAG)
  81   2                      && (!(i2cStatus & I2C_TIP)) && (i2cStatus & I2C_BUS_BUSY))
  82   2                      {
  83   3                              if (!I2C_FlagChk(I2C_BUSY))
  84   3                              {
  85   4                                      I2C_FlagEnb(I2C_RESTART);
  86   4                              }
  87   3                              else
  88   3                              {
  89   4                                      if ((i2cCtrl & I2C_10BIT) && (i2cActF & I2C_START_COND))
  90   4                                      {
  91   5                                              i2c_MasterXmit((U8_T)(ptI2cTxBuf->I2cAddr.TenBitAddr & 0x00FF), I2C_MASTER_GO | I2C_CMD_WRITE);
  92   5                                      }
  93   4                                      else
  94   4                                      {
  95   5                                              if (i2cDataLenCnt < (i2cDataLen-1))
  96   5                                              {
  97   6                                                      /* transmit the first data byte */
  98   6                                                      i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE);
  99   6                                                      i2cDataLenCnt ++;
 100   6                                              }
 101   5                                              else if (i2cDataLenCnt == (i2cDataLen-1))
 102   5                                              {
 103   6                                                      /* transmit the last data byte */
 104   6                                                      if (i2cEndCond & I2C_STOP_COND)
 105   6                                                      {
 106   7                                                              i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE | I2C_STOP_COND);
 107   7                                                              i2cDataLenCnt = 0;
 108   7                                                      }
 109   6                                                      else
 110   6                                                      {
 111   7                                                              i2c_MasterXmit(ptI2cTxBuf->I2cData[i2cDataLenCnt], I2C_MASTER_GO | I2C_CMD_WRITE);
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 3   

 112   7                                                              i2cDataLenCnt = 0;
 113   7                                                              EA = 0;
 114   7                                                              I2C_FlagClr(I2C_BUSY);
 115   7                                                              EA = 1;
 116   7                                                      }
 117   6                                              }
 118   5                                      }
 119   4                              }
 120   3                      /*      if (i2cActF & I2C_STOP_COND)
 121   3                              {
 122   3                                      i2cDataLenCnt = 0;
 123   3                                      EA = 0;
 124   3                                      I2C_FlagClr(I2C_BUSY);
 125   3                                      EA = 1;
 126   3                              }*/
 127   3                      }
 128   2                      else if (i2cStatus & I2C_NO_ACK)
 129   2                      {
 130   3                              i2cDataLenCnt = 0;
 131   3                              if (i2cActF & I2C_START_COND)
 132   3                              {
 133   4                                      /* transmit the STOP condition */
 134   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 135   4                                      i2cDataLenCnt = 0;
 136   4                                      EA = 0;
 137   4                                      I2C_FlagClr(I2C_BUSY);
 138   4                                      I2C_FlagEnb(I2C_NACK);
 139   4                                      EA = 1;
 140   4                              }
 141   3                              else
 142   3                              {
 143   4                                      i2cDataLenCnt = 0;
 144   4                                      EA = 0;
 145   4                                      I2C_FlagClr(I2C_BUSY);
 146   4                                      EA = 1;
 147   4                              }
 148   3                      }
 149   2                      else if (i2cStatus & I2C_ARB_LOST)
 150   2                      {
 151   3                              i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 152   3                              i2cDataLenCnt = 0;
 153   3                              EA = 0;
 154   3                              I2C_FlagClr(I2C_BUSY);
 155   3                              I2C_FlagEnb(I2C_NACK);
 156   3      //                      printd("I2C arbitration lost\n\r");
 157   3                              EA = 1;
 158   3                      }
 159   2                      else if (i2cStatus & I2C_TIP)
 160   2                      {
 161   3                              i2cDataLenCnt = 0;
 162   3                              if (i2cActF & I2C_START_COND)
 163   3                              {
 164   4                                      I2C_FlagClr(I2C_BUSY);
 165   4                                      /* transmit the STOP condition */
 166   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 167   4                              }
 168   3                              else
 169   3                              {
 170   4                                      /* transmit the STOP condition or repeat START condition */
 171   4                                      I2C_PktBuf(ptI2cTxBuf);
 172   4                              }
 173   3                      }
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 4   

 174   2                      else if ((!(i2cStatus & I2C_NO_ACK)) && (!(i2cStatus & I2C_TIP)) && (!(i2cStatus & I2C_BUS_BUSY)))
 175   2                      {
 176   3                              if (i2cActF & I2C_STOP_COND)
 177   3                              {
 178   4                                      i2cDataLenCnt = 0;
 179   4                                      EA = 0;
 180   4                                      I2C_FlagClr(I2C_BUSY);
 181   4                                      EA = 1;
 182   4                              }
 183   3                      }
 184   2              }
 185   1              else if (i2cPktDir == I2C_MST_RCVR)
 186   1              {
 187   2                      /* Check the current byte ack */
 188   2                      if ((!(i2cStatus & I2C_NO_ACK)) && (i2cStatus & I2C_INTR_FLAG)
 189   2                      && (!(i2cStatus & I2C_TIP)) && (i2cStatus & I2C_BUS_BUSY))
 190   2                      {
 191   3                              if (i2cActF & I2C_START_COND)
 192   3                              {
 193   4                                      if (i2cDataLenCnt == (i2cDataLen - 1))
 194   4                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[0]), I2C_MASTER_GO | I2C_CMD_READ | I2C_STOP_COND);
 195   4                                      else
 196   4                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[0]), I2C_MASTER_GO | I2C_CMD_READ);
 197   4                              }
 198   3                              else if (i2cActF & I2C_STOP_COND)
 199   3                              {
 200   4                                      I2C_FlagClr(I2C_BUSY);
 201   4                                      i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), 0);
 202   4                              }
 203   3                              else
 204   3                              {
 205   4                                      if (i2cDataLenCnt < (i2cDataLen - 1))
 206   4                                      {
 207   5                                              /* reveive the next byte */
 208   5                                              i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), I2C_MASTER_GO | I2C_CMD_READ);
 209   5                                      }
 210   4                                      else if (i2cDataLenCnt == (i2cDataLen - 1))
 211   4                                      {
 212   5                                              /* receive the last byte */
 213   5                                              i2c_MasterRcvr((U8_T *)(&(ptI2cRxBuf->I2cData[i2cDataLenCnt])), I2C_MASTER_GO | I2C_CMD_READ | I2C_ST
             -OP_COND);
 214   5                                      }
 215   4                              }
 216   3                      }
 217   2                      else if (i2cStatus & I2C_NO_ACK)
 218   2                      {
 219   3                              i2cDataLenCnt = 0;
 220   3                              if (i2cActF & I2C_START_COND)
 221   3                              {
 222   4                                      i2c_MasterXmit(0, I2C_MASTER_GO | I2C_STOP_COND);
 223   4                                      i2cDataLenCnt = 0;
 224   4                                      EA = 0;
 225   4                                      I2C_FlagClr(I2C_BUSY);
 226   4                                      I2C_FlagEnb(I2C_NACK);
 227   4                                      EA = 1;
 228   4                              }
 229   3                              else
 230   3                              {
 231   4                                      i2cDataLenCnt = 0;
 232   4                                      EA = 0;
 233   4                                      I2C_FlagClr(I2C_BUSY);
 234   4                                      EA = 1;
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 5   

 235   4                              }
 236   3                      }
 237   2                      else
 238   2                      {
 239   3                              if (i2cActF & I2C_STOP_COND)
 240   3                              {
 241   4                                      I2C_FlagClr(I2C_BUSY);
 242   4                                      i2c_MasterRcvr(&(ptI2cRxBuf->I2cData[i2cDataLenCnt]), 0);
 243   4                              }
 244   3                      }
 245   2              }
 246   1      }
 247          
 248          /*
 249           *--------------------------------------------------------------------------------
 250           * static void i2c_SlvStatus(U8_T i2cStatus)
 251           * Purpose : Handles the interrupt status of I2C slave mode.
 252           * Params  : none
 253           * Returns : none
 254           * Note    : none
 255           *--------------------------------------------------------------------------------
 256           */
 257          static void i2c_SlvStatus(U8_T i2cStatus)
 258          {
 259   1              U8_T    devAddr;
 260   1      
 261   1              if (i2cStatus & I2C_SLV_STOP)
 262   1              {
 263   2                      if (!(i2cStatus & I2C_SLV_START))
 264   2                      {
 265   3                              if (i2cPktDir == I2C_SLV_RCVR)
 266   3                              {
 267   4                                      i2cDataLen = i2cDataLenCnt;
 268   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 271   4                              }
 272   3                              i2cDataLenCnt = 0;
 273   3                              i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 274   3                      }
 275   2              }
 276   1              if (i2cStatus & I2C_SLV_NACK)
 277   1              {
 278   2                      i2c_SlaveRcvr(&devAddr, I2C_RLS);
 279   2              }
 280   1              else
 281   1              {
 282   2                      if (i2cStatus & I2C_SLV_WR)
 283   2                      {
 284   3                              if (i2cStatus & I2C_SLV_START)
 285   3                              {
 286   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 287   4                                      i2cPktDir = I2C_SLV_RCVR;
 288   4                                      i2cDataLenCnt = 0;
 289   4                              }
 290   3                              else if (i2cStatus & I2C_SLV_STOP)
 291   3                              {
 292   4                                      i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 293   4                                      i2cDataLen = i2cDataLenCnt;
 294   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 6   

 297   4                                      i2cDataLenCnt = 0;
 298   4                              }
 299   3                              else if (i2cStatus & I2C_SLV_RESTART)
 300   3                              {
 301   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 302   4                                      i2cPktDir = I2C_SLV_RCVR;
 303   4                                      i2cDataLenCnt = 0;
 304   4                              }
 305   3                              else
 306   3                              {
 307   4                                      i2c_SlaveRcvr(&i2cSlvRxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 308   4                                      i2cDataLenCnt ++;
 309   4                              }
 310   3                      }
 311   2                      else if (i2cStatus & I2C_SLV_RD)
 312   2                      {
 313   3                              if (i2cStatus & I2C_SLV_STOP)
 314   3                              {
 315   4                                      i2c_SlaveRcvr(&devAddr, I2C_SLAVE_GO);
 316   4                                      i2cDataLenCnt = 0;
 317   4                              }
 318   3                              else if (i2cStatus & I2C_SLV_START)
 319   3                              {
 320   4                                      i2cPktDir = I2C_SLV_XMIT;
 321   4                                      i2cDataLenCnt = 0;
 322   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 325   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 326   4                                      i2cDataLenCnt ++;
 327   4                              }
 328   3                              else if (i2cStatus & I2C_SLV_RESTART)
 329   3                              {
 330   4                                      i2cPktDir = I2C_SLV_XMIT;
 331   4                                      i2cDataLenCnt = 0;
 332   4                                      #if I2C_SLAVE_ENABLE
                                              i2c_SlvRxProcess();
                                              #endif
 335   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 336   4                                      i2cDataLenCnt ++;
 337   4                              }
 338   3                              else
 339   3                              {
 340   4                                      if (i2cSlvRxPkt[0] == I2C_SLV_BRDM)
 341   4                                      {
 342   5                                              #if I2C_SLAVE_ENABLE
                                                      i2c_SlvRxProcess();
                                                      #endif
 345   5                                      }
 346   4                                      i2c_SlaveXmit(i2cSlvTxPkt[i2cDataLenCnt], I2C_SLAVE_GO);
 347   4                                      i2cDataLenCnt ++;
 348   4                              }
 349   3                      }
 350   2              }
 351   1      }
 352          
 353          #if I2C_SLAVE_ENABLE
              /*
               *--------------------------------------------------------------------------------
               * static void i2c_SlvRxProcess(void)
               * Purpose : Handling received command functions in I2C slave mode And replying
               *           packets corresponding with the received command.
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 7   

               * Params  : none
               * Returns : none
               * Note    : none
               *--------------------------------------------------------------------------------
               */
              static void i2c_SlvRxProcess(void)
              {
                      U8_T    slvCmd;
                      U8_T    sfrAddr;
                      U8_T    cmdIndReg, realReg, realLen;
                      U32_T   memAddr, memData;
                      U16_T   i;
              
                      slvCmd = i2cSlvRxPkt[0];
                      if ((slvCmd & 0xF0) == I2C_SLV_SWSFR)
                      {
                              realLen = (slvCmd & 0x0F) + 1;
                              sfrAddr = i2cSlvRxPkt[1];
                              for (i = 0 ; i < realLen ; i ++)
                              {
                                      CLI_SfrWr((U32_T)sfrAddr, (U32_T)i2cSlvRxPkt[i + 2]);
                              }
                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_SRSFR)
                      {
                              realLen = (slvCmd & 0x0F) + 1;
                              sfrAddr = i2cSlvRxPkt[1];
                              for (i = 0 ; i < realLen ; i ++)
                              {
                                      CLI_SfrRd((U32_T)sfrAddr, &memData);
                                      i2cSlvTxPkt[i] = (U8_T)memData;
                              }
                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_IWSFR)
                      {
                              cmdIndReg = i2cSlvRxPkt[1];
                              realReg = i2cSlvRxPkt[2];
                              realLen = (slvCmd & 0x0F) + 1;
                              if (cmdIndReg == SFR_I2CCIR)
                              {
                                      CLI_I2cWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_SPICIR)
                              {
                                      CLI_SpiWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_OWCIR)
                              {
                                      CLI_OwWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_CANCIR)
                              {
                                      CLI_CanWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_TCIR)
                              {
                                      CLI_ToeWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_MCIR)
                              {
                                      CLI_MacWr((U32_T)realReg, &i2cSlvRxPkt[3], (U8_T)realLen);
                              }
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 8   

                      }
                      else if ((slvCmd & 0xF0) == I2C_SLV_IRSFR)
                      {
                              cmdIndReg = i2cSlvRxPkt[1];
                              realReg = i2cSlvRxPkt[2];
                              realLen = (slvCmd & 0x0F) + 1;
                              if (cmdIndReg == SFR_I2CCIR)
                              {
                                      CLI_I2cRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_SPICIR)
                              {
                                      CLI_SpiRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_OWCIR)
                              {
                                      CLI_OwRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_CANCIR)
                              {
                                      CLI_CanRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_TCIR)
                              {
                                      CLI_ToeRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                              else if (cmdIndReg == SFR_MCIR)
                              {
                                      CLI_MacRd((U32_T)realReg, &i2cSlvTxPkt[i2cDataLenCnt], (U8_T)realLen);
                              }
                      }
                      else if (slvCmd == I2C_SLV_BWDM)
                      {
                              memAddr = ((U32_T)i2cSlvRxPkt[3] << 16) | ((U32_T)i2cSlvRxPkt[2] << 8) | ((U32_T)i2cSlvRxPkt[1]);
                              for (i = 4 ; i < i2cDataLen ; i ++)
                              {
                                      CLI_ExtMemWr((U32_T)memAddr, (U32_T)i2cSlvRxPkt[i]);
                                      memAddr ++;
                              }
                      }
                      else if (slvCmd == I2C_SLV_BRDM)
                      {
                              if (i2cDataLenCnt == 0)
                              {
                                      memAddr = ((U32_T)i2cSlvRxPkt[3] << 16) | ((U32_T)i2cSlvRxPkt[2] << 8) | ((U32_T)i2cSlvRxPkt[1]);
                              }
                              CLI_ExtMemRd((U32_T)memAddr, &memData);
                              i2cSlvTxPkt[i2cDataLenCnt] = (U8_T)memData;
                              memAddr ++;
                      }
              }
              #endif
 473          
 474          /*
 475           *--------------------------------------------------------------------------------
 476           * static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd)
 477           * Purpose : Putting the data into i2c transmitting register and setting the
 478           *           master's command and condition in I2C master mode.
 479           * Params  : wrData - one byte data to transmit.
 480           *           mstCmd - master command of the current byte data.
 481           * Returns : none
 482           * Note    : none
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 9   

 483           *--------------------------------------------------------------------------------
 484           */
 485          static void i2c_MasterXmit(U8_T wrData, U8_T mstCmd)
 486          {
 487   1              /* Record the globe flag of command condition */
 488   1              i2cActF = mstCmd;
 489   1              /* First the master flipper sends the slave address to access */
 490   1              I2C_Cmd(SI_WR, I2CTR, &wrData);
 491   1              /* Order command to I2CCR */
 492   1              I2C_Cmd(SI_WR, I2CCR, &mstCmd);
 493   1      }
 494          
 495          /*
 496           *--------------------------------------------------------------------------------
 497           * static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd)
 498           * Purpose : Getting the receiving byte data in I2C master mode.
 499           * Params  : *rdData - a pointer to store receiving data.
 500           *           mstCmd - master command of the current byte data.
 501           * Returns : none
 502           * Note    : none
 503           *--------------------------------------------------------------------------------
 504           */
 505          static void i2c_MasterRcvr(U8_T *rdData, U8_T mstCmd)
 506          {
 507   1              /* Record the globe flag of command condition */
 508   1              i2cActF = mstCmd;
 509   1              /* After ACK, read data from I2CRR */
 510   1              I2C_Cmd(SI_RD, I2CRR, rdData);
 511   1              /* Then, reply ACK to slave */
 512   1              I2C_Cmd(SI_WR, I2CCR, &mstCmd);
 513   1      
 514   1              i2cDataLenCnt ++;
 515   1      }
 516          
 517          /*
 518           *--------------------------------------------------------------------------------
 519           * static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd)
 520           * Purpose : Putting the data into i2c transmitting register and setting the
 521           *           master's command and condition in I2C slave mode.
 522           * Params  : wrData - one byte data to transmit.
 523           *           slvCmd - slave command of the current byte data.
 524           * Returns : none
 525           * Note    : none
 526           *--------------------------------------------------------------------------------
 527           */
 528          static void i2c_SlaveXmit(U8_T wrData, U8_T slvCmd)
 529          {
 530   1              /* Record the globe flag of command condition */
 531   1              i2cActF = slvCmd;
 532   1              /* transmit the data byte */
 533   1              I2C_Cmd(SI_WR, I2CTR, &wrData);
 534   1              /* Order command to I2CCR */
 535   1              I2C_Cmd(SI_WR, I2CCR, &slvCmd);
 536   1      }
 537          
 538          /*
 539           *--------------------------------------------------------------------------------
 540           * static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd)
 541           * Purpose : Getting the receiving byte data in I2C slave mode.
 542           * Params  : *rdData - a pointer to store receiving data.
 543           *           slvCmd - slave command of the current byte data.
 544           * Returns : none
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 10  

 545           * Note    : none
 546           *--------------------------------------------------------------------------------
 547           */
 548          static void i2c_SlaveRcvr(U8_T *rdData, U8_T slvCmd)
 549          {
 550   1              /* Record the globe flag of command condition */
 551   1              i2cActF = slvCmd;
 552   1              /* After ACK, read data from I2CRR */
 553   1              I2C_Cmd(SI_RD, I2CRR, rdData);
 554   1              /* Then, reply ACK to slave */
 555   1              I2C_Cmd(SI_WR, I2CCR, &slvCmd);
 556   1      }
 557          
 558          
 559          /* EXPORTED SUBPROGRAM BODIES */
 560          
 561          /*
 562           *--------------------------------------------------------------------------------
 563           * void I2C_Setup(U8_T ctrlCmd, U16_T preClk, U16_T axIdAddr)
 564           * Purpose : This function is used to setup the I2C module and
 565           *           to initial the globe values in this module.
 566           * Params  : ctrlCmd - control register value.
 567           *           preClk - a pre-scale parameter calculates the bus speed.
 568           *           axIdAddr - a device address of local AX11000 I2C module.
 569           * Returns : none
 570           * Note    : none
 571           *--------------------------------------------------------------------------------
 572           */
 573          void I2C_Setup(U8_T ctrlCmd, U16_T preClk, U16_T axIdAddr)
 574          {
 575   1              U16_T   i;
 576   1              /* Values initial */
 577   1              i2cCtrl = 0;
 578   1              i2cEndCond = 0;
 579   1              i2cActF = 0;
 580   1              i2cDataLen = 0;
 581   1              i2cDataLenCnt = 0;
 582   1              i2cPktDir = 0;
 583   1              ptI2cTxBuf = NULL;
 584   1              ptI2cRxBuf = NULL;
 585   1              i2cState = 0;
 586   1              for (i=0 ; i<SLV_MAX_PKT_NUM ; i++)
 587   1              {
 588   2                      i2cSlvRxPkt[i] = 0;
 589   2                      i2cSlvTxPkt[i] = 0;
 590   2              }
 591   1      
 592   1              /* Pre-scale Clock */
 593   1              I2CDR = (U8_T)(0x00FF & preClk);
 594   1              I2CDR = (U8_T)((0xFF00 & preClk) >> 8);
 595   1              I2CCIR = I2CCPR;
 596   1              /* Flipper device address for slave mode */
 597   1              I2CDR = (U8_T)(axIdAddr & 0x00FF);
 598   1              I2CDR = (U8_T)((axIdAddr & 0xFF00) >> 8);
 599   1              I2CCIR = I2CSDAR;
 600   1              /* Setup I2C mode */
 601   1              I2C_Cmd(SI_WR, I2CCTL, &ctrlCmd);
 602   1      }
 603          
 604          /*
 605           *--------------------------------------------------------------------------------
 606           * void I2C_Func(void)
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 11  

 607           * Purpose : Handling serial interface I2C interrupt function.
 608           * Params  : none
 609           * Returns : none
 610           * Note    : The I2C_RLE_ING (reloading I2C EEPROM) bit and
 611           *           the I2C_BL_DONE (Bootloader done) bit must always be checked,
 612           *           whichever in master mode or slave mode.
 613           *--------------------------------------------------------------------------------
 614           */
 615          void I2C_Func(void)
 616          {
 617   1              U8_T    i2cStatus;
 618   1      
 619   1              I2C_Cmd(SI_RD, I2CCTL, &i2cCtrl);
 620   1      
 621   1              if (i2cCtrl & I2C_MASTER_MODE)
 622   1              {
 623   2                      EA = 0;
 624   2                      I2C_Cmd(SI_RD, I2CMSR, &i2cStatus);
 625   2                      EA = 1;
 626   2                      if (!(i2cStatus & I2C_RLE_ING) && (i2cStatus & I2C_BL_DONE))
 627   2                      {
 628   3                              if (i2cCtrl & I2C_MST_IE)
 629   3                              {
 630   4                                      if (i2cStatus & I2C_INTR_FLAG)
 631   4                                      {
 632   5                                              i2c_MstStatus(i2cStatus);
 633   5                                      }
 634   4                              }
 635   3                              else
 636   3                              {
 637   4                                      if (!(i2cStatus & I2C_TIP))
 638   4                                      {
 639   5                                              i2c_MstStatus(i2cStatus);
 640   5                                      }
 641   4                              }
 642   3                      }
 643   2              }
 644   1              else
 645   1              {
 646   2                      EA = 0;
 647   2                      I2C_Cmd(SI_RD, I2CMSR, &i2cStatus);
 648   2                      EA = 1;
 649   2      
 650   2                      if (!(i2cStatus & I2C_RLE_ING) && (i2cStatus & I2C_BL_DONE))
 651   2                      {
 652   3                              i2cStatus = 0;
 653   3                              EA = 0;
 654   3                              I2C_Cmd(SI_RD, I2CSSR, &i2cStatus);
 655   3                              EA = 1;
 656   3                              if (i2cCtrl & I2C_SLV_IE)
 657   3                              {
 658   4                                      if (i2cStatus & I2C_SLV_TXR_OK)
 659   4                                      {
 660   5                                              i2c_SlvStatus(i2cStatus);
 661   5                                      }
 662   4                              }
 663   3                              else
 664   3                              {
 665   4                                      if (i2cStatus & I2C_SLV_TXR_OK)
 666   4                                      {
 667   5                                              i2c_SlvStatus(i2cStatus);
 668   5                                      }
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 12  

 669   4                              }
 670   3                      }
 671   2              }
 672   1      }
 673          
 674          /*
 675           *--------------------------------------------------------------------------------
 676           * void I2C_PktBuf(I2C_BUF *ptI2cBuf)
 677           * Purpose : Packeting a packet and transmitting the first byte
 678           * Params  : ptI2cBuf - a pointer stores the packet.
 679           * Returns : none
 680           * Note    : none
 681           *--------------------------------------------------------------------------------
 682           */
 683          void I2C_PktBuf(I2C_BUF *ptI2cBuf)
 684          {
 685   1              U8_T    firstAddr;
 686   1      
 687   1              I2C_Cmd(SI_RD, I2CCTL, &i2cCtrl); 
 688   1              if (i2cCtrl & I2C_MASTER_MODE) // I2C Master Mode
 689   1              {
 690   2                      i2cDataLenCnt = 0;
 691   2                      i2cEndCond = ptI2cBuf->I2cEnd;
 692   2                      i2cPktDir = ptI2cBuf->I2cDir;
 693   2                      i2cDataLen = ptI2cBuf->DataLen;
 694   2                                      
 695   2                              if (i2cCtrl & I2C_10BIT)
 696   2                              {
 697   3                                      firstAddr = ((U8_T)((ptI2cBuf->I2cAddr.TenBitAddr & 0x0300) >> 7) | 0xF0);
 698   3                                      if (i2cPktDir & I2C_XMIT)
 699   3                                      {
 700   4                                              ptI2cTxBuf = ptI2cBuf;
 701   4                                              i2c_MasterXmit(firstAddr & ~BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 702   4                                      }
 703   3                                      else
 704   3                                      {
 705   4                                              ptI2cRxBuf = ptI2cBuf;
 706   4                                              i2c_MasterXmit(firstAddr | BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 707   4                                      }
 708   3                              }
 709   2                              else
 710   2                              {
 711   3                                      firstAddr = ptI2cBuf->I2cAddr.SevenBitAddr << 1;
 712   3                                      if (i2cPktDir & I2C_XMIT)
 713   3                                      {
 714   4                                              ptI2cTxBuf = ptI2cBuf;
 715   4                                              i2c_MasterXmit(firstAddr & ~BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 716   4                                      }
 717   3                                      else
 718   3                                      {
 719   4                                              ptI2cRxBuf = ptI2cBuf;
 720   4                                              i2c_MasterXmit(firstAddr | BIT0, I2C_MASTER_GO | I2C_CMD_WRITE | I2C_START_COND);
 721   4                                      }
 722   3                              }
 723   2              }
 724   1              else // I2C Slave Mode
 725   1              {
 726   2                      if (ptI2cBuf->I2cDir & I2C_XMIT)
 727   2                      {
 728   3                              /* Get the slave data to transmit */
 729   3                              //ptI2cTxBuf->ptI2c = ??;
 730   3                              ptI2cBuf->DataLen = i2cDataLen;
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 13  

 731   3                      }
 732   2                      else
 733   2                      {
 734   3                              /* packet the received data to upper layer */
 735   3                              ptI2cBuf->DataLen = i2cDataLen;
 736   3                      }
 737   2              }
 738   1      }
 739          
 740          /*
 741           *--------------------------------------------------------------------------------
 742           * BOOL I2C_FlagChk(U8_T chkBit)
 743           * Purpose : Checking the current state in I2C driver.
 744           * Params  : chkBit - the state bit to be checked.
 745           * Returns : TRUE - the state value meets the chkBit.
 746           * Note    : none
 747           *--------------------------------------------------------------------------------
 748           */
 749          BOOL I2C_FlagChk(U8_T chkBit)
 750          {
 751   1              if (i2cState & chkBit)
 752   1                      return TRUE;
 753   1              else
 754   1                      return FALSE;
 755   1      }
 756          
 757          /*
 758           *--------------------------------------------------------------------------------
 759           * void I2C_FlagEnb(U8_T enbBit)
 760           * Purpose : Setting the current state in I2C driver.
 761           * Params  : enbBit - the state bit to be set.
 762           * Returns : none
 763           * Note    : none
 764           *--------------------------------------------------------------------------------
 765           */
 766          void I2C_FlagEnb(U8_T enbBit)
 767          {
 768   1              i2cState = i2cState | enbBit;
 769   1      }
 770          
 771          /*
 772           *--------------------------------------------------------------------------------
 773           * void I2C_FlagClr(U8_T clrBit)
 774           * Purpose : Clearing the current state in I2C driver.
 775           * Params  : clrBit - the state bit to be cleared.
 776           * Returns : none
 777           * Note    : none
 778           *--------------------------------------------------------------------------------
 779           */
 780          void I2C_FlagClr(U8_T clrBit)
 781          {
 782   1              i2cState = i2cState & ~clrBit;
 783   1      }
 784          
 785          /*
 786           *--------------------------------------------------------------------------------
 787           * void I2C_Cmd(U8_T cmdType, U8_T i2cCmdIndex, U8_T *i2cData)
 788           * Purpose : Accessing the I2C interface indirectly through I2C's SFR.
 789           * Params  : cmdType - command type of writing or reading.
 790           *           i2cCmdIndex - I2C register address.
 791           *           *i2cData - a pointer store the data.
 792           * Returns : none
C51 COMPILER V9.06   I2C                                                                   05/28/2013 10:15:30 PAGE 14  

 793           * Note    : none
 794           *--------------------------------------------------------------------------------
 795           */
 796          void I2C_Cmd(U8_T cmdType, U8_T i2cCmdIndex, U8_T *i2cData)
 797          {
 798   1              if (cmdType == SI_WR)
 799   1              {
 800   2                      I2CDR = *i2cData;
 801   2                      I2CCIR = i2cCmdIndex;
 802   2              }
 803   1              else if (cmdType == SI_RD)
 804   1              {
 805   2                      I2CCIR = i2cCmdIndex;
 806   2                      *i2cData = I2CDR;
 807   2              }
 808   1      }
 809          
 810          /*
 811           *--------------------------------------------------------------------------------
 812           * void I2C_Post(void)
 813           * Purpose :
 814           * Params  :
 815           * Returns :
 816           * Note    :
 817           *--------------------------------------------------------------------------------
 818           */
 819          void I2C_Post(void)
 820          {
 821   1      }
 822          
 823          
 824          /* End of i2c.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2076    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    143      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
