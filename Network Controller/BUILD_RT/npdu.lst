C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE NPDU
OBJECT MODULE PLACED IN .\npdu.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\npdu.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version) DEFINE(KEIL_AX11000
                    -) VARBANKING DEBUG PRINT(.\npdu.lst) OBJECT(.\npdu.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2005 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          #include <stdbool.h>
  35          #include <stdint.h>
  36          #include "../include/bacdef.h"
  37          #include "../include/bacdcode.h"
  38          #include "../include/bacint.h"
  39          #include "../include/bacenum.h"
  40          #include "../include/bits.h"
  41          #include "../include/npdu.h"
  42          #include "../include/apdu.h"
  43          
  44          /** @file npdu.c  Encode/Decode NPDUs - Network Protocol Data Units */
  45          
  46          /** Copy the npdu_data structure information from src to dest.
  47           * @param dest [out] The 'to' structure
  48           * @param src   [in] The 'from' structure
  49           */
  50          void npdu_copy_data(
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 2   

  51              BACNET_NPDU_DATA * dest,
  52              BACNET_NPDU_DATA * src)
  53          {
  54   1          if (dest && src) {
  55   2              dest->protocol_version = src->protocol_version;
  56   2              dest->data_expecting_reply = src->data_expecting_reply;
  57   2              dest->network_layer_message = src->network_layer_message;
  58   2              dest->priority = src->priority;
  59   2              dest->network_message_type = src->network_message_type;
  60   2              dest->vendor_id = src->vendor_id;
  61   2              dest->hop_count = src->hop_count;
  62   2          }
  63   1      
  64   1          return;
  65   1      }
  66          
  67          /*
  68          
  69          The following ICI parameters are exchanged with the
  70          various service primitives across an API:
  71          
  72          'destination_address' (DA): the address of the device(s)
  73          intended to receive the service primitive. Its format (device name,
  74          network address, etc.) is a local matter. This address
  75          may also be a multicast, local broadcast or global broadcast type.
  76          
  77          'source_address' (SA): the address of the device from which
  78          the service primitive was received. Its format (device name,
  79          network address, etc.) is a local matter.
  80          
  81          'network_priority' (NP): a four-level network priority parameter
  82          described in 6.2.2.
  83          
  84          'data_expecting_reply' (DER): a Boolean parameter that indicates
  85          whether (TRUE) or not (FALSE) a reply service primitive
  86          is expected for the service being issued.
  87          
  88          
  89          Table 5-1. Applicability of ICI parameters for abstract service primitives
  90               Service Primitive         DA           SA         NP        DER
  91          CONF_SERV.request              Yes          No         Yes       Yes
  92          CONF_SERV.indication           Yes         Yes         Yes       Yes
  93          CONF_SERV.response             Yes          No         Yes       Yes
  94          CONF_SERV.confirm              Yes         Yes         Yes        No
  95          UNCONF_SERV.request            Yes          No         Yes        No
  96          UNCONF_SERV.indication         Yes         Yes         Yes        No
  97          REJECT.request                 Yes          No         Yes        No
  98          REJECT.indication              Yes         Yes         Yes        No
  99          SEGMENT_ACK.request            Yes          No         Yes        No
 100          SEGMENT_ACK.indication         Yes         Yes         Yes        No
 101          ABORT.request                  Yes          No         Yes        No
 102          ABORT.indication               Yes         Yes         Yes        No
 103          */
 104          
 105          
 106          /** Encode the NPDU portion of a message to be sent, based on the npdu_data
 107           *  and associated data.
 108           *  If this is to be a Network Layer Control Message, there are probably
 109           *  more bytes which will need to be encoded following the ones encoded here.
 110           *  The Network Layer Protocol Control Information byte is described
 111           *  in section 6.2.2 of the BACnet standard.
 112           * @param npdu [out] Buffer which will hold the encoded NPDU header bytes.
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 3   

 113           *                                       The size isn't given, but it must be at least 2 bytes
 114           *                   for the simplest case, and should always be at least 24
 115           *                   bytes to accommodate the maximal case (all fields loaded).
 116           * @param dest [in] The routing destination information if the message must
 117           *                   be routed to reach its destination.
 118           *                   If dest->net and dest->len are 0, there is no
 119           *                   routing destination information.
 120           * @param src  [in] The routing source information if the message was routed
 121           *                   from another BACnet network.
 122           *                   If src->net and src->len are 0, there is no
 123           *                   routing source information.
 124           *                   This src describes the original source of the message when
 125           *                   it had to be routed to reach this BACnet Device.
 126           * @param npdu_data [in] The structure which describes how the NCPI and other
 127           *                   NPDU bytes should be encoded.
 128           * @return On success, returns the number of bytes which were encoded into the
 129           *                 NPDU section.
 130           *         If 0 or negative, there were problems with the data or encoding.
 131           */
 132          int npdu_encode_pdu(
 133              uint8_t * npdu,
 134              BACNET_ADDRESS * dest,
 135              BACNET_ADDRESS * src,
 136              BACNET_NPDU_DATA * npdu_data)
 137          {
 138   1          int len = 0;        /* return value - number of octets loaded in this function */
 139   1          uint8_t i = 0;      /* counter  */
 140   1      
 141   1      
 142   1          if (npdu && npdu_data) {
 143   2              /* protocol version */
 144   2              npdu[0] = npdu_data->protocol_version;
 145   2              /* initialize the control octet */
 146   2              npdu[1] = 0;
 147   2              /* Bit 7: 1 indicates that the NSDU conveys a network layer message. */
 148   2              /*          Message Type field is present. */
 149   2              /*        0 indicates that the NSDU contains a BACnet APDU. */
 150   2              /*          Message Type field is absent. */
 151   2              if (npdu_data->network_layer_message)
 152   2                  npdu[1] |= BIT7;
 153   2              /*Bit 6: Reserved. Shall be zero. */
 154   2              /*Bit 5: Destination specifier where: */
 155   2              /* 0 = DNET, DLEN, DADR, and Hop Count absent */
 156   2              /* 1 = DNET, DLEN, and Hop Count present */
 157   2              /* DLEN = 0 denotes broadcast MAC DADR and DADR field is absent */
 158   2              /* DLEN > 0 specifies length of DADR field */
 159   2              if (dest && dest->net)
 160   2                  npdu[1] |= BIT5;
 161   2              /* Bit 4: Reserved. Shall be zero. */
 162   2              /* Bit 3: Source specifier where: */
 163   2              /* 0 =  SNET, SLEN, and SADR absent */
 164   2              /* 1 =  SNET, SLEN, and SADR present */
 165   2              /* SLEN = 0 Invalid */
 166   2              /* SLEN > 0 specifies length of SADR field */
 167   2              if (src && src->net && src->len)
 168   2                  npdu[1] |= BIT3;
 169   2              /* Bit 2: The value of this bit corresponds to the */
 170   2              /* data_expecting_reply parameter in the N-UNITDATA primitives. */
 171   2              /* 1 indicates that a BACnet-Confirmed-Request-PDU, */
 172   2              /* a segment of a BACnet-ComplexACK-PDU, */
 173   2              /* or a network layer message expecting a reply is present. */
 174   2              /* 0 indicates that other than a BACnet-Confirmed-Request-PDU, */
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 4   

 175   2              /* a segment of a BACnet-ComplexACK-PDU, */
 176   2              /* or a network layer message expecting a reply is present. */
 177   2              if (npdu_data->data_expecting_reply)
 178   2                  npdu[1] |= BIT2;
 179   2              /* Bits 1,0: Network priority where: */
 180   2              /* B'11' = Life Safety message */
 181   2              /* B'10' = Critical Equipment message */
 182   2              /* B'01' = Urgent message */
 183   2              /* B'00' = Normal message */
 184   2              npdu[1] |= (npdu_data->priority & 0x03);
 185   2              len = 2;
 186   2              if (dest && dest->net) {
 187   3                  len += encode_unsigned16(&npdu[len], dest->net);
 188   3                  npdu[len++] = dest->len;
 189   3                  /* DLEN = 0 denotes broadcast MAC DADR and DADR field is absent */
 190   3                  /* DLEN > 0 specifies length of DADR field */
 191   3                  if (dest->len) {
 192   4                      for (i = 0; i < dest->len; i++) {
 193   5                          npdu[len++] = dest->adr[i];
 194   5                      }
 195   4                  }
 196   3              }
 197   2              if (src && src->net && src->len) {      /* Only insert if valid */
 198   3                  len += encode_unsigned16(&npdu[len], src->net);
 199   3                  npdu[len++] = src->len;
 200   3                  /* SLEN = 0 denotes broadcast MAC SADR and SADR field is absent */
 201   3                  /* SLEN > 0 specifies length of SADR field */
 202   3                  if (src->len) {
 203   4                      for (i = 0; i < src->len; i++) {
 204   5                          npdu[len++] = src->adr[i];
 205   5                      }
 206   4                  }
 207   3              }
 208   2              /* The Hop Count field shall be present only if the message is */
 209   2              /* destined for a remote network, i.e., if DNET is present. */
 210   2              /* This is a one-octet field that is initialized to a value of 0xff. */
 211   2              if (dest && dest->net) {
 212   3                  npdu[len] = npdu_data->hop_count;
 213   3                  len++;
 214   3              }
 215   2              if (npdu_data->network_layer_message) {
 216   3                  npdu[len] = npdu_data->network_message_type;
 217   3                  len++;
 218   3                  /* Message Type field contains a value in the range 0x80 - 0xFF, */
 219   3                  /* then a Vendor ID field shall be present */
 220   3                  if (npdu_data->network_message_type >= 0x80)
 221   3                      len += encode_unsigned16(&npdu[len], npdu_data->vendor_id);
 222   3              }
 223   2          }
 224   1      
 225   1          return len;
 226   1      }
 227          
 228          /* Configure the NPDU portion of the packet for an APDU */
 229          /* This function does not handle the network messages, just APDUs. */
 230          /* From BACnet 5.1:
 231          Applicability of ICI parameters for abstract service primitives
 232          Service Primitive      DA  SA  NP  DER
 233          -----------------      --- --- --- ---
 234          CONF_SERV.request      Yes No  Yes Yes
 235          CONF_SERV.indication   Yes Yes Yes Yes
 236          CONF_SERV.response     Yes No  Yes Yes
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 5   

 237          CONF_SERV.confirm      Yes Yes Yes No
 238          UNCONF_SERV.request    Yes No  Yes No
 239          UNCONF_SERV.indication Yes Yes Yes No
 240          REJECT.request         Yes No  Yes No
 241          REJECT.indication      Yes Yes Yes No
 242          SEGMENT_ACK.request    Yes No  Yes No
 243          SEGMENT_ACK.indication Yes Yes Yes No
 244          ABORT.request          Yes No  Yes No
 245          ABORT.indication       Yes Yes Yes No
 246          
 247          Where:
 248          'destination_address' (DA): the address of the device(s) intended
 249          to receive the service primitive. Its format (device name,
 250          network address, etc.) is a local matter. This address may
 251          also be a multicast, local broadcast or global broadcast type.
 252          'source_address' (SA): the address of the device from which
 253          the service primitive was received. Its format (device name,
 254          network address, etc.) is a local matter.
 255          'network_priority' (NP): a four-level network priority parameter
 256          described in 6.2.2.
 257          'data_expecting_reply' (DER): a Boolean parameter that indicates
 258          whether (TRUE) or not (FALSE) a reply service primitive
 259          is expected for the service being issued.
 260          */
 261          
 262          /** Initialize an npdu_data structure to good defaults.
 263           * The name is a misnomer, as it doesn't do any actual encoding here.
 264           * @see npdu_encode_npdu_network if you need to set a network layer msg.
 265           *
 266           * @param npdu_data [out] Returns a filled-out structure with information
 267           *                                       provided by the other arguments and good defaults.
 268           * @param data_expecting_reply [in] True if message should have a reply.
 269           * @param priority [in] One of the 4 priorities defined in section 6.2.2,
 270           *                      like B'11' = Life Safety message
 271           */
 272          void npdu_encode_npdu_data(
 273              BACNET_NPDU_DATA * npdu_data,
 274              bool data_expecting_reply,
 275              BACNET_MESSAGE_PRIORITY priority)
 276          {
 277   1          if (npdu_data) {
 278   2              npdu_data->data_expecting_reply = data_expecting_reply;
 279   2              npdu_data->protocol_version = BACNET_PROTOCOL_VERSION;
 280   2              npdu_data->network_layer_message = false;       /* false if APDU */
 281   2              npdu_data->network_message_type = NETWORK_MESSAGE_INVALID;      /* optional */
 282   2              npdu_data->vendor_id = 0;       /* optional, if net message type is > 0x80 */
 283   2              npdu_data->priority = priority;
 284   2              npdu_data->hop_count = HOP_COUNT_DEFAULT;
 285   2          }
 286   1      }
 287          
 288          /** Decode the NPDU portion of a received message, particularly the NCPI byte.
 289           *  The Network Layer Protocol Control Information byte is described
 290           *  in section 6.2.2 of the BACnet standard.
 291           * @param npdu [in] Buffer holding the received NPDU header bytes (must be at least 2)
 292           * @param dest [out] Returned with routing destination information if the NPDU
 293           *                   has any and if this points to non-null storage for it.
 294           *                   If dest->net and dest->len are 0 on return, there is no
 295           *                   routing destination information.
 296           * @param src  [out] Returned with routing source information if the NPDU
 297           *                   has any and if this points to non-null storage for it.
 298           *                   If src->net and src->len are 0 on return, there is no
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 6   

 299           *                   routing source information.
 300           *                   This src describes the original source of the message when
 301           *                   it had to be routed to reach this BACnet Device.
 302           * @param npdu_data [out] Returns a filled-out structure with information
 303           *                                       decoded from the NCPI and other NPDU bytes.
 304           * @return On success, returns the number of bytes which were decoded from the
 305           *                 NPDU section; if this is a  network layer message, there may be more
 306           *         bytes left in the NPDU; if not a network msg, the APDU follows.
 307           *         If 0 or negative, there were problems with the data or arguments.
 308           */
 309          int npdu_decode(
 310              uint8_t * npdu,
 311              BACNET_ADDRESS * dest,
 312              BACNET_ADDRESS * src,
 313              BACNET_NPDU_DATA * npdu_data)
 314          {
 315   1          int len = 0;        /* return value - number of octets loaded in this function */
 316   1          uint8_t i = 0;      /* counter */
 317   1          uint16_t src_net = 0;
 318   1          uint16_t dest_net = 0;
 319   1          uint8_t address_len = 0;
 320   1          uint8_t mac_octet = 0;
 321   1      
 322   1          if (npdu && npdu_data) {
 323   2              /* Protocol Version */
 324   2              npdu_data->protocol_version = npdu[0];
 325   2              /* control octet */
 326   2              /* Bit 7: 1 indicates that the NSDU conveys a network layer message. */
 327   2              /*          Message Type field is present. */
 328   2              /*        0 indicates that the NSDU contains a BACnet APDU. */
 329   2              /*          Message Type field is absent. */
 330   2              npdu_data->network_layer_message = (npdu[1] & BIT7) ? true : false;
 331   2              /*Bit 6: Reserved. Shall be zero. */
 332   2              /* Bit 4: Reserved. Shall be zero. */
 333   2              /* Bit 2: The value of this bit corresponds to data expecting reply */
 334   2              /* parameter in the N-UNITDATA primitives. */
 335   2              /* 1 indicates that a BACnet-Confirmed-Request-PDU, */
 336   2              /* a segment of a BACnet-ComplexACK-PDU, */
 337   2              /* or a network layer message expecting a reply is present. */
 338   2              /* 0 indicates that other than a BACnet-Confirmed-Request-PDU, */
 339   2              /* a segment of a BACnet-ComplexACK-PDU, */
 340   2              /* or a network layer message expecting a reply is present. */
 341   2              npdu_data->data_expecting_reply = (npdu[1] & BIT2) ? true : false;
 342   2              /* Bits 1,0: Network priority where: */
 343   2              /* B'11' = Life Safety message */
 344   2              /* B'10' = Critical Equipment message */
 345   2              /* B'01' = Urgent message */
 346   2              /* B'00' = Normal message */
 347   2              npdu_data->priority = (BACNET_MESSAGE_PRIORITY) (npdu[1] & 0x03);
 348   2              /* set the offset to where the optional stuff starts */
 349   2              len = 2;
 350   2              /*Bit 5: Destination specifier where: */
 351   2              /* 0 = DNET, DLEN, DADR, and Hop Count absent */
 352   2              /* 1 = DNET, DLEN, and Hop Count present */
 353   2              /* DLEN = 0 denotes broadcast MAC DADR and DADR field is absent */
 354   2              /* DLEN > 0 specifies length of DADR field */
 355   2              if (npdu[1] & BIT5) {
 356   3                  len += decode_unsigned16(&npdu[len], &dest_net);
 357   3                  /* DLEN = 0 denotes broadcast MAC DADR and DADR field is absent */
 358   3                  /* DLEN > 0 specifies length of DADR field */
 359   3                  address_len = npdu[len++];
 360   3                  if (dest) {
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 7   

 361   4                      dest->net = dest_net;
 362   4                      dest->len = address_len;
 363   4                  }
 364   3                  if (address_len) {
 365   4                      if (address_len > MAX_MAC_LEN) {
 366   5                          /* address is too large could be a malformed message */
 367   5                          return -1;
 368   5                      }
 369   4      
 370   4                      for (i = 0; i < address_len; i++) {
 371   5                          mac_octet = npdu[len++];
 372   5                          if (dest)
 373   5                              dest->adr[i] = mac_octet;
 374   5                      }
 375   4                  }
 376   3              }
 377   2              /* zero out the destination address */
 378   2              else if (dest) {
 379   3                  dest->net = 0;
 380   3                  dest->len = 0;
 381   3                  for (i = 0; i < MAX_MAC_LEN; i++) {
 382   4                      dest->adr[i] = 0;
 383   4                  }
 384   3              }
 385   2              /* Bit 3: Source specifier where: */
 386   2              /* 0 =  SNET, SLEN, and SADR absent */
 387   2              /* 1 =  SNET, SLEN, and SADR present */
 388   2              /* SLEN = 0 Invalid */
 389   2              /* SLEN > 0 specifies length of SADR field */
 390   2              if (npdu[1] & BIT3) {
 391   3                  len += decode_unsigned16(&npdu[len], &src_net);
 392   3                  /* SLEN = 0 denotes broadcast MAC SADR and SADR field is absent */
 393   3                  /* SLEN > 0 specifies length of SADR field */
 394   3                  address_len = npdu[len++];
 395   3                  if (src) {
 396   4                      src->net = src_net;
 397   4                      src->len = address_len;
 398   4                  }
 399   3                  if (address_len) {
 400   4                      if (address_len > MAX_MAC_LEN) {
 401   5                          /* address is too large could be a malformed message */
 402   5                          return -1;
 403   5                      }
 404   4      
 405   4                      for (i = 0; i < address_len; i++) {
 406   5                          mac_octet = npdu[len++];
 407   5                          if (src)
 408   5                              src->adr[i] = mac_octet;
 409   5                      }
 410   4                  }
 411   3              } else if (src) {
 412   3                  /* Clear the net number, with one exception: if the receive() 
 413   3                   * function set it to BACNET_BROADCAST_NETWORK, (eg, for 
 414   3                   * BVLC_ORIGINAL_BROADCAST_NPDU) then don't stomp on that.
 415   3                   */
 416   3                  if (src->net != BACNET_BROADCAST_NETWORK)
 417   3                      src->net = 0;
 418   3                  src->len = 0;
 419   3                  for (i = 0; i < MAX_MAC_LEN; i++) {
 420   4                      src->adr[i] = 0;
 421   4                  }
 422   3              }
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 8   

 423   2              /* The Hop Count field shall be present only if the message is */
 424   2              /* destined for a remote network, i.e., if DNET is present. */
 425   2              /* This is a one-octet field that is initialized to a value of 0xff. */
 426   2              if (dest_net) {
 427   3                  npdu_data->hop_count = npdu[len++];
 428   3              } else {
 429   3                  npdu_data->hop_count = 0;
 430   3              }
 431   2              /* Indicates that the NSDU conveys a network layer message. */
 432   2              /* Message Type field is present. */
 433   2              if (npdu_data->network_layer_message) {
 434   3                  npdu_data->network_message_type =
 435   3                      (BACNET_NETWORK_MESSAGE_TYPE) npdu[len++];
 436   3                  /* Message Type field contains a value in the range 0x80 - 0xFF, */
 437   3                  /* then a Vendor ID field shall be present */
 438   3                  if (npdu_data->network_message_type >= 0x80)
 439   3                      len += decode_unsigned16(&npdu[len], &npdu_data->vendor_id);
 440   3              } else {
 441   3                  /* Since npdu_data->network_layer_message is false,
 442   3                   * it doesn't much matter what we set here; this is safe: */
 443   3                  npdu_data->network_message_type = NETWORK_MESSAGE_INVALID;
 444   3              }
 445   2          }
 446   1      
 447   1          return len;
 448   1      }
 449          
 450          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include "ctest.h"
              
              void testNPDU2(
                  Test * pTest)
              {
                  uint8_t pdu[480] = { 0 };
                  BACNET_ADDRESS dest = { 0 };
                  BACNET_ADDRESS src = { 0 };
                  BACNET_ADDRESS npdu_dest = { 0 };
                  BACNET_ADDRESS npdu_src = { 0 };
                  int len = 0;
                  bool data_expecting_reply = true;
                  BACNET_MESSAGE_PRIORITY priority = MESSAGE_PRIORITY_NORMAL;
                  BACNET_NPDU_DATA npdu_data = { 0 };
                  int i = 0;  /* counter */
                  int npdu_len = 0;
                  bool network_layer_message = false; /* false if APDU */
                  BACNET_NETWORK_MESSAGE_TYPE network_message_type = 0;       /* optional */
                  uint16_t vendor_id = 0;     /* optional, if net message type is > 0x80 */
              
                  dest.mac_len = 6;
                  for (i = 0; i < dest.mac_len; i++) {
                      dest.mac[i] = i;
                  }
                  /* DNET,DLEN,DADR */
                  dest.net = 1;
                  dest.len = 6;
                  for (i = 0; i < dest.len; i++) {
                      dest.adr[i] = i * 10;
                  }
                  src.mac_len = 1;
                  for (i = 0; i < src.mac_len; i++) {
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 9   

                      src.mac[i] = 0x80;
                  }
                  /* SNET,SLEN,SADR */
                  src.net = 2;
                  src.len = 1;
                  for (i = 0; i < src.len; i++) {
                      src.adr[i] = 0x40;
                  }
                  npdu_encode_npdu_data(&npdu_data, true, priority);
                  len = npdu_encode_pdu(&pdu[0], &dest, &src, &npdu_data);
                  ct_test(pTest, len != 0);
                  /* can we get the info back? */
                  npdu_len = npdu_decode(&pdu[0], &npdu_dest, &npdu_src, &npdu_data);
                  ct_test(pTest, npdu_len != 0);
                  ct_test(pTest, npdu_data.data_expecting_reply == data_expecting_reply);
                  ct_test(pTest, npdu_data.network_layer_message == network_layer_message);
                  if (npdu_data.network_layer_message) {
                      ct_test(pTest, npdu_data.network_message_type == network_message_type);
                  }
                  ct_test(pTest, npdu_data.vendor_id == vendor_id);
                  ct_test(pTest, npdu_data.priority == priority);
                  /* DNET,DLEN,DADR */
                  ct_test(pTest, npdu_dest.net == dest.net);
                  ct_test(pTest, npdu_dest.len == dest.len);
                  for (i = 0; i < dest.len; i++) {
                      ct_test(pTest, npdu_dest.adr[i] == dest.adr[i]);
                  }
                  /* SNET,SLEN,SADR */
                  ct_test(pTest, npdu_src.net == src.net);
                  ct_test(pTest, npdu_src.len == src.len);
                  for (i = 0; i < src.len; i++) {
                      ct_test(pTest, npdu_src.adr[i] == src.adr[i]);
                  }
              }
              
              void testNPDU1(
                  Test * pTest)
              {
                  uint8_t pdu[480] = { 0 };
                  BACNET_ADDRESS dest = { 0 };
                  BACNET_ADDRESS src = { 0 };
                  BACNET_ADDRESS npdu_dest = { 0 };
                  BACNET_ADDRESS npdu_src = { 0 };
                  int len = 0;
                  bool data_expecting_reply = false;
                  BACNET_MESSAGE_PRIORITY priority = MESSAGE_PRIORITY_NORMAL;
                  BACNET_NPDU_DATA npdu_data = { 0 };
                  int i = 0;  /* counter */
                  int npdu_len = 0;
                  bool network_layer_message = false; /* false if APDU */
                  BACNET_NETWORK_MESSAGE_TYPE network_message_type = 0;       /* optional */
                  uint16_t vendor_id = 0;     /* optional, if net message type is > 0x80 */
              
                  /* mac_len = 0 if global address */
                  dest.mac_len = 0;
                  for (i = 0; i < MAX_MAC_LEN; i++) {
                      dest.mac[i] = 0;
                  }
                  /* DNET,DLEN,DADR */
                  dest.net = 0;
                  dest.len = 0;
                  for (i = 0; i < MAX_MAC_LEN; i++) {
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 10  

                      dest.adr[i] = 0;
                  }
                  src.mac_len = 0;
                  for (i = 0; i < MAX_MAC_LEN; i++) {
                      src.mac[i] = 0;
                  }
                  /* SNET,SLEN,SADR */
                  src.net = 0;
                  src.len = 0;
                  for (i = 0; i < MAX_MAC_LEN; i++) {
                      src.adr[i] = 0;
                  }
                  npdu_encode_npdu_data(&npdu_data, false, priority);
                  len = npdu_encode_pdu(&pdu[0], &dest, &src, &npdu_data);
                  ct_test(pTest, len != 0);
                  /* can we get the info back? */
                  npdu_len = npdu_decode(&pdu[0], &npdu_dest, &npdu_src, &npdu_data);
                  ct_test(pTest, npdu_len != 0);
                  ct_test(pTest, npdu_data.data_expecting_reply == data_expecting_reply);
                  ct_test(pTest, npdu_data.network_layer_message == network_layer_message);
                  if (npdu_data.network_layer_message) {
                      ct_test(pTest, npdu_data.network_message_type == network_message_type);
                  }
                  ct_test(pTest, npdu_data.vendor_id == vendor_id);
                  ct_test(pTest, npdu_data.priority == priority);
                  ct_test(pTest, npdu_dest.mac_len == src.mac_len);
                  ct_test(pTest, npdu_src.mac_len == dest.mac_len);
              }
              
              #ifdef TEST_NPDU
              /* dummy stub for testing */
              void tsm_free_invoke_id(
                  uint8_t invokeID)
              {
                  (void) invokeID;
              }
              
              void iam_handler(
                  uint8_t * service_request,
                  uint16_t service_len,
                  BACNET_ADDRESS * src)
              {
                  (void) service_request;
                  (void) service_len;
                  (void) src;
              }
              
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACnet NPDU", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testNPDU1);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testNPDU2);
                  assert(rc);
              
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
C51 COMPILER V9.06   NPDU                                                                  03/29/2013 16:57:07 PAGE 11  

                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_NPDU */
              #endif /* TEST */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3396    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
