C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE QUEUE
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\queue.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(
                    -0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC
                    -\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;
                    -..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX1
                    -1000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\queue.lst) SRC(.\qu
                    -eue.SRC)

line level    source

   1          /*
   2                  FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
   3          
   4                  This file is part of the FreeRTOS distribution.
   5          
   6                  FreeRTOS is free software; you can redistribute it and/or modify
   7                  it under the terms of the GNU General Public License as published by
   8                  the Free Software Foundation; either version 2 of the License, or
   9                  (at your option) any later version.
  10          
  11                  FreeRTOS is distributed in the hope that it will be useful,
  12                  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14                  GNU General Public License for more details.
  15          
  16                  You should have received a copy of the GNU General Public License
  17                  along with FreeRTOS; if not, write to the Free Software
  18                  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  19          
  20                  A special exception to the GPL can be applied should you wish to distribute
  21                  a combined work that includes FreeRTOS, without being obliged to provide
  22                  the source code for any proprietary components.  See the licensing section 
  23                  of http://www.FreeRTOS.org for full details of how and when the exception
  24                  can be applied.
  25          
  26                  ***************************************************************************
  27                  See http://www.FreeRTOS.org for documentation, latest information, license 
  28                  and contact details.  Please ensure to read the configuration and relevant 
  29                  port sections of the online documentation.
  30                  ***************************************************************************
  31          */
  32          
  33          /*
  34          Changes from V1.01
  35          
  36                  + More use of 8bit data types.
  37                  + Function name prefixes changed where the data type returned has changed.
  38          
  39          Changed from V2.0.0
  40          
  41                  + Added the queue locking mechanism and make more use of the scheduler
  42                    suspension feature to minimise the time interrupts have to be disabled
  43                    when accessing a queue.
  44          
  45          Changed from V2.2.0
  46          
  47                  + Explicit use of 'signed' qualifier on portCHAR types added.
  48          */
  49          
  50          #include <stdlib.h>
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 2   

  51          #include <string.h>
  52          #include "projdefs.h"
  53          #include "portable.h"
  54          #include "errors.h"
  55          #include "task.h"
  56          #include "list.h"
  57          
  58          /*-----------------------------------------------------------
  59           * PUBLIC LIST API documented in list.h
  60           *----------------------------------------------------------*/
  61          
  62          /* Constants used with the cRxLock and cTxLock structure members. */
  63          #define queueUNLOCKED   ( ( signed portCHAR ) -1 )
  64          
  65          /*
  66           * Definition of the queue used by the scheduler.
  67           * Items are queued by copy, not reference.
  68           */
  69          typedef struct QueueDefinition
  70          {
  71                  signed portCHAR *pcHead;                                /*< Points to the beginning of the queue storage area. */
  72                  signed portCHAR *pcTail;                                /*< Points to the byte at the end of the queue storage area.  Once more byte 
             -is allocated than necessary to store the queue items, this is used as a marker. */
  73          
  74                  signed portCHAR *pcWriteTo;                             /*< Points to the free next place in the storage area. */
  75                  signed portCHAR *pcReadFrom;                    /*< Points to the last place that a queued item was read from. */
  76          
  77                  xList xTasksWaitingToSend;                              /*< List of tasks that are blocked waiting to post onto this queue.  Stored
             - in priority order. */
  78                  xList xTasksWaitingToReceive;                   /*< List of tasks that are blocked waiting to read from this queue.  Stor
             -ed in priority order. */
  79          
  80                  unsigned portCHAR ucMessagesWaiting;    /*< The number of items currently in the queue. */
  81                  unsigned portCHAR ucLength;                             /*< The length of the queue defined as the number of items it will hold, n
             -ot the number of bytes. */
  82                  unsigned portCHAR ucItemSize;                   /*< The size of each items that the queue will hold. */
  83          
  84                  signed portCHAR cRxLock;                                /*< Stores the number of items received from the queue (removed from the queu
             -e) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
  85                  signed portCHAR cTxLock;                                /*< Stores the number of items transmitted to the queue (added to the queue) 
             -while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
  86          } xQUEUE;
  87          /*-----------------------------------------------------------*/
  88          
  89          /*
  90           * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
  91           * To keep the definition private the API header file defines it as a
  92           * pointer to void. 
  93           */
  94          typedef xQUEUE * xQueueHandle;
  95          
  96          /*
  97           * Prototypes for public functions are included here so we don't have to
  98           * include the API header file (as it defines xQueueHandle differently).  These
  99           * functions are documented in the API header file. 
 100           */
 101          xQueueHandle xQueueCreate( unsigned portCHAR ucQueueLength, unsigned portCHAR ucItemSize ) reentrant;
 102          signed portCHAR cQueueSend( xQueueHandle xQueue, const void * pvItemToQueue, portTickType xTicksToWait ) r
             -eentrant;
 103          unsigned portCHAR ucQueueMessagesWaiting( xQueueHandle pxQueue ) reentrant;
 104          void vQueueDelete( xQueueHandle xQueue ) reentrant;
 105          signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTaskP
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 3   

             -reviouslyWoken ) reentrant;
 106          signed portCHAR cQueueReceive( xQueueHandle pxQueue, void *pcBuffer, portTickType xTicksToWait ) reentrant
             -;
 107          signed portCHAR cQueueReceiveFromISR( xQueueHandle pxQueue, void *pcBuffer, signed portCHAR *pcTaskWoken )
             - reentrant;
 108          
 109          #ifdef KEIL_AX11000
 110          /*
 111           * Mark a queue as locked.  Locking a queue prevents an ISR from 
 112           * accessing the queue event lists. 
 113           */
 114          static void prvLockQueue( xQueueHandle pxQueue ) reentrant;
 115          #endif
 116          
 117          /* 
 118           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not 
 119           * prevent an ISR from adding or removing items to the queue, but does prevent 
 120           * an ISR from removing tasks from the queue event lists.  If an ISR finds a 
 121           * queue is locked it will instead increment the appropriate queue lock count 
 122           * to indicate that a task may require unblocking.  When the queue in unlocked
 123           * these lock counts are inspected, and the appropriate action taken.
 124           */
 125          static signed portCHAR prvUnlockQueue( xQueueHandle pxQueue ) reentrant;
 126          
 127          /*
 128           * Uses a critical section to determine if there is any data in a queue.
 129           *
 130           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 131           */
 132          static signed portCHAR prvIsQueueEmpty( const xQueueHandle pxQueue ) reentrant;
 133          
 134          /*
 135           * Uses a critical section to determine if there is any space in a queue.
 136           *
 137           * @return pdTRUE if there is no space, otherwise pdFALSE;
 138           */
 139          static signed portCHAR prvIsQueueFull( const xQueueHandle pxQueue ) reentrant;
 140          
 141          /*
 142           * Macro that copies an item into the queue.  This is done by copying the item
 143           * byte for byte, not by reference.  Updates the queue state to ensure it's
 144           * integrity after the copy.
 145           */
 146          #define prvCopyQueueData( pxQueue, pvItemToQueue )                                                                                              \
 147                  memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->ucItemSize );       \
 148                  ++( pxQueue->ucMessagesWaiting );                                                                                                                       \
 149                  pxQueue->pcWriteTo += pxQueue->ucItemSize;                                                                                                      \
 150                  if( pxQueue->pcWriteTo >= pxQueue->pcTail )                                                                                                     \
 151                  {                                                                                                                                                                                       \
 152                          pxQueue->pcWriteTo = pxQueue->pcHead;                                                                                                   \
 153                  }                                                                                                                                                                                       \
 154          
 155          /*-----------------------------------------------------------*/
 156          
 157          #ifndef KEIL_AX11000
              
              /*
               * Macro to mark a queue as locked.  Locking a queue prevents an ISR from 
               * accessing the queue event lists. 
               */
              #define prvLockQueue( pxQueue )                 \
                      taskENTER_CRITICAL();                           \
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 4   

                              ++( pxQueue->cRxLock );                 \
                              ++( pxQueue->cTxLock );                 \
                      taskEXIT_CRITICAL();                            \
              
              /*-----------------------------------------------------------*/
              #endif
 171          
 172          /*-----------------------------------------------------------
 173           * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 174           *----------------------------------------------------------*/
 175          
 176          xQueueHandle xQueueCreate( unsigned portCHAR ucQueueLength, unsigned portCHAR ucItemSize ) reentrant
 177          {
 178   1      xQUEUE *pxNewQueue;
 179   1      unsigned portSHORT usQueueSizeInBytes;
 180   1      
 181   1              /* Allocate the new queue structure. */
 182   1              if( ucQueueLength > ( unsigned portCHAR ) 0 )
 183   1              {
 184   2                      pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 185   2                      if( pxNewQueue != NULL )
 186   2                      {
 187   3                              /* Create the list of pointers to queue items.  The queue is one byte 
 188   3                              longer than asked for to make wrap checking easier/faster. */
 189   3                              usQueueSizeInBytes = ( unsigned portSHORT ) ( ucQueueLength * ucItemSize ) + ( unsigned portSHORT ) 1;
 190   3      
 191   3                              pxNewQueue->pcHead = ( signed portCHAR * ) pvPortMalloc( usQueueSizeInBytes );
 192   3                              if( pxNewQueue->pcHead != NULL )
 193   3                              {
 194   4                                      /* Initialise the queue members as described above where the 
 195   4                                      queue type is defined. */
 196   4                                      pxNewQueue->pcTail = pxNewQueue->pcHead + ( ucQueueLength * ucItemSize );
 197   4                                      pxNewQueue->ucMessagesWaiting = ( unsigned portCHAR ) 0;
 198   4                                      pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 199   4                                      pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( ucQueueLength - ( unsigned portCHAR ) 1 ) * ucItemSi
             -ze );
 200   4                                      pxNewQueue->ucLength = ucQueueLength;
 201   4                                      pxNewQueue->ucItemSize = ucItemSize;
 202   4                                      pxNewQueue->cRxLock = queueUNLOCKED;
 203   4                                      pxNewQueue->cTxLock = queueUNLOCKED;
 204   4      
 205   4                                      /* Likewise ensure the event queues start with the correct state. */
 206   4                                      vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 207   4                                      vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) ); 
 208   4      
 209   4                                      return  pxNewQueue;
 210   4                              }
 211   3                              else
 212   3                              {
 213   4                                      vPortFree( pxNewQueue );
 214   4                              }
 215   3                      }
 216   2              }
 217   1      
 218   1              /* Will only reach here if we could not allocate enough memory or no memory
 219   1              was required. */
 220   1              return NULL;
 221   1      }
 222          /*-----------------------------------------------------------*/
 223          
 224          signed portCHAR cQueueSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait ) r
             -eentrant
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 5   

 225          {
 226   1      signed portCHAR cReturn;
 227   1      
 228   1              /* Make sure other tasks do not access the queue. */
 229   1              vTaskSuspendAll();
 230   1      
 231   1              /* It is important that this is the only thread/ISR that modifies the
 232   1              ready or delayed lists until cTaskResumeAll() is called.  Places where 
 233   1              the ready/delayed lists are modified include:
 234   1      
 235   1                      + vTaskDelay() -  Nothing can call vTaskDelay as the scheduler is 
 236   1                        suspended, vTaskDelay() cannot be called from an ISR.
 237   1                      + vTaskPrioritySet() - Has a critical section around the access.
 238   1                      + vTaskSwitchContext() - This will not get executed while the scheduler 
 239   1                        is suspended.
 240   1                      + prvCheckDelayedTasks() - This will not get executed while the 
 241   1                        scheduler is suspended.
 242   1                      + sTaskCreate() - Has a critical section around the access.
 243   1                      + vTaskResume() - Has a critical section around the access.
 244   1                      + cTaskResumeAll() - Has a critical section around the access.
 245   1                      + cTaskRemoveFromEventList - Checks to see if the scheduler is 
 246   1                        suspended.  If so then the TCB being removed from the event is 
 247   1                        removed from the event and added to the xPendingReadyList.
 248   1              */
 249   1      
 250   1              /* Make sure interrupts do not access the queue event list. */
 251   1              prvLockQueue( pxQueue );
 252   1      
 253   1              /* It is important that interrupts to not access the event list of the
 254   1              queue being modified here.  Places where the event list is modified
 255   1              include:
 256   1      
 257   1                      + cQueueSendFromISR().  This checks the lock on the queue to see if
 258   1                        it has access.  If the queue is locked then the Tx lock count is 
 259   1                        incremented to signify that a task waiting for data can be made ready
 260   1                        once the queue lock is removed.  If the queue is not locked then
 261   1                        a task can be moved from the event list, but will not be removed
 262   1                        from the delayed list or placed in the ready list until the scheduler 
 263   1                        is unlocked.  
 264   1      
 265   1                      + cQueueReceiveFromISR().  As per cQueueSendFromISR().
 266   1              */
 267   1                      
 268   1              /* If the queue is already full we may have to block. */
 269   1              if( prvIsQueueFull( pxQueue ) )
 270   1              {
 271   2                      /* The queue is full - do we want to block or just leave without
 272   2                      posting? */
 273   2                      if( xTicksToWait > ( portTickType ) 0 )
 274   2                      {
 275   3                              /* We are going to place ourselves on the xTasksWaitingToSend event
 276   3                              list, and will get woken should the delay expire, or space become
 277   3                              available on the queue. 
 278   3                              
 279   3                              As detailed above we do not require mutual exclusion on the event
 280   3                              list as nothing else can modify it or the ready lists while we
 281   3                              have the scheduler suspended and queue locked. 
 282   3                              
 283   3                              It is possible that an ISR has removed data from the queue since we
 284   3                              checked if any was available.  If this is the case then the data
 285   3                              will have been copied from the queue, and the queue variables 
 286   3                              updated, but the event list will not yet have been checked to see if
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 6   

 287   3                              anything is waiting as the queue is locked. */
 288   3                              vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 289   3      
 290   3                              /* Force a context switch now as we are blocked.  We can do
 291   3                              this from within a critical section as the task we are 
 292   3                              switching to has its own context.  When we return here (i.e. we
 293   3                              unblock) we will leave the critical section as normal. 
 294   3                              
 295   3                              It is possible that an ISR has caused an event on an unrelated and 
 296   3                              unlocked queue.  If this was the case then the event list for that 
 297   3                              queue will have been updated but the ready lists left unchanged -
 298   3                              instead the readied task will have been added to the pending ready 
 299   3                              list. */
 300   3                              taskENTER_CRITICAL();
 301   3                              {
 302   4                                      /* We can safely unlock the queue and scheduler here as 
 303   4                                      interrupts are disabled.  We must not yield with anything 
 304   4                                      locked, but we can yield from within a critical section.
 305   4                                      
 306   4                                      Tasks that have been placed on the pending ready list cannot
 307   4                                      be tasks that are waiting for events on this queue.  See 
 308   4                                      in comment cTaskRemoveFromEventList(). */
 309   4                                      prvUnlockQueue( pxQueue );
 310   4      
 311   4                                      /* Resuming the scheduler may cause a yield.  If so then there
 312   4                                      is no point yielding again here. */
 313   4                                      if( !cTaskResumeAll() )
 314   4                                      {
 315   5                                              taskYIELD();
 316   5                                      }
 317   4      
 318   4                                      /* Before leaving the critical section we have to ensure
 319   4                                      exclusive access again. */
 320   4                                      vTaskSuspendAll();
 321   4                                      prvLockQueue( pxQueue );                                
 322   4                              }
 323   3                              taskEXIT_CRITICAL();
 324   3                      }
 325   2              }
 326   1                      
 327   1              /* When we are here it is possible that we unlblocked as space became 
 328   1              available on the queue.  It is also possible that an ISR posted to the
 329   1              queue since we left the critical section, so it may be that again there
 330   1              is no space.  This would only happen if a task and ISR post onto the
 331   1              same queue. */
 332   1              taskENTER_CRITICAL();
 333   1              {
 334   2                      if( pxQueue->ucMessagesWaiting < pxQueue->ucLength )
 335   2                      {
 336   3                              /* There is room in the queue, copy the data into the queue. */                 
 337   3                              prvCopyQueueData( pxQueue, pvItemToQueue );             
 338   3                              cReturn = ( signed portCHAR ) pdPASS;
 339   3      
 340   3                              /* Update the TxLock count so prvUnlockQueue knows to check for
 341   3                              tasks waiting for data to become available in the queue. */
 342   3                              ++( pxQueue->cTxLock );
 343   3                      }
 344   2                      else
 345   2                      {
 346   3                              cReturn = errQUEUE_FULL;
 347   3                      }
 348   2              }
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 7   

 349   1              taskEXIT_CRITICAL();
 350   1      
 351   1              /* We no longer require exclusive access to the queue.  prvUnlockQueue
 352   1              will remove any tasks suspended on a receive if either this function 
 353   1              or an ISR has posted onto the queue. */
 354   1              if( prvUnlockQueue( pxQueue ) )
 355   1              {
 356   2                      /* Resume the scheduler - making ready any tasks that were woken
 357   2                      by an event while the scheduler was locked.  Resuming the 
 358   2                      scheduler may cause a yield, in which case there is no point
 359   2                      yielding again here. */
 360   2                      if( !cTaskResumeAll() )
 361   2                      {
 362   3                              taskYIELD();
 363   3                      }
 364   2              }
 365   1              else
 366   1              {
 367   2                      /* Resume the scheduler - making ready any tasks that were woken
 368   2                      by an event while the scheduler was locked. */
 369   2                      cTaskResumeAll();
 370   2              }
 371   1      
 372   1              return cReturn;
 373   1      }
 374          
 375          /*-----------------------------------------------------------*/
 376          //signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTas
             -kPreviouslyWoken )
 377          signed portCHAR cQueueSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portCHAR cTaskP
             -reviouslyWoken ) reentrant
 378          {
 379   1              /* Similar to cQueueSend, except we don't block if there is no room in the
 380   1              queue.  Also we don't directly wake a task that was blocked on a queue
 381   1              read, instead we return a flag to say whether a context switch is required
 382   1              or not (i.e. has a task with a higher priority than us been woken by this
 383   1              post). */
 384   1              if( pxQueue->ucMessagesWaiting < pxQueue->ucLength )
 385   1              {
 386   2                      prvCopyQueueData( pxQueue, pvItemToQueue );
 387   2      
 388   2                      /* If the queue is locked we do not alter the event list.  This will
 389   2                      be done when the queue is unlocked later. */
 390   2                      if( pxQueue->cTxLock == queueUNLOCKED )
 391   2                      {
 392   3                              /* We only want to wake one task per ISR, so check that a task has
 393   3                              not already been woken. */
 394   3                              if( !cTaskPreviouslyWoken )             
 395   3                              {
 396   4                                      if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 397   4                                      {
 398   5                                              if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( signed portCHAR ) pdFALSE )
 399   5                                              {
 400   6                                                      /* The task waiting has a higher priority so record that a 
 401   6                                                      context switch is required. */
 402   6                                                      return pdTRUE;
 403   6                                              }
 404   5                                      }
 405   4                              }
 406   3                      }
 407   2                      else
 408   2                      {
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 8   

 409   3                              /* Increment the lock count so the task that unlocks the queue 
 410   3                              knows that data was posted while it was locked. */
 411   3                              ++( pxQueue->cTxLock );
 412   3                      }
 413   2              }
 414   1      
 415   1              return cTaskPreviouslyWoken;
 416   1      }
 417          /*-----------------------------------------------------------*/
 418          
 419          signed portCHAR cQueueReceive( xQueueHandle pxQueue, void *pcBuffer, portTickType xTicksToWait ) reentrant
 420          {
 421   1      signed portCHAR cReturn;
 422   1      
 423   1              /* This function is very similar to cQueueSend().  See comments within
 424   1              cQueueSend() for a more detailed explanation.
 425   1      
 426   1              Make sure other tasks do not access the queue. */
 427   1              vTaskSuspendAll();
 428   1      
 429   1              /* Make sure interrupts do not access the queue. */
 430   1              prvLockQueue( pxQueue );
 431   1      
 432   1              /* If there are no messages in the queue we may have to block. */
 433   1              if( prvIsQueueEmpty( pxQueue ) )
 434   1              {
 435   2                      /* There are no messages in the queue, do we want to block or just
 436   2                      leave with nothing? */                  
 437   2                      if( xTicksToWait > ( portTickType ) 0 )
 438   2                      {
 439   3                              vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 440   3                              taskENTER_CRITICAL();
 441   3                              {
 442   4                                      prvUnlockQueue( pxQueue );
 443   4                                      if( !cTaskResumeAll() )
 444   4                                      {
 445   5                                              taskYIELD();
 446   5                                      }
 447   4      
 448   4                                      vTaskSuspendAll();
 449   4                                      prvLockQueue( pxQueue );                        
 450   4                              }
 451   3                              taskEXIT_CRITICAL();
 452   3                      }
 453   2              }
 454   1      
 455   1              taskENTER_CRITICAL();
 456   1              {
 457   2                      if( pxQueue->ucMessagesWaiting > ( unsigned portCHAR ) 0 )
 458   2                      {
 459   3                              pxQueue->pcReadFrom += pxQueue->ucItemSize;
 460   3                              if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 461   3                              {
 462   4                                      pxQueue->pcReadFrom = pxQueue->pcHead;
 463   4                              }
 464   3                              --( pxQueue->ucMessagesWaiting );
 465   3                              memcpy( ( void * ) pcBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->ucItemSize );
 466   3      
 467   3                              /* Increment the lock count so prvUnlockQueue knows to check for
 468   3                              tasks waiting for space to become available on the queue. */
 469   3                              ++( pxQueue->cRxLock );
 470   3                              cReturn = ( signed portCHAR ) pdPASS;
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 9   

 471   3                      }
 472   2                      else
 473   2                      {
 474   3                              cReturn = ( signed portCHAR ) pdFAIL;
 475   3                      }
 476   2              }
 477   1              taskEXIT_CRITICAL();
 478   1      
 479   1              /* We no longer require exclusive access to the queue. */
 480   1              if( prvUnlockQueue( pxQueue ) )
 481   1              {
 482   2                      if( !cTaskResumeAll() )
 483   2                      {
 484   3                              taskYIELD();
 485   3                      }
 486   2              }
 487   1              else
 488   1              {
 489   2                      cTaskResumeAll();
 490   2              }
 491   1      
 492   1              return cReturn;
 493   1      }
 494          /*-----------------------------------------------------------*/
 495          
 496          signed portCHAR cQueueReceiveFromISR( xQueueHandle pxQueue, void *pcBuffer, signed portCHAR *pcTaskWoken )
             - reentrant
 497          {
 498   1      signed portCHAR cReturn;
 499   1      
 500   1              /* We cannot block from an ISR, so check there is data available. */
 501   1              if( pxQueue->ucMessagesWaiting > ( unsigned portCHAR ) 0 )
 502   1              {
 503   2                      /* Copy the data from the queue. */
 504   2                      pxQueue->pcReadFrom += pxQueue->ucItemSize;
 505   2                      if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 506   2                      {
 507   3                              pxQueue->pcReadFrom = pxQueue->pcHead;
 508   3                      }
 509   2                      --( pxQueue->ucMessagesWaiting );
 510   2                      memcpy( ( void * ) pcBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->ucItemSize );
 511   2      
 512   2                      /* If the queue is locked we will not modify the event list.  Instead
 513   2                      we update the lock count so the task that unlocks the queue will know
 514   2                      that an ISR has removed data while the queue was locked. */
 515   2                      if( pxQueue->cRxLock == queueUNLOCKED )
 516   2                      {
 517   3                              /* We only want to wake one task per ISR, so check that a task has
 518   3                              not already been woken. */
 519   3                              if( !( *pcTaskWoken ) )
 520   3                              {
 521   4                                      if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 522   4                                      {
 523   5                                              if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( signed portCHAR ) pdFALSE )
 524   5                                              {
 525   6                                                      /* The task waiting has a higher priority than us so
 526   6                                                      force a context switch. */
 527   6                                                      *pcTaskWoken = ( signed portCHAR ) pdTRUE;
 528   6                                              }
 529   5                                      }
 530   4                              }
 531   3                      }
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 10  

 532   2                      else
 533   2                      {
 534   3                              /* Increment the lock count so the task that unlocks the queue 
 535   3                              knows that data was removed while it was locked. */
 536   3                              ++( pxQueue->cRxLock );
 537   3                      }
 538   2      
 539   2                      cReturn = ( signed portCHAR ) pdPASS;
 540   2              }
 541   1              else
 542   1              {
 543   2                      cReturn = ( signed portCHAR ) pdFAIL;
 544   2              }
 545   1      
 546   1              return cReturn;
 547   1      }
 548          /*-----------------------------------------------------------*/
 549          
 550          unsigned portCHAR ucQueueMessagesWaiting( xQueueHandle pxQueue ) reentrant
 551          {
 552   1      unsigned portCHAR ucReturn;
 553   1      
 554   1              taskENTER_CRITICAL();
 555   1                      ucReturn = pxQueue->ucMessagesWaiting;
 556   1              taskEXIT_CRITICAL();
 557   1      
 558   1              return ucReturn;
 559   1      }
 560          /*-----------------------------------------------------------*/
 561          
 562          void vQueueDelete( xQueueHandle pxQueue ) reentrant
 563          {
 564   1              vPortFree( pxQueue->pcHead );
 565   1              vPortFree( pxQueue );
 566   1      }
 567          /*-----------------------------------------------------------*/
 568          
 569          #ifdef KEIL_AX11000
 570          /*
 571           * Mark a queue as locked.  Locking a queue prevents an ISR from 
 572           * accessing the queue event lists. 
 573           */
 574          static void prvLockQueue( xQueueHandle pxQueue ) reentrant
 575          {
 576   1              taskENTER_CRITICAL();
 577   1              ++( pxQueue->cRxLock );
 578   1              ++( pxQueue->cTxLock );
 579   1              taskEXIT_CRITICAL();    
 580   1      }
 581          #endif
 582          /*-----------------------------------------------------------*/
 583          
 584          static signed portCHAR prvUnlockQueue( xQueueHandle pxQueue ) reentrant
 585          {
 586   1      signed portCHAR cYieldRequired = ( signed portCHAR ) pdFALSE;
 587   1      
 588   1              /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 589   1      
 590   1              /* The lock counts contains the number of extra data items placed or 
 591   1              removed from the queue while the queue was locked.  When a queue is
 592   1              locked items can be added or removed, but the event lists cannot be
 593   1              updated. */
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 11  

 594   1              taskENTER_CRITICAL();
 595   1              {
 596   2                      --( pxQueue->cTxLock );
 597   2      
 598   2                      /* See if data was added to the queue while it was locked. */
 599   2                      if( pxQueue->cTxLock > queueUNLOCKED )
 600   2                      {
 601   3                              pxQueue->cTxLock = queueUNLOCKED;
 602   3      
 603   3                              /* Data was posted while the queue was locked.  Are any tasks
 604   3                              blocked waiting for data to become available? */
 605   3                              if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 606   3                              {
 607   4                                      /* Tasks that are removed from the event list will get added to
 608   4                                      the pending ready list as the scheduler is still suspended. */
 609   4                                      if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( signed portCHAR ) pdFALSE )
 610   4                                      {
 611   5                                              /* The task waiting has a higher priority so record that a 
 612   5                                              context switch is required. */
 613   5                                              cYieldRequired = ( signed portCHAR ) pdTRUE;
 614   5                                      }
 615   4                              }                       
 616   3                      }
 617   2              }
 618   1              taskEXIT_CRITICAL();
 619   1      
 620   1              /* Do the same for the Rx lock. */
 621   1              taskENTER_CRITICAL();
 622   1              {
 623   2                      --( pxQueue->cRxLock );
 624   2      
 625   2                      if( pxQueue->cRxLock > queueUNLOCKED )
 626   2                      {
 627   3                              pxQueue->cRxLock = queueUNLOCKED;
 628   3      
 629   3                              if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 630   3                              {
 631   4                                      if( cTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( signed portCHAR ) pdFALSE )
 632   4                                      {
 633   5                                              cYieldRequired = ( signed portCHAR ) pdTRUE;
 634   5                                      }
 635   4                              }                       
 636   3                      }
 637   2              }
 638   1              taskEXIT_CRITICAL();
 639   1      
 640   1              return cYieldRequired;
 641   1      }
 642          /*-----------------------------------------------------------*/
 643          
 644          static signed portCHAR prvIsQueueEmpty( const xQueueHandle pxQueue ) reentrant
 645          {
 646   1      signed portCHAR cReturn;
 647   1      
 648   1              taskENTER_CRITICAL();
 649   1                      cReturn = ( pxQueue->ucMessagesWaiting == ( unsigned portCHAR ) 0 );
 650   1              taskEXIT_CRITICAL();
 651   1      
 652   1              return cReturn;
 653   1      }
 654          /*-----------------------------------------------------------*/
 655          
C51 COMPILER V9.06   QUEUE                                                                 03/13/2013 09:32:27 PAGE 12  

 656          static signed portCHAR prvIsQueueFull( const xQueueHandle pxQueue ) reentrant
 657          {
 658   1      signed portCHAR cReturn;
 659   1      
 660   1              taskENTER_CRITICAL();
 661   1                      cReturn = ( pxQueue->ucMessagesWaiting == pxQueue->ucLength );
 662   1              taskEXIT_CRITICAL();
 663   1      
 664   1              return cReturn;
 665   1      }
 666          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3931    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
