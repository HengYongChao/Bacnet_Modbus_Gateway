C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\uart.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\uart\uart.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\sr
                    -c\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\uart.lst) OBJE
                    -CT(.\uart.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2005       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : uart.c
  13           * Purpose     : The UART module driver. It manages the character
  14           *               buffer and handles the ISR. This driver includes UART0 and UART1.
  15           * Author      : Robin Lee
  16           * Date        : 2006-01-10
  17           * Notes       : None.
  18           * $Log: uart.c,v $
  19           * Revision 1.3  2006/05/18 02:15:34  robin6633
  20           * 1.Add UART1 disable definition.
  21           *
  22           * Revision 1.2  2006/05/17 08:31:32  robin6633
  23           * 1. Changed the default baudrate to 115200.
  24           *
  25           * Revision 1.1  2006/05/12 14:24:47  robin6633
  26           * no message
  27           *
  28           * Revision 1.3  2006/05/03 02:45:55  robin6633
  29           * Changed the the function name UART_GetBufCount()
  30           * to UART_GetRxBufCount() .
  31           *
  32           * Revision 1.2  2006/05/02 01:43:40  robin6633
  33           * Add an expanding function to get the counter value of UART software buffer.
  34           *
  35           * Revision 1.1  2006/04/07 11:39:14  robin6633
  36           * no message
  37           *
  38           *================================================================================
  39           */
  40          
  41          /* INCLUDE FILE DECLARATIONS */
  42          #include        "reg80390.h"
  43          #include        "types.h"
  44          #include        "uart.h"
  45          #include        "ax11000_cfg.h"
  46          #if HSUR_ENABLE
  47          #include        "hsuart.h"
  48          #endif
  49          #include        "adapter_cfg.h"
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 2   

  50          
  51          // #include "Main.h"
  52          // #include <string.h>
  53          
  54          
  55          uart_frame rsv_msg;                     // LJ 6/11/2012
  56          
  57          
  58          /* STATIC VARIABLE DECLARATIONS */
  59          #if UART0_ENABLE
  60           U8_T           uart0_TxBuf[MAX_TX_UART0_BUF_SIZE]; //  lihengning static
  61          static U16_T    uart0_TxHead = 0;
  62          static U16_T    uart0_TxTail = 0;
  63           U16_T  uart0_TxCount = 0;
  64          static U8_T             uart0_TxFlag = 0;
  65           U8_T           uart0_RxBuf[MAX_RX_UART0_BUF_SIZE];  
  66          static U16_T    uart0_RxHead = 0;
  67          static U16_T    uart0_RxTail = 0;
  68          static U8_T             uart0_Mode = 0;
  69          U16_T                   uart0_RxCount = 0;
  70          #endif
  71          
  72          #if UART1_ENABLE
  73           U8_T           uart1_TxBuf[MAX_TX_UART1_BUF_SIZE]; //  lihengning static
  74          static U16_T    uart1_TxHead = 0;
  75          static U16_T    uart1_TxTail = 0;
  76           U16_T  uart1_TxCount = 0;
  77          static U8_T             uart1_TxFlag = 0;
  78           U8_T           uart1_RxBuf[MAX_RX_UART1_BUF_SIZE]; //  lihengning static
  79          static U16_T    uart1_RxHead = 0;
  80          static U16_T    uart1_RxTail = 0;
  81          static U8_T             uart1_Mode = 0;
  82          U16_T uart1_RxCount = 0;
  83          U8_T uart1_rec_size = 8;
  84          U8_T uart1_dealwithTag = 0;
  85          #endif
  86          static U8_T             uartPort = 0;
  87          
  88          U8_T far uart1_timeout = UART1_TIMEOUT;
  89          U8_T xdata FlagSend0;
  90          
  91          /* LOCAL SUBPROGRAM DECLARATIONS */
  92          #if UART0_ENABLE
  93          static void             uart0_ISR(void);
  94           void           uart0_Init(void);
  95          static S8_T             uart0_PutChar(S8_T c);
  96          static S8_T             uart0_GetKey(void);
  97          static S8_T             UART0_NoBlockGetkey(void);
  98          #endif
  99          #if UART1_ENABLE
 100          static void             uart1_ISR(void);
 101           void           uart1_Init(void);  //lihengning static
 102          static S8_T             uart1_PutChar(S8_T c);
 103          static S8_T             uart1_GetKey(void);
 104          static S8_T             uart1_NoBlockGetkey(void);
 105          #endif
 106          
 107          
 108          
 109          U8_T far UartRev[8] ;
 110          extern  U8_T SYS_FREQUENCY_PERIOD;
 111          extern  U8_T SYS_FREQUENCY_PERIOD1;
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 3   

 112          
 113          
 114          U8_T far UartSend[255];
 115          U8_T far UartRevNum=0;
 116          U8_T far UartSendNum=0;
 117          //U8_T far FlagRev=0;// receive finished flag 0=unfinished 1=read 2= reset
 118          U8_T far FlagSend=0;
 119          
 120          U8_T GetNum=0;
 121          U8_T TypeData=0;
 122          U8_T SerialFlag=0;
 123          
 124          extern U8_T far Para[400];
 125          extern unsigned char  auchCRCHi[256];
 126          extern unsigned char  auchCRCLo[256];
 127          extern void InitCRC16(void);
 128          extern void CRC16_Tstat(unsigned char ch);
 129          extern  unsigned char far  CRClo;
 130          extern unsigned  char far  CRChi;
 131          
 132          extern void Led_485RxD();
 133          
 134          U8_T far begin=0;
 135          U8_T far  buf[255]={0};
 136          //U8_T far  buf1[255]={0};
 137          
 138          
 139          
 140          /* LOCAL SUBPROGRAM BODIES */
 141          #if UART0_ENABLE
 142          /*
 143           * ----------------------------------------------------------------------------
 144           * static void UART0_ISR(void)
 145           * Purpose : UART0 interrupt service routine. For sending out, it puts data
 146           *           from software buffer into hardware serial buffer register (SBUF0).
 147           *           For receiving, it gets data from hardware serial buffer register
 148           *           (SBUF0) and stores into software buffer.
 149           * Params  : none
 150           * Returns : none
 151           * Note    : none
 152           * ----------------------------------------------------------------------------
 153           */
 154          
 155          #if 1
 156          static void UART0_ISR(void) interrupt 4
 157          {
 158   1              U8_T i= 0;
 159   1              EA = 0;
 160   1      
 161   1              if (RI0)
 162   1              {
 163   2      
 164   2                      uart0_RxBuf[uart0_RxCount++] = SBUF0;
 165   2                      if(uart0_RxCount > MAX_RX_UART0_BUF_SIZE)
 166   2                              uart0_RxCount = 0;         
 167   2                      
 168   2                      RI0 = 0;
 169   2              } 
 170   1      
 171   1              if (TI0)
 172   1              {
 173   2                      
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 4   

 174   2                      FlagSend = 1;// finishing sending flag
 175   2                      TI0 = 0;
 176   2      
 177   2      
 178   2              } /* End of if(TI0) */
 179   1              
 180   1              EA = 1;
 181   1      }
 182          
 183          #endif 
 184          
 185          
 186          /*
 187           * ----------------------------------------------------------------------------
 188           * static void uart0_Init(void)
 189           * Purpose : Setting operation mode of UART0 and initiating the global values.
 190           * Params  : none
 191           * Returns : none
 192           * Note    : none
 193           * ----------------------------------------------------------------------------
 194           */
 195          
 196          
 197          static void uart0_Init(void)
 198          {
 199   1              U8_T    sysClk = 0;
 200   1              U16_T   i;
 201   1      
 202   1              uart0_TxHead = 0;
 203   1              uart0_TxTail = 0;
 204   1              uart0_TxCount = 0;
 205   1              uart0_TxFlag = 0;
 206   1              uart0_RxHead = 0;
 207   1              uart0_RxTail = 0;
 208   1              uart0_RxCount = 0;
 209   1              for (i=0 ; i<MAX_TX_UART0_BUF_SIZE ; i++)
 210   1                      uart0_TxBuf[i] = 0;
 211   1              for (i=0 ; i<MAX_RX_UART0_BUF_SIZE ; i++)
 212   1                      uart0_RxBuf[i] = 0;
 213   1      
 214   1              // Initialize TIMER1 for standard 8051 UART clock
 215   1              PCON  |= 0x80;                  // Disable BaudRate doubler.
 216   1              SM01  = 1;                      // Use serial port 0 in mode 1 with 8-bits data.
 217   1              REN0  = 1;                      // Enable UART0 receiver.
 218   1              TMOD  = 0x20;           // Use timer 1 in mode 2, 8-bit counter with auto-reload.
 219   1              uart0_Mode = 1;
 220   1      
 221   1              sysClk = CSREPR & 0xC0;
 222   1              switch (sysClk)
 223   1              {
 224   2                      case SCS_100M :
 225   2                      //      AX_DBG_LED(0x10);
 226   2                              TH1 = 0xE5;             // Baud rate = 9600 @ 100MHz.
 227   2                              SYS_FREQUENCY_PERIOD1 = 30;
 228   2                              SYS_FREQUENCY_PERIOD = 100;
 229   2                              break;
 230   2                      case SCS_50M :
 231   2                      //      AX_DBG_LED(0x50);
 232   2                              TH1 = 0xF2;             // Baud rate = 9600 @ 50MHz.
 233   2                              break;
 234   2                      case SCS_25M :
 235   2                      //      AX_DBG_LED(0x25);
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 5   

 236   2                              SYS_FREQUENCY_PERIOD1 =100;
 237   2                              SYS_FREQUENCY_PERIOD = 200;
 238   2                              TH1 = 0xF9;             // Baud rate = 9600 @ 25MHz.
 239   2                              break;
 240   2                      default :
 241   2                      //      AX_DBG_LED(0xAA);
 242   2                              TH1 = 0xF9;             // Baud rate = 9600 @ 25MHz.
 243   2                              break;
 244   2              }
 245   1      
 246   1              ES0     = 1;                            // Enable serial port Interrupt request
 247   1              TR1 = 1;                                // Run Timer 1
 248   1              TI0 = 0;
 249   1      
 250   1              
 251   1      
 252   1      } /* End of UART_Init */
 253          
 254          
 255          
 256          /*
 257           * ----------------------------------------------------------------------------
 258           * static S8_T uart0_PutChar(S8_T c)
 259           * Purpose : UART0 output function. This function puts one byte data into the
 260           *           software character buffer.
 261           * Params  : c - one byte character.
 262           * Returns : c - one byte character.
 263           * Note    : none
 264           * ----------------------------------------------------------------------------
 265           */
 266          S8_T uart0_PutChar (S8_T c)
 267          {
 268   1              U16_T   count = 0;
 269   1      
 270   1              if (c == 0xa)
 271   1              {
 272   2                      do
 273   2                      {
 274   3                              EA = 0;
 275   3                              count = uart0_TxCount; 
 276   3                              EA = 1;
 277   3                      } while (count == MAX_TX_UART0_BUF_SIZE);
 278   2                      uart0_TxBuf[uart0_TxHead] = 0xd;
 279   2                      EA = 0;
 280   2                      uart0_TxCount++;
 281   2                      EA = 1;
 282   2                      uart0_TxHead++;
 283   2                      uart0_TxHead &= MAX_TX_UART0_MASK;
 284   2              }
 285   1              do
 286   1              {
 287   2                      EA = 0;
 288   2                      count = uart0_TxCount; 
 289   2                      EA = 1;
 290   2              } while (count == MAX_TX_UART0_BUF_SIZE);
 291   1              uart0_TxBuf[uart0_TxHead] = c;
 292   1              EA = 0;
 293   1              uart0_TxCount++;
 294   1              EA = 1;
 295   1              uart0_TxHead++;
 296   1              uart0_TxHead &= MAX_TX_UART0_MASK;
 297   1      
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 6   

 298   1              if (!uart0_TxFlag)
 299   1              {
 300   2                      uart0_TxFlag = 1;
 301   2                      SBUF0 = uart0_TxBuf[uart0_TxTail];
 302   2              }
 303   1      
 304   1              return c;
 305   1      
 306   1      }
 307          
 308          /*
 309           * ----------------------------------------------------------------------------
 310           * static S8_T uart0_GetKey(void)
 311           * Purpose : UART0 input function. This function replies one byte data from the
 312           *           software character buffer.
 313           * Params  : none
 314           * Returns : c - one byte character.
 315           * Note    : none
 316           * ----------------------------------------------------------------------------
 317           */
 318          static S8_T uart0_GetKey (void)
 319          {
 320   1          /* NAMING CONSTANT DECLARATIONS */
 321   1      
 322   1          /* LOCAL VARIABLE DECLARATIONS */
 323   1          S8_T        c = 0;
 324   1          /* BODY */
 325   1              while(uart0_RxCount == 0);
 326   1              EA = 0;
 327   1              uart0_RxCount--;
 328   1              EA = 1;
 329   1              c = uart0_RxBuf[uart0_RxTail];
 330   1              uart0_RxTail++;
 331   1              uart0_RxTail &= MAX_RX_UART0_MASK;
 332   1              return c;
 333   1      }
 334          
 335          /*
 336           * ----------------------------------------------------------------------------
 337           * static S8_T uart0_NoBlockGetkey(void)
 338           * Purpose : UART0 input function. This function replies one byte data from the
 339           *           software character buffer. But it only check the buffer one time.
 340           *           If no data, it will reply a FALSE condition.
 341           * Params  : none
 342           * Returns : c - one byte character.
 343           * Note    : none
 344           * ----------------------------------------------------------------------------
 345           */
 346          static S8_T UART0_NoBlockGetkey (void)
 347          {
 348   1          char c = 0;
 349   1      
 350   1              if (uart0_RxCount !=0 )
 351   1              {
 352   2                      EA = 0;
 353   2                      uart0_RxCount--;
 354   2                      EA = 1;
 355   2                      c = uart0_RxBuf[uart0_RxTail];
 356   2                      uart0_RxTail++;
 357   2                      uart0_RxTail &= MAX_RX_UART0_MASK;
 358   2                      return c;
 359   2              }
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 7   

 360   1              else
 361   1              {
 362   2                      return FALSE;
 363   2              }
 364   1      }
 365          #endif
 366          
 367          
 368          #if UART1_ENABLE
 369          ////////////////////////////////////////////////////////////////////////////////
 370          /*
 371           * ----------------------------------------------------------------------------
 372           * static void UART1_ISR(void)
 373           * Purpose : UART1 interrupt service routine. For sending out, it puts data
 374           *           from software buffer into hardware serial buffer register (SBUF1).
 375           *           For receiving, it gets data from hardware serial buffer register
 376           *           (SBUF1) and stores into software buffer.
 377           * Params  : none
 378           * Returns : none
 379           * Note    : none
 380           * ----------------------------------------------------------------------------
 381           */
 382          #if 1
 383          static void uart1_ISR(void) interrupt 6
 384          {
 385   1              EA = 0;
 386   1      
 387   1      
 388   1              if(RI1)
 389   1              {
 390   2                      uart1_RxBuf[uart1_RxCount++] = SBUF1;
 391   2      
 392   2                      if(uart1_RxCount >= MAX_RX_UART1_BUF_SIZE)
 393   2                              uart1_RxCount = 0;
 394   2                      
 395   2      
 396   2                      RI1 = 0;
 397   2      
 398   2                      uart1_timeout = 5;       // reveice data  timer = 20              (3)
 399   2      
 400   2              } 
 401   1              if (TI1)
 402   1              {
 403   2                      EA = 0;
 404   2                      FlagSend = 1;// finishing sending flag
 405   2                      TI1 = 0;
 406   2              } /* End of if(TI0) */
 407   1         EA = 1;
 408   1      }  
 409          
 410          #endif 
 411          
 412          /*
 413           * ----------------------------------------------------------------------------
 414           * static void uart1_Init(void)
 415           * Purpose : Setting operation mode of UART1 and initiating the global values.
 416           * Params  : none
 417           * Returns : none
 418           * Note    : none
 419           * ----------------------------------------------------------------------------
 420           */
 421          static void uart1_Init(void)
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 8   

 422          {
 423   1              U8_T    sysClk = 0;
 424   1              U16_T   i;
 425   1      
 426   1              uart1_TxHead = 0;
 427   1              uart1_TxTail = 0;
 428   1              uart1_TxCount = 0;
 429   1              uart1_TxFlag = 0;
 430   1              uart1_RxHead = 0;
 431   1              uart1_RxTail = 0;
 432   1              uart1_RxCount = 0;
 433   1              for (i=0 ; i<MAX_TX_UART1_BUF_SIZE ; i++)
 434   1                      uart1_TxBuf[i] = 0;
 435   1              for (i=0 ; i<MAX_RX_UART1_BUF_SIZE ; i++)
 436   1                      uart1_RxBuf[i] = 0;
 437   1      
 438   1              // Initialize TIMER1 for standard 8051 UART clock
 439   1              PCON  |= 0x00;                  // Disable BaudRate doubler.     9600    
 440   1              SM10  = 0;
 441   1              SM11  = 1;                      // Use serial port 1 in mode 1 with 8-bits data.
 442   1              REN1  = 1;                      // Enable UART1 receiver.
 443   1              TMOD  = 0x20;           // Use timer 1 in mode 2, 8-bit counter with auto-reload.
 444   1              uart1_Mode = 1;
 445   1      
 446   1              sysClk = CSREPR & 0xC0;
 447   1              switch (sysClk)
 448   1              {                                                        /* UART1 rate = 57600,only work on 100Mhz*/
 449   2                      case SCS_100M :
 450   2                              TH1 = 0xe5;             // Baud rate = 57600 @ 100MHz.           19200=0xE5,57600=0xF7
 451   2                              break;
 452   2                      case SCS_50M :
 453   2                              TH1 = 0xF2;             // Baud rate = 9600 @ 50MHz.
 454   2                              break;
 455   2                      case SCS_25M :
 456   2                              TH1 = 0xF9;             // Baud rate = 9600 @ 25MHz.
 457   2                              break;
 458   2                      default :
 459   2                              TH1 = 0xF9;             // Baud rate = 9600 @ 25MHz.
 460   2                              break;
 461   2              }
 462   1      
 463   1              ES1     = 1;                            // Enable serial port Interrupt request
 464   1              TR1 = 1;                                // Run Timer 1
 465   1              TI1 = 0;
 466   1      
 467   1      }
 468          
 469          /*
 470           * ----------------------------------------------------------------------------
 471           * static S8_T uart1_PutChar(S8_T c)
 472           * Purpose : UART1 output function. This function puts one byte data into the
 473           *           software character buffer.
 474           * Params  : c - one byte character.
 475           * Returns : c - one byte character.
 476           * Note    : none
 477           * ----------------------------------------------------------------------------
 478           */
 479          static S8_T uart1_PutChar(S8_T c)
 480          {
 481   1              U16_T   count = 0;
 482   1      
 483   1              if (c == 0xa)
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 9   

 484   1              {
 485   2                      do
 486   2                      {
 487   3                              EA = 0;
 488   3                              count = uart1_TxCount; 
 489   3                              EA = 1;
 490   3                      } while (count == MAX_TX_UART1_BUF_SIZE);
 491   2                      uart1_TxBuf[uart1_TxHead] = 0xd;
 492   2                      EA = 0;
 493   2                      uart1_TxCount++;
 494   2                      EA = 1;
 495   2                      uart1_TxHead++;
 496   2                      uart1_TxHead &= MAX_TX_UART1_MASK;
 497   2              }
 498   1              do
 499   1              {
 500   2                      EA = 0;
 501   2                      count = uart1_TxCount; 
 502   2                      EA = 1;
 503   2              } while (count == MAX_TX_UART1_BUF_SIZE);
 504   1              uart1_TxBuf[uart1_TxHead] = c;
 505   1              EA = 0;
 506   1              uart1_TxCount++;
 507   1              EA = 1;
 508   1              uart1_TxHead++;
 509   1              uart1_TxHead &= MAX_TX_UART1_MASK;
 510   1      
 511   1              if (!uart1_TxFlag)
 512   1              {
 513   2                      uart1_TxFlag = 1;
 514   2                      SBUF1 = uart1_TxBuf[uart1_TxTail];
 515   2              }
 516   1              
 517   1              return c;
 518   1      
 519   1      }
 520          
 521          /*
 522           * ----------------------------------------------------------------------------
 523           * static S8_T uart1_GetKey(void)
 524           * Purpose : UART1 input function. This function replies one byte data from the
 525           *           software character buffer.
 526           * Params  : none
 527           * Returns : c - one byte character.
 528           * Note    : none
 529           * ----------------------------------------------------------------------------
 530           */
 531          static S8_T uart1_GetKey (void)
 532          {
 533   1          /* NAMING CONSTANT DECLARATIONS */
 534   1      
 535   1          /* LOCAL VARIABLE DECLARATIONS */
 536   1          S8_T c;
 537   1          /* BODY */
 538   1              while(uart1_RxCount==0);
 539   1              EA = 0;
 540   1              uart1_RxCount--;
 541   1              EA = 1;
 542   1              c = uart1_RxBuf[uart1_RxTail];
 543   1              uart1_RxTail++;
 544   1              uart1_RxTail &= MAX_RX_UART1_MASK;
 545   1              return c;
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 10  

 546   1      }
 547          
 548          /*
 549           * ----------------------------------------------------------------------------
 550           * static S8_T uart1_NoBlockGetkey(void)
 551           * Purpose : UART1 input function. This function replies one byte data from the
 552           *           software character buffer. But it only check the buffer one time.
 553           *           If no data, it will reply a FALSE condition.
 554           * Params  : none
 555           * Returns : c - one byte character.
 556           * Note    : none
 557           * ----------------------------------------------------------------------------
 558           */
 559          static S8_T uart1_NoBlockGetkey (void)
 560          {
 561   1          char c = 0;
 562   1      
 563   1              if (uart1_RxCount !=0 )
 564   1              {
 565   2                      EA = 0;
 566   2                      uart1_RxCount--;
 567   2                      EA = 1;
 568   2                      c = uart1_RxBuf[uart1_RxTail];
 569   2                      uart1_RxTail++;
 570   2                      uart1_RxTail &= MAX_RX_UART1_MASK;
 571   2                      return c;
 572   2              }
 573   1              else
 574   1              {
 575   2                      return FALSE;
 576   2              }
 577   1      }
 578          #endif
 579          
 580          
 581          /* EXPORTED SUBPROGRAM BODIES */
 582          
 583          /*
 584           * ----------------------------------------------------------------------------
 585           * S8_T _getkey (void)
 586           * Purpose : UART getkey function. This function is the entry of getting
 587           *           characters from software buffer of system's UART ports,
 588           *           UART0, UART1 and HSUR. 
 589           * Params  : none
 590           * Returns : ch - one byte character.
 591           * Note    : The default UART port is UART0.
 592           * ----------------------------------------------------------------------------
 593           */
 594          S8_T _getkey (void)
 595          {
 596   1              S8_T    ch = 0;
 597   1      
 598   1              ch = HSUR_GetChar();
 599   1              return ch;
 600   1      }
 601          
 602          /*
 603           * ----------------------------------------------------------------------------
 604           * S8_T putchar(S8_T c)
 605           * Purpose : UART putchar function. This function is the entry of putting
 606           *           characters into software buffer of system's UART ports,
 607           *           UART0, UART1 and HSUR. 
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 11  

 608           * Params  : c - one byte character to be put.
 609           * Returns : ch - the same character to be replied.
 610           * Note    : The default UART port is UART0.
 611           * ----------------------------------------------------------------------------
 612           */
 613          S8_T putchar(S8_T c)
 614          {
 615   1              S8_T    ch = 0;
 616   1      
 617   1              ch = HSUR_PutChar(c);
 618   1              return ch;
 619   1      }
 620          
 621          /*
 622           * ----------------------------------------------------------------------------
 623           * void UART_Init(void)
 624           * Purpose : UART initial function. It will call a real initial function
 625           *           corresponding to the used UART port.
 626           * Params  : none
 627           * Returns : none
 628           * Note    : none
 629           * ----------------------------------------------------------------------------
 630           */
 631          void UART_Init(U8_T port)
 632          {
 633   1              if (port == 0)
 634   1              {
 635   2                      uart0_Init();
 636   2              }
 637   1              else if (port == 1)
 638   1              {
 639   2                      uart1_Init();
 640   2              }
 641   1              else if (port == 2)
 642   1              {
 643   2                      HSUR_InitValue();
 644   2                      HSUR_Setup(0x0010, (UR2_CHAR_8|UR2_STOP_10), (UR2_RDI_ENB|UR2_RLSI_ENB|UR2_MSI_ENB),
 645   2                      (UR2_FIFO_MODE|UR2_RXFIFO_RST|UR2_TXFIFO_RST|UR2_TRIG_08), UR2_DTR | UR2_RTS);
 646   2              }
 647   1              
 648   1      }
 649          
 650          /*
 651           * ----------------------------------------------------------------------------
 652           * S8_T NOBLK_getkey (void)
 653           * Purpose : UART no blocking getkey function with one checked. This function
 654           *           is the entry of getting characters from software buffer of
 655           *           system's UART ports, UART0, UART1 and HSUR.
 656           * Params  : none
 657           * Returns : ch - one byte character.
 658           * Note    : The default UART port is UART0.
 659           * ----------------------------------------------------------------------------
 660           */
 661          S8_T NOBLK_getkey (void)
 662          {
 663   1          S8_T        c = 0;
 664   1      
 665   1              c = HSUR_GetCharNb();
 666   1      
 667   1              return c;
 668   1      }
 669          
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 12  

 670          /*
 671           * ----------------------------------------------------------------------------
 672           * BOOL UART_ParityChk(S8_T checkByte)
 673           * Purpose : UART parity checked function in one byte transfer.
 674           * Params  : checkByte - one byte character.
 675           * Returns : TRUE - odd parity ; FALSE - even parity.
 676           * Note    : none
 677           * ----------------------------------------------------------------------------
 678           */
 679          BOOL UART_ParityChk(S8_T checkByte)
 680          {
 681   1              U8_T    oneNum = 0;
 682   1              U16_T   i;
 683   1      
 684   1              oneNum = 0;
 685   1              for (i=0 ; i<=7 ; i++)
 686   1              {
 687   2                      if (checkByte & (BIT0<<i))
 688   2                      {
 689   3                              oneNum ++;
 690   3                      }
 691   2              }
 692   1              if ((oneNum % 2) == 0)
 693   1                      return FALSE;           // if '1' number is even, return 0
 694   1              else
 695   1                      return TRUE;            // if '1' number is odd, return 1
 696   1      }
 697          
 698          #if UART0_ENABLE
 699          /*
 700           * ----------------------------------------------------------------------------
 701           * void UART0_SetMode(U8_T mode)
 702           * Purpose : Setting operation mode of UART0.
 703           * Params  : mode - operation mode (0~3).
 704           * Returns : none
 705           * Note    : none
 706           * ----------------------------------------------------------------------------
 707           */
 708          void UART0_SetMode(U8_T mode)
 709          {
 710   1              uart0_Mode = mode;
 711   1      }
 712          #endif
 713          
 714          #if UART1_ENABLE
 715          /*
 716           * ----------------------------------------------------------------------------
 717           * void UART1_SetMode(U8_T mode)
 718           * Purpose : Setting operation mode of UART0.
 719           * Params  : mode - operation mode (0~3).
 720           * Returns : none
 721           * Note    : none
 722           * ----------------------------------------------------------------------------
 723           */
 724          void UART1_SetMode(U8_T mode)
 725          {
 726   1              uart1_Mode = mode;
 727   1      }
 728          #endif
 729          
 730          /*
 731           * ----------------------------------------------------------------------------
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 13  

 732           * BOOL UART_SetPort(U8_T portNum)
 733           * Purpose : Setting which UART port will be used.
 734           * Params  : portNum - uart port number (0~2).
 735           * Returns : none
 736           * Note    : none
 737           * ----------------------------------------------------------------------------
 738           */
 739          BOOL UART_SetPort(U8_T portNum)
 740          {
 741   1              uartPort = portNum & 0x03;
 742   1              UART_Init(0);
 743   1              UART_Init(1);
 744   1              return TRUE;
 745   1      }
 746          
 747          /*
 748           * ----------------------------------------------------------------------------
 749           * U16_T UART_GetRxBufCount(void)
 750           * Purpose : Getting the remain character number in UART Rx buffer.
 751           * Params  : none
 752           * Returns : bufCount - the number of remain character in UART software RX buffer.
 753           * Note    : none
 754           * ----------------------------------------------------------------------------
 755           */
 756          U16_T UART_GetRxBufCount(void)
 757          {
 758   1              U16_T   bufCount = 0;
 759   1      
 760   1              bufCount = HSUR_GetRxBufCount();
 761   1      
 762   1              return bufCount;
 763   1      }
 764          
 765          /*
 766           * ----------------------------------------------------------------------------
 767           * void PMM_Uart0Init(void)
 768           * Purpose : Initiating the UART0 to work in power management mode.
 769           * Params  : none
 770           * Returns : none
 771           * Note    : none
 772           * ----------------------------------------------------------------------------
 773           */
 774          #if UART_PMM_ENABLE
              void PMM_Uart0Init(void)
              {
                      U16_T   i;
              
                      uart0_TxHead = 0;
                      uart0_TxTail = 0;
                      uart0_TxCount = 0;
                      uart0_TxFlag = 0;
                      uart0_RxHead = 0;
                      uart0_RxTail = 0;
                      uart0_RxCount = 0;
                      for (i=0 ; i<MAX_TX_UART0_BUF_SIZE ; i++)
                              uart0_TxBuf[i] = 0;
                      for (i=0 ; i<MAX_RX_UART0_BUF_SIZE ; i++)
                              uart0_RxBuf[i] = 0;
              
                      // Initialize TIMER1 for standard 8051 UART clock
                      PCON  = BIT7;           // Enable BaudRate doubler.
                      SM01  = 1;                      // Use serial port 0 in mode 1 with 8-bits data.
C51 COMPILER V9.06   UART                                                                  05/28/2013 10:15:27 PAGE 14  

                      REN0  = 1;                      // Enable UART0 receiver.
                      TMOD  = 0x20;           // Use timer 1 in mode 2, 8-bit counter with auto-reload.
              
                      TH1 = 0xFE;                     // Baud rate = 1200 @ 25MHz.
              
                      ES0     = 1;                            // Enable serial port Interrupt request
                      TR1 = 1;                                // Run Timer 1
                      TI0 = 0;
              
              }
              #endif
 805          
 806          
 807          /* End of uart.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1476    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   1662       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =    523    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
