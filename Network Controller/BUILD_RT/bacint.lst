C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE BACINT
OBJECT MODULE PLACED IN .\bacint.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\bacint.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020)
                    - INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;
                    -..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\
                    -buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;.
                    -.\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\bacint.lst) OBJECT(.\bacin
                    -t.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2004 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          
  35          /* BACnet Integer encoding and decoding */
  36          
  37          #include <stdint.h>
  38          #include <stdbool.h>
  39          #include "../include/config.h"
  40          #include "../include/bacint.h"
  41          
  42          /** @file bacint.c  Encode/Decode Integer Types */
  43          
  44          int encode_unsigned16(
  45              uint8_t * apdu,
  46              uint16_t value)
  47          {
  48   1          apdu[0] = (uint8_t) ((value & 0xff00) >> 8);
  49   1          apdu[1] = (uint8_t) (value & 0x00ff);
  50   1      
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 2   

  51   1          return 2;
  52   1      }
  53          
  54          int decode_unsigned16(
  55              uint8_t * apdu,
  56              uint16_t * value)
  57          {
  58   1          if (value) {
  59   2              *value = (uint16_t) ((((uint16_t) apdu[0]) << 8) & 0xff00);
  60   2              *value |= ((uint16_t) (((uint16_t) apdu[1]) & 0x00ff));
  61   2          }
  62   1      
  63   1          return 2;
  64   1      }
  65          
  66          int encode_unsigned24(
  67              uint8_t * apdu,
  68              uint32_t value)
  69          {
  70   1          apdu[0] = (uint8_t) ((value & 0xff0000) >> 16);
  71   1          apdu[1] = (uint8_t) ((value & 0x00ff00) >> 8);
  72   1          apdu[2] = (uint8_t) (value & 0x0000ff);
  73   1      
  74   1          return 3;
  75   1      }
  76          
  77          int decode_unsigned24(
  78              uint8_t * apdu,
  79              uint32_t * value)
  80          {
  81   1          if (value) {
  82   2              *value = ((uint32_t) ((((uint32_t) apdu[0]) << 16) & 0x00ff0000));
  83   2              *value |= (uint32_t) ((((uint32_t) apdu[1]) << 8) & 0x0000ff00);
  84   2              *value |= ((uint32_t) (((uint32_t) apdu[2]) & 0x000000ff));
  85   2          }
  86   1      
  87   1          return 3;
  88   1      }
  89          
  90          int encode_unsigned32(
  91              uint8_t * apdu,
  92              uint32_t value)
  93          {
  94   1          apdu[0] = (uint8_t) ((value & 0xff000000) >> 24);
  95   1          apdu[1] = (uint8_t) ((value & 0x00ff0000) >> 16);
  96   1          apdu[2] = (uint8_t) ((value & 0x0000ff00) >> 8);
  97   1          apdu[3] = (uint8_t) (value & 0x000000ff);
  98   1      
  99   1          return 4;
 100   1      }
 101          
 102          int decode_unsigned32(
 103              uint8_t * apdu,
 104              uint32_t * value)
 105          {
 106   1          if (value) {
 107   2              *value = ((uint32_t) ((((uint32_t) apdu[0]) << 24) & 0xff000000));
 108   2              *value |= ((uint32_t) ((((uint32_t) apdu[1]) << 16) & 0x00ff0000));
 109   2              *value |= ((uint32_t) ((((uint32_t) apdu[2]) << 8) & 0x0000ff00));
 110   2              *value |= ((uint32_t) (((uint32_t) apdu[3]) & 0x000000ff));
 111   2          }
 112   1      
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 3   

 113   1          return 4;
 114   1      }
 115          
 116          #if BACNET_USE_SIGNED
 117          int encode_signed8(
 118              uint8_t * apdu,
 119              int8_t value)
 120          {
 121   1          apdu[0] = (uint8_t) value;
 122   1      
 123   1          return 1;
 124   1      }
 125          
 126          int decode_signed8(
 127              uint8_t * apdu,
 128              int32_t * value)
 129          {
 130   1          if (value) {
 131   2              /* negative - bit 7 is set */
 132   2              if (apdu[0] & 0x80)
 133   2                  *value = 0xFFFFFF00;
 134   2              else
 135   2                  *value = 0;
 136   2              *value |= ((int32_t) (((int32_t) apdu[0]) & 0x000000ff));
 137   2          }
 138   1      
 139   1          return 1;
 140   1      }
 141          
 142          int encode_signed16(
 143              uint8_t * apdu,
 144              int16_t value)
 145          {
 146   1          apdu[0] = (uint8_t) ((value & 0xff00) >> 8);
 147   1          apdu[1] = (uint8_t) (value & 0x00ff);
 148   1      
 149   1          return 2;
 150   1      }
 151          
 152          int decode_signed16(
 153              uint8_t * apdu,
 154              int32_t * value)
 155          {
 156   1          if (value) {
 157   2              /* negative - bit 7 is set */
 158   2              if (apdu[0] & 0x80)
 159   2                  *value = 0xFFFF0000;
 160   2              else
 161   2                  *value = 0;
 162   2              *value |= ((int32_t) ((((int32_t) apdu[0]) << 8) & 0x0000ff00));
 163   2              *value |= ((int32_t) (((int32_t) apdu[1]) & 0x000000ff));
 164   2          }
 165   1      
 166   1          return 2;
 167   1      }
 168          
 169          int encode_signed24(
 170              uint8_t * apdu,
 171              int32_t value)
 172          {
 173   1          apdu[0] = (uint8_t) ((value & 0xff0000) >> 16);
 174   1          apdu[1] = (uint8_t) ((value & 0x00ff00) >> 8);
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 4   

 175   1          apdu[2] = (uint8_t) (value & 0x0000ff);
 176   1      
 177   1          return 3;
 178   1      }
 179          
 180          int decode_signed24(
 181              uint8_t * apdu,
 182              int32_t * value)
 183          {
 184   1          if (value) {
 185   2              /* negative - bit 7 is set */
 186   2              if (apdu[0] & 0x80)
 187   2                  *value = 0xFF000000;
 188   2              else
 189   2                  *value = 0;
 190   2              *value |= ((int32_t) ((((int32_t) apdu[0]) << 16) & 0x00ff0000));
 191   2              *value |= ((int32_t) ((((int32_t) apdu[1]) << 8) & 0x0000ff00));
 192   2              *value |= ((int32_t) (((int32_t) apdu[2]) & 0x000000ff));
 193   2          }
 194   1      
 195   1          return 3;
 196   1      }
 197          
 198          int encode_signed32(
 199              uint8_t * apdu,
 200              int32_t value)
 201          {
 202   1          apdu[0] = (uint8_t) ((value & 0xff000000) >> 24);
 203   1          apdu[1] = (uint8_t) ((value & 0x00ff0000) >> 16);
 204   1          apdu[2] = (uint8_t) ((value & 0x0000ff00) >> 8);
 205   1          apdu[3] = (uint8_t) (value & 0x000000ff);
 206   1      
 207   1          return 4;
 208   1      }
 209          
 210          int decode_signed32(
 211              uint8_t * apdu,
 212              int32_t * value)
 213          {
 214   1          if (value) {
 215   2              *value = ((int32_t) ((((int32_t) apdu[0]) << 24) & 0xff000000));
 216   2              *value |= ((int32_t) ((((int32_t) apdu[1]) << 16) & 0x00ff0000));
 217   2              *value |= ((int32_t) ((((int32_t) apdu[2]) << 8) & 0x0000ff00));
 218   2              *value |= ((int32_t) (((int32_t) apdu[3]) & 0x000000ff));
 219   2          }
 220   1      
 221   1          return 4;
 222   1      }
 223          #endif
 224          /* end of decoding_encoding.c */
 225          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include <ctype.h>
              #include "ctest.h"
              
              void testBACnetUnsigned16(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  uint16_t value = 0, test_value = 0;
                  int len = 0;
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 5   

              
                  for (value = 0;; value++) {
                      len = encode_unsigned16(&apdu[0], value);
                      ct_test(pTest, len == 2);
                      len = decode_unsigned16(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                      if (value == 0xFFFF)
                          break;
                  }
              }
              
              void testBACnetUnsigned24(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  uint32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = 0;; value += 0xf) {
                      len = encode_unsigned24(&apdu[0], value);
                      ct_test(pTest, len == 3);
                      len = decode_unsigned24(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                      if (value == 0xffffff)
                          break;
                  }
              }
              
              void testBACnetUnsigned32(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  uint32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = 0;; value += 0xff) {
                      len = encode_unsigned32(&apdu[0], value);
                      ct_test(pTest, len == 4);
                      len = decode_unsigned32(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                      if (value == 0xffffffff)
                          break;
                  }
              }
              
              void testBACnetSigned8(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  int32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = -127;; value++) {
                      len = encode_signed8(&apdu[0], value);
                      ct_test(pTest, len == 1);
                      len = decode_signed8(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                      if (value == 127)
                          break;
                  }
              }
              
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 6   

              void testBACnetSigned16(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  int32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = -32767;; value++) {
                      len = encode_signed16(&apdu[0], value);
                      ct_test(pTest, len == 2);
                      len = decode_signed16(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                      if (value == 32767)
                          break;
                  }
              }
              
              void testBACnetSigned24(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  int32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = -8388607; value <= 8388607; value += 15) {
                      len = encode_signed24(&apdu[0], value);
                      ct_test(pTest, len == 3);
                      len = decode_signed24(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                  }
              }
              
              void testBACnetSigned32(
                  Test * pTest)
              {
                  uint8_t apdu[32] = { 0 };
                  int32_t value = 0, test_value = 0;
                  int len = 0;
              
                  for (value = -2147483647; value < 0; value += 127) {
                      len = encode_signed32(&apdu[0], value);
                      ct_test(pTest, len == 4);
                      len = decode_signed32(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                  }
                  for (value = 2147483647; value > 0; value -= 127) {
                      len = encode_signed32(&apdu[0], value);
                      ct_test(pTest, len == 4);
                      len = decode_signed32(&apdu[0], &test_value);
                      ct_test(pTest, value == test_value);
                  }
              }
              
              #ifdef TEST_BACINT
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACint", NULL);
                  /* individual tests */
C51 COMPILER V9.06   BACINT                                                                03/13/2013 09:32:30 PAGE 7   

                  rc = ct_addTestFunction(pTest, testBACnetUnsigned16);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetUnsigned24);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetUnsigned32);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetSigned8);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetSigned16);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetSigned24);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testBACnetSigned32);
                  assert(rc);
                  /* configure output */
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_BACINT */
              #endif /* TEST */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2290    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      70
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
