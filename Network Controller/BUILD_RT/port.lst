C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE PORT
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\portable\Keil\AX11000\port.c LARGE OMF2 ROM(D1
                    -6M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\
                    -;..\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SR
                    -C\i2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSou
                    -rce\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\sr
                    -c\version;..\src\modbusTCP;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANK
                    -ING DEBUG PRINT(.\port.lst) SRC(.\port.SRC)

line level    source

   1          /*
   2                  FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
   3          
   4                  This file is part of the FreeRTOS distribution.
   5          
   6                  FreeRTOS is free software; you can redistribute it and/or modify
   7                  it under the terms of the GNU General Public License as published by
   8                  the Free Software Foundation; either version 2 of the License, or
   9                  (at your option) any later version.
  10          
  11                  FreeRTOS is distributed in the hope that it will be useful,
  12                  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14                  GNU General Public License for more details.
  15          
  16                  You should have received a copy of the GNU General Public License
  17                  along with FreeRTOS; if not, write to the Free Software
  18                  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  19          
  20                  A special exception to the GPL can be applied should you wish to distribute
  21                  a combined work that includes FreeRTOS, without being obliged to provide
  22                  the source code for any proprietary components.  See the licensing section 
  23                  of http://www.FreeRTOS.org for full details of how and when the exception
  24                  can be applied.
  25          
  26                  ***************************************************************************
  27                  See http://www.FreeRTOS.org for documentation, latest information, license 
  28                  and contact details.  Please ensure to read the configuration and relevant 
  29                  port sections of the online documentation.
  30                  ***************************************************************************
  31          */
  32          
  33          /*-----------------------------------------------------------
  34           * Implementation of functions defined in portable.h for the Cygnal port.
  35           *----------------------------------------------------------*/
  36          //#pragma SRC   
  37          /* Standard includes. */
  38          #include <string.h>
  39          
  40          /* Scheduler includes. */
  41          #include "projdefs.h"
  42          #include "portable.h"
  43          #include "task.h"
  44          #include "queue.h"
  45          #include "mstimer.h"
  46          #include "interrupt.h"
  47          #include "dma.h"
  48          
  49          #include "hsuart.h"
C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 2   

  50          #include "uart.h"
  51          #include "../../../../USB/ch375_com.h"
  52          
  53          /* Constants required to setup timer 2 to produce the RTOS tick. */
  54          //#define portCLOCK_DIVISOR                             ( ( unsigned portLONG ) 12 )
  55          //#define portMAX_TIMER_VALUE                           ( ( unsigned portLONG ) 0xffff )
  56          //#define portENABLE_TIMER                              ( ( unsigned portCHAR ) 0x04 )
  57          //#define portTIMER_2_INTERRUPT_ENABLE  ( ( unsigned portCHAR ) 0x20 )
  58          
  59          /* The value used in the IE register when a task first starts. */
  60          #define portGLOBAL_INTERRUPT_BIT        ( ( portSTACK_TYPE ) 0x80 )
  61          
  62          /* The value used in the PSW register when a task first starts. */
  63          #define portINITIAL_PSW                         ( ( portSTACK_TYPE ) 0x00 )
  64          
  65          /* Macro to clear the timer 2 interrupt flag. */
  66          #define portCLEAR_INTERRUPT_FLAG()      {                                       \
  67                                                                                          EINT5 = 0;              \
  68                                                                                          EIF &= ~INT5F;  \
  69                                                                                          EINT5 = 1;              \
  70                                                                                  }
  71                                                                                                  
  72          /* Used during a context switch to store the size of the stack being copied
  73          to or from XRAM. */
  74          //data static unsigned portCHAR ucStackBytes;
  75          //data  unsigned portCHAR ucStackBytes;
  76          
  77          /* Used during a context switch to point to the next byte in XRAM from/to which
  78          a RAM byte is to be copied. */
  79          //xdata static portSTACK_TYPE * data pxXRAMStack;
  80          //static portSTACK_TYPE xdata * data pxXRAMStack;
  81          
  82          /* Used during a context switch to point to the next byte in RAM from/to which
  83          an XRAM byte is to be copied. */
  84          //data static portSTACK_TYPE * data pxRAMStack;
  85          //static  portSTACK_TYPE data * data pxRAMStack;
  86          
  87          /* We require the address of the pxCurrentTCB variable, but don't want to know
  88          any details of its type. */
  89          //typedef void tskTCB;
  90          //extern volatile tskTCB * volatile pxCurrentTCB;
  91          
  92          void LoadCtx() reentrant;   /* Save the current working registers to stack, defined in OS_CPU_A.ASM */
  93          extern INT8U xdata * data C_XBP, TICK_INT;
  94          
  95          
  96          /*
  97           * Setup the hardware to generate an interrupt off timer 2 at the required 
  98           * frequency.
  99           */
 100          static void prvSetupTimerInterrupt( void );
 101          
 102          
 103          /* 
 104           * See header file for description. 
 105           */
 106          portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameter
             -s ) reentrant
 107          {
 108   1          portSTACK_TYPE * stk;
 109   1      
 110   1          stk    = (portSTACK_TYPE *) pxTopOfStack;        /* Load stack pointer                                
C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 3   

             -      */
 111   1      
 112   1              stk                             -= sizeof(void *);              /* Save the pvParameters to external stack */
 113   1              *(void**)stk     = pvParameters;        /*                               */
 114   1      
 115   1              stk                             -= sizeof(INT16U);                                              /* The value should be loaded to PC    */
 116   1              *(INT16U*)stk    = (INT16U) pxCode;                                             /* next time when this task is running */
 117   1      
 118   1              *--stk                   = (portSTACK_TYPE )(((INT32U) pxCode>>16)+0x7F);      /* Third byte of PC for dallas 390 */
 119   1      
 120   1      /* Following is the registers pushed into hardware stack */
 121   1              *--stk                   = 'A';                 /* ACC */
 122   1              *--stk                   = 'B';                 /* B   */
 123   1              *--stk                   = 'X';                 /* DPX */
 124   1              *--stk                   = 'H';                 /* DPH */
 125   1              *--stk                   = 'L';                 /* DPL */
 126   1      //      *--stk                   = 'X';                 /* DPX1 for second DPTR */
 127   1      //      *--stk                   = 'H';                 /* DPH1 for second DPTR */
 128   1      //      *--stk                   = 'L';                 /* DPL1 for second DPTR */
 129   1      //      *--stk                   = DPS;                 /* DPS for second DPTR */
 130   1              *--stk                   = PSW;                                 /* PSW */
 131   1              *--stk                   = 0;                   /* R0  */
 132   1      /*
 133   1              *--stk                   = 1;                   // should be R1
 134   1              *--stk                   = 2;                   // should be R2
 135   1              *--stk                   = 3;                   // should be R3
 136   1      */
 137   1              stk                             -= sizeof(void *);      /* Keil C uses R1,R2,R3 to pass the */
 138   1              *(void**)stk     = pvParameters;                  /* arguments of functions.          */
 139   1      
 140   1              *--stk                   = 4;                   /* R4  */
 141   1              *--stk                   = 5;                   /* R5  */
 142   1              *--stk                   = 6;                   /* R6  */
 143   1              *--stk                   = 7;                   /* R7  */
 144   1      /* Following is the registers pushed into hardware stack manually to support the dallas 390 */
 145   1          *--stk           = 0x80;                /* IE, EA is enabled  */
 146   1      
 147   1      /*
 148   1          Next is calculating the hardware stack pointer.
 149   1      */
 150   1          *--stk                       = (INT8U) portSTACK_START-1      /* Initial value when main was called    */
 151   1                                 +1                   /* IE */
 152   1                                 +8                   /* R0-R7, eight registers was saved      */
 153   1                             +5                   /* ACC, B, DPH, DPL, PSW, five registers */
 154   1                             +1                   /* Dallas 390 extra registers DPX1 */
 155   1      //                       +4                   /* Dallas 390 extra registers for second DPTR - DPL1 DPH1 DP
             -X1 DPS */
 156   1                             +sizeof(INT16U)      /* The PC value to be loaded             */
 157   1                             +sizeof(INT8U)       /* The third byte of PC value to be loaded for dallas 390  */
 158   1                                                 ;
 159   1          return ((void *)stk);
 160   1      
 161   1      }
 162          
 163          /* 
 164           * See header file for description. 
 165           */
 166          portSHORT sPortStartScheduler( portSHORT sUsePreemption ) reentrant
 167          {
 168   1              /* Stop compiler warnings.  This port uses a constant defined in
 169   1              portmacro.h to specify whether or not preemption is used. */
 170   1              sUsePreemption = sUsePreemption;
C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 4   

 171   1      
 172   1              /* Setup timer 2 to generate the RTOS tick. */
 173   1              prvSetupTimerInterrupt();       
 174   1      
 175   1          prvSetCurrentTCB_XBP();
 176   1              LoadCtx();
 177   1                                                                                      /* Should never get here! */
 178   1              return pdTRUE;
 179   1      }
 180          
 181          /*-----------------------------------------------------------*/
 182          
 183          void vPortEndScheduler(void) reentrant
 184          {
 185   1      
 186   1              /* Not implemented for this port. */
 187   1      }
 188          /*-----------------------------------------------------------*/
 189          
 190          
 191          /*********************************************************************************************************
             -*
 192          * C_OSCtxSw is the c part of OSCtxSw.
 193          * When control passes to this function, the processor registers have been saved in external stack
 194          **********************************************************************************************************
             -*/
 195          void vPortContextSwitch(void) reentrant
 196          {
 197   1      
 198   1      /*      Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  *
             -/
 199   1      
 200   1      /*      Save the current task's stack pointer into the current task's OS_TCB:  
 201   1                      prvGetCurrentTCB_XBP();
 202   1              Call vTaskSwitchContext();                                    
 203   1              Get the stack pointer of the task to resume:                           
 204   1                      prvSetCurrentTCB_XBP;
 205   1              Restore all processor registers from the new task's stack;             
 206   1              Execute a return from interrupt instruction;                           */
 207   1          prvGetCurrentTCB_XBP();
 208   1          
 209   1              vTaskSwitchContext();
 210   1      
 211   1          prvSetCurrentTCB_XBP();
 212   1          LoadCtx();
 213   1      
 214   1      }
 215          
 216          
 217          INT8U data SaveSP;
 218          
 219          void OSIntCtxSw(void) reentrant
 220          {
 221   1      
 222   1              EA=0;
 223   1          SP=SaveSP;
 224   1      
 225   1          prvSetCurrentTCB_XBP();
 226   1      
 227   1      #pragma ASM
 228   1              EXTRN   CODE(_?KCOSCtxSw)
 229   1              MOV             A, #BYTE0( _?KCOSCtxSw)
C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 5   

 230   1              PUSH    ACC
 231   1              MOV             A, #BYTE1(_?KCOSCtxSw)
 232   1              PUSH    ACC
 233   1              MOV             A, #BYTE2(_?KCOSCtxSw)
 234   1              PUSH    ACC
 235   1              RETI
 236   1      #pragma ENDASM
 237   1      
 238   1      }
 239          
 240          
 241          void vIntPortContextSwitch(void) reentrant
 242          {
 243   1      
 244   1      /*      Save processor registers; DONE in the OSCtxSw part in OS_CPU_ASM.ASM                                  *
             -/
 245   1      
 246   1      /*      Save the current task's stack pointer into the current task's OS_TCB:  
 247   1                      prvGetCurrentTCB_XBP();
 248   1              Call vTaskSwitchContext();                                    
 249   1              Get the stack pointer of the task to resume:                           
 250   1                      prvSetCurrentTCB_XBP;
 251   1              Restore all processor registers from the new task's stack;             
 252   1              Execute a return from interrupt instruction;                           */
 253   1          prvGetCurrentTCB_XBP();
 254   1      
 255   1              if ( TICK_INT == 1 )
 256   1              {
 257   2                      vTaskIncrementTick();
 258   2                      TICK_INT = 0;
 259   2              }
 260   1              vTaskSwitchContext();
 261   1                      
 262   1              portCLEAR_INTERRUPT_FLAG();
 263   1      
 264   1          prvSetCurrentTCB_XBP();
 265   1          LoadCtx();
 266   1              return;
 267   1      
 268   1      }
 269          
 270          /*-----------------------------------------------------------*/
 271          
 272          #if portUSE_PREEMPTION == 1
 273          
 274          /*-----------------------------------------------------------*/
 275          
 276          void vTimer2ISR( void ) interrupt 10
 277          {
 278   1              unsigned portCHAR       isr;
 279   1      #pragma ASM
 280   1                      PUSH IE
 281   1      #pragma ENDASM
 282   1                      isr = EA;
 283   1                      EA = 0;
 284   1                      if(uart2_timeout)
 285   1                              uart2_timeout--;
 286   1                      if(uart1_timeout)
 287   1                      { uart1_timeout--;  }
 288   1                      if(USB_timeout)
 289   1                              USB_timeout--;
 290   1                      TICK_INT = 1;
C51 COMPILER V9.06   PORT                                                                  05/28/2013 16:07:30 PAGE 6   

 291   1                      SaveSP=SP;
 292   1              prvGetCurrentTCB_XBP();
 293   1                      EA=isr;
 294   1      
 295   1                      OSIntCtxSw();
 296   1      }
 297          
 298          #endif
 299          
 300          /*-----------------------------------------------------------*/
 301          static void prvSetupTimerInterrupt( void )
 302          {
 303   1              /* using MS_TIMER */
 304   1              U8_T XDATA      temp[2];
 305   1      
 306   1              /* set software timer */
 307   1              temp[1] = (U8_T)SWTIMER_INTERVAL;
 308   1              temp[0] = (U8_T)(SWTIMER_INTERVAL >> 8) + SWTIMER_START + SWTIMER_INT_ENABLE;
 309   1              DMA_WriteReg(SWTIMER_REG, temp, 2);
 310   1      
 311   1              EXTINT5(ON);    /* Enable INT5 interrupt for software timer. */
 312   1      
 313   1      }
 314          
 315          #if ( configUSE_TICK_HOOK == 1 )
              void vApplicationTickHook( void )
              {
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1015    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
