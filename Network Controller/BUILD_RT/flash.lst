C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN .\flash.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\flash\flash.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) I
                    -NCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..
                    -\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\bu
                    -ffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\
                    -Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\
                    -src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\flash.lst) O
                    -BJECT(.\flash.obj)

line level    source

   1          /*
   2           *********************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           *********************************************************************************
  10           */
  11          /*================================================================================
  12           * Module Name : flash.c
  13           * Purpose     : 
  14           * Author      : 
  15           * Date        : 
  16           * Notes       : 
  17           *
  18           *================================================================================
  19           */
  20          
  21          
  22          
  23          #include        <absacc.h>
  24          #include        "reg80390.h"
  25          #include        "types.h"
  26          #include        "ax11000.h"
  27          #include        "flash.h"
  28          #include        "mstimer.h"
  29          #include        <absacc.h>
  30          #include        "reg80390.h"
  31          #include        "ax11000_cfg.h"
  32          #include        "flash.h"
  33          
  34          /* GLOBAL VARIABLE DECLARATIONS */
  35          U8_T IDATA fwAutoUpdated[4] _at_ 0x31;
  36          
  37          
  38          /* GLOBAL VARIABLE DECLARATIONS */
  39          U8_T CODE* PFlash = 0x6000;
  40          
  41          
  42          #if (RUNTIME_CODE_START_ADDRESS == RUNTIME_CODE_START_AT_24kH)
  43          
  44          typedef S16_T (*pFlashWrite)(U32_T ProgAddr, U8_T * ptWrData/*, U32_T ProgLen, U8_T BootldrSel*/);
  45          typedef S16_T (*pFlashErase)(U32_T EraAddr);
  46          
  47          /*
  48           *--------------------------------------------------------------------------------
  49           * S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData,
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 2   

  50           *                     U32_T ProgLen, U8_T BootldrSel)
  51           * Purpose : save prWrtData in Praddr with ProgLen bytes
  52           * Params  :    ProgAddr - start address
  53           *                              ptWrData - source data array
  54           *                              ProgLen  - no use
  55           *                              BootldrSel  - no use
  56           * Returns : TRUE or FALSE, whether the routine is done successfully 
  57           * Note    :
  58           *-------------------------------------------------------------------------------
  59           */
  60          
  61          S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData, U32_T ProgLen, U8_T BootldrSel)
  62          {
  63   1              U8_T    ret = FALSE;
  64   1              pFlashWrite     ptrFlashWrite = (void code*)0x003100;
  65   1      
  66   1              ProgLen = ProgLen;
  67   1              BootldrSel = BootldrSel;
  68   1      
  69   1              EA = 0;
  70   1              ret = (*ptrFlashWrite)(ProgAddr, ptWrData);     
  71   1              EA = 1;
  72   1              if (ret == FALSE)               return FALSE;   
  73   1              return TRUE;
  74   1      }
  75          /*
  76           *--------------------------------------------------------------------------------
  77           * S16_T S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
  78           * Purpose : Erase a flash block
  79           * Params  : EraseSel - no use
  80           *                       EraAddr  - start flash block address you want to erase
  81           * Returns : TRUE or FALSE, whether the routine is done successfully 
  82           * Note    :
  83           *-------------------------------------------------------------------------------
  84           */
  85          S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) //large reentrant
  86          {
  87   1              U8_T    ret = FALSE;    
  88   1              pFlashErase  ptrFlashErase = (void code*)0x003B00;
  89   1      
  90   1              EraseSel = EraseSel;
  91   1      
  92   1              EA = 0;
  93   1              ret = (*ptrFlashErase)(EraAddr);
  94   1              EA = 1; 
  95   1              if (ret == FALSE)               return FALSE;
  96   1              return TRUE;
  97   1      }
  98          
  99          #else
              /*
               *--------------------------------------------------------------------------------
               * S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData,
               *                     U32_T ProgLen, U8_T BootldrSel)
               * Purpose : save prWrtData in Praddr with ProgLen bytes
               * Params  :    ProgAddr - start address
               *                              ptWrData - source data array
               *                              ProgLen  - the length of source datas
               *                              BootldrSel  - select the boot load way or application way, for my application ,select ERA_RUN
               * Returns : TRUE or FALSE, whether the routine is done successfully 
               * Note    :
               *--------------------------------------------------------------------------------
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 3   

               */
              S16_T IntFlashWrite(U32_T ProgAddr, U8_T *ptWrData, U32_T ProgLen, U8_T BootldrSel) 
              {
                      U8_T    LastWtst;
              //      U32_T   idata i;
              //      U8_T    idata PollData;
                      U32_T   i;
                      U8_T    PollData;
              
                      LastWtst = WTST;
                      WTST = 0x07;
                      EA = 0;
              
                      if (CSREPR & PMS) // SRAM shadow
                      {
                              if (BootldrSel & ERA_BLD)
                              {
                                      CSREPR |= FAES | FARM;
                                      for (i = 0 ; i < 0x4000 ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              FVAR(U8_T, 0x4000 + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, 0x4000 + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FARM;
              
                                      for (i = 0x4000 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FAES;
                              }
                              else
                              {
                                      CSREPR |= FAES;
                                      for (i = 0 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, ProgAddr + i) = *(ptWrData + i);
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 4   

                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, ProgAddr + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FAES;
                              }
                      }
                      else // Flash, No shadow
                      {
                              CSREPR &= ~FAES;
              
                              if (BootldrSel & ERA_BLD)
                              {
                                      CSREPR |= FARM;
                                      for (i = 0 ; i < 0x4000 ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              FVAR(U8_T, 0x4000 + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, 0x4000 + i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                                      CSREPR &= ~FARM;
                                      for (i = 0x4000 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, i);
                                              } while (PollData != *(ptWrData + i)) ;
                                      }
                              }
                              else
                              {
                                      for (i = 0 ; i < ProgLen ; i++)
                                      {
                                              FLASH_WR_ENB;
                                              CSREPR |= FARM;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xAA;
                                              FVAR(U8_T, 0x4000 + 0x0002AA) = 0x55;
                                              FVAR(U8_T, 0x4000 + 0x000555) = 0xA0;
                                              CSREPR &= ~FARM;
                                              FVAR(U8_T, ProgAddr + i) = *(ptWrData + i);
                                              FLASH_WR_DISB;
                                              do
                                              {
                                                      PollData = FCVAR(U8_T, ProgAddr + i);
                                              } while (PollData != *(ptWrData + i)) ;
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 5   

                                      }
                              }
                      }
              
                      WTST = LastWtst;
                      EA = 1;
              
                      return TRUE;
              }
              
              /*
               *--------------------------------------------------------------------------------
               * S16_T S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
               * Purpose : Erase a flash block
               * Params  : EraseSel - select erase block. for my application, EraseSel = ERA_RUN
               *                       EraAddr  - start flash block address you want to erase
               * Returns : TRUE or FALSE, whether the routine is done successfully 
               * Note    : changed by chelsea 13th,Nov
               *--------------------------------------------------------------------------------
               */
              S16_T IntFlashErase(U8_T EraseSel,U32_T EraAddr) 
              {
              //      U8_T    idata PollData, LastWtst;
              //      U32_T   idata BaseAddr;
                      U8_T    PollData, LastWtst;
                      U32_T   BaseAddr;
                      U32_T   temp;
                      temp = EraAddr;
                      LastWtst = WTST;
                      WTST = 0x07;
                      EA = 0;
                      BaseAddr = 0x4000;
                      
                      FLASH_WR_ENB;
              
                      if (CSREPR & PMS) // SRAM shadow
                              CSREPR |= FAES;
                      else
                              CSREPR &= ~FAES;
                      
                      if (EraseSel & ERA_BLD) // Erase  BootLoader
                      {
                              CSREPR |= FARM;
                              
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0x80;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
              
                              FVAR(U8_T, BaseAddr + 0x000000) = 0x30;
                              
                              CSREPR &= ~FARM;
                      }
                      else 
                      {
                              CSREPR |= FARM;
              
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0x80;
                              FVAR(U8_T, BaseAddr + 0x000555) = 0xAA;
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 6   

                              FVAR(U8_T, BaseAddr + 0x0002AA) = 0x55;
              
                              CSREPR &= ~FARM;
                      if(EraseSel & ERA_CFG) // Erase configuration data
                      {
              
                                      FVAR(U8_T, 0x004000) = 0x30;
                      }
                              else                               // Erase runtime code
                              {
                                      /*FVAR(U8_T, 0x006000) = 0x30;
                                      FVAR(U8_T, 0x008000) = 0x30;
                                      FVAR(U8_T, 0x010000) = 0x30;
                                      FVAR(U8_T, 0x020000) = 0x30;
                                      FVAR(U8_T, 0x030000) = 0x30;
                                      FVAR(U8_T, 0x040000) = 0x30;
                                      FVAR(U8_T, 0x050000) = 0x30;
                                      FVAR(U8_T, 0x060000) = 0x30;
                                      FVAR(U8_T, 0x070000) = 0x30;*/
                                      FVAR(U8_T, temp) = 0x30;
                              }
                      }
                      FLASH_WR_DISB;
                  // check for completition
                      if (EraseSel & ERA_BLD)
                      {
                              CSREPR |= FARM;
                              while (1)
                              {   
                                      PollData = FCVAR(U8_T, BaseAddr + 0x000000);
                                      if (PollData == 0xFF)
                                      {
                                              break;
                                      }
                              }
                              CSREPR &= ~FARM;
                      }
                      else
                      {
                              while (1)
                              {
                          if(EraseSel & ERA_CFG)
                                              PollData = FCVAR(U8_T, BaseAddr + 0x000000);
                                      else
                                              PollData = FCVAR(U8_T, temp/*BaseAddr + 0x002000*/);
              
                                      if (PollData == 0xFF)
                                      {
                                              break;
                                      }
                              }
                      }
              
                      CSREPR &= ~FAES;
              
                      WTST = LastWtst;
                      EA = 1;
              
                      return TRUE;
              }
              #endif
 359          
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 7   

 360          
 361          
 362          U8_T IntFlashReadByte(U32_T location, U8_T *value)
 363          {
 364   1      
 365   1          *value = FCVAR(U8_T,location);
 366   1              
 367   1              return TRUE;
 368   1      
 369   1      }
 370          
 371          /*
 372           *--------------------------------------------------------------------------------
 373           * U8_T IntFlashWriteInt(U32_T location, U16_T value)
 374           * Purpose : write a word
 375           * Params  : location - flash address what you want to write 
 376           *                       value  - data what you want to write
 377           * Returns : TRUE or FALSE, whether the routine is done successfully 
 378           * Note    : 
 379           *--------------------------------------------------------------------------------
 380           */
 381          U8_T IntFlashReadInt(U32_T location, U16_T *value)
 382          {
 383   1              U8_T temp1,temp2;
 384   1              IntFlashReadByte(location + 1,&temp1);
 385   1              IntFlashReadByte(location,&temp2);
 386   1              *value = temp1 * 256 + temp2;   
 387   1              
 388   1              return TRUE;
 389   1      
 390   1      }
 391          
 392          
 393          
 394          
 395          U8_T IntFlashWriteByte(U32_T location,U8_T value)
 396          {
 397   1              IntFlashWrite(location,&value,1,0);
 398   1              return TRUE;
 399   1      }
 400          
 401          U8_T IntFlashWriteInt(U32_T location,U16_T value)
 402          {
 403   1              U8_T temp;
 404   1              temp = (U8_T)value;
 405   1              IntFlashWriteByte(location,temp);
 406   1              temp = value >> 8;
 407   1              IntFlashWriteByte(location+1,temp);
 408   1              return TRUE;
 409   1      }
 410          
 411          #if 1
 412          void MassFlashWrite(U32_T location,U8_T *value,U32_T lenght)
 413          {
 414   1              U16_T i;
 415   1              /*for(i = 0;i < lenght;i++)
 416   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);*/
 417   1              /* after add watchdog , must short flash time*/
 418   1              for(i = 0;i < lenght;i++)
 419   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);
 420   1              //IntFlashWrite((U32_T)(location + FLASH_BLOCK),value,lenght,0);
 421   1      }
C51 COMPILER V9.06   FLASH                                                                 05/28/2013 10:15:31 PAGE 8   

 422          
 423          
 424          void ISPMassFlashWrite(U32_T location,U8_T *value,U32_T lenght)
 425          {
 426   1              U16_T i;
 427   1              for(i = 0;i < lenght;i++)
 428   1              IntFlashWrite((U32_T)(location + FLASH_BLOCK + i),(value + i),1,0);
 429   1              /* after add watchdog , must short flash time*/
 430   1              //IntFlashWrite((U32_T)(location +0x60000),value,lenght,0);
 431   1      }
 432          
 433          #endif
 434          
 435          
 436          /* LOCAL SUBPROGRAM BODIES */
 437          
 438          
 439          /* EXPORTED SUBPROGRAM BODIES */
 440          
 441          /*
 442           * ----------------------------------------------------------------------------
 443           * void FirmwareUpdate(void)
 444           * Purpose: 
 445           * Params:
 446           * Returns:
 447           * Note:
 448           * ----------------------------------------------------------------------------
 449           */
 450          void FirmwareUpdate(void)
 451          {
 452   1              fwAutoUpdated[0] = 'a';
 453   1              fwAutoUpdated[1] = 's';
 454   1              fwAutoUpdated[2] = 'i';
 455   1              fwAutoUpdated[3] = 'x';
 456   1              AX11000_SoftReboot();
 457   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    876    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      69
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
