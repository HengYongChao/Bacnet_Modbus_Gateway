C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE RPM
OBJECT MODULE PLACED IN .\rpm.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\rpm.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) IN
                    -CDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\
                    -SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buf
                    -fer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\S
                    -rc\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\rpm.lst) OBJECT(.\rpm.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2005 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          #include <stdint.h>
  35          #include "../include/bacenum.h"
  36          #include "../include/bacerror.h"
  37          #include "../include/bacdcode.h"
  38          #include "../include/bacdef.h"
  39          #include "../include/bacapp.h"
  40          #include "../include/memcopy.h"
  41          #include "../include/rpm.h"
  42          
  43          /** @file rpm.c  Encode/Decode Read Property Multiple and RPM ACKs  */
  44          
  45          #if BACNET_SVC_RPM_A
  46          /* encode the initial portion of the service */
  47          int rpm_encode_apdu_init(
  48              uint8_t * apdu,
  49              uint8_t invoke_id)
  50          {
  51   1          int apdu_len = 0;   /* total length of the apdu, return value */
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 2   

  52   1      
  53   1          if (apdu) {
  54   2              apdu[0] = PDU_TYPE_CONFIRMED_SERVICE_REQUEST;
  55   2              apdu[1] = encode_max_segs_max_apdu(0, MAX_APDU);
  56   2              apdu[2] = invoke_id;
  57   2              apdu[3] = SERVICE_CONFIRMED_READ_PROP_MULTIPLE; /* service choice */
  58   2              apdu_len = 4;
  59   2          }
  60   1      
  61   1          return apdu_len;
  62   1      }
  63          
  64          int rpm_encode_apdu_object_begin(
  65              uint8_t * apdu,
  66              BACNET_OBJECT_TYPE object_type,
  67              uint32_t object_instance)
  68          {
  69   1          int apdu_len = 0;   /* total length of the apdu, return value */
  70   1      
  71   1          if (apdu) {
  72   2              apdu_len =
  73   2                  encode_context_object_id(&apdu[0], 0, object_type,
  74   2                  object_instance);
  75   2              /* Tag 1: sequence of ReadAccessSpecification */
  76   2              apdu_len += encode_opening_tag(&apdu[apdu_len], 1);
  77   2          }
  78   1      
  79   1          return apdu_len;
  80   1      }
  81          
  82          int rpm_encode_apdu_object_property(
  83              uint8_t * apdu,
  84              BACNET_PROPERTY_ID object_property,
  85              uint32_t array_index)
  86          {
  87   1          int apdu_len = 0;   /* total length of the apdu, return value */
  88   1      
  89   1          if (apdu) {
  90   2              apdu_len = encode_context_enumerated(&apdu[0], 0, object_property);
  91   2              /* optional array index */
  92   2              if (array_index != BACNET_ARRAY_ALL)
  93   2                  apdu_len +=
  94   2                      encode_context_unsigned(&apdu[apdu_len], 1, array_index);
  95   2          }
  96   1      
  97   1          return apdu_len;
  98   1      }
  99          
 100          int rpm_encode_apdu_object_end(
 101              uint8_t * apdu)
 102          {
 103   1          int apdu_len = 0;   /* total length of the apdu, return value */
 104   1      
 105   1          if (apdu) {
 106   2              apdu_len = encode_closing_tag(&apdu[0], 1);
 107   2          }
 108   1      
 109   1          return apdu_len;
 110   1      }
 111          
 112          /** Encode an RPM request, to be sent.
 113           *
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 3   

 114           * @param apdu [in,out] Buffer to hold encoded bytes.
 115           * @param max_apdu [in] Length of apdu buffer.
 116           * @param invoke_id [in] The Invoke ID to use for this message.
 117           * @param read_access_data [in] The RPM data to be requested.
 118           * @return Length of encoded bytes, or 0 on failure.
 119           */
 120          int rpm_encode_apdu(
 121              uint8_t * apdu,
 122              size_t max_apdu,
 123              uint8_t invoke_id,
 124              BACNET_READ_ACCESS_DATA * read_access_data)
 125          {
 126   1          int apdu_len = 0;   /* total length of the apdu, return value */
 127   1          int len = 0;        /* length of the data */
 128   1          BACNET_READ_ACCESS_DATA *rpm_object;        /* current object */
 129   1          uint8_t apdu_temp[16];      /* temp for data before copy */
 130   1          BACNET_PROPERTY_REFERENCE *rpm_property;    /* current property */
 131   1      
 132   1          len = rpm_encode_apdu_init(&apdu_temp[0], invoke_id);
 133   1          len =
 134   1              (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len, (size_t) len,
 135   1              (size_t) max_apdu);
 136   1          if (len == 0) {
 137   2              return 0;
 138   2          }
 139   1          apdu_len += len;
 140   1          rpm_object = read_access_data;
 141   1          while (rpm_object) {
 142   2              len =
 143   2                  encode_context_object_id(&apdu_temp[0], 0, rpm_object->object_type,
 144   2                  rpm_object->object_instance);
 145   2              len =
 146   2                  (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len,
 147   2                  (size_t) len, (size_t) max_apdu);
 148   2              if (len == 0) {
 149   3                  return 0;
 150   3              }
 151   2              apdu_len += len;
 152   2              /* Tag 1: sequence of ReadAccessSpecification */
 153   2              len = encode_opening_tag(&apdu_temp[0], 1);
 154   2              len =
 155   2                  (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len,
 156   2                  (size_t) len, (size_t) max_apdu);
 157   2              if (len == 0) {
 158   3                  return 0;
 159   3              }
 160   2              apdu_len += len;
 161   2              rpm_property = rpm_object->listOfProperties;
 162   2              while (rpm_property) {
 163   3                  /* stuff as many properties into it as APDU length will allow */
 164   3                  len =
 165   3                      encode_context_enumerated(&apdu_temp[0], 0,
 166   3                      rpm_property->propertyIdentifier);
 167   3                  len =
 168   3                      (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len,
 169   3                      (size_t) len, (size_t) max_apdu);
 170   3                  if (len == 0) {
 171   4                      return 0;
 172   4                  }
 173   3                  apdu_len += len;
 174   3                  /* optional array index */
 175   3                  if (rpm_property->propertyArrayIndex != BACNET_ARRAY_ALL) {
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 4   

 176   4                      len =
 177   4                          encode_context_unsigned(&apdu_temp[0], 1,
 178   4                          rpm_property->propertyArrayIndex);
 179   4                      len =
 180   4                          (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len,
 181   4                          (size_t) len, (size_t) max_apdu);
 182   4                      if (len == 0) {
 183   5                          return 0;
 184   5                      }
 185   4                      apdu_len += len;
 186   4                  }
 187   3                  rpm_property = rpm_property->next;
 188   3              }
 189   2              len = encode_closing_tag(&apdu_temp[0], 1);
 190   2              len =
 191   2                  (int) memcopy(&apdu[0], &apdu_temp[0], (size_t) apdu_len,
 192   2                  (size_t) len, (size_t) max_apdu);
 193   2              if (len == 0) {
 194   3                  return 0;
 195   3              }
 196   2              apdu_len += len;
 197   2              rpm_object = rpm_object->next;
 198   2          }
 199   1      
 200   1          return apdu_len;
 201   1      }
 202          
 203          #endif
 204          
 205          /* decode the object portion of the service request only. Bails out if
 206           * tags are wrong or missing/incomplete
 207           */
 208          int rpm_decode_object_id(
 209              uint8_t * apdu,
 210              unsigned apdu_len,
 211              BACNET_RPM_DATA * rpmdata)
 212          {
 213   1          unsigned len = 0;
 214   1          uint16_t type = 0;  /* for decoding */
 215   1      
 216   1          /* check for value pointers */
 217   1          if (apdu && apdu_len && rpmdata) {
 218   2              if (apdu_len < 5) {     /* Must be at least 2 tags and an object id */
 219   3                  rpmdata->error_code = ERROR_CODE_REJECT_MISSING_REQUIRED_PARAMETER;
 220   3                  return BACNET_STATUS_REJECT;
 221   3              }
 222   2              /* Tag 0: Object ID */
 223   2              if (!decode_is_context_tag(&apdu[len++], 0)) {
 224   3                  rpmdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 225   3                  return BACNET_STATUS_REJECT;
 226   3              }
 227   2              len += decode_object_id(&apdu[len], &type, &rpmdata->object_instance);
 228   2              rpmdata->object_type = (BACNET_OBJECT_TYPE) type;
 229   2              /* Tag 1: sequence of ReadAccessSpecification */
 230   2              if (!decode_is_opening_tag_number(&apdu[len], 1)) {
 231   3                  rpmdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 232   3                  return BACNET_STATUS_REJECT;
 233   3              }
 234   2              len++;  /* opening tag is only one octet */
 235   2          }
 236   1      
 237   1          return (int) len;
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 5   

 238   1      }
 239          
 240          int rpm_decode_object_end(
 241              uint8_t * apdu,
 242              unsigned apdu_len)
 243          {
 244   1          int len = 0;        /* total length of the apdu, return value */
 245   1      
 246   1          if (apdu && apdu_len) {
 247   2              if (decode_is_closing_tag_number(apdu, 1) == true)
 248   2                  len = 1;
 249   2          }
 250   1      
 251   1          return len;
 252   1      }
 253          
 254          /* decode the object property portion of the service request only */
 255          /*  BACnetPropertyReference ::= SEQUENCE {
 256                  propertyIdentifier [0] BACnetPropertyIdentifier,
 257                  propertyArrayIndex [1] Unsigned OPTIONAL
 258                  --used only with array datatype
 259                  -- if omitted with an array the entire array is referenced
 260              }
 261          */
 262          int rpm_decode_object_property(
 263              uint8_t * apdu,
 264              unsigned apdu_len,
 265              BACNET_RPM_DATA * rpmdata)
 266          {
 267   1          unsigned len = 0;
 268   1          unsigned option_len = 0;
 269   1          uint8_t tag_number = 0;
 270   1          uint32_t len_value_type = 0;
 271   1          uint32_t property = 0;      /* for decoding */
 272   1          uint32_t array_value = 0;   /* for decoding */
 273   1      
 274   1          /* check for valid pointers */
 275   1          if (apdu && apdu_len && rpmdata) {
 276   2              /* Tag 0: propertyIdentifier */
 277   2      
 278   2              if (!IS_CONTEXT_SPECIFIC(apdu[len])) {
 279   3                 
 280   3                          rpmdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 281   3                 
 282   3                          return BACNET_STATUS_REJECT;
 283   3              
 284   3                      }
 285   2      
 286   2              len +=
 287   2                  decode_tag_number_and_value(&apdu[len], &tag_number,
 288   2                  &len_value_type);
 289   2              if (tag_number != 0) {
 290   3                  rpmdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 291   3                  return BACNET_STATUS_REJECT;
 292   3              }
 293   2              /* Should be at least the unsigned value + 1 tag left */
 294   2              if ((len + len_value_type) >= apdu_len) {
 295   3                  rpmdata->error_code = ERROR_CODE_REJECT_MISSING_REQUIRED_PARAMETER;
 296   3                  return BACNET_STATUS_REJECT;
 297   3              }
 298   2              len += decode_enumerated(&apdu[len], len_value_type, &property);
 299   2              rpmdata->object_property = (BACNET_PROPERTY_ID) property;
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 6   

 300   2              /* Assume most probable outcome */
 301   2              rpmdata->array_index = BACNET_ARRAY_ALL;
 302   2              /* Tag 1: Optional propertyArrayIndex */
 303   2              if (IS_CONTEXT_SPECIFIC(apdu[len]) && !IS_CLOSING_TAG(apdu[len])) {
 304   3                  option_len =
 305   3                      (unsigned) decode_tag_number_and_value(&apdu[len], &tag_number,
 306   3                      &len_value_type);
 307   3                  if (tag_number == 1) {
 308   4                      len += option_len;
 309   4                      /* Should be at least the unsigned array index + 1 tag left */
 310   4                      if ((len + len_value_type) >= apdu_len) {
 311   5                          rpmdata->error_code =
 312   5                              ERROR_CODE_REJECT_MISSING_REQUIRED_PARAMETER;
 313   5                          return BACNET_STATUS_REJECT;
 314   5                      }
 315   4                      len +=
 316   4                          decode_unsigned(&apdu[len], len_value_type, &array_value);
 317   4                      rpmdata->array_index = array_value;
 318   4                  }
 319   3              }
 320   2          }
 321   1      
 322   1          return (int) len;
 323   1      }
 324          
 325          int rpm_ack_encode_apdu_init(
 326              uint8_t * apdu,
 327              uint8_t invoke_id)
 328          {
 329   1          int apdu_len = 0;   /* total length of the apdu, return value */
 330   1      
 331   1          if (apdu) {
 332   2              apdu[0] = PDU_TYPE_COMPLEX_ACK; /* complex ACK service */
 333   2              apdu[1] = invoke_id;    /* original invoke id from request */
 334   2              apdu[2] = SERVICE_CONFIRMED_READ_PROP_MULTIPLE; /* service choice */
 335   2              apdu_len = 3;
 336   2          }
 337   1      
 338   1          return apdu_len;
 339   1      }
 340          
 341          int rpm_ack_encode_apdu_object_begin(
 342              uint8_t * apdu,
 343              BACNET_RPM_DATA * rpmdata)
 344          {
 345   1          int apdu_len = 0;   /* total length of the apdu, return value */
 346   1      
 347   1          if (apdu) {
 348   2              /* Tag 0: objectIdentifier */
 349   2              apdu_len =
 350   2                  encode_context_object_id(&apdu[0], 0, rpmdata->object_type,
 351   2                  rpmdata->object_instance);
 352   2              /* Tag 1: listOfResults */
 353   2              apdu_len += encode_opening_tag(&apdu[apdu_len], 1);
 354   2          }
 355   1      
 356   1          return apdu_len;
 357   1      }
 358          
 359          int rpm_ack_encode_apdu_object_property(
 360              uint8_t * apdu,
 361              BACNET_PROPERTY_ID object_property,
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 7   

 362              uint32_t array_index)
 363          {
 364   1          int apdu_len = 0;   /* total length of the apdu, return value */
 365   1      
 366   1          if (apdu) {
 367   2              /* Tag 2: propertyIdentifier */
 368   2              apdu_len = encode_context_enumerated(&apdu[0], 2, object_property);
 369   2              /* Tag 3: optional propertyArrayIndex */
 370   2              if (array_index != BACNET_ARRAY_ALL)
 371   2                  apdu_len +=
 372   2                      encode_context_unsigned(&apdu[apdu_len], 3, array_index);
 373   2          }
 374   1      
 375   1          return apdu_len;
 376   1      }
 377          
 378          int rpm_ack_encode_apdu_object_property_value(
 379              uint8_t * apdu,
 380              uint8_t * application_data,
 381              unsigned application_data_len)
 382          {
 383   1          int apdu_len = 0;   /* total length of the apdu, return value */
 384   1          unsigned len = 0;
 385   1      
 386   1          if (apdu) {
 387   2              /* Tag 4: propertyValue */
 388   2              apdu_len += encode_opening_tag(&apdu[apdu_len], 4);
 389   2              if (application_data == &apdu[apdu_len]) {      /* Is Data already in place? */
 390   3                  apdu_len += application_data_len;   /* Yes, step over data */
 391   3              } else {        /* No, copy data in */
 392   3                  for (len = 0; len < application_data_len; len++) {
 393   4                      apdu[apdu_len++] = application_data[len];
 394   4                  }
 395   3              }
 396   2              apdu_len += encode_closing_tag(&apdu[apdu_len], 4);
 397   2          }
 398   1      
 399   1          return apdu_len;
 400   1      }
 401          
 402          int rpm_ack_encode_apdu_object_property_error(
 403              uint8_t * apdu,
 404              BACNET_ERROR_CLASS error_class,
 405              BACNET_ERROR_CODE error_code)
 406          {
 407   1          int apdu_len = 0;   /* total length of the apdu, return value */
 408   1      
 409   1          if (apdu) {
 410   2              /* Tag 5: propertyAccessError */
 411   2              apdu_len += encode_opening_tag(&apdu[apdu_len], 5);
 412   2              apdu_len +=
 413   2                  encode_application_enumerated(&apdu[apdu_len], error_class);
 414   2              apdu_len += encode_application_enumerated(&apdu[apdu_len], error_code);
 415   2              apdu_len += encode_closing_tag(&apdu[apdu_len], 5);
 416   2          }
 417   1      
 418   1          return apdu_len;
 419   1      }
 420          
 421          int rpm_ack_encode_apdu_object_end(
 422              uint8_t * apdu)
 423          {
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 8   

 424   1          int apdu_len = 0;   /* total length of the apdu, return value */
 425   1      
 426   1          if (apdu) {
 427   2              apdu_len = encode_closing_tag(&apdu[0], 1);
 428   2          }
 429   1      
 430   1          return apdu_len;
 431   1      }
 432          
 433          #if BACNET_SVC_RPM_A
 434          
 435          /* decode the object portion of the service request only */
 436          int rpm_ack_decode_object_id(
 437              uint8_t * apdu,
 438              unsigned apdu_len,
 439              BACNET_OBJECT_TYPE * object_type,
 440              uint32_t * object_instance)
 441          {
 442   1          unsigned len = 0;
 443   1          uint16_t type = 0;  /* for decoding */
 444   1      
 445   1          /* check for value pointers */
 446   1          if (apdu && apdu_len && object_type && object_instance) {
 447   2              /* Tag 0: objectIdentifier */
 448   2              if (!decode_is_context_tag(&apdu[len++], 0))
 449   2                  return -1;
 450   2              len += decode_object_id(&apdu[len], &type, object_instance);
 451   2              if (object_type)
 452   2                  *object_type = (BACNET_OBJECT_TYPE) type;
 453   2              /* Tag 1: listOfResults */
 454   2              if (!decode_is_opening_tag_number(&apdu[len], 1))
 455   2                  return -1;
 456   2              len++;  /* opening tag is only one octet */
 457   2          }
 458   1      
 459   1          return (int) len;
 460   1      }
 461          
 462          /* is this the end of the list of this objects properties values? */
 463          int rpm_ack_decode_object_end(
 464              uint8_t * apdu,
 465              unsigned apdu_len)
 466          {
 467   1          int len = 0;        /* total length of the apdu, return value */
 468   1      
 469   1          if (apdu && apdu_len) {
 470   2              if (decode_is_closing_tag_number(apdu, 1))
 471   2                  len = 1;
 472   2          }
 473   1      
 474   1          return len;
 475   1      }
 476          
 477          int rpm_ack_decode_object_property(
 478              uint8_t * apdu,
 479              unsigned apdu_len,
 480              BACNET_PROPERTY_ID * object_property,
 481              uint32_t * array_index)
 482          {
 483   1          unsigned len = 0;
 484   1          unsigned tag_len = 0;
 485   1          uint8_t tag_number = 0;
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 9   

 486   1          uint32_t len_value_type = 0;
 487   1          uint32_t property = 0;      /* for decoding */
 488   1          uint32_t array_value = 0;   /* for decoding */
 489   1      
 490   1          /* check for valid pointers */
 491   1          if (apdu && apdu_len && object_property && array_index) {
 492   2              /* Tag 2: propertyIdentifier */
 493   2              if (!IS_CONTEXT_SPECIFIC(apdu[len]))
 494   2                  return -1;
 495   2              len +=
 496   2                  decode_tag_number_and_value(&apdu[len], &tag_number,
 497   2                  &len_value_type);
 498   2              if (tag_number != 2)
 499   2                  return -1;
 500   2              len += decode_enumerated(&apdu[len], len_value_type, &property);
 501   2              if (object_property)
 502   2                  *object_property = (BACNET_PROPERTY_ID) property;
 503   2              /* Tag 3: Optional propertyArrayIndex */
 504   2              if ((len < apdu_len) && IS_CONTEXT_SPECIFIC(apdu[len]) &&
 505   2                  (!IS_CLOSING_TAG(apdu[len]))) {
 506   3                  tag_len =
 507   3                      (unsigned) decode_tag_number_and_value(&apdu[len], &tag_number,
 508   3                      &len_value_type);
 509   3                  if (tag_number == 3) {
 510   4                      len += tag_len;
 511   4                      len +=
 512   4                          decode_unsigned(&apdu[len], len_value_type, &array_value);
 513   4                      *array_index = array_value;
 514   4                  } else {
 515   4                      *array_index = BACNET_ARRAY_ALL;
 516   4                  }
 517   3              } else {
 518   3                  *array_index = BACNET_ARRAY_ALL;
 519   3              }
 520   2          }
 521   1      
 522   1          return (int) len;
 523   1      }
 524          
 525          #endif
 526          
 527          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include "ctest.h"
              
              int rpm_ack_decode_apdu(
                  uint8_t * apdu,
                  int apdu_len,       /* total length of the apdu */
                  uint8_t * invoke_id,
                  uint8_t ** service_request,
                  unsigned *service_request_len)
              {
                  int offset = 0;
              
                  if (!apdu)
                      return -1;
                  /* optional checking - most likely was already done prior to this call */
                  if (apdu[0] != PDU_TYPE_COMPLEX_ACK)
                      return -1;
                  *invoke_id = apdu[1];
                  if (apdu[2] != SERVICE_CONFIRMED_READ_PROP_MULTIPLE)
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 10  

                      return -1;
                  offset = 3;
                  if (apdu_len > offset) {
                      if (service_request)
                          *service_request = &apdu[offset];
                      if (service_request_len)
                          *service_request_len = apdu_len - offset;
                  }
              
                  return offset;
              }
              
              int rpm_decode_apdu(
                  uint8_t * apdu,
                  unsigned apdu_len,
                  uint8_t * invoke_id,
                  uint8_t ** service_request,
                  unsigned *service_request_len)
              {
                  unsigned offset = 0;
              
                  if (!apdu)
                      return -1;
                  /* optional checking - most likely was already done prior to this call */
                  if (apdu[0] != PDU_TYPE_CONFIRMED_SERVICE_REQUEST)
                      return -1;
                  /*  apdu[1] = encode_max_segs_max_apdu(0, MAX_APDU); */
                  *invoke_id = apdu[2];       /* invoke id - filled in by net layer */
                  if (apdu[3] != SERVICE_CONFIRMED_READ_PROP_MULTIPLE)
                      return -1;
                  offset = 4;
              
                  if (apdu_len > offset) {
                      if (service_request)
                          *service_request = &apdu[offset];
                      if (service_request_len)
                          *service_request_len = apdu_len - offset;
                  }
              
                  return offset;
              }
              
              void testReadPropertyMultiple(
                  Test * pTest)
              {
                  uint8_t apdu[480] = { 0 };
                  int len = 0;
                  int test_len = 0;
                  int apdu_len = 0;
                  uint8_t invoke_id = 12;
                  uint8_t test_invoke_id = 0;
                  uint8_t *service_request = NULL;
                  unsigned service_request_len = 0;
                  BACNET_RPM_DATA rpmdata;
              
                  rpmdata.object_type = OBJECT_DEVICE;
                  rpmdata.object_instance = 0;
                  rpmdata.object_property = PROP_OBJECT_IDENTIFIER;
                  rpmdata.array_index = 0;
              
                  /* build the RPM - try to make it easy for the Application Layer development */
                  /* IDEA: similar construction, but pass apdu, apdu_len pointer, size of apdu to
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 11  

                     let the called function handle the out of space problem that these get into
                     by returning a boolean of success/failure.
                     It almost needs to use the keylist library or something similar.
                     Also check case of storing a backoff point (i.e. save enough room for object_end) */
                  apdu_len = rpm_encode_apdu_init(&apdu[0], invoke_id);
                  /* each object has a beginning and an end */
                  apdu_len +=
                      rpm_encode_apdu_object_begin(&apdu[apdu_len], OBJECT_DEVICE, 123);
                  /* then stuff as many properties into it as APDU length will allow */
                  apdu_len +=
                      rpm_encode_apdu_object_property(&apdu[apdu_len],
                      PROP_OBJECT_IDENTIFIER, BACNET_ARRAY_ALL);
                  apdu_len +=
                      rpm_encode_apdu_object_property(&apdu[apdu_len], PROP_OBJECT_NAME,
                      BACNET_ARRAY_ALL);
                  apdu_len += rpm_encode_apdu_object_end(&apdu[apdu_len]);
                  /* each object has a beginning and an end */
                  apdu_len +=
                      rpm_encode_apdu_object_begin(&apdu[apdu_len], OBJECT_ANALOG_INPUT, 33);
                  apdu_len +=
                      rpm_encode_apdu_object_property(&apdu[apdu_len],
                      PROP_OBJECT_IDENTIFIER, BACNET_ARRAY_ALL);
                  apdu_len +=
                      rpm_encode_apdu_object_property(&apdu[apdu_len], PROP_ALL,
                      BACNET_ARRAY_ALL);
                  apdu_len += rpm_encode_apdu_object_end(&apdu[apdu_len]);
              
                  ct_test(pTest, apdu_len != 0);
              
                  test_len = rpm_decode_apdu(&apdu[0], apdu_len, &test_invoke_id, &service_request,   /* will point to t
             -he service request in the apdu */
                      &service_request_len);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, test_invoke_id == invoke_id);
                  ct_test(pTest, service_request != NULL);
                  ct_test(pTest, service_request_len > 0);
              
                  test_len =
                      rpm_decode_object_id(service_request, service_request_len, &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_type == OBJECT_DEVICE);
                  ct_test(pTest, rpmdata.object_instance == 123);
                  len = test_len;
                  /* decode the object property portion of the service request */
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_property == PROP_OBJECT_IDENTIFIER);
                  ct_test(pTest, rpmdata.array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_property == PROP_OBJECT_NAME);
                  ct_test(pTest, rpmdata.array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  /* try again - we should fail */
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 12  

                  ct_test(pTest, test_len < 0);
                  /* is it the end of this object? */
                  test_len =
                      rpm_decode_object_end(&service_request[len],
                      service_request_len - len);
                  ct_test(pTest, test_len == 1);
                  len += test_len;
                  /* try to decode an object id */
                  test_len =
                      rpm_decode_object_id(&service_request[len], service_request_len - len,
                      &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_type == OBJECT_ANALOG_INPUT);
                  ct_test(pTest, rpmdata.object_instance == 33);
                  len += test_len;
                  /* decode the object property portion of the service request only */
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_property == PROP_OBJECT_IDENTIFIER);
                  ct_test(pTest, rpmdata.array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, rpmdata.object_property == PROP_ALL);
                  ct_test(pTest, rpmdata.array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  test_len =
                      rpm_decode_object_property(&service_request[len],
                      service_request_len - len, &rpmdata);
                  ct_test(pTest, test_len < 0);
                  /* got an error -1, is it the end of this object? */
                  test_len =
                      rpm_decode_object_end(&service_request[len],
                      service_request_len - len);
                  ct_test(pTest, test_len == 1);
                  len += test_len;
                  ct_test(pTest, len == service_request_len);
              }
              
              void testReadPropertyMultipleAck(
                  Test * pTest)
              {
                  uint8_t apdu[480] = { 0 };
                  int len = 0;
                  int test_len = 0;
                  int apdu_len = 0;
                  uint8_t invoke_id = 12;
                  uint8_t test_invoke_id = 0;
                  uint8_t *service_request = NULL;
                  unsigned service_request_len = 0;
                  BACNET_OBJECT_TYPE object_type = OBJECT_DEVICE;
                  uint32_t object_instance = 0;
                  BACNET_PROPERTY_ID object_property = PROP_OBJECT_IDENTIFIER;
                  uint32_t array_index = 0;
                  BACNET_APPLICATION_DATA_VALUE application_data[4] = { {0} };
                  BACNET_APPLICATION_DATA_VALUE test_application_data = { 0 };
                  uint8_t application_data_buffer[MAX_APDU] = { 0 };
                  int application_data_buffer_len = 0;
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 13  

                  BACNET_ERROR_CLASS error_class;
                  BACNET_ERROR_CODE error_code;
                  BACNET_RPM_DATA rpmdata;
              
                  /* build the RPM - try to make it easy for the
                     Application Layer development */
                  /* IDEA: similar construction, but pass apdu, apdu_len pointer,
                     size of apdu to let the called function handle the out of
                     space problem that these get into  by returning a boolean
                     of success/failure.
                     It almost needs to use the keylist library or something similar.
                     Also check case of storing a backoff point
                     (i.e. save enough room for object_end) */
                  apdu_len = rpm_ack_encode_apdu_init(&apdu[0], invoke_id);
                  /* object beginning */
                  rpmdata.object_type = OBJECT_DEVICE;
                  rpmdata.object_instance = 123;
                  apdu_len += rpm_ack_encode_apdu_object_begin(&apdu[apdu_len], &rpmdata);
                  /* reply property */
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property(&apdu[apdu_len],
                      PROP_OBJECT_IDENTIFIER, BACNET_ARRAY_ALL);
                  /* reply value */
                  application_data[0].tag = BACNET_APPLICATION_TAG_OBJECT_ID;
                  application_data[0].type.Object_Id.type = OBJECT_DEVICE;
                  application_data[0].type.Object_Id.instance = 123;
                  application_data_buffer_len =
                      bacapp_encode_application_data(&application_data_buffer[0],
                      &application_data[0]);
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property_value(&apdu[apdu_len],
                      &application_data_buffer[0], application_data_buffer_len);
                  /* reply property */
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property(&apdu[apdu_len], PROP_OBJECT_TYPE,
                      BACNET_ARRAY_ALL);
                  /* reply value */
                  application_data[1].tag = BACNET_APPLICATION_TAG_ENUMERATED;
                  application_data[1].type.Enumerated = OBJECT_DEVICE;
                  application_data_buffer_len =
                      bacapp_encode_application_data(&application_data_buffer[0],
                      &application_data[1]);
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property_value(&apdu[apdu_len],
                      &application_data_buffer[0], application_data_buffer_len);
                  /* object end */
                  apdu_len += rpm_ack_encode_apdu_object_end(&apdu[apdu_len]);
              
                  /* object beginning */
                  rpmdata.object_type = OBJECT_ANALOG_INPUT;
                  rpmdata.object_instance = 33;
                  apdu_len += rpm_ack_encode_apdu_object_begin(&apdu[apdu_len], &rpmdata);
                  /* reply property */
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property(&apdu[apdu_len],
                      PROP_PRESENT_VALUE, BACNET_ARRAY_ALL);
                  /* reply value */
                  application_data[2].tag = BACNET_APPLICATION_TAG_REAL;
                  application_data[2].type.Real = 0.0;
                  application_data_buffer_len =
                      bacapp_encode_application_data(&application_data_buffer[0],
                      &application_data[2]);
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 14  

                  apdu_len +=
                      rpm_ack_encode_apdu_object_property_value(&apdu[apdu_len],
                      &application_data_buffer[0], application_data_buffer_len);
                  /* reply property */
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property(&apdu[apdu_len], PROP_DEADBAND,
                      BACNET_ARRAY_ALL);
                  /* reply error */
                  apdu_len +=
                      rpm_ack_encode_apdu_object_property_error(&apdu[apdu_len],
                      ERROR_CLASS_PROPERTY, ERROR_CODE_UNKNOWN_PROPERTY);
                  /* object end */
                  apdu_len += rpm_ack_encode_apdu_object_end(&apdu[apdu_len]);
                  ct_test(pTest, apdu_len != 0);
              
                /****** decode the packet ******/
                  test_len = rpm_ack_decode_apdu(&apdu[0], apdu_len, &test_invoke_id, &service_request,       /* will po
             -int to the service request in the apdu */
                      &service_request_len);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, test_invoke_id == invoke_id);
                  ct_test(pTest, service_request != NULL);
                  ct_test(pTest, service_request_len > 0);
                  /* the first part should be the first object id */
                  test_len =
                      rpm_ack_decode_object_id(service_request, service_request_len,
                      &object_type, &object_instance);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, object_type == OBJECT_DEVICE);
                  ct_test(pTest, object_instance == 123);
                  len = test_len;
                  /* extract the property */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, object_property == PROP_OBJECT_IDENTIFIER);
                  ct_test(pTest, array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  /* what is the result? An error or a value? */
                  ct_test(pTest, decode_is_opening_tag_number(&service_request[len], 4));
                  len++;
                  /* decode the object property portion of the service request */
                  /* note: if this was an array, there could have been
                     more than one element to decode */
                  test_len =
                      bacapp_decode_application_data(&service_request[len],
                      service_request_len - len, &test_application_data);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, bacapp_same_value(&application_data[0],
                          &test_application_data));
                  len += test_len;
                  ct_test(pTest, decode_is_closing_tag_number(&service_request[len], 4));
                  len++;
                  /* see if there is another property */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, object_property == PROP_OBJECT_TYPE);
                  ct_test(pTest, array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  /* what is the result value? */
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 15  

                  ct_test(pTest, decode_is_opening_tag_number(&service_request[len], 4));
                  len++;
                  /* decode the object property portion of the service request */
                  test_len =
                      bacapp_decode_application_data(&service_request[len],
                      service_request_len - len, &test_application_data);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, bacapp_same_value(&application_data[1],
                          &test_application_data));
                  len += test_len;
                  ct_test(pTest, decode_is_closing_tag_number(&service_request[len], 4));
                  len++;
                  /* see if there is another property */
                  /* this time we should fail */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, test_len == -1);
                  /* see if it is the end of this object */
                  test_len =
                      rpm_ack_decode_object_end(&service_request[len],
                      service_request_len - len);
                  ct_test(pTest, test_len == 1);
                  len += test_len;
                  /* try to decode another object id */
                  test_len =
                      rpm_ack_decode_object_id(&service_request[len],
                      service_request_len - len, &object_type, &object_instance);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, object_type == OBJECT_ANALOG_INPUT);
                  ct_test(pTest, object_instance == 33);
                  len += test_len;
                  /* decode the object property portion of the service request only */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, object_property == PROP_PRESENT_VALUE);
                  ct_test(pTest, array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  /* what is the result value? */
                  ct_test(pTest, decode_is_opening_tag_number(&service_request[len], 4));
                  len++;
                  /* decode the object property portion of the service request */
                  test_len =
                      bacapp_decode_application_data(&service_request[len],
                      service_request_len - len, &test_application_data);
                  ct_test(pTest, test_len > 0);
                  ct_test(pTest, bacapp_same_value(&application_data[2],
                          &test_application_data));
                  len += test_len;
                  ct_test(pTest, decode_is_closing_tag_number(&service_request[len], 4));
                  len++;
                  /* see if there is another property */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, test_len != -1);
                  ct_test(pTest, object_property == PROP_DEADBAND);
                  ct_test(pTest, array_index == BACNET_ARRAY_ALL);
                  len += test_len;
                  /* what is the result value? */
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 16  

                  ct_test(pTest, decode_is_opening_tag_number(&service_request[len], 5));
                  len++;
                  /* it was an error reply */
                  test_len =
                      bacerror_decode_error_class_and_code(&service_request[len],
                      service_request_len - len, &error_class, &error_code);
                  ct_test(pTest, test_len != 0);
                  ct_test(pTest, error_class == ERROR_CLASS_PROPERTY);
                  ct_test(pTest, error_code == ERROR_CODE_UNKNOWN_PROPERTY);
                  len += test_len;
                  ct_test(pTest, decode_is_closing_tag_number(&service_request[len], 5));
                  len++;
                  /* is there another property? */
                  test_len =
                      rpm_ack_decode_object_property(&service_request[len],
                      service_request_len - len, &object_property, &array_index);
                  ct_test(pTest, test_len == -1);
                  /* got an error -1, is it the end of this object? */
                  test_len =
                      rpm_ack_decode_object_end(&service_request[len],
                      service_request_len - len);
                  ct_test(pTest, test_len == 1);
                  len += test_len;
                  /* check for another object */
                  test_len =
                      rpm_ack_decode_object_id(&service_request[len],
                      service_request_len - len, &object_type, &object_instance);
                  ct_test(pTest, test_len == 0);
                  ct_test(pTest, len == service_request_len);
              }
              
              #ifdef TEST_READ_PROPERTY_MULTIPLE
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACnet ReadPropertyMultiple", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testReadPropertyMultiple);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testReadPropertyMultipleAck);
                  assert(rc);
              
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_READ_PROPERTY_MULTIPLE */
              
              #endif /* TEST */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4716    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     186
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.06   RPM                                                                   01/29/2013 10:19:51 PAGE 17  

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
