C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE HTTPD
OBJECT MODULE PLACED IN .\httpd.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\http\httpd.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) IN
                    -CDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\
                    -SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buf
                    -fer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\S
                    -rc\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\s
                    -rc\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\httpd.lst) OB
                    -JECT(.\httpd.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: httpd.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: httpd.c,v $
  18           * Revision 1.0  2006/05/30 06:39:38  Francis
  19           * Revision 3.0.0  2010/09/29 09:51:00  Smile
  20           * no message
  21           *
  22           *=============================================================================
  23           */
  24          
  25          /* INCLUDE FILE DECLARATIONS */
  26          #include "reg80390.h"
  27          #include "stoe.h"
  28          #include "main.h"
  29          #include "mstimer.h"
  30          #include "httpd.h"
  31          #include "filesys.h"
  32          #include "adapter.h"
  33          #include "gs2e.h"
  34          #include "gconfig.h"
  35          #include "tcpip.h"
  36          #include "delay.h"
  37          #include "uart.h"
  38          #include "printd.h"
  39          #include <string.h>
  40          #include "ax11000.h"
  41          #include "ctype.h"
  42          #include "lcd.h"
  43          
  44          
  45          #if (INCLUDE_EVENT_DETECT)
  46          #include "gevent.h"
  47          #endif
  48          /* NAMING CONSTANT DECLARATIONS */
  49          
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 2   

  50          /* GLOBAL VARIABLES DECLARATIONS */
  51          entry entries[20];
  52          U8_T num_parms;
  53          /* LOCAL VARIABLES DECLARATIONS */
  54          static HTTP_SERVER_CONN XDATA HTTP_Connects[MAX_HTTP_CONNECT];
  55          static U8_T CODE HtmlHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\n
             -Content-type: text/html\r\n\r\n"};
  56          static U8_T XDATA HtmlHeaderLen = (sizeof(HtmlHeader) - 1);
  57          static U8_T CODE CSSHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\nC
             -ontent-type: text/css\r\n\r\n"};
  58          static U8_T XDATA CSSHeaderLen = (sizeof(CSSHeader) - 1);
  59          static U8_T CODE JsHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\nCo
             -ntent-type: application/javascript\r\n\r\n"};
  60          static U8_T XDATA JsHeaderLen = (sizeof(JsHeader) - 1);
  61          static U8_T XDATA ImageHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r
             -\nContent-Length: xxxxx\r\nContent-type: image/jpeg\r\n\r\n"};
  62          static U8_T XDATA ImageHeaderLen = (sizeof(ImageHeader) - 1);
  63          static U8_T XDATA ImageByteCountOffset = 82;
  64          HTTP_TEMP_BUF XDATA HTTPtemp;
  65          
  66          /* LOCAL SUBPROGRAM DECLARATIONS */
  67          
  68          static U8_T HTTP_NewConfig(void);
  69          static void HTTP_DivideHtmlFile(HTTP_SERVER_CONN XDATA* pHttpConn, U8_T id);
  70          static U8_T HTTP_CheckPassWord(HTTP_SERVER_CONN XDATA*  pHttpConn);
  71          static void HTTP_LoadSetting(void);
  72          static U8_T HTTP_CheckNewPassword(void);
  73          static U8_T HTTP_CheckNewUsername(void);
  74          /*
  75           * ----------------------------------------------------------------------------
  76           * Function Name: HTTP_Task()
  77           * Purpose: Main function
  78           * Params:
  79           * Returns:
  80           * Note:
  81           * ----------------------------------------------------------------------------
  82           */
  83          void HTTP_Task(void)
  84          {
  85   1      
  86   1      } /* End of HTTP_Task() */
  87          
  88          /*
  89           * ----------------------------------------------------------------------------
  90           * Function Name: HTTP_Init()
  91           * Purpose: Initialize HTTP server. 
  92           * Params:
  93           * Returns:
  94           * Note:
  95           * ----------------------------------------------------------------------------
  96           */
  97          void HTTP_Init(void)
  98          {
  99   1              U8_T    i;
 100   1      
 101   1              for (i = 0; i < MAX_HTTP_CONNECT; i++)
 102   1              {
 103   2                      HTTP_Connects[i].State = HTTP_STATE_FREE;
 104   2                      HTTP_Connects[i].FileId = 0xff;
 105   2                      HTTP_Connects[i].ContinueFlag = 0;
 106   2              }
 107   1      
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 3   

 108   1              HTTPtemp.InterFaceID = TCPIP_Bind(HTTP_NewConn, HTTP_Event, HTTP_Receive);
 109   1              TCPIP_TcpListen(HTTP_SERVER_PORT, HTTPtemp.InterFaceID);
 110   1      
 111   1              memset((U8_T*)&HTTPtemp, 0 , sizeof(HTTPtemp));
 112   1              FSYS_Init();
 113   1              HTTP_LoadSetting();
 114   1              if (GCONFIG_GetNetwork() & GCONFIG_NETWORK_ACC_IP_ENABLE)
 115   1                      HTTPtemp.AccessibleIP_EnableFlag = 1;
 116   1      //      printd("HTTP init ok.\n\r");
 117   1      
 118   1      } /* End of HTTP_Init() */
 119           
 120          /*
 121           * ----------------------------------------------------------------------------
 122           * Function Name: HTTP_NewConn()
 123           * Purpose: 
 124           * Params:
 125           * Returns:
 126           * Note:
 127           * ----------------------------------------------------------------------------
 128           */
 129          U8_T HTTP_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 130          {
 131   1              U8_T    i;
 132   1      
 133   1              for (i = 0; i < MAX_HTTP_CONNECT; i++)
 134   1              {
 135   2                      if (HTTP_Connects[i].State == HTTP_STATE_FREE)
 136   2                      {
 137   3                              HTTP_Connects[i].State = HTTP_STATE_ACTIVE;
 138   3                              HTTP_Connects[i].Timer = (U16_T)SWTIMER_Tick();
 139   3                              HTTP_Connects[i].Ip = *pip;
 140   3                              HTTP_Connects[i].Port = remotePort;
 141   3                              HTTP_Connects[i].TcpSocket = socket;
 142   3      
 143   3                              return i;
 144   3                      }
 145   2              }
 146   1              return TCPIP_NO_NEW_CONN;
 147   1      } /* End of HTTP_NewConn() */
 148          
 149          /*
 150           * ----------------------------------------------------------------------------
 151           * Function Name: HTTP_Event()
 152           * Purpose: 
 153           * Params:
 154           * Returns:
 155           * Note:
 156           * ----------------------------------------------------------------------------
 157           */
 158          void HTTP_Event(U8_T id, U8_T event)
 159          {
 160   1              U8_T    fileId = HTTP_Connects[id].FileId;
 161   1              
 162   1              if (event < TCPIP_CONNECT_XMIT_COMPLETE)
 163   1              {
 164   2                      if (event == TCPIP_CONNECT_CANCEL)
 165   2                      {
 166   3                              if(0)
 167   3                              {
 168   4                              }
 169   3      /*====== for msgrestore.htm web page, start ====== */   //Add for redirection web page
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 4   

 170   3                              else if (fileId == FILE_MSGRESTORE)
 171   3                              {
 172   4      //                              printd("Restore and Reboot!!\n\r");
 173   4      //                              GCONFIG_ReadDefaultConfigData();
 174   4      //                              GCONFIG_WriteConfigData();
 175   4      //                              DELAY_Ms(500);
 176   4      //                              AX11000_SoftReboot();
 177   4      
 178   4                                      lcdreset();
 179   4                                      Lcd_Initial();
 180   4                                      Display_reboot();
 181   4                                      AX11000_SoftReboot();
 182   4      
 183   4                                      
 184   4                              }
 185   3      /*====== for msgrestore.htm web page, end ====== */     
 186   3      /*====== for msgupg.htm web page, start ====== */               
 187   3                              else if (fileId == FILE_MSGUPG)
 188   3                              {
 189   4      //                              printd("Upgrade\n\r");
 190   4      //                              GCONFIG_EnableFirmwareUpgrade();
 191   4      //                              GCONFIG_WriteConfigData();              
 192   4      //                              AX11000_SoftReboot();
 193   4      
 194   4                                      lcdreset();
 195   4                                      Lcd_Initial();
 196   4                                      Display_reboot();
 197   4                                      AX11000_SoftReboot();
 198   4      
 199   4      
 200   4                              }
 201   3      /*====== for msgupg.htm web page, end ====== */                         
 202   3      /*====== for msgreboot.htm web page, start ====== */    
 203   3                              else if (fileId == FILE_MSGREBOOT)                      
 204   3                              {
 205   4                              //      printd("Device Reboot!!\n\r");                  
 206   4                              //      DELAY_Ms(500);
 207   4                                      lcdreset();
 208   4                                      Lcd_Initial();
 209   4                                      Display_reboot();
 210   4                                      AX11000_SoftReboot();
 211   4                              }
 212   3      /*====== for msgreboot.htm web page, end ====== */                              
 213   3      /*====== for msgaccerr.htm web page, start ====== */
 214   3                              else if (fileId == FILE_MSGACCERR)                      
 215   3                              {
 216   4                                      printd ("Unaccessible error !!\n\r");
 217   4                              }                       
 218   3      /*====== for msgaccerr.htm web page, end ====== */
 219   3                      HTTP_Connects[id].State = event;
 220   3                      }
 221   2              }
 222   1              else if (event == TCPIP_CONNECT_XMIT_COMPLETE)
 223   1              {
 224   2                      U8_T*                   pSour;
 225   2                      static U16_T    dataLen;
 226   2      
 227   2                      if (HTTP_Connects[id].State == HTTP_STATE_SEND_HEADER)
 228   2                      {
 229   3                              {
 230   4                                      if (FSYS_Manage[fileId].FType & FILE_TYPE_BIN)
 231   4                                      {
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 5   

 232   5                                              HTTP_Connects[id].Divide.Fragment = 0;
 233   5                                      }
 234   4                                      else
 235   4                                      {
 236   5                                              HTTP_DivideHtmlFile(&HTTP_Connects[id], fileId);
 237   5                                      }
 238   4      
 239   4                                      pSour = FSYS_Manage[fileId].PBuf;
 240   4                                      dataLen = FSYS_Manage[fileId].FileSize;
 241   4      
 242   4                                      if (HTTP_Connects[id].Divide.Fragment == 0)
 243   4                                      {
 244   5                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_FINAL);
 245   5                                              HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 246   5                                      }
 247   4                                      else
 248   4                                      {
 249   5                                              HTTP_Connects[id].State = HTTP_STATE_SEND_DATA;
 250   5                                              HTTP_Connects[id].Divide.PData = pSour;
 251   5                                              HTTP_Connects[id].Divide.LeftLen = dataLen;
 252   5                                              HTTP_Connects[id].Divide.CurIndex = 0;
 253   5                                              HTTP_Connects[id].Divide.PadFlag = 0;
 254   5                                              goto SENDHTML;
 255   5                                      }
 256   4                              }
 257   3                      }
 258   2                      else if (HTTP_Connects[id].State == HTTP_STATE_SEND_DATA)
 259   2                      {
 260   3      SENDHTML:
 261   3                              {
 262   4                                      BUF_TEXT XDATA          *pText;
 263   4      //                              BUF_TAG XDATA*          pTag;
 264   4                                      U8_T*                           pSour = HTTP_Connects[id].Divide.PData;
 265   4                                      static U8_T XDATA       pTrue[] = " checked";
 266   4                                      static U8_T XDATA       pSele[] = " selected";                          
 267   4                                      static U16_T            leftLen;
 268   4                                      static U8_T                     index;
 269   4      
 270   4                                      leftLen = HTTP_Connects[id].Divide.LeftLen;
 271   4                                      index = HTTP_Connects[id].Divide.CurIndex;
 272   4                                      
 273   4                                      if (!HTTP_Connects[id].Divide.PadFlag)
 274   4                                      {
 275   5                                              if (index == 0)
 276   5                                                      dataLen = HTTP_Connects[id].Divide.Offset[index];
 277   5                                              else if (index == HTTP_Connects[id].Divide.Fragment)
 278   5                                                      dataLen = leftLen;
 279   5                                              else
 280   5                                                      dataLen = HTTP_Connects[id].Divide.Offset[index] - 
 281   5                                                              HTTP_Connects[id].Divide.Offset[index - 1];
 282   5      
 283   5                                              if (index == HTTP_Connects[id].Divide.Fragment)
 284   5                                              {
 285   6                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_FINAL);
 286   6                                                      HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 287   6                                              }
 288   5                                              else
 289   5                                              {
 290   6                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_NOT_FINAL);
 291   6                                                      HTTP_Connects[id].Divide.PData += dataLen;
 292   6                                                      HTTP_Connects[id].Divide.LeftLen -= dataLen;
 293   6                                                      HTTP_Connects[id].Divide.PadFlag = 1;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 6   

 294   6                                              }
 295   5                                      }
 296   4                                      else
 297   4                                      {
 298   5                                              if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_RADIO)
 299   5                                              {
 300   6                                                      if (HTTP_Connects[id].Divide.SetFlag[index] == 1)
 301   6                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pTrue, 8, TCPIP_SEND_NOT_FINAL);
 302   6                                                      else if (HTTP_Connects[id].Divide.SetFlag[index] == 2)
 303   6                                                      {
 304   7                                                              if (*pSour == ' ')
 305   7                                                              {
 306   8                                                                      HTTP_Connects[id].Divide.PData += 8;
 307   8                                                                      HTTP_Connects[id].Divide.Offset[index] += 8;
 308   8                                                                      HTTP_Connects[id].Divide.LeftLen -= 8;
 309   8                                                              }
 310   7                                                              else
 311   7                                                              {
 312   8                                                                      HTTP_Connects[id].Divide.PData += 7;
 313   8                                                                      HTTP_Connects[id].Divide.Offset[index] += 7;
 314   8                                                                      HTTP_Connects[id].Divide.LeftLen -= 7;
 315   8                                                              }
 316   7                                                              HTTP_Connects[id].Divide.PadFlag = 0;
 317   7                                                              HTTP_Connects[id].Divide.CurIndex++;
 318   7                                                              goto SENDHTML;
 319   7                                                      }
 320   6                                              }
 321   5                                              else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_TEXT)
 322   5                                              {
 323   6                                                              pText = POST_Record[HTTP_Connects[id].Divide.RecordIndex[index]].PValue;
 324   6                                                              leftLen -= pText->DefaultLength;
 325   6                                                              if (!leftLen)
 326   6                                                              {
 327   7                                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pText->CurrValue, pText->CurrLength, TCPIP_SEND_FINAL);
 328   7                                                                      HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 329   7                                                                      return;
 330   7                                                              }
 331   6      
 332   6                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pText->CurrValue, pText->CurrLength, TCPIP_SEND_NOT_FINA
             -L);
 333   6                                                              HTTP_Connects[id].Divide.PData += pText->DefaultLength;
 334   6                                                              HTTP_Connects[id].Divide.Offset[index] += pText->DefaultLength;
 335   6                                                              HTTP_Connects[id].Divide.LeftLen =leftLen;
 336   6                                              }
 337   5      #if(MAX_POST_BUF_TAG)                                   
                                                      else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_TAG)
                                                      {
                                                              pTag = POST_Record[HTTP_Connects[id].Divide.RecordIndex[index]].PValue;
                                                              leftLen -= pTag->DefaultLength;
                                                              if(pTag->CurrLength)
                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pTag->CurrValue, pTag->CurrLength, TCPIP_SEND_NOT_FINAL);
                                                              HTTP_Connects[id].Divide.PData += pTag->DefaultLength;
                                                              HTTP_Connects[id].Divide.Offset[index] += pTag->DefaultLength;
                                                              HTTP_Connects[id].Divide.LeftLen =leftLen;
                                                              if(!pTag->CurrLength)
                                                              {
                                                                      HTTP_Connects[id].Divide.PadFlag = 0;
                                                                      HTTP_Connects[id].Divide.CurIndex++;
                                                                      goto SENDHTML;
                                                              }
                                                      } 
              #endif                                                                          
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 7   

 355   5                                              else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_SELECT)
 356   5                                              {
 357   6                                                      if (HTTP_Connects[id].Divide.SetFlag[index] == 1)
 358   6                                                      {
 359   7                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSele, 9, TCPIP_SEND_NOT_FINAL);
 360   7                                                      }
 361   6                                                      else if (HTTP_Connects[id].Divide.SetFlag[index] == 2)
 362   6                                                      {
 363   7                                                              HTTP_Connects[id].Divide.PData += 9;
 364   7                                                              HTTP_Connects[id].Divide.Offset[index] += 9;
 365   7                                                              HTTP_Connects[id].Divide.LeftLen -= 9;
 366   7      
 367   7                                                              HTTP_Connects[id].Divide.PadFlag = 0;
 368   7                                                              HTTP_Connects[id].Divide.CurIndex++;
 369   7                                                              goto SENDHTML;
 370   7                                                      }
 371   6                                              }       
 372   5                                              HTTP_Connects[id].Divide.PadFlag = 0;
 373   5                                              HTTP_Connects[id].Divide.CurIndex++;
 374   5                                      }
 375   4                              }
 376   3                      }
 377   2                      else if (HTTP_Connects[id].State == HTTP_STATE_SEND_FINAL)
 378   2                      {
 379   3                              // HTTP_Connects[id].State = HTTP_STATE_FREE;
 380   3                      }
 381   2              }
 382   1      } /* End of HTTP_Event() */
 383          
 384          
 385          /*
 386           * ----------------------------------------------------------------------------
 387           * Function Name: StringCompare()
 388           * Purpose: 
 389           * Params:
 390           * Returns:
 391           * Note:
 392           * ----------------------------------------------------------------------------
 393           */
 394          U8_T StringCompare(U8_T XDATA* pData, U8_T XDATA* pStr, U8_T len)
 395          {
 396   1              U8_T    index;
 397   1      
 398   1              for (index = 0; index < len; index++)
 399   1              {
 400   2                      if (*pData++ != *pStr++) break;
 401   2              }
 402   1              if (index == len) return 1;
 403   1              
 404   1              return 0;
 405   1      } /* End of StringCompare() */
 406          
 407          /*
 408           * ----------------------------------------------------------------------------
 409           * Function Name: GHTTP_GetFile()
 410           * Purpose: 
 411           * Params:
 412           * Returns:
 413           * Note:
 414           * ----------------------------------------------------------------------------
 415           */
 416          U8_T GHTTP_GetFile(U8_T XDATA** pData, U8_T XDATA** pFName, U8_T XDATA** pFNameExt, U16_T* length)
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 8   

 417          {
 418   1              U8_T    c, find = 0;
 419   1              U8_T    parse_state = 0;
 420   1      
 421   1              c = **pData;
 422   1              while ((c != ' ') && (c != '\0') && (c != '\r') && (c != '\n'))
 423   1              {
 424   2                      switch(parse_state)
 425   2                      {
 426   3                      case 0:
 427   3                              if (c == '/' || c == '\\')
 428   3                              {
 429   4                                      parse_state = 1;
 430   4                                      *pFName = *pData + 1;
 431   4                              }
 432   3                              break;
 433   3                      case 1:
 434   3                              if (c == '?')
 435   3                              {
 436   4                                      find = 2;
 437   4                                      return find;
 438   4                              }
 439   3                              else if (c == '&')
 440   3                              {
 441   4                                      **pData = '\0';
 442   4                                      return find;
 443   4                              }
 444   3                              else
 445   3                              {
 446   4                                      if ((c == '+') || (c == '=')) return 0;
 447   4                                      /* a path, change it to '_' */
 448   4                                      else if ((c == '/') || (c == '\\')) **pData = '_';
 449   4                                      /* Remember where file extension starts. */
 450   4                                      else if (c == '.')
 451   4                                      {
 452   5                                              *pFNameExt = *pData + 1;
 453   5                                              find = 1;
 454   5                                      }
 455   4                              }
 456   3                              break;
 457   3                      }
 458   2                      (*pData)++;
 459   2                      (*length)--;
 460   2                      c = **pData;
 461   2              }
 462   1      
 463   1              return find;
 464   1      } /* End of GHTTP_GetFile() */
 465          
 466          /*
 467           * ----------------------------------------------------------------------------
 468           * Function Name: HTTP_LoadSetting()
 469           * Purpose:
 470           * Params:
 471           * Returns:
 472           * Note:
 473           * ----------------------------------------------------------------------------
 474           */
 475          void HTTP_LoadSetting(void)
 476          {
 477   1      //      U32_T                           temp32;
 478   1              U16_T                           temp16;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 9   

 479   1              BUF_TEXT XDATA          *pText;
 480   1              BUF_SELECT XDATA        *pSelect;
 481   1              
 482   1              // Load IP address
 483   1              pText = POST_Record[RECORD_TEXT_static_ip].PValue;
 484   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetServerStaticIP(), pText->CurrValue);
 485   1              pText->CurrValue[pText->CurrLength ++] = '"';
 486   1              
 487   1              // Load subnet mask
 488   1              pText = POST_Record[RECORD_TEXT_mask].PValue;
 489   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetNetmask(), pText->CurrValue);
 490   1              pText->CurrValue[pText->CurrLength ++] = '"';
 491   1                      
 492   1              // Load gateway
 493   1              pText = POST_Record[RECORD_TEXT_gateway_ip].PValue;
 494   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetGateway(), pText->CurrValue);
 495   1              pText->CurrValue[pText->CurrLength ++] = '"';
 496   1      
 497   1      //      // Load DNS
 498   1      //      pText = POST_Record[RECORD_TEXT_dns_ip].PValue;
 499   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetDNS(), pText->CurrValue);
 500   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 501   1      
 502   1      //      // Load server listen port
 503   1      //      pText = POST_Record[RECORD_TEXT_s_lstport].PValue;
 504   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetServerDataPktListenPort(), pText->CurrValue);
 505   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 506   1      
 507   1      //      // Load transmit timer
 508   1      //      pText = POST_Record[RECORD_TEXT_txtimer].PValue;
 509   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetEthernetTxTimer(), pText->CurrValue);
 510   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 511   1                      
 512   1      //      // Load destination port
 513   1      //      pText = POST_Record[RECORD_TEXT_c_desport].PValue;
 514   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetClientDestPort(), pText->CurrValue);
 515   1      //      pText->CurrValue[pText->CurrLength ++] = '"';   
 516   1      
 517   1              // Load DHCP/Connection type/Connection mode/Accessiable control
 518   1              temp16 = GCONFIG_GetNetwork();
 519   1              
 520   1              pSelect = POST_Record[RECORD_SELECT_dhcp].PValue;               //Load DHCP control bit.
 521   1              pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_DHCP_ENABLE) ? 1 : 0;//+1 for web display
 522   1              
 523   1      //      pSelect = POST_Record[RECORD_SELECT_conntype].PValue;   //Load Connection type option.
 524   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_PROTO_TCP) ? 0 : 1;     
 525   1                      
 526   1      //      pSelect = POST_Record[RECORD_SELECT_cs_mode].PValue;    //Load client/Server mode option.
 527   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_CLIENT) ? 1 : 0;
 528   1      
 529   1      //      pSelect = POST_Record[RECORD_SELECT_acc_ipen].PValue;   //Load accessible IP control bit.
 530   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_ACC_IP_ENABLE) ? 1 : 0; 
 531   1      //              
 532   1      //      // Load serial setting
 533   1      //      temp16 = GCONFIG_GetSerialPort();
 534   1      //
 535   1      //      pSelect = POST_Record[RECORD_SELECT_dbr].PValue;
 536   1      //      pSelect->CurrentSet = ((temp16 & 0xF800) >> 11);
 537   1      //
 538   1      //      pSelect = POST_Record[RECORD_SELECT_data].PValue;
 539   1      //      pSelect->CurrentSet = ((temp16 & 0x0700) >> 8);
 540   1      //
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 10  

 541   1      //      pSelect = POST_Record[RECORD_SELECT_parity].PValue;
 542   1      //      pSelect->CurrentSet = ((temp16 & 0x00E0) >> 5);
 543   1      //
 544   1      //      pSelect = POST_Record[RECORD_SELECT_stop].PValue;
 545   1      //      pSelect->CurrentSet = ((temp16 & 0x0003));
 546   1      //
 547   1      //      pSelect = POST_Record[RECORD_SELECT_flow].PValue;
 548   1      //      pSelect->CurrentSet = ((temp16 & 0x0001C) >> 2);
 549   1      //
 550   1      //      // Load SMTP Domain name
 551   1      //      pText = POST_Record[RECORD_TEXT_email_addr].PValue;             
 552   1      //      pText->CurrLength = GCONFIG_GetSMTPDomainName(pText->CurrValue);
 553   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 554   1      //
 555   1      //      // Load SMTP From addr
 556   1      //      pText = POST_Record[RECORD_TEXT_email_from].PValue;
 557   1      //      pText->CurrLength = GCONFIG_GetSMTPFrom(pText->CurrValue);
 558   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 559   1      //              
 560   1      //      // Load SMTP To1 addr
 561   1      //      pText = POST_Record[RECORD_TEXT_email_to1].PValue;
 562   1      //      pText->CurrLength = GCONFIG_GetSMTPTo1(pText->CurrValue);
 563   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 564   1      //      
 565   1      //      // Load SMTP To2 addr
 566   1      //      pText = POST_Record[RECORD_TEXT_email_to2].PValue;
 567   1      //      pText->CurrLength = GCONFIG_GetSMTPTo2(pText->CurrValue);
 568   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 569   1      //      
 570   1      //      // Load SMTP To3 addr
 571   1      //      pText = POST_Record[RECORD_TEXT_email_to3].PValue;
 572   1      //      pText->CurrLength = GCONFIG_GetSMTPTo3(pText->CurrValue);
 573   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 574   1      //
 575   1      ////    // Load Destination host name
 576   1      ////    pText = POST_Record[RECORD_TEXT_c_deshn].PValue;                
 577   1      ////    pText->CurrLength = GCONFIG_GetDestHostName(pText->CurrValue);
 578   1      ////    pText->CurrValue[pText->CurrLength ++] = '"';   
 579   1      //      
 580   1      //      // Load FIle Name
 581   1      //      pText = POST_Record[RECORD_TEXT_file_name].PValue;
 582   1      //      GCONFIG_GetFilename(pText->CurrValue, 128);
 583   1      //      pText->CurrLength = strlen(pText->CurrValue);
 584   1      //      pText->CurrValue[pText->CurrLength ++] = '"';   
 585   1      //      
 586   1      //      // Load Auto Warning enable bits
 587   1      //      temp16 = GCONFIG_GetAutoWarning();
 588   1      //      
 589   1      //      pSelect = POST_Record[RECORD_SELECT_coldstart].PValue;  //Load cold start enable bit
 590   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_COLDSTART) ? 1 : 0;
 591   1      //                                      
 592   1      //      pSelect = POST_Record[RECORD_SELECT_authfail].PValue;   //Load authentication fail enable bit
 593   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_AUTH_FAIL) ? 1 : 0;
 594   1      //              
 595   1      //      pSelect = POST_Record[RECORD_SELECT_ipchg].PValue;              //Load IP changed enable bit
 596   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_IP_CHANGED) ? 1 : 0;
 597   1      //              
 598   1      //      pSelect = POST_Record[RECORD_SELECT_pswchg].PValue;             //Load password changed enable bit
 599   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_PSW_CHANGED) ? 1 : 0;
 600   1      //              
 601   1      //      // Accessible IP address 0~3
 602   1      //      pText = POST_Record[RECORD_TEXT_acc_ip1].PValue;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 11  

 603   1      //      GCONFIG_GetAccessibleIP(0,&temp32);
 604   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 605   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 606   1      //              
 607   1      //      pText = POST_Record[RECORD_TEXT_acc_ip2].PValue;
 608   1      //      GCONFIG_GetAccessibleIP(1,&temp32);
 609   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 610   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 611   1      //              
 612   1      //      pText = POST_Record[RECORD_TEXT_acc_ip3].PValue;
 613   1      //      GCONFIG_GetAccessibleIP(2,&temp32);
 614   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 615   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 616   1      //              
 617   1      //      pText = POST_Record[RECORD_TEXT_acc_ip4].PValue;
 618   1      //      GCONFIG_GetAccessibleIP(3,&temp32);
 619   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 620   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 621   1      //      
 622   1      //      // Load rs485 control bits
 623   1      //      pSelect = POST_Record[RECORD_SELECT_rs485].PValue;
 624   1      //      pSelect->CurrentSet = GCONFIG_GetRs485Mode();
 625   1      //
 626   1      //      // Load Tftp Server IP
 627   1      //      pText = POST_Record[RECORD_TEXT_tftps_ip].PValue;
 628   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetTftpServerIp(), pText->CurrValue);
 629   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 630   1                                              
 631   1      } /* End of HTTP_LoadSetting() */
 632          
 633          
 634          /*
 635           * ----------------------------------------------------------------------------
 636           * Function Name: GHTTP_UserPost()
 637           * Purpose: 
 638           * Params:
 639           * Returns:
 640           * Note:
 641           * ----------------------------------------------------------------------------
 642           */
 643          U8_T http_UserPost(U8_T XDATA* pData, U16_T length, U8_T fileId, U8_T continueFlag)
 644          {
 645   1              BUF_SUBMIT XDATA        *pSubmit;
 646   1              BUF_TEXT XDATA          *pText;
 647   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA*        pRadio;
              #endif
 650   1      #if (MAX_POST_BUF_SELECT)
 651   1              BUF_SELECT XDATA*       pSelect;
 652   1      #endif  
 653   1              U16_T                           i;
 654   1              U8_T                            x, y, a, nameLen;
 655   1              U8_T                            status = 0, final = 0;
 656   1      
 657   1              U8_T index;
 658   1              U8_T tempchar;
 659   1              
 660   1              U8_T IPtemp[4]; 
 661   1      //      U16_T Porttemp;
 662   1              if (continueFlag)
 663   1                      goto MAPRECORD;
 664   1      
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 12  

 665   1              if (length < 150)
 666   1              {
 667   2                      return HTTP_POST_FAILURE;
 668   2              }
 669   1      
 670   1              HTTPtemp.PostCnt = 0;
 671   1              if (*pData == '?')
 672   1              {
 673   2                      length -= 1;
 674   2                      pData += 1;
 675   2                      goto MAPRECORD;
 676   2              }
 677   1      /*
 678   1              if (length > 170) // parse the last 170 bytes
 679   1              {
 680   1                      length -= 170;
 681   1                      pData += length;
 682   1                      length = 170;           
 683   1              }
 684   1      */
 685   1              i = 0;
 686   1              while(i < length)
 687   1              {
 688   2                      while (1)
 689   2                      {
 690   3                              if ((pData[0]=='\r')&&(pData[1]=='\n')&&(pData[2]=='\r')&&(pData[3]=='\n'))//Find the two empty line.
 691   3                              {
 692   4                                      pData += 4;
 693   4                                      i += 4;
 694   4                                      if (i == length) return HTTP_POST_CONTINUE;
 695   4                                              
 696   4                                      break;
 697   4                              }
 698   3                              else
 699   3                              {
 700   4                                      pData++;
 701   4                                      i++;
 702   4                                      if ((i + 3) >= length) return HTTP_POST_FAILURE;
 703   4                              }
 704   3                      }
 705   2      MAPRECORD:
 706   2                      for (x = 0; x < MAX_POST_RECORDS; x++)
 707   2                      {
 708   3                              if (POST_Record[x].Occupy == 1)
 709   3                              {
 710   4                                      // check file id
 711   4                                      if (fileId != POST_Record[x].FileIndex)
 712   4                                      {
 713   5                                              if (POST_Record[x].FileIndex != 0xff)
 714   5                                              {
 715   6                                                      continue;
 716   6                                              }
 717   5                                      }
 718   4      
 719   4                                      for (y = 0; y < POST_Record[x].NameLen; y++)
 720   4                                      {
 721   5                                              if (POST_Record[x].Name[y] != pData[y]) 
 722   5                                                      break;
 723   5                                      }
 724   4                                      if (y == POST_Record[x].NameLen)
 725   4                                      {
 726   5                                              if (pData[y] == '=')
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 13  

 727   5                                              {
 728   6                                                      nameLen = (y + 1);
 729   6                                                      pData += nameLen;
 730   6                                                      i += nameLen;
 731   6      
 732   6                                                      switch (POST_Record[x].PostType)
 733   6                                                      {
 734   7                                                      case POST_TYPE_SUBMIT:
 735   7                                                              pSubmit = POST_Record[x].PValue;
 736   7                                                              for (a = 0; a < pSubmit->DefaultVlaueLen; a++)
 737   7                                                              {
 738   8                                                                      if (pSubmit->Value[a] != pData[a]) 
 739   8                                                                              break;
 740   8                                                              }
 741   7                                                              if (a == pSubmit->DefaultVlaueLen)
 742   7                                                              {
 743   8                                                                      HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
 744   8                                                                      HTTPtemp.PostCnt ++;
 745   8      
 746   8                                                                      printd ("SUBMIT\n\r");
 747   8      
 748   8                                                                      if (pSubmit->IsApply)
 749   8                                                                      {
 750   9                                                                              return (status ? HTTP_POST_FAILURE : HTTP_POST_SUCCESS);
 751   9                                                                      }
 752   8                                                                      else
 753   8                                                                              return HTTP_POST_CANCEL;
 754   8                                                              }
 755   7                                                              else
 756   7                                                              {
 757   8                                                                      pData -= nameLen;
 758   8                                                                      i -= nameLen;
 759   8      
 760   8                                                                      goto MAPRECORD;
 761   8                                                              }
 762   7                                                              break;
 763   7                                                      case POST_TYPE_TEXT:
 764   7                                                              pText = POST_Record[x].PValue;                                          
 765   7                                                              memset(HTTPtemp.Buf[0], 0, sizeof(HTTPtemp.Buf[0]));
 766   7                                                      index=0;
 767   7                                                              for (a = 0; a < MAX_POST_VALUE_LEN + 3; a++)
 768   7                                                              {
 769   8                                                                      if (pData[a] == '&')
 770   8                                                                              break;
 771   8                                                                      else if (pData[a] == ' ')
 772   8                                                                      {
 773   9                                                                              final = 1;
 774   9                                                                              break;
 775   9                                                                      }
 776   8      
 777   8                                                                      HTTPtemp.Buf[0][index] = pData[a];
 778   8      
 779   8                                                                      if(pData[a] == '%')
 780   8                                                                      {       
 781   9                                                                       if(isdigit(pData[a+1]))
 782   9                                                                              tempchar = (pData[a+1] - '0') << 4;
 783   9                                                                       else
 784   9                                                                              tempchar = ((pData[a+1] - 'A') + 10) << 4;
 785   9                                
 786   9                                                                       if(isdigit(pData[a+2]))
 787   9                                                                              tempchar += (pData[a+2] - '0');
 788   9                                                                      else
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 14  

 789   9                                                                              tempchar += ((pData[a+2] - 'A') + 10);
 790   9      
 791   9                                                                  HTTPtemp.Buf[0][index] = tempchar;
 792   9                                                                      a+=2;                           
 793   9                                                              }
 794   8                                                                      index++;
 795   8                                                              }
 796   7      
 797   7                                                              if (pText == NULL)      // username or password
 798   7                                                              {
 799   8      //------------------- Add for chack username & password function start -------------------------------
 800   8                                                                      if (fileId == FILE_INDEX)//If posted page is Authentication, get the username and password from we
             -b page.
 801   8                                                                      {
 802   9                                                                              if (RECORD_TEXT_username == x)
 803   9                                                                              {
 804  10                                                                                      HTTPtemp.UserNameLen = strlen(HTTPtemp.Buf[0]);
 805  10                                                                                      strncpy(HTTPtemp.UserName, HTTPtemp.Buf[0], HTTPtemp.UserNameLen + 1);//Include '\0' char
 806  10                                                                              }
 807   9                                                                              else if (RECORD_TEXT_password == x)
 808   9                                                                              {
 809  10                                                                                      HTTPtemp.PassWordLen = strlen(HTTPtemp.Buf[0]);
 810  10                                                                                      strncpy(HTTPtemp.PassWord, HTTPtemp.Buf[0], HTTPtemp.PassWordLen + 1);                                                                  
 811  10                                                                              }
 812   9                                                                              else
 813   9                                                                              {
 814  10                                                                                      return HTTP_POST_FAILURE;
 815  10                                                                              }
 816   9      //------------------- Add for chack username & password function end -------------------------------
 817   9      //------------------- Add for set new username & password function start -------------------------------
 818   9                                                                      }                       
 819   8                                                                      else if (fileId == FILE_SECURITY)
 820   8                                                                      {
 821   9                                                                              if (RECORD_TEXT_old_psw == x) // original password
 822   9                                                                              {
 823  10                                                                                      HTTPtemp.OldPassWordLen = strlen(HTTPtemp.Buf[0]);
 824  10                                                                                      strncpy(HTTPtemp.OldPassWord, HTTPtemp.Buf[0], HTTPtemp.OldPassWordLen + 1);//Include '\0' char
 825  10                                                                              }
 826   9                                                                              else if (RECORD_TEXT_new_psw == x) // set new password
 827   9                                                                              {
 828  10                                                                                      HTTPtemp.NewPassWordLen = strlen(HTTPtemp.Buf[0]);
 829  10                                                                                      strncpy(HTTPtemp.NewPassWord, HTTPtemp.Buf[0], HTTPtemp.NewPassWordLen + 1);
 830  10                                                                              }
 831   9                                                                              else if (RECORD_TEXT_cfm_psw == x) // set confirm password
 832   9                                                                              {
 833  10                                                                                      HTTPtemp.CfmPassWordLen = strlen(HTTPtemp.Buf[0]);
 834  10                                                                                      strncpy(HTTPtemp.CfmPassWord, HTTPtemp.Buf[0], HTTPtemp.CfmPassWordLen + 1);
 835  10      
 836  10                                                                              }
 837   9                                                                              else if (RECORD_TEXT_new_usn == x) // set new username
 838   9                                                                              {
 839  10                                                                                      HTTPtemp.NewUserNameLen = strlen(HTTPtemp.Buf[0]);
 840  10                                                                                      strncpy(HTTPtemp.NewUserName, HTTPtemp.Buf[0], HTTPtemp.NewUserNameLen + 1);
 841  10                                                                              }
 842   9                                                                              else
 843   9                                                                              {
 844  10                                                                                      return HTTP_POST_FAILURE;
 845  10                                                                              }
 846   9                                                                      }
 847   8                                                                      else                                                                    
 848   8      //------------------- Add for set new username & password function end -------------------------------
 849   8                                                                      {
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 15  

 850   9                                                                              return HTTP_POST_FAILURE;
 851   9                                                                      }
 852   8                                                              }
 853   7                                                              else
 854   7                                                              {
 855   8                                                                              strncpy(pText->UserValue, HTTPtemp.Buf[0], strlen(HTTPtemp.Buf[0]) + 1);//copy post data to user 
             -value include '\0' character.
 856   8                                                                              pText->UserLength = strlen(HTTPtemp.Buf[0]);//set user length not include '\0' character.
 857   8      /*====== for nrmsetting.htm web page, start ====== */
 858   8      //                                                                      if ((x == RECORD_TEXT_static_ip) ||
 859   8      //                                                                              (x == RECORD_TEXT_tftps_ip) ||                                                                  
 860   8      //                                                                              (x == RECORD_TEXT_dns_ip))
 861   8      
 862   8                                                                              if ((x == RECORD_TEXT_static_ip) ||
 863   8                                                                                      (x == RECORD_TEXT_tftps_ip))                                                                    
 864   8                                                                                                                                                      {
 865   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 866   9                                                                                      if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 867   9                                                                                      if ((IPtemp[0] == 0) || (IPtemp[0] > 223) || (IPtemp[3] == 0) || (IPtemp[3] == 255)) return HTTP
             -_POST_FAILURE;
 868   9                                                                              }
 869   8                                                                              else if (x == RECORD_TEXT_mask)
 870   8                                                                              {
 871   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 872   9                                                                                      if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 873   9                                                                                      if (IPtemp[0] != 255) return HTTP_POST_FAILURE;
 874   9                                                                                      if (IPtemp[0] >= 128)
 875   9                                                                                      {
 876  10                                                                                              if (IPtemp[1] != 255) return HTTP_POST_FAILURE;
 877  10                                                                                      }
 878   9                                                                              }
 879   8                                                                              else if (x == RECORD_TEXT_gateway_ip)
 880   8                                                                              {
 881   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);                                                                       
 882   9                                                                                      if (pText->UserLength)
 883   9                                                                                      {
 884  10                                                                                              if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 885  10       //                                                                                     if ((IPtemp[3] == 0) || (IPtemp[3] == 255)) return HTTP_POST_FAILURE;
 886  10                                                                                      }
 887   9                                                                              }
 888   8      //                                                                 else if      ((x == RECORD_TEXT_s_lstport) ||
 889   8      //                                                                                       (x == RECORD_TEXT_c_desport))
 890   8      //                                                                      {
 891   8      //                                                                              Porttemp = HTTP_Str2Short(pText->UserValue, pText->UserLength);
 892   8      //                                                                              if (Porttemp < 1024) return HTTP_POST_FAILURE;
 893   8      //                                                                              
 894   8      //                                                                      }
 895   8      //                                                                      else if ((x == RECORD_TEXT_acc_ip1) ||
 896   8      //                                                                                       (x == RECORD_TEXT_acc_ip2) ||
 897   8      //                                                                                       (x == RECORD_TEXT_acc_ip3) ||
 898   8      //                                                                                       (x == RECORD_TEXT_acc_ip4))
 899   8      //                                                                      {
 900   8      //                                                                              *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 901   8      //                                                                              if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 902   8      ////                                                                            if ((IPtemp[3] == 255)) return HTTP_POST_FAILURE;                                                                       
 903   8      //                                                              }
 904   8      /*====== for nrmsetting.htm web page, end ====== */
 905   8                                                              }
 906   7                                                              if (strlen(HTTPtemp.Buf[0]) == MAX_POST_VALUE_LEN)
 907   7                                                              {
 908   8                                                                      if ((pData[a] != '&') && (pData[a] != ' '))
 909   8                                                                      {
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 16  

 910   9                                                                              printd ("TEXT_FALSE\n\r");
 911   9                                                                              status = 1;
 912   9                                                                              pData += a;
 913   9                                                                              i += a;
 914   9      
 915   9                                                                              while ((*pData != '&') && (*pData != 0xa) && (*pData != 0xd))
 916   9                                                                              {
 917  10                                                                                      pData++;
 918  10                                                                                      i++;
 919  10                                                                              }
 920   9      
 921   9                                                                              pData++;
 922   9                                                                              i++;
 923   9      
 924   9                                                                              goto MAPRECORD;
 925   9                                                                      }
 926   8                                                                      else if (pData[a] == ' ') final = 1;
 927   8                                                              }
 928   7                                                              printd ("POST_TEXT: %s\n\r", HTTPtemp.Buf[0]);
 929   7                                                              HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
 930   7                                                              HTTPtemp.PostCnt ++;
 931   7                                                              if (final == 1)
 932   7                                                              {
 933   8                                                                      return (status ? HTTP_POST_FAILURE : HTTP_POST_SUCCESS);                                                                        
 934   8                                                              }
 935   7                                                              pData += (a + 1);
 936   7                                                              i += (a + 1);
 937   7                                                              goto MAPRECORD;
 938   7                                                              break;
 939   7      #if (MAX_POST_BUF_RADIO)
                                                              case POST_TYPE_RADIO:
                                                                      pRadio = POST_Record[x].PValue;
                                                                      for (j = 0; j < pRadio->Count; j++)
                                                                      {
                                                                                      for (a = 0; a < pRadio->Length[j]; a++)
                                                                              {
                                                                                      if (pRadio->Value[j][a] != pData[a]) break;
                                                                              }
                                                                              if (a == pRadio->Length[j])
                                                                              {
                                                                                      pData += (a + 1);
                                                                                      i += (a + 1);
                                                                                      pRadio->UserSet = j;
                                                                                      HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
                                                                                      HTTPtemp.PostCnt ++;
              
                                                                                      printd ("Radio item : %bx\n\r", j);
              
                                                                                      goto MAPRECORD;
                                                                              }
                                                                      }
                                                                      return HTTP_POST_FAILURE;
                                                                      break;
              #endif
 964   7      #if (MAX_POST_BUF_SELECT)
 965   7                                                      case POST_TYPE_SELECT:
 966   7                                                              pSelect = POST_Record[x].PValue;
 967   7      
 968   7                                                              pSelect->UserSet = (*pData) - 0x30;
 969   7      
 970   7                                                              if (pSelect->UserSet >= pSelect->Count)
 971   7                                                                      return HTTP_POST_FAILURE;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 17  

 972   7      
 973   7                                                              pData++;
 974   7                                                              i++;
 975   7      
 976   7                                                              if (*pData != '&')
 977   7                                                              {
 978   8                                                                      /* support select item > 10 */
 979   8                                                                      if ((*pData >= '0') && (*pData <= '9'))
 980   8                                                                      {
 981   9                                                                              pSelect->UserSet *= 10;
 982   9                                                                              pSelect->UserSet += ((*pData) - 0x30);
 983   9                                                                              if (pSelect->UserSet >= pSelect->Count)
 984   9                                                                                      return HTTP_POST_FAILURE;
 985   9      
 986   9                                                                              pData++;
 987   9                                                                              i++;
 988   9                                                                      }
 989   8      
 990   8                                                                      if (*pData != '&')
 991   8                                                                      {
 992   9                                                                              while ((*pData != '&') && (*pData != 0xa) && (*pData != 0xd))
 993   9                                                                              {
 994  10                                                                                      pData++;
 995  10                                                                                      i++;
 996  10                                                                              }
 997   9      
 998   9                                                                              pData++;
 999   9                                                                              i++;
1000   9      
1001   9                                                                              goto MAPRECORD;
1002   9                                                                      }
1003   8                                                              }
1004   7      
1005   7                                                              pData++;
1006   7                                                              i++;
1007   7                                                              HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
1008   7                                                              HTTPtemp.PostCnt ++;
1009   7                                                              printd("POST_SELECT: %bu\n\r", pSelect->UserSet);
1010   7                                                              goto MAPRECORD;
1011   7                                                              break;
1012   7      #endif
1013   7                                                      default:
1014   7                                                              break;
1015   7                                                      }
1016   6                                              }
1017   5                                      }
1018   4                              }
1019   3                      }
1020   2              }                       
1021   1              return HTTP_POST_FAILURE;                                                                                                                                                               
1022   1      } /* End of GHTTP_UserPost() */
1023          
1024          /*
1025           * ----------------------------------------------------------------------------
1026           * Function Name: http_PostVal()
1027           * Purpose: 
1028           * Params:
1029           * Returns:
1030           * Note:
1031           * ----------------------------------------------------------------------------
1032           */
1033          U8_T http_PostVal(U8_T XDATA* pData, U16_T length,U8_T Continue_Flag )
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 18  

1034          {
1035   1        U8_T* pTemp;
1036   1        U8_T idx,index;
1037   1        U16_T temp;
1038   1        U8_T tempchar;
1039   1        
1040   1        num_parms=0;
1041   1        pData[length]=0x0;
1042   1      
1043   1        if(!Continue_Flag)
1044   1        {
1045   2              for(temp=0;temp<length;temp++)
1046   2              {
1047   3                      if((pData[temp]=='\r') && (pData[temp+1]=='\n') && (pData[temp+2]=='\r') && (pData[temp+3]=='\n')) break
             -;
1048   3              }
1049   2              if(temp==length) return HTTP_POST_FAILURE;
1050   2              pData+=temp+4;
1051   2        }
1052   1        
1053   1        idx=0;
1054   1        while (*pData != 0x0)
1055   1        {
1056   2          entries[idx].name = pData;
1057   2          pTemp = strchr(pData, '=');
1058   2          if (!pTemp) break;
1059   2          pData=pTemp;
1060   2          *pData++ = 0x0;
1061   2          entries[idx].val = pData;
1062   2                      
1063   2          while (*pData != 0x0)
1064   2          {
1065   3            if (*pData == '\r') *pData++= 0x0;
1066   3            if (*pData == '&')
1067   3            {
1068   4              *pData++ = 0x0;    
1069   4              if (*pData == 0x0d) pData +=2;  //for \r\n
1070   4              break;
1071   4            }
1072   3            pData++;
1073   3          }
1074   2      
1075   2          /* convert  '+' to spaces */
1076   2          pTemp = entries[idx].val;
1077   2          for (; *pTemp != 0x0; pTemp++)
1078   2            if (*pTemp == '+') *pTemp = ' '; 
1079   2                      
1080   2          /* convert  '%XX' */
1081   2          memset(HTTPtemp.Buf[0], 0, sizeof(HTTPtemp.Buf[0]));
1082   2          index=0;
1083   2          for (pTemp = entries[idx].val ; *pTemp != 0x0 ; pTemp++)
1084   2          {
1085   3            HTTPtemp.Buf[0][index] = *pTemp;
1086   3            if (*pTemp == '%')
1087   3            { 
1088   4              if (isdigit(*(pTemp+1)))
1089   4                tempchar = (*(pTemp+1) - '0') << 4;
1090   4              else
1091   4                tempchar = ((*(pTemp+1) - 'A') + 10) << 4;
1092   4                                
1093   4              if (isdigit(*(pTemp+2)))
1094   4                tempchar += (*(pTemp+2) - '0');
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 19  

1095   4              else
1096   4                tempchar += ((*(pTemp+2) - 'A') + 10);
1097   4      
1098   4              HTTPtemp.Buf[0][index] = tempchar;
1099   4              pTemp+=2;                               
1100   4            }
1101   3            index ++;
1102   3          }
1103   2          strncpy(entries[idx].val, HTTPtemp.Buf[0], strlen(HTTPtemp.Buf[0])+1 );
1104   2          idx++;
1105   2        }
1106   1      
1107   1        if(idx==0) return HTTP_POST_CONTINUE; 
1108   1        num_parms=idx;
1109   1        return  0;
1110   1      } /* End of http_PostVal() */
1111          
1112          /*
1113           * ----------------------------------------------------------------------------
1114           * Function Name: HTTP_Receive()
1115           * Purpose: 
1116           * Params:
1117           * Returns:
1118           * Note:
1119           * ----------------------------------------------------------------------------
1120           */
1121          void HTTP_Receive(U8_T XDATA* pData, U16_T length, U8_T conn_id)
1122          {
1123   1              HTTP_SERVER_CONN XDATA* pHttpConn = &HTTP_Connects[conn_id];
1124   1              U8_T XDATA                              str_post[] = {"POST"};
1125   1              U8_T                                    command, status, fileId, index, fileStatus;
1126   1              U8_T XDATA*                             pFName;
1127   1              U8_T XDATA*                             pFNameExt;
1128   1              U8_T CODE*                              pSour;
1129   1              U8_T                                    *pExpanSour;
1130   1              U16_T                                   data_len;
1131   1              U8_T i, j;
1132   1          U16_T num_parms=0;
1133   1              
1134   1              U32_T AccIP;
1135   1                              
1136   1              if (pHttpConn->State < HTTP_STATE_ACTIVE) return;
1137   1              
1138   1              if (pHttpConn->ContinueFlag)
1139   1              {
1140   2                      fileId = pHttpConn->ContinueFileId;
1141   2                      goto POST_START;
1142   2              }
1143   1              
1144   1              if (length < 14) return;
1145   1      
1146   1              if (StringCompare(pData, str_post, 4))
1147   1              {
1148   2                      command = HTTP_CMD_POST;
1149   2                      pData += 5;
1150   2                      length -= 5;
1151   2              }
1152   1              else
1153   1              {
1154   2                      command = HTTP_CMD_GET;
1155   2                      pData += 4;
1156   2                      length -= 4;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 20  

1157   2              }
1158   1      
1159   1              /* skip space */
1160   1              while (*pData == ' ')
1161   1                      pData++;
1162   1      
1163   1              fileId = MAX_STORE_FILE_NUM;
1164   1              fileStatus = GHTTP_GetFile(&pData, &pFName, &pFNameExt, &length);
1165   1              
1166   1              if (fileStatus)
1167   1                      fileId = FSYS_FindFile(pFName);
1168   1      
1169   1      //-----  Add for accessible IP function start ------    
1170   1              if ((HTTPtemp.AccessibleIP_EnableFlag != 0) && (FSYS_Manage[fileId].FType == FILE_TYPE_HTML))
1171   1              {
1172   2                      for (i = 0 ; i < GCONFIG_ACCESSIBLE_IP_NUM ; i ++)
1173   2                      {
1174   3                              GCONFIG_GetAccessibleIP(i, &AccIP);
1175   3                              if (pHttpConn->Ip == AccIP) break;
1176   3                      }
1177   2      
1178   2                      if (i == GCONFIG_ACCESSIBLE_IP_NUM)
1179   2                      {
1180   3                              fileId = FILE_MSGACCERR;
1181   3                              goto HTTP_TX_HEADER;
1182   3                      }
1183   2              }
1184   1      //-----  Add for accessible IP function end ------
1185   1      //--------- Add for user link to not index page directly start ----------------------------------------
1186   1      //      if ((fileId != FILE_INDEX) && (FSYS_Manage[fileId].FType == FILE_TYPE_HTML))
1187   1      //      {
1188   1      //              for (i = 0; i < 4; i++)
1189   1      //              {
1190   1      //                      if (HTTPtemp.AuthenIP[i] == pHttpConn->Ip) break;
1191   1      //              }
1192   1      //              if (i == 4)//not found in table.
1193   1      //              {
1194   1      //              //      fileId = FILE_JMPINDEX;      /* jump */
1195   1      //                      fileId = FILE_BSCSETTING;
1196   1      //
1197   1      //                      goto HTTP_TX_HEADER;                                    
1198   1      //              }
1199   1      //      }
1200   1      //--------- Add for user link to not index page directly end ----------------------------------------   
1201   1              if (fileStatus == 2) /* for GET /XXX.XXX?--- mode */
1202   1                      goto POST_START;
1203   1      
1204   1              if (command == HTTP_CMD_POST)
1205   1              {
1206   2      POST_START:
1207   2                      if (fileId == MAX_STORE_FILE_NUM)
1208   2                      {
1209   3                              printd ("POST error file not found.\n\r");
1210   3                              TCPIP_TcpClose(pHttpConn->TcpSocket); /*RST | ACK*/
1211   3                              pHttpConn->State = HTTP_STATE_FREE;
1212   3                              return;
1213   3                      }
1214   2                      
1215   2                      if(FSYS_Manage[fileId].CgiRef==0xff)
1216   2                      {
1217   3                              status = http_PostVal(pData, length, pHttpConn->ContinueFlag);
1218   3      
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 21  

1219   3                              if (status == HTTP_POST_CONTINUE)
1220   3                              {
1221   4                                      printd ("POST continue.\n\r");
1222   4                                      pHttpConn->ContinueFlag = 1;
1223   4                                      pHttpConn->ContinueFileId = fileId;
1224   4                                      return;
1225   4                              }
1226   3      
1227   3                              i=0;
1228   3                              while(i<num_parms)
1229   3                              {
1230   4                                      printd("entry[%02bx]=%s,%s\n",i,entries[i].name,entries[i].val);
1231   4                                      i++;
1232   4                              }  
1233   3                              pHttpConn->ContinueFlag = 0;
1234   3      
1235   3                              if (status == HTTP_POST_FAILURE)
1236   3                              {
1237   4                                      printd ("POST error data0.\n\r");
1238   4      
1239   4                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1240   4                                      pHttpConn->State = HTTP_STATE_FREE;
1241   4                                      return;
1242   4                              }
1243   3                      }       
1244   2                      else
1245   2                      {
1246   3                              /* look for Referer */
1247   3                              status = http_UserPost(pData, length, FSYS_Manage[fileId].CgiRef, pHttpConn->ContinueFlag);
1248   3      
1249   3                              if (status == HTTP_POST_SUCCESS)
1250   3                              {
1251   4                                      pHttpConn->ContinueFlag = 0;
1252   4      
1253   4      /*====== for index.htm web page, start ====== */
1254   4                                      if (fileId == FILE_INDEX)
1255   4                                      {
1256   5                                              status = HTTP_CheckPassWord(pHttpConn);
1257   5                                              if (status == HTTP_POST_FAILURE)
1258   5                                              {
1259   6      #if (INCLUDE_EVENT_DETECT)
1260   6      //                                              GEVENT_SetAuthFailEvent(1);//*** Add for authentication fail detect ***                                 
1261   6      #endif
1262   6                                                      fileId = FILE_MSGAUTHERR;
1263   6                                              }
1264   5                                              else
1265   5                                              {
1266   6                                                      fileId = FILE_MSGAUTHOK;
1267   6                                              }
1268   5                                      }
1269   4      /*====== for index.htm web page, end ====== */
1270   4      /*====== for security.htm web page, start ====== */
1271   4                                      else if (fileId == FILE_SECURITY)
1272   4                                      {
1273   5                                              if ((HTTPtemp.PostTable[0] == RECORD_TEXT_old_psw) &&
1274   5                                                      (HTTPtemp.PostTable[1] == RECORD_TEXT_new_psw) &&
1275   5                                                      (HTTPtemp.PostTable[2] == RECORD_TEXT_cfm_psw) && 
1276   5                                                      (HTTPtemp.PostCnt == 4))
1277   5                                              {
1278   6                                                      status = HTTP_CheckNewPassword();
1279   6                                                      fileId = (status == HTTP_POST_FAILURE) ? FILE_MSGSCTERR : FILE_MSGUNPWOK;
1280   6                                              }
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 22  

1281   5                                              else if ((HTTPtemp.PostTable[0] == RECORD_TEXT_new_usn) &&
1282   5                                                               (HTTPtemp.PostCnt == 2))
1283   5                                              {
1284   6                                                      status = HTTP_CheckNewUsername();
1285   6                                                      fileId = (status == HTTP_POST_FAILURE) ? FILE_MSGSCTERR : FILE_MSGUNPWOK;
1286   6                                              }
1287   5                                              else
1288   5                                                      goto POST_NORM;
1289   5                                      }
1290   4                                      else
1291   4                                      {
1292   5      /*====== for security.htm web page, end ====== */                               
1293   5      POST_NORM:
1294   5                                              status = HTTP_NewConfig();
1295   5      /*====== for msgreboot.htm web page, start ====== */
1296   5                                              if (fileId == FILE_BSCSETTING)
1297   5                                              {
1298   6                                                      if (HTTPtemp.SysRebootFlag)
1299   6                                                      {
1300   7                                                              HTTPtemp.SysRebootFlag = 0;
1301   7                                                              fileId = FILE_MSGREBOOT;
1302   7                                                      }
1303   6                                              }
1304   5      /*====== for msgreboot.htm web page, end ====== */
1305   5      /*====== for advsetting.htm web page, start ====== */
1306   5                                              else if (fileId == FILE_ADVSETTING)
1307   5                                              {
1308   6                                                      for (i = 0; i < HTTPtemp.PostCnt ; i ++)
1309   6                                                      {
1310   7                                                              j = HTTPtemp.PostTable[i];
1311   7                                                              if (!strncmp("upgrade", POST_Record[j].Name, POST_Record[j].NameLen))
1312   7                                                              {
1313   8                                                                      fileId = FILE_MSGUPG;
1314   8                                                                      break;
1315   8                                                              }
1316   7                                                      }
1317   6                                              }
1318   5      /*====== for advsetting.htm web page, end ====== */
1319   5                                      }
1320   4                              }
1321   3                              else if (status == HTTP_POST_CONTINUE)
1322   3                              {
1323   4                                      printd ("POST continue.\n\r");                  
1324   4                                      pHttpConn->ContinueFlag = 1;
1325   4                                      pHttpConn->ContinueFileId = fileId;
1326   4                                      return;
1327   4                              }
1328   3                              else if (status == HTTP_POST_FAILURE)
1329   3                              {
1330   4                                      pHttpConn->ContinueFlag = 0;                            
1331   4                                      printd ("POST error data1.\n\r");
1332   4      
1333   4                                      if (fileId == FILE_ADVSETTING)
1334   4                                              fileId = FILE_MSGADVERR;
1335   4                                      else if (fileId == FILE_BSCSETTING)
1336   4                                              fileId = FILE_MSGBSCERR;
1337   4                                      else if (fileId == FILE_SECURITY)
1338   4                                              fileId = FILE_MSGSCTERR;
1339   4                                      else
1340   4                                      {
1341   5                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1342   5                                      pHttpConn->State = HTTP_STATE_FREE;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 23  

1343   5                                      return;
1344   5                              }
1345   4                      }
1346   3              }
1347   2              }
1348   1      
1349   1              if (command == HTTP_CMD_GET)
1350   1              {
1351   2      
1352   2                      if (fileStatus)
1353   2                      {
1354   3                              if (fileId == MAX_STORE_FILE_NUM)
1355   3                              {
1356   4                                      /* not find file, send reset */
1357   4                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1358   4                                      pHttpConn->State = HTTP_STATE_FREE;
1359   4                                      return;
1360   4                              }
1361   3      //--------- Add for delete validated IP when user logout start ----------------------------------------                 
1362   3                              else if (fileId == FILE_INDEX)
1363   3                              {
1364   4                                      for (i = 0; i < 4; i++)
1365   4                                      {
1366   5                                              if (HTTPtemp.AuthenIP[i] == pHttpConn->Ip)
1367   5                                                      HTTPtemp.AuthenIP[i] = 0;
1368   5                                      }
1369   4                              }
1370   3      //--------- Add for delete validated IP when user logout end ----------------------------------------                                   
             -        
1371   3                      }
1372   2                      else
1373   2                      {
1374   3      //--------- Add for user link to a web page not specify file name start ----------------------------------
             -------
1375   3                              fileId = FILE_JMPINDEX;
1376   3      //--------- Add for user link to a web page not specify file name end ------------------------------------
             -----
1377   3                      }
1378   2              }
1379   1      
1380   1          //call cgi function
1381   1              if(FSYS_Manage[fileId].CgiCall)
1382   1              {
1383   2                      void (*pF)(void);
1384   2                      pF= FSYS_Manage[fileId].CgiCall;
1385   2                      pF();
1386   2              }
1387   1              
1388   1              // update data in some web page
1389   1              {
1390   2                      U8_T i;
1391   2      
1392   2                      for (i = 0; i < MAX_POST_RECORDS; i++)
1393   2                      {
1394   3                              if (fileId == POST_Record[i].FileIndex)
1395   3                              {
1396   4                                      if ((POST_Record[i].UpdateSelf == TRUE) && (POST_Record[i].PostType == POST_TYPE_TAG))
1397   4                                      {
1398   5                                              void *pValue = POST_Record[i].PValue;
1399   5                                              void (*f)(void *pWebData);
1400   5                                              f = fun_tbl[i];
1401   5                                              f(pValue);
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 24  

1402   5                                      }
1403   4                              }
1404   3                      }
1405   2              }
1406   1      HTTP_TX_HEADER: 
1407   1              pHttpConn->FileId = fileId;
1408   1      
1409   1              /* begin send html and jpg header */
1410   1              if (FSYS_Manage[fileId].FType & FILE_TYPE_BIN)
1411   1              {
1412   2                      data_len = (U32_T)FSYS_Manage[fileId].FileSize;
1413   2      
1414   2                      index = 5;
1415   2                      while (index > 0)
1416   2                      {
1417   3                              index--;
1418   3                              ImageHeader[ImageByteCountOffset + index] = (U8_T)((data_len%10) + 0x30);
1419   3                              data_len /= 10;
1420   3                      }
1421   2                      
1422   2                      if (FSYS_Manage[fileId].FType == FILE_TYPE_CSS)
1423   2                      {
1424   3                              data_len = (U32_T)CSSHeaderLen;
1425   3                              pExpanSour = CSSHeader;
1426   3                      }
1427   2                      else
1428   2                      { 
1429   3                              data_len = (U32_T)ImageHeaderLen;
1430   3                              pExpanSour = ImageHeader;
1431   3                      }
1432   2                      TCPIP_TcpSend(pHttpConn->TcpSocket, pExpanSour, data_len, TCPIP_SEND_NOT_FINAL);
1433   2              }
1434   1              else
1435   1              {
1436   2                      if (FSYS_Manage[fileId].FType == FILE_TYPE_JS)
1437   2                      {
1438   3                              data_len = (U32_T)JsHeaderLen;
1439   3                              pSour = JsHeader;
1440   3                      }
1441   2                      else
1442   2                      { 
1443   3                              HTTP_LoadSetting();
1444   3                              data_len = (U32_T)HtmlHeaderLen;
1445   3                              pSour = HtmlHeader;
1446   3                      }
1447   2                      TCPIP_TcpSend(pHttpConn->TcpSocket, pSour, data_len, TCPIP_SEND_NOT_FINAL);
1448   2              }
1449   1      
1450   1              pHttpConn->State = HTTP_STATE_SEND_HEADER;
1451   1      
1452   1      } /* End of HTTP_Receive() */
1453          
1454          /*
1455           * ----------------------------------------------------------------------------
1456           * Function Name: HTTP_DivideHtmlFile()
1457           * Purpose: 
1458           * Params:
1459           * Returns:
1460           * Note:
1461           * ----------------------------------------------------------------------------
1462           */
1463          void HTTP_DivideHtmlFile(HTTP_SERVER_CONN XDATA* pHttpConn, U8_T id)
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 25  

1464          {
1465   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA         *pRadio;
              #endif
1468   1              BUF_TEXT XDATA          *pText;
1469   1      #if (MAX_POST_BUF_SELECT)       
1470   1              BUF_SELECT XDATA        *pSelect;
1471   1      #endif
1472   1              BUF_TAG XDATA           *pTag;
1473   1              U8_T                            tableIndex = 0;
1474   1              U8_T                            i, k;
1475   1      
1476   1              {
1477   2                      for (i = 0; i < MAX_POST_RECORDS; i++)
1478   2                      {
1479   3                              if (id != POST_Record[i].FileIndex)
1480   3                                      continue;
1481   3      //--------------- Ignore process for non-data structure item start -----------------------
1482   3                              if ((i == RECORD_TEXT_old_psw) || 
1483   3                                      (i == RECORD_TEXT_new_psw) || 
1484   3                                      (i == RECORD_TEXT_cfm_psw) || 
1485   3                                      (i == RECORD_TEXT_username) ||
1486   3                                      (i == RECORD_TEXT_password) ||
1487   3                                      (i == RECORD_TEXT_new_usn))
1488   3                                      continue;
1489   3      //--------------- Ignore process for non-data structure item end -------------------------
1490   3                              if (POST_Record[i].PostType == POST_TYPE_TEXT)
1491   3                              {
1492   4                                      U8_T    *pData;
1493   4      
1494   4                                              pText = POST_Record[i].PValue;
1495   4                                              if ((!pText) || (pText->DefaultLength == 0) || (pText->CurrLength == 0) ||
1496   4                                                      ((pText->CurrLength == 1) && (pText->DefaultLength == 1))) continue;
1497   4      
1498   4                                              pData = FSYS_Manage[id].PBuf + pText->Offset;
1499   4                                              if (pText->CurrLength == pText->DefaultLength)
1500   4                                              {
1501   5                                                      for (k = 0; k < pText->CurrLength; k++)
1502   5                                                      {
1503   6                                                              if (pData[k] != pText->CurrValue[k]) break;
1504   6                                                      }
1505   5                                                      if (k == pText->CurrLength)     continue;
1506   5                                              }
1507   4                                                                      
1508   4                                              pHttpConn->Divide.Offset[tableIndex] = pText->Offset;
1509   4                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1510   4                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_TEXT;
1511   4      
1512   4                                      tableIndex++;
1513   4                              }
1514   3                              else if (POST_Record[i].PostType == POST_TYPE_TAG)
1515   3                              {
1516   4                                      
1517   4                                      pTag = POST_Record[i].PValue;
1518   4                                      if (pTag->DefaultLength == 0)
1519   4                                              continue;
1520   4                                      pHttpConn->Divide.Offset[tableIndex] = pTag->Offset;
1521   4                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1522   4                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_TAG;
1523   4      
1524   4                                      tableIndex++;
1525   4                              }
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 26  

1526   3      #if (MAX_POST_BUF_RADIO)        
                                      else if (POST_Record[i].PostType == POST_TYPE_RADIO)
                                      {
                                              pRadio = POST_Record[i].PValue;
                                              if (pRadio->DefaultSet == pRadio->CurrentSet)
                                                      continue;
                                      
                                              for (k = 0; k < pRadio->Count; k++)
                                              {
                                                      pHttpConn->Divide.Offset[tableIndex] = pRadio->Offset[k];
                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_RADIO;
                                                      if (pRadio->CurrentSet == k)
                                                      {
                                                              pHttpConn->Divide.SetFlag[tableIndex] = 1;
                                                              tableIndex++;
                                                      }
                                                      else if (pRadio->DefaultSet == k)
                                                      {
                                                              pHttpConn->Divide.SetFlag[tableIndex] = 2;
                                                              tableIndex++;
                                                      }
                                              }
                                      }
              #endif
1551   3      #if (MAX_POST_BUF_SELECT)
1552   3                              else if (POST_Record[i].PostType == POST_TYPE_SELECT)
1553   3                              {
1554   4                                      pSelect = POST_Record[i].PValue;
1555   4                                      if ((pSelect->DefaultSet == pSelect->CurrentSet) ||
1556   4                                                      (pSelect->CurrentSet >= pSelect->Count))
1557   4                                      {
1558   5                                              continue;
1559   5                                      }
1560   4                                      for (k = 0; k < pSelect->Count; k++)
1561   4                                      {
1562   5                                              if (pSelect->DefaultSet == k)
1563   5                                              {
1564   6                                                      pHttpConn->Divide.Offset[tableIndex] = pSelect->Offset[k];
1565   6                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1566   6                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_SELECT;
1567   6                                                      pHttpConn->Divide.SetFlag[tableIndex] = 2;
1568   6                                                      tableIndex++;
1569   6                                              }
1570   5                                              else if (pSelect->CurrentSet == k)
1571   5                                              {
1572   6                                                      pHttpConn->Divide.Offset[tableIndex] = pSelect->Offset[k];
1573   6                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1574   6                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_SELECT;
1575   6                                                      pHttpConn->Divide.SetFlag[tableIndex] = 1;
1576   6                                                      tableIndex++;
1577   6                                              }
1578   5                                      }                       
1579   4                              }
1580   3      #endif                  
1581   3                              else
1582   3                                      continue;
1583   3                      }
1584   2              }
1585   1              pHttpConn->Divide.Fragment = tableIndex;        
1586   1      
1587   1      } /* End of HTTP_DivideHtmlFile() */
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 27  

1588          
1589          /*
1590           * ----------------------------------------------------------------------------
1591           * Function Name: HTTP_NewConfig()
1592           * Purpose: 
1593           * Params:
1594           * Returns:
1595           * Note:
1596           * ----------------------------------------------------------------------------
1597           */
1598          U8_T HTTP_NewConfig(void)
1599          {
1600   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA         *pRadio;
              #endif
1603   1              BUF_TEXT XDATA          *pText;
1604   1      #if (MAX_POST_BUF_SELECT)
1605   1              BUF_SELECT XDATA        *pSelect;
1606   1      #endif  
1607   1              U8_T                            i;
1608   1              U8_T                            change;
1609   1              void                            (*f)(void *pWebData);
1610   1      
1611   1              HTTPtemp.SaveCfgFlag = 0;
1612   1              HTTPtemp.SysRebootFlag = 0;     
1613   1      
1614   1              for (i = 0; i < HTTPtemp.PostCnt; i++)
1615   1              {
1616   2                      if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_TEXT)
1617   2                      {
1618   3                              change = 0;
1619   3                              pText = POST_Record[HTTPtemp.PostTable[i]].PValue;
1620   3                              
1621   3                              if (pText == NULL) continue; // it may be password
1622   3                              {
1623   4                                      if ((pText->CurrLength - 1) == pText->UserLength)
1624   4                                      {
1625   5                                              if (memcmp(pText->CurrValue, pText->UserValue, pText->CurrLength - 1))  change = 1;
1626   5                                      }
1627   4                                      else change = 1;
1628   4      
1629   4                                      if (!change) continue;
1630   4      
1631   4                                      memcpy(pText->CurrValue, pText->UserValue, pText->UserLength);
1632   4                                      pText->CurrValue[pText->UserLength] = '"';
1633   4                                      pText->CurrLength = pText->UserLength + 1;
1634   4                                      pText->UserLength ++;
1635   4      
1636   4                                      f = fun_tbl[HTTPtemp.PostTable[i]];
1637   4                                      f(pText);
1638   4                              }
1639   3                      }
1640   2      #if (MAX_POST_BUF_RADIO)                
                              else if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_RADIO)
                              {
                                      change = 0;
                                      pRadio = POST_Record[HTTPtemp.PostTable[i]].PValue;     
                                      if (pRadio->UserSet != pRadio->CurrentSet)
                                      {
                                              pRadio->CurrentSet = pRadio->UserSet;
                                              change = 1;
                                      }
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 28  

              
                                      if (!change) continue;
              
                                      f = fun_tbl[HTTPtemp.PostTable[i]];
                                      f(&pRadio->CurrentSet);
                              }
              #endif
1657   2      #if (MAX_POST_BUF_SELECT)
1658   2                      else if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_SELECT)
1659   2                      {
1660   3                              change = 0;
1661   3                              pSelect = POST_Record[HTTPtemp.PostTable[i]].PValue;
1662   3                              {
1663   4                                      if (pSelect->UserSet != pSelect->CurrentSet)
1664   4                                      {
1665   5                                              pSelect->CurrentSet = pSelect->UserSet;
1666   5                                              change = 1;
1667   5                                      }
1668   4                                      if (!change) continue;
1669   4      
1670   4                                      f = fun_tbl[HTTPtemp.PostTable[i]];
1671   4                                      f(&pSelect->CurrentSet);
1672   4                              }
1673   3                      }
1674   2      #endif
1675   2                      else continue;
1676   2              }
1677   1      
1678   1              if (HTTPtemp.SaveCfgFlag)
1679   1              {
1680   2                      printd("Change Setting\n\r");
1681   2                      GCONFIG_WriteConfigData();              
1682   2              }
1683   1              
1684   1              return HTTP_POST_SUCCESS;
1685   1      
1686   1      } /* End of HTTP_NewConfig() */
1687          
1688          
1689          /*
1690           * ----------------------------------------------------------------------------
1691           * Function Name: HTTP_Ulong2IpAddr()
1692           * Purpose: Transfer a ulong number to ip address string. exp: 192.168.0.3
1693           * Params:
1694           * Returns:
1695           * Note:
1696           * ----------------------------------------------------------------------------
1697           */
1698          U8_T HTTP_Ulong2IpAddr(U32_T ip, U8_T* pbuf)
1699          {
1700   1              U8_T*   point = (U8_T*)&ip;
1701   1              U8_T    i = sizeof (U32_T);
1702   1              U8_T    temp, value[3];
1703   1              U8_T    j, len = 0;
1704   1      
1705   1              while (i--)
1706   1              {
1707   2                      temp = *point++;
1708   2                      if (temp == 0)
1709   2                      {
1710   3                              *pbuf++ = 0x30;
1711   3                              len++;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 29  

1712   3                      }
1713   2                      else
1714   2                      {
1715   3                              j = 3;
1716   3                              while (j--)
1717   3                              {
1718   4                                      value[j] = (temp % 10) + 0x30;
1719   4                                      temp /= 10;
1720   4                              }
1721   3      
1722   3                              if (value[0] != '0')
1723   3                              {
1724   4                                      *pbuf++ = value[0];
1725   4                                      *pbuf++ = value[1];
1726   4                                      *pbuf++ = value[2];
1727   4                                      len += 3;
1728   4                              }
1729   3                              else if (value[1] != '0')
1730   3                              {
1731   4                                      *pbuf++ = value[1];
1732   4                                      *pbuf++ = value[2];
1733   4                                      len += 2;
1734   4                              }
1735   3                              else
1736   3                              {
1737   4                                      *pbuf++ = value[2];
1738   4                                      len++;
1739   4                              }
1740   3                      }
1741   2      
1742   2                      if (i)
1743   2                      {
1744   3                              *pbuf++ = '.';
1745   3                              len++;
1746   3                      }
1747   2              }
1748   1      
1749   1              return len;
1750   1                              
1751   1      } /* End of HTTP_Ulong2IpAddr() */
1752          
1753          /*====== for index.htm web page, start ====== */
1754          /*
1755           * ----------------------------------------------------------------------------
1756           * Function Name: HTTP_CheckPassWord()
1757           * Purpose: 
1758           * Params:
1759           * Returns:
1760           * Note:
1761           * ----------------------------------------------------------------------------
1762           */
1763          U8_T HTTP_CheckPassWord(HTTP_SERVER_CONN XDATA* pHttpConn)
1764          {
1765   1              U8_T    Index, LvlTemp;
1766   1      
1767   1              return HTTP_POST_SUCCESS;  /* jump */
1768   1      
1769   1              if ((HTTPtemp.PostCnt != 3) ||
1770   1                      (HTTPtemp.PostTable[0] != RECORD_TEXT_username) || 
1771   1                      (HTTPtemp.PostTable[1] != RECORD_TEXT_password))
1772   1              {
1773   2                      printd ("Login: Lost username or password data!\n\r");  
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 30  

1774   2                      return HTTP_POST_FAILURE;
1775   2              }
1776   1      
1777   1              if ((HTTPtemp.UserNameLen == 0) || 
1778   1                      (HTTPtemp.PassWordLen == 0) || 
1779   1                      (HTTPtemp.UserNameLen > MAX_AUTH_POST_VALUE_LEN) || 
1780   1                      (HTTPtemp.PassWordLen > MAX_AUTH_POST_VALUE_LEN))
1781   1              {
1782   2                      printd ("Login: username or password length error!\n\r");
1783   2                      return HTTP_POST_FAILURE;       
1784   2              }
1785   1              
1786   1              for (Index = 0; Index < MAX_USER_COUNT; Index ++)
1787   1              {
1788   2                      GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &LvlTemp);   //Get username and password.    
1789   2                      if ((HTTPtemp.UserNameLen == strlen(HTTPtemp.Buf[0])) &&                //Check length and content, not include '\0' 
             -char.
1790   2                              (HTTPtemp.PassWordLen == strlen(HTTPtemp.Buf[1])) &&            
1791   2                              (memcmp(HTTPtemp.UserName, HTTPtemp.Buf[0], HTTPtemp.UserNameLen) == 0) &&                      
1792   2                              (memcmp(HTTPtemp.PassWord, HTTPtemp.Buf[1], HTTPtemp.PassWordLen) == 0))
1793   2                              break;
1794   2              }
1795   1              
1796   1              if (Index == MAX_USER_COUNT)
1797   1              {
1798   2                      printd ("Login: username or password not metch!\n\r");  
1799   2                      return HTTP_POST_FAILURE;
1800   2              }
1801   1              
1802   1              for (Index = 0 ; Index < MAX_HTTP_CONNECT ; Index ++)           //Fine a empty space for save authenticationed IP.
1803   1              {
1804   2                      if (HTTPtemp.AuthenIP[Index] == 0)
1805   2                      {
1806   3                              HTTPtemp.AuthenIP[Index] = pHttpConn->Ip;
1807   3                              break;
1808   3                      }
1809   2              }
1810   1      
1811   1              if (Index == MAX_HTTP_CONNECT)          //Force this IP to save.
1812   1                      HTTPtemp.AuthenIP[0] = pHttpConn->Ip;
1813   1              
1814   1              printd ("Login: username and password check ok!\n\r");  
1815   1              return HTTP_POST_SUCCESS;                                               
1816   1      
1817   1      } /* End of HTTP_CheckPassWord() */
1818          /*====== for index.htm web page, end ======*/
1819          /*====== for system.htm web page, start ====== */
1820          /*
1821           * ----------------------------------------------------------------------------
1822           * Function Name: HTTP_CheckNewPassword()
1823           * Purpose: 
1824           * Params:
1825           * Returns:
1826           * Note:
1827           * ----------------------------------------------------------------------------
1828           */
1829          U8_T HTTP_CheckNewPassword(void)
1830          {
1831   1              U8_T Index, LvlTemp;
1832   1              
1833   1              if ((HTTPtemp.PostCnt != 4) ||
1834   1                      (HTTPtemp.PostTable[0] != RECORD_TEXT_old_psw) || 
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 31  

1835   1                      (HTTPtemp.PostTable[1] != RECORD_TEXT_new_psw) || 
1836   1                      (HTTPtemp.PostTable[2] != RECORD_TEXT_cfm_psw))
1837   1              {
1838   2                      printd ("Change PassWord: Lost password data!\n\r");    
1839   2                      return HTTP_POST_FAILURE;
1840   2              }
1841   1      
1842   1              if ((HTTPtemp.NewPassWordLen == 0) || 
1843   1                      (HTTPtemp.CfmPassWordLen == 0) || 
1844   1                      (HTTPtemp.NewPassWordLen > MAX_AUTH_POST_VALUE_LEN) || 
1845   1                      (HTTPtemp.CfmPassWordLen > MAX_AUTH_POST_VALUE_LEN))
1846   1              {
1847   2                      printd ("Change PassWord: New password or confirm password length error!\n\r");
1848   2                      return HTTP_POST_FAILURE;       
1849   2              }
1850   1      
1851   1              for (Index = 0; Index < MAX_USER_COUNT; Index ++)//Find the Old password.
1852   1              {
1853   2                      GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &LvlTemp);
1854   2                      if ((HTTPtemp.OldPassWordLen == strlen(HTTPtemp.Buf[1])) &&
1855   2                              (memcmp(HTTPtemp.Buf[1], HTTPtemp.OldPassWord, HTTPtemp.OldPassWordLen) == 0))
1856   2                              break;
1857   2              }
1858   1      
1859   1              if (Index == MAX_USER_COUNT) 
1860   1              {
1861   2                      printd ("Change PassWord: Old password not found!\n\r");                
1862   2                      return HTTP_POST_FAILURE;
1863   2              }
1864   1      
1865   1              if (HTTPtemp.NewPassWordLen != HTTPtemp.CfmPassWordLen)
1866   1              {
1867   2                      printd ("Change PassWord: New password and confirm password length not equal!\n\r");    
1868   2                      return HTTP_POST_FAILURE;
1869   2              }
1870   1      
1871   1              if (memcmp(HTTPtemp.NewPassWord, HTTPtemp.CfmPassWord, HTTPtemp.NewPassWordLen))
1872   1              {
1873   2                      printd ("Change PassWord: Data not equal in %s to %s\n\r",HTTPtemp.OldPassWord , HTTPtemp.NewPassWord);
1874   2                      return HTTP_POST_FAILURE;
1875   2              }
1876   1      
1877   1      //      if (Index == 0)
1878   1              {
1879   2                      GCONFIG_SetAdmin(HTTPtemp.Buf[0], HTTPtemp.NewPassWord);
1880   2                      printd ("Change PassWord: change ok! from: %s to %s\n\r", HTTPtemp.Buf[1], HTTPtemp.NewPassWord);
1881   2              GCONFIG_WriteConfigData();
1882   2              }
1883   1              return HTTP_POST_SUCCESS;
1884   1      
1885   1      } /* End of HTTP_CheckNewPassword() */
1886          
1887          /*
1888           * ----------------------------------------------------------------------------
1889           * Function Name: HTTP_CheckNewUsername()
1890           * Purpose: 
1891           * Params:
1892           * Returns:
1893           * Note:
1894           * ----------------------------------------------------------------------------
1895           */
1896          U8_T HTTP_CheckNewUsername(void)
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 32  

1897          {
1898   1              U8_T Temp;
1899   1              
1900   1              if (HTTPtemp.PostCnt != 2) return HTTP_POST_FAILURE;
1901   1              
1902   1              if ((!HTTPtemp.NewUserNameLen) || (HTTPtemp.NewUserNameLen > MAX_AUTH_POST_VALUE_LEN))
1903   1              {
1904   2                      printd ("Change UserName: New username length error!\n\r");
1905   2                      return HTTP_POST_FAILURE;
1906   2              }
1907   1              
1908   1              GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &Temp);
1909   1              GCONFIG_SetAdmin(HTTPtemp.NewUserName, HTTPtemp.Buf[1]);
1910   1              printd ("Change UserName: change ok! from: %s to %s\n\r", HTTPtemp.Buf[0], HTTPtemp.NewUserName);
1911   1          GCONFIG_WriteConfigData();          
1912   1              
1913   1              return HTTP_POST_SUCCESS;
1914   1      } /* End of HTTP_CheckNewUsername() */
1915          
1916          /*
1917           * ----------------------------------------------------------------------------
1918           * Function Name: HTTP_IpAddr2Ulong()
1919           * Purpose: Transfer a ip address string to ulong number. exp: 0xc0a80003
1920           * Params:
1921           * Returns:
1922           * Note:
1923           * ----------------------------------------------------------------------------
1924           */
1925          U32_T HTTP_IpAddr2Ulong(U8_T* pBuf, U8_T len)
1926          {
1927   1              U32_T   ip = 0;
1928   1              U8_T*   point = (U8_T*)&ip;
1929   1              U8_T    count = 0;
1930   1              U8_T    count2 = 0;
1931   1      
1932   1              while (1)
1933   1              {
1934   2                      count2 = 0;
1935   2                      while ((*pBuf != '.') && len)
1936   2                      {
1937   3                              count2++;
1938   3                              if (count2 > 3) return 0xffffffff;
1939   3      
1940   3                              *point *= 10;
1941   3        
1942   3                              if ((*pBuf < 0x3a) && (*pBuf > 0x2f))
1943   3                                      *point += (*pBuf - 0x30);
1944   3                              else
1945   3                                      return 0xffffffff;
1946   3      
1947   3                              pBuf++;
1948   3                              len--;
1949   3                      }
1950   2        
1951   2                      if (len == 0) break;
1952   2      
1953   2                      pBuf++;
1954   2                      len--;
1955   2                      count++;
1956   2                      point++;
1957   2      
1958   2                      if (count > 3) return 0xffffffff;
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 33  

1959   2              }
1960   1      
1961   1              if (count != 3) return 0xffffffff;
1962   1      
1963   1              return ip;
1964   1      } /* End of HTTP_IpAddr2Ulong() */
1965          
1966          /*
1967           * ----------------------------------------------------------------------------
1968           * Function Name: HTTP_Str2Short()
1969           * Purpose: Transfer a string to ushort number.
1970           * Params:
1971           * Returns:
1972           * Note:
1973           * ----------------------------------------------------------------------------
1974           */
1975          U16_T HTTP_Str2Short(U8_T* pBuf, U8_T len)
1976          {
1977   1              U32_T   value = 0;
1978   1      
1979   1              while (len--)
1980   1              {
1981   2                      value *= 10;
1982   2       
1983   2                      if ((*pBuf < 0x3a) && (*pBuf > 0x2f))
1984   2                              value += (*pBuf - 0x30);
1985   2                      else
1986   2                              return 0xffff;
1987   2      
1988   2                      pBuf++;
1989   2              }
1990   1              if (value & 0xFFFF0000) return 0xFFFF;
1991   1              return (U16_T)(value & 0xFFFF);
1992   1      
1993   1      } /* End of HTTP_Str2Short() */
1994          
1995          /*
1996           * ----------------------------------------------------------------------------
1997           * Function Name: HTTP_Short2Str()
1998           * Purpose: Transfer a string to ushort number.
1999           * Params:
2000           * Returns:
2001           * Note:
2002           * ----------------------------------------------------------------------------
2003           */
2004          U8_T HTTP_Short2Str(U16_T port, U8_T* pBuf)
2005          {
2006   1              U8_T*   point = (U8_T*)&port;
2007   1              U8_T    i, j, k, len = 0;
2008   1              U16_T   tmp;
2009   1      
2010   1              if (port > 9999)
2011   1                      len = 5;
2012   1              else if (port > 999)
2013   1                      len = 4;
2014   1              else if (port > 99)
2015   1                      len = 3;
2016   1              else if (port > 9)
2017   1                      len = 2;
2018   1              else
2019   1                      len = 1;
2020   1      
C51 COMPILER V9.06   HTTPD                                                                 05/28/2013 10:15:32 PAGE 34  

2021   1              pBuf[len - 1] = (port % 10) + 0x30;
2022   1              for (i = 0; i < len - 1 ; i++)
2023   1              {
2024   2                      j = (len - 1) - i;
2025   2                      tmp = 1;
2026   2                      for (k = 0; k < j; k++)
2027   2                      {
2028   3                              tmp = tmp * 10;
2029   3                      }
2030   2                      pBuf[i] = (port / tmp) + 0x30;
2031   2                      port = port - ((pBuf[i] - 0x30) * tmp);
2032   2              }
2033   1      
2034   1              return len;
2035   1      
2036   1      } /* End of HTTP_Short2Str() */
2037           
2038          
2039          /* End of httpd.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14626    ----
   CONSTANT SIZE    =   1079    ----
   XDATA SIZE       =   1125     184
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
