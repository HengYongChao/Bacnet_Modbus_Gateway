C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE HTTPD
OBJECT MODULE PLACED IN .\httpd.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\http\httpd.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) IN
                    -CDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\
                    -SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buf
                    -fer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\S
                    -rc\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP;..\s
                    -rc\gs2e;..\src\adpter1;..\src\scan;..\src\gsm) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\httpd.lst) OBJECT(.\httpd.o
                    -bj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: httpd.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: httpd.c,v $
  18           * Revision 1.0  2006/05/30 06:39:38  Francis
  19           * Revision 3.0.0  2010/09/29 09:51:00  Smile
  20           * no message
  21           *
  22           *=============================================================================
  23           */
  24          
  25          /* INCLUDE FILE DECLARATIONS */
  26          #include "reg80390.h"
  27          #include "stoe.h"
  28          #include "main.h"
  29          #include "mstimer.h"
  30          #include "httpd.h"
  31          #include "filesys.h"
  32          #include "adapter.h"
  33          #include "gs2e.h"
  34          #include "gconfig.h"
  35          #include "tcpip.h"
  36          #include "delay.h"
  37          #include "uart.h"
  38          #include "printd.h"
  39          #include <string.h>
  40          #include "ax11000.h"
  41          #include "ctype.h"
  42          #include "lcd.h"
  43          
  44          
  45          #if (INCLUDE_EVENT_DETECT)
  46          #include "gevent.h"
  47          #endif
  48          /* NAMING CONSTANT DECLARATIONS */
  49          
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 2   

  50          /* GLOBAL VARIABLES DECLARATIONS */
  51          entry entries[20];
  52          U8_T num_parms;
  53          /* LOCAL VARIABLES DECLARATIONS */
  54          static HTTP_SERVER_CONN XDATA HTTP_Connects[MAX_HTTP_CONNECT];
  55          static U8_T CODE HtmlHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\n
             -Content-type: text/html\r\n\r\n"};
  56          static U8_T XDATA HtmlHeaderLen = (sizeof(HtmlHeader) - 1);
  57          static U8_T CODE CSSHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\nC
             -ontent-type: text/css\r\n\r\n"};
  58          static U8_T XDATA CSSHeaderLen = (sizeof(CSSHeader) - 1);
  59          static U8_T CODE JsHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r\nCo
             -ntent-type: application/javascript\r\n\r\n"};
  60          static U8_T XDATA JsHeaderLen = (sizeof(JsHeader) - 1);
  61          static U8_T XDATA ImageHeader[] = {"HTTP/1.0 200 OK\r\nCache-control: no-cache\r\nConnection: Keep-Alive\r
             -\nContent-Length: xxxxx\r\nContent-type: image/jpeg\r\n\r\n"};
  62          static U8_T XDATA ImageHeaderLen = (sizeof(ImageHeader) - 1);
  63          static U8_T XDATA ImageByteCountOffset = 82;
  64          HTTP_TEMP_BUF XDATA HTTPtemp;
  65          
  66          /* LOCAL SUBPROGRAM DECLARATIONS */
  67          
  68          static U8_T HTTP_NewConfig(void);
  69          static void HTTP_DivideHtmlFile(HTTP_SERVER_CONN XDATA* pHttpConn, U8_T id);
  70          static U8_T HTTP_CheckPassWord(HTTP_SERVER_CONN XDATA*  pHttpConn);
  71          static void HTTP_LoadSetting(void);
  72          static U8_T HTTP_CheckNewPassword(void);
  73          static U8_T HTTP_CheckNewUsername(void);
  74          /*
  75           * ----------------------------------------------------------------------------
  76           * Function Name: HTTP_Task()
  77           * Purpose: Main function
  78           * Params:
  79           * Returns:
  80           * Note:
  81           * ----------------------------------------------------------------------------
  82           */
  83          void HTTP_Task(void)
  84          {
  85   1      
  86   1      } /* End of HTTP_Task() */
  87          
  88          /*
  89           * ----------------------------------------------------------------------------
  90           * Function Name: HTTP_Init()
  91           * Purpose: Initialize HTTP server. 
  92           * Params:
  93           * Returns:
  94           * Note:
  95           * ----------------------------------------------------------------------------
  96           */
  97          void HTTP_Init(void)
  98          {
  99   1              U8_T    i;
 100   1      
 101   1              for (i = 0; i < MAX_HTTP_CONNECT; i++)
 102   1              {
 103   2                      HTTP_Connects[i].State = HTTP_STATE_FREE;
 104   2                      HTTP_Connects[i].FileId = 0xff;
 105   2                      HTTP_Connects[i].ContinueFlag = 0;
 106   2              }
 107   1      
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 3   

 108   1              HTTPtemp.InterFaceID = TCPIP_Bind(HTTP_NewConn, HTTP_Event, HTTP_Receive);
 109   1              TCPIP_TcpListen(HTTP_SERVER_PORT, HTTPtemp.InterFaceID);
 110   1      
 111   1              memset((U8_T*)&HTTPtemp, 0 , sizeof(HTTPtemp));
 112   1              FSYS_Init();
 113   1              HTTP_LoadSetting();
 114   1              if (GCONFIG_GetNetwork() & GCONFIG_NETWORK_ACC_IP_ENABLE)
 115   1                      HTTPtemp.AccessibleIP_EnableFlag = 1;
 116   1      //      printd("HTTP init ok.\n\r");
 117   1      
 118   1      } /* End of HTTP_Init() */
 119           
 120          /*
 121           * ----------------------------------------------------------------------------
 122           * Function Name: HTTP_NewConn()
 123           * Purpose: 
 124           * Params:
 125           * Returns:
 126           * Note:
 127           * ----------------------------------------------------------------------------
 128           */
 129          U8_T HTTP_NewConn(U32_T XDATA* pip, U16_T remotePort, U8_T socket)
 130          {
 131   1              U8_T    i;
 132   1      
 133   1              for (i = 0; i < MAX_HTTP_CONNECT; i++)
 134   1              {
 135   2                      if (HTTP_Connects[i].State == HTTP_STATE_FREE)
 136   2                      {
 137   3                              HTTP_Connects[i].State = HTTP_STATE_ACTIVE;
 138   3                              HTTP_Connects[i].Timer = (U16_T)SWTIMER_Tick();
 139   3                              HTTP_Connects[i].Ip = *pip;
 140   3                              HTTP_Connects[i].Port = remotePort;
 141   3                              HTTP_Connects[i].TcpSocket = socket;
 142   3      
 143   3                              return i;
 144   3                      }
 145   2              }
 146   1              return TCPIP_NO_NEW_CONN;
 147   1      } /* End of HTTP_NewConn() */
 148          
 149          /*
 150           * ----------------------------------------------------------------------------
 151           * Function Name: HTTP_Event()
 152           * Purpose: 
 153           * Params:
 154           * Returns:
 155           * Note:
 156           * ----------------------------------------------------------------------------
 157           */
 158          void HTTP_Event(U8_T id, U8_T event)
 159          {
 160   1              U8_T    fileId = HTTP_Connects[id].FileId;
 161   1              
 162   1              if (event < TCPIP_CONNECT_XMIT_COMPLETE)
 163   1              {
 164   2                      if (event == TCPIP_CONNECT_CANCEL)
 165   2                      {
 166   3                              if(0)
 167   3                              {
 168   4                              }
 169   3      /*====== for msgrestore.htm web page, start ====== */   //Add for redirection web page
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 4   

 170   3                              else if (fileId == FILE_MSGRESTORE)
 171   3                              {
 172   4      //                              printd("Restore and Reboot!!\n\r");
 173   4      //                              GCONFIG_ReadDefaultConfigData();
 174   4      //                              GCONFIG_WriteConfigData();
 175   4      //                              DELAY_Ms(500);
 176   4      //                              AX11000_SoftReboot();
 177   4      
 178   4                                      lcdreset();
 179   4                                      Lcd_Initial();
 180   4                                      Display_reboot();
 181   4                                      AX11000_SoftReboot();
 182   4      
 183   4                                      
 184   4                              }
 185   3      /*====== for msgrestore.htm web page, end ====== */     
 186   3      /*====== for msgupg.htm web page, start ====== */               
 187   3                              else if (fileId == FILE_MSGUPG)
 188   3                              {
 189   4      //                              printd("Upgrade\n\r");
 190   4      //                              GCONFIG_EnableFirmwareUpgrade();
 191   4      //                              GCONFIG_WriteConfigData();              
 192   4      //                              AX11000_SoftReboot();
 193   4      
 194   4                                      lcdreset();
 195   4                                      Lcd_Initial();
 196   4                                      Display_reboot();
 197   4                                      AX11000_SoftReboot();
 198   4      
 199   4      
 200   4                              }
 201   3      /*====== for msgupg.htm web page, end ====== */                         
 202   3      /*====== for msgreboot.htm web page, start ====== */    
 203   3                              else if (fileId == FILE_MSGREBOOT)                      
 204   3                              {
 205   4                              //      printd("Device Reboot!!\n\r");                  
 206   4                              //      DELAY_Ms(500);
 207   4                                      lcdreset();
 208   4                                      Lcd_Initial();
 209   4                                      Display_reboot();
 210   4                                      AX11000_SoftReboot();
 211   4                              }
 212   3      /*====== for msgreboot.htm web page, end ====== */                              
 213   3      /*====== for msgaccerr.htm web page, start ====== */
 214   3                              else if (fileId == FILE_MSGACCERR)                      
 215   3                              {
 216   4                                      printd ("Unaccessible error !!\n\r");
 217   4                              }                       
 218   3      /*====== for msgaccerr.htm web page, end ====== */
 219   3                      HTTP_Connects[id].State = event;
 220   3                      }
 221   2              }
 222   1              else if (event == TCPIP_CONNECT_XMIT_COMPLETE)
 223   1              {
 224   2                      U8_T*                   pSour;
 225   2                      static U16_T    dataLen;
 226   2      
 227   2                      if (HTTP_Connects[id].State == HTTP_STATE_SEND_HEADER)
 228   2                      {
 229   3                              {
 230   4                                      if (FSYS_Manage[fileId].FType & FILE_TYPE_BIN)
 231   4                                      {
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 5   

 232   5                                              HTTP_Connects[id].Divide.Fragment = 0;
 233   5                                      }
 234   4                                      else
 235   4                                      {
 236   5                                              HTTP_DivideHtmlFile(&HTTP_Connects[id], fileId);
 237   5                                      }
 238   4      
 239   4                                      pSour = FSYS_Manage[fileId].PBuf;
 240   4                                      dataLen = FSYS_Manage[fileId].FileSize;
 241   4      
 242   4                                      if (HTTP_Connects[id].Divide.Fragment == 0)
 243   4                                      {
 244   5                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_FINAL);
 245   5                                              HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 246   5                                      }
 247   4                                      else
 248   4                                      {
 249   5                                              HTTP_Connects[id].State = HTTP_STATE_SEND_DATA;
 250   5                                              HTTP_Connects[id].Divide.PData = pSour;
 251   5                                              HTTP_Connects[id].Divide.LeftLen = dataLen;
 252   5                                              HTTP_Connects[id].Divide.CurIndex = 0;
 253   5                                              HTTP_Connects[id].Divide.PadFlag = 0;
 254   5                                              goto SENDHTML;
 255   5                                      }
 256   4                              }
 257   3                      }
 258   2                      else if (HTTP_Connects[id].State == HTTP_STATE_SEND_DATA)
 259   2                      {
 260   3      SENDHTML:
 261   3                              {
 262   4                                      BUF_TEXT XDATA          *pText;
 263   4      //                              BUF_TAG XDATA*          pTag;
 264   4                                      U8_T*                           pSour = HTTP_Connects[id].Divide.PData;
 265   4                                      static U8_T XDATA       pTrue[] = " checked";
 266   4                                      static U8_T XDATA       pSele[] = " selected";                          
 267   4                                      static U16_T            leftLen;
 268   4                                      static U8_T                     index;
 269   4      
 270   4                                      leftLen = HTTP_Connects[id].Divide.LeftLen;
 271   4                                      index = HTTP_Connects[id].Divide.CurIndex;
 272   4                                      
 273   4                                      if (!HTTP_Connects[id].Divide.PadFlag)
 274   4                                      {
 275   5                                              if (index == 0)
 276   5                                                      dataLen = HTTP_Connects[id].Divide.Offset[index];
 277   5                                              else if (index == HTTP_Connects[id].Divide.Fragment)
 278   5                                                      dataLen = leftLen;
 279   5                                              else
 280   5                                                      dataLen = HTTP_Connects[id].Divide.Offset[index] - 
 281   5                                                              HTTP_Connects[id].Divide.Offset[index - 1];
 282   5      
 283   5                                              if (index == HTTP_Connects[id].Divide.Fragment)
 284   5                                              {
 285   6                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_FINAL);
 286   6                                                      HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 287   6                                              }
 288   5                                              else
 289   5                                              {
 290   6                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSour, dataLen, TCPIP_SEND_NOT_FINAL);
 291   6                                                      HTTP_Connects[id].Divide.PData += dataLen;
 292   6                                                      HTTP_Connects[id].Divide.LeftLen -= dataLen;
 293   6                                                      HTTP_Connects[id].Divide.PadFlag = 1;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 6   

 294   6                                              }
 295   5                                      }
 296   4                                      else
 297   4                                      {
 298   5                                              if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_RADIO)
 299   5                                              {
 300   6                                                      if (HTTP_Connects[id].Divide.SetFlag[index] == 1)
 301   6                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pTrue, 8, TCPIP_SEND_NOT_FINAL);
 302   6                                                      else if (HTTP_Connects[id].Divide.SetFlag[index] == 2)
 303   6                                                      {
 304   7                                                              if (*pSour == ' ')
 305   7                                                              {
 306   8                                                                      HTTP_Connects[id].Divide.PData += 8;
 307   8                                                                      HTTP_Connects[id].Divide.Offset[index] += 8;
 308   8                                                                      HTTP_Connects[id].Divide.LeftLen -= 8;
 309   8                                                              }
 310   7                                                              else
 311   7                                                              {
 312   8                                                                      HTTP_Connects[id].Divide.PData += 7;
 313   8                                                                      HTTP_Connects[id].Divide.Offset[index] += 7;
 314   8                                                                      HTTP_Connects[id].Divide.LeftLen -= 7;
 315   8                                                              }
 316   7                                                              HTTP_Connects[id].Divide.PadFlag = 0;
 317   7                                                              HTTP_Connects[id].Divide.CurIndex++;
 318   7                                                              goto SENDHTML;
 319   7                                                      }
 320   6                                              }
 321   5                                              else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_TEXT)
 322   5                                              {
 323   6                                                              pText = POST_Record[HTTP_Connects[id].Divide.RecordIndex[index]].PValue;
 324   6                                                              leftLen -= pText->DefaultLength;
 325   6                                                              if (!leftLen)
 326   6                                                              {
 327   7                                                                      TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pText->CurrValue, pText->CurrLength, TCPIP_SEND_FINAL);
 328   7                                                                      HTTP_Connects[id].State = HTTP_STATE_SEND_FINAL;
 329   7                                                                      return;
 330   7                                                              }
 331   6      
 332   6                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pText->CurrValue, pText->CurrLength, TCPIP_SEND_NOT_FINA
             -L);
 333   6                                                              HTTP_Connects[id].Divide.PData += pText->DefaultLength;
 334   6                                                              HTTP_Connects[id].Divide.Offset[index] += pText->DefaultLength;
 335   6                                                              HTTP_Connects[id].Divide.LeftLen =leftLen;
 336   6                                              }
 337   5      #if(MAX_POST_BUF_TAG)                                   
                                                      else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_TAG)
                                                      {
                                                              pTag = POST_Record[HTTP_Connects[id].Divide.RecordIndex[index]].PValue;
                                                              leftLen -= pTag->DefaultLength;
                                                              if(pTag->CurrLength)
                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pTag->CurrValue, pTag->CurrLength, TCPIP_SEND_NOT_FINAL);
                                                              HTTP_Connects[id].Divide.PData += pTag->DefaultLength;
                                                              HTTP_Connects[id].Divide.Offset[index] += pTag->DefaultLength;
                                                              HTTP_Connects[id].Divide.LeftLen =leftLen;
                                                              if(!pTag->CurrLength)
                                                              {
                                                                      HTTP_Connects[id].Divide.PadFlag = 0;
                                                                      HTTP_Connects[id].Divide.CurIndex++;
                                                                      goto SENDHTML;
                                                              }
                                                      } 
              #endif                                                                          
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 7   

 355   5                                              else if (HTTP_Connects[id].Divide.PostType[index] == POST_TYPE_SELECT)
 356   5                                              {
 357   6                                                      if (HTTP_Connects[id].Divide.SetFlag[index] == 1)
 358   6                                                      {
 359   7                                                              TCPIP_TcpSend(HTTP_Connects[id].TcpSocket, pSele, 9, TCPIP_SEND_NOT_FINAL);
 360   7                                                      }
 361   6                                                      else if (HTTP_Connects[id].Divide.SetFlag[index] == 2)
 362   6                                                      {
 363   7                                                              HTTP_Connects[id].Divide.PData += 9;
 364   7                                                              HTTP_Connects[id].Divide.Offset[index] += 9;
 365   7                                                              HTTP_Connects[id].Divide.LeftLen -= 9;
 366   7      
 367   7                                                              HTTP_Connects[id].Divide.PadFlag = 0;
 368   7                                                              HTTP_Connects[id].Divide.CurIndex++;
 369   7                                                              goto SENDHTML;
 370   7                                                      }
 371   6                                              }       
 372   5                                              HTTP_Connects[id].Divide.PadFlag = 0;
 373   5                                              HTTP_Connects[id].Divide.CurIndex++;
 374   5                                      }
 375   4                              }
 376   3                      }
 377   2                      else if (HTTP_Connects[id].State == HTTP_STATE_SEND_FINAL)
 378   2                      {
 379   3                              // HTTP_Connects[id].State = HTTP_STATE_FREE;
 380   3                      }
 381   2              }
 382   1      } /* End of HTTP_Event() */
 383          
 384          
 385          
 386          
 387          
 388          
 389          /*
 390           * ----------------------------------------------------------------------------
 391           * Function Name: StringCompare()
 392           * Purpose: 
 393           * Params:
 394           * Returns:
 395           * Note:
 396           * ----------------------------------------------------------------------------
 397           */
 398          U8_T StringCompare(U8_T XDATA* pData, U8_T XDATA* pStr, U8_T len)
 399          {
 400   1              U8_T    index;
 401   1      
 402   1              for (index = 0; index < len; index++)
 403   1              {
 404   2                      if (*pData++ != *pStr++) break;
 405   2              }
 406   1              if (index == len) return 1;
 407   1              
 408   1              return 0;
 409   1      } /* End of StringCompare() */
 410          
 411          /*
 412           * ----------------------------------------------------------------------------
 413           * Function Name: GHTTP_GetFile()
 414           * Purpose: 
 415           * Params:
 416           * Returns:
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 8   

 417           * Note:
 418           * ----------------------------------------------------------------------------
 419           */
 420          U8_T GHTTP_GetFile(U8_T XDATA** pData, U8_T XDATA** pFName, U8_T XDATA** pFNameExt, U16_T* length)
 421          {
 422   1              U8_T    c, find = 0;
 423   1              U8_T    parse_state = 0;
 424   1      
 425   1              c = **pData;
 426   1              while ((c != ' ') && (c != '\0') && (c != '\r') && (c != '\n'))
 427   1              {
 428   2                      switch(parse_state)
 429   2                      {
 430   3                      case 0:
 431   3                              if (c == '/' || c == '\\')
 432   3                              {
 433   4                                      parse_state = 1;
 434   4                                      *pFName = *pData + 1;
 435   4                              }
 436   3                              break;
 437   3                      case 1:
 438   3                              if (c == '?')
 439   3                              {
 440   4                                      find = 2;
 441   4                                      return find;
 442   4                              }
 443   3                              else if (c == '&')
 444   3                              {
 445   4                                      **pData = '\0';
 446   4                                      return find;
 447   4                              }
 448   3                              else
 449   3                              {
 450   4                                      if ((c == '+') || (c == '=')) return 0;
 451   4                                      /* a path, change it to '_' */
 452   4                                      else if ((c == '/') || (c == '\\')) **pData = '_';
 453   4                                      /* Remember where file extension starts. */
 454   4                                      else if (c == '.')
 455   4                                      {
 456   5                                              *pFNameExt = *pData + 1;
 457   5                                              find = 1;
 458   5                                      }
 459   4                              }
 460   3                              break;
 461   3                      }
 462   2                      (*pData)++;
 463   2                      (*length)--;
 464   2                      c = **pData;
 465   2              }
 466   1      
 467   1              return find;
 468   1      } /* End of GHTTP_GetFile() */
 469          
 470          /*
 471           * ----------------------------------------------------------------------------
 472           * Function Name: HTTP_LoadSetting()
 473           * Purpose:
 474           * Params:
 475           * Returns:
 476           * Note:
 477           * ----------------------------------------------------------------------------
 478           */
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 9   

 479          
 480          
 481          
 482          void HTTP_LoadSetting(void)
 483          {
 484   1      //      U32_T                           temp32;
 485   1              U16_T                           temp16;
 486   1              BUF_TEXT XDATA          *pText;
 487   1              BUF_SELECT XDATA        *pSelect;
 488   1              
 489   1              // Load IP address
 490   1              pText = POST_Record[RECORD_TEXT_static_ip].PValue;
 491   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetServerStaticIP(), pText->CurrValue);
 492   1              pText->CurrValue[pText->CurrLength ++] = '"';
 493   1              
 494   1              // Load subnet mask
 495   1              pText = POST_Record[RECORD_TEXT_mask].PValue;
 496   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetNetmask(), pText->CurrValue);
 497   1              pText->CurrValue[pText->CurrLength ++] = '"';
 498   1                      
 499   1              // Load gateway
 500   1              pText = POST_Record[RECORD_TEXT_gateway_ip].PValue;
 501   1              pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetGateway(), pText->CurrValue);
 502   1              pText->CurrValue[pText->CurrLength ++] = '"';
 503   1      
 504   1      //      // Load DNS
 505   1      //      pText = POST_Record[RECORD_TEXT_dns_ip].PValue;
 506   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetDNS(), pText->CurrValue);
 507   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 508   1      
 509   1      //      // Load server listen port
 510   1      //      pText = POST_Record[RECORD_TEXT_s_lstport].PValue;
 511   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetServerDataPktListenPort(), pText->CurrValue);
 512   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 513   1      
 514   1      //      // Load transmit timer
 515   1      //      pText = POST_Record[RECORD_TEXT_txtimer].PValue;
 516   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetEthernetTxTimer(), pText->CurrValue);
 517   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 518   1                      
 519   1      //      // Load destination port
 520   1      //      pText = POST_Record[RECORD_TEXT_c_desport].PValue;
 521   1      //      pText->CurrLength = HTTP_Short2Str(GCONFIG_GetClientDestPort(), pText->CurrValue);
 522   1      //      pText->CurrValue[pText->CurrLength ++] = '"';   
 523   1      
 524   1              // Load DHCP/Connection type/Connection mode/Accessiable control
 525   1              temp16 = GCONFIG_GetNetwork();
 526   1              
 527   1              pSelect = POST_Record[RECORD_SELECT_dhcp].PValue;               //Load DHCP control bit.
 528   1              pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_DHCP_ENABLE) ? 1 : 0;//+1 for web display
 529   1              
 530   1      //      pSelect = POST_Record[RECORD_SELECT_conntype].PValue;   //Load Connection type option.
 531   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_PROTO_TCP) ? 0 : 1;     
 532   1                      
 533   1      //      pSelect = POST_Record[RECORD_SELECT_cs_mode].PValue;    //Load client/Server mode option.
 534   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_CLIENT) ? 1 : 0;
 535   1      
 536   1      //      pSelect = POST_Record[RECORD_SELECT_acc_ipen].PValue;   //Load accessible IP control bit.
 537   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_NETWORK_ACC_IP_ENABLE) ? 1 : 0; 
 538   1      //              
 539   1      //      // Load serial setting
 540   1      //      temp16 = GCONFIG_GetSerialPort();
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 10  

 541   1      //
 542   1      //      pSelect = POST_Record[RECORD_SELECT_dbr].PValue;
 543   1      //      pSelect->CurrentSet = ((temp16 & 0xF800) >> 11);
 544   1      //
 545   1      //      pSelect = POST_Record[RECORD_SELECT_data].PValue;
 546   1      //      pSelect->CurrentSet = ((temp16 & 0x0700) >> 8);
 547   1      //
 548   1      //      pSelect = POST_Record[RECORD_SELECT_parity].PValue;
 549   1      //      pSelect->CurrentSet = ((temp16 & 0x00E0) >> 5);
 550   1      //
 551   1      //      pSelect = POST_Record[RECORD_SELECT_stop].PValue;
 552   1      //      pSelect->CurrentSet = ((temp16 & 0x0003));
 553   1      //
 554   1      //      pSelect = POST_Record[RECORD_SELECT_flow].PValue;
 555   1      //      pSelect->CurrentSet = ((temp16 & 0x0001C) >> 2);
 556   1      //
 557   1      //      // Load SMTP Domain name
 558   1      //      pText = POST_Record[RECORD_TEXT_email_addr].PValue;             
 559   1      //      pText->CurrLength = GCONFIG_GetSMTPDomainName(pText->CurrValue);
 560   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 561   1      //
 562   1      //      // Load SMTP From addr
 563   1      //      pText = POST_Record[RECORD_TEXT_email_from].PValue;
 564   1      //      pText->CurrLength = GCONFIG_GetSMTPFrom(pText->CurrValue);
 565   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 566   1      //              
 567   1      //      // Load SMTP To1 addr
 568   1      //      pText = POST_Record[RECORD_TEXT_email_to1].PValue;
 569   1      //      pText->CurrLength = GCONFIG_GetSMTPTo1(pText->CurrValue);
 570   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 571   1      //      
 572   1      //      // Load SMTP To2 addr
 573   1      //      pText = POST_Record[RECORD_TEXT_email_to2].PValue;
 574   1      //      pText->CurrLength = GCONFIG_GetSMTPTo2(pText->CurrValue);
 575   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 576   1      //      
 577   1      //      // Load SMTP To3 addr
 578   1      //      pText = POST_Record[RECORD_TEXT_email_to3].PValue;
 579   1      //      pText->CurrLength = GCONFIG_GetSMTPTo3(pText->CurrValue);
 580   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 581   1      //
 582   1      ////    // Load Destination host name
 583   1      ////    pText = POST_Record[RECORD_TEXT_c_deshn].PValue;                
 584   1      ////    pText->CurrLength = GCONFIG_GetDestHostName(pText->CurrValue);
 585   1      ////    pText->CurrValue[pText->CurrLength ++] = '"';   
 586   1      //      
 587   1      //      // Load FIle Name
 588   1      //      pText = POST_Record[RECORD_TEXT_file_name].PValue;
 589   1      //      GCONFIG_GetFilename(pText->CurrValue, 128);
 590   1      //      pText->CurrLength = strlen(pText->CurrValue);
 591   1      //      pText->CurrValue[pText->CurrLength ++] = '"';   
 592   1      //      
 593   1      //      // Load Auto Warning enable bits
 594   1      //      temp16 = GCONFIG_GetAutoWarning();
 595   1      //      
 596   1      //      pSelect = POST_Record[RECORD_SELECT_coldstart].PValue;  //Load cold start enable bit
 597   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_COLDSTART) ? 1 : 0;
 598   1      //                                      
 599   1      //      pSelect = POST_Record[RECORD_SELECT_authfail].PValue;   //Load authentication fail enable bit
 600   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_AUTH_FAIL) ? 1 : 0;
 601   1      //              
 602   1      //      pSelect = POST_Record[RECORD_SELECT_ipchg].PValue;              //Load IP changed enable bit
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 11  

 603   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_IP_CHANGED) ? 1 : 0;
 604   1      //              
 605   1      //      pSelect = POST_Record[RECORD_SELECT_pswchg].PValue;             //Load password changed enable bit
 606   1      //      pSelect->CurrentSet = (temp16 & GCONFIG_SMTP_EVENT_PSW_CHANGED) ? 1 : 0;
 607   1      //              
 608   1      //      // Accessible IP address 0~3
 609   1      //      pText = POST_Record[RECORD_TEXT_acc_ip1].PValue;
 610   1      //      GCONFIG_GetAccessibleIP(0,&temp32);
 611   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 612   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 613   1      //              
 614   1      //      pText = POST_Record[RECORD_TEXT_acc_ip2].PValue;
 615   1      //      GCONFIG_GetAccessibleIP(1,&temp32);
 616   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 617   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 618   1      //              
 619   1      //      pText = POST_Record[RECORD_TEXT_acc_ip3].PValue;
 620   1      //      GCONFIG_GetAccessibleIP(2,&temp32);
 621   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 622   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 623   1      //              
 624   1      //      pText = POST_Record[RECORD_TEXT_acc_ip4].PValue;
 625   1      //      GCONFIG_GetAccessibleIP(3,&temp32);
 626   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(temp32, pText->CurrValue);
 627   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 628   1      //      
 629   1      //      // Load rs485 control bits
 630   1      //      pSelect = POST_Record[RECORD_SELECT_rs485].PValue;
 631   1      //      pSelect->CurrentSet = GCONFIG_GetRs485Mode();
 632   1      //
 633   1      //      // Load Tftp Server IP
 634   1      //      pText = POST_Record[RECORD_TEXT_tftps_ip].PValue;
 635   1      //      pText->CurrLength = HTTP_Ulong2IpAddr(GCONFIG_GetTftpServerIp(), pText->CurrValue);
 636   1      //      pText->CurrValue[pText->CurrLength ++] = '"';
 637   1                                              
 638   1      } /* End of HTTP_LoadSetting() */
 639          
 640          
 641          /*
 642           * ----------------------------------------------------------------------------
 643           * Function Name: GHTTP_UserPost()
 644           * Purpose: 
 645           * Params:
 646           * Returns:
 647           * Note:
 648           * ----------------------------------------------------------------------------
 649           */
 650          U8_T http_UserPost(U8_T XDATA* pData, U16_T length, U8_T fileId, U8_T continueFlag)
 651          {
 652   1              BUF_SUBMIT XDATA        *pSubmit;
 653   1              BUF_TEXT XDATA          *pText;
 654   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA*        pRadio;
              #endif
 657   1      #if (MAX_POST_BUF_SELECT)
 658   1              BUF_SELECT XDATA*       pSelect;
 659   1      #endif  
 660   1              U16_T                           i;
 661   1              U8_T                            x, y, a, nameLen;
 662   1              U8_T                            status = 0, final = 0;
 663   1      
 664   1              U8_T index;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 12  

 665   1              U8_T tempchar;
 666   1              
 667   1              U8_T IPtemp[4]; 
 668   1      //      U16_T Porttemp;
 669   1              if (continueFlag)
 670   1                      goto MAPRECORD;
 671   1      
 672   1              if (length < 150)
 673   1              {
 674   2                      return HTTP_POST_FAILURE;
 675   2              }
 676   1      
 677   1              HTTPtemp.PostCnt = 0;
 678   1              if (*pData == '?')
 679   1              {
 680   2                      length -= 1;
 681   2                      pData += 1;
 682   2                      goto MAPRECORD;
 683   2              }
 684   1      /*
 685   1              if (length > 170) // parse the last 170 bytes
 686   1              {
 687   1                      length -= 170;
 688   1                      pData += length;
 689   1                      length = 170;           
 690   1              }
 691   1      */
 692   1              i = 0;
 693   1              while(i < length)
 694   1              {
 695   2                      while (1)
 696   2                      {
 697   3                              if ((pData[0]=='\r')&&(pData[1]=='\n')&&(pData[2]=='\r')&&(pData[3]=='\n'))//Find the two empty line.
 698   3                              {
 699   4                                      pData += 4;
 700   4                                      i += 4;
 701   4                                      if (i == length) return HTTP_POST_CONTINUE;
 702   4                                              
 703   4                                      break;
 704   4                              }
 705   3                              else
 706   3                              {
 707   4                                      pData++;
 708   4                                      i++;
 709   4                                      if ((i + 3) >= length) return HTTP_POST_FAILURE;
 710   4                              }
 711   3                      }
 712   2      MAPRECORD:
 713   2                      for (x = 0; x < MAX_POST_RECORDS; x++)
 714   2                      {
 715   3                              if (POST_Record[x].Occupy == 1)
 716   3                              {
 717   4                                      // check file id
 718   4                                      if (fileId != POST_Record[x].FileIndex)
 719   4                                      {
 720   5                                              if (POST_Record[x].FileIndex != 0xff)
 721   5                                              {
 722   6                                                      continue;
 723   6                                              }
 724   5                                      }
 725   4      
 726   4                                      for (y = 0; y < POST_Record[x].NameLen; y++)
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 13  

 727   4                                      {
 728   5                                              if (POST_Record[x].Name[y] != pData[y]) 
 729   5                                                      break;
 730   5                                      }
 731   4                                      if (y == POST_Record[x].NameLen)
 732   4                                      {
 733   5                                              if (pData[y] == '=')
 734   5                                              {
 735   6                                                      nameLen = (y + 1);
 736   6                                                      pData += nameLen;
 737   6                                                      i += nameLen;
 738   6      
 739   6                                                      switch (POST_Record[x].PostType)
 740   6                                                      {
 741   7                                                      case POST_TYPE_SUBMIT:
 742   7                                                              pSubmit = POST_Record[x].PValue;
 743   7                                                              for (a = 0; a < pSubmit->DefaultVlaueLen; a++)
 744   7                                                              {
 745   8                                                                      if (pSubmit->Value[a] != pData[a]) 
 746   8                                                                              break;
 747   8                                                              }
 748   7                                                              if (a == pSubmit->DefaultVlaueLen)
 749   7                                                              {
 750   8                                                                      HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
 751   8                                                                      HTTPtemp.PostCnt ++;
 752   8      
 753   8                                                                      printd ("SUBMIT\n\r");
 754   8      
 755   8                                                                      if (pSubmit->IsApply)
 756   8                                                                      {
 757   9                                                                              return (status ? HTTP_POST_FAILURE : HTTP_POST_SUCCESS);
 758   9                                                                      }
 759   8                                                                      else
 760   8                                                                              return HTTP_POST_CANCEL;
 761   8                                                              }
 762   7                                                              else
 763   7                                                              {
 764   8                                                                      pData -= nameLen;
 765   8                                                                      i -= nameLen;
 766   8      
 767   8                                                                      goto MAPRECORD;
 768   8                                                              }
 769   7                                                              break;
 770   7                                                      case POST_TYPE_TEXT:
 771   7                                                              pText = POST_Record[x].PValue;                                          
 772   7                                                              memset(HTTPtemp.Buf[0], 0, sizeof(HTTPtemp.Buf[0]));
 773   7                                                      index=0;
 774   7                                                              for (a = 0; a < MAX_POST_VALUE_LEN + 3; a++)
 775   7                                                              {
 776   8                                                                      if (pData[a] == '&')
 777   8                                                                              break;
 778   8                                                                      else if (pData[a] == ' ')
 779   8                                                                      {
 780   9                                                                              final = 1;
 781   9                                                                              break;
 782   9                                                                      }
 783   8      
 784   8                                                                      HTTPtemp.Buf[0][index] = pData[a];
 785   8      
 786   8                                                                      if(pData[a] == '%')
 787   8                                                                      {       
 788   9                                                                       if(isdigit(pData[a+1]))
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 14  

 789   9                                                                              tempchar = (pData[a+1] - '0') << 4;
 790   9                                                                       else
 791   9                                                                              tempchar = ((pData[a+1] - 'A') + 10) << 4;
 792   9                                
 793   9                                                                       if(isdigit(pData[a+2]))
 794   9                                                                              tempchar += (pData[a+2] - '0');
 795   9                                                                      else
 796   9                                                                              tempchar += ((pData[a+2] - 'A') + 10);
 797   9      
 798   9                                                                  HTTPtemp.Buf[0][index] = tempchar;
 799   9                                                                      a+=2;                           
 800   9                                                              }
 801   8                                                                      index++;
 802   8                                                              }
 803   7      
 804   7                                                              if (pText == NULL)      // username or password
 805   7                                                              {
 806   8      //------------------- Add for chack username & password function start -------------------------------
 807   8                                                                      if (fileId == FILE_INDEX)//If posted page is Authentication, get the username and password from we
             -b page.
 808   8                                                                      {
 809   9                                                                              if (RECORD_TEXT_username == x)
 810   9                                                                              {
 811  10                                                                                      HTTPtemp.UserNameLen = strlen(HTTPtemp.Buf[0]);
 812  10                                                                                      strncpy(HTTPtemp.UserName, HTTPtemp.Buf[0], HTTPtemp.UserNameLen + 1);//Include '\0' char
 813  10                                                                              }
 814   9                                                                              else if (RECORD_TEXT_password == x)
 815   9                                                                              {
 816  10                                                                                      HTTPtemp.PassWordLen = strlen(HTTPtemp.Buf[0]);
 817  10                                                                                      strncpy(HTTPtemp.PassWord, HTTPtemp.Buf[0], HTTPtemp.PassWordLen + 1);                                                                  
 818  10                                                                              }
 819   9                                                                              else
 820   9                                                                              {
 821  10                                                                                      return HTTP_POST_FAILURE;
 822  10                                                                              }
 823   9      //------------------- Add for chack username & password function end -------------------------------
 824   9      //------------------- Add for set new username & password function start -------------------------------
 825   9                                                                      }                       
 826   8                                                                      else if (fileId == FILE_SECURITY)
 827   8                                                                      {
 828   9                                                                              if (RECORD_TEXT_old_psw == x) // original password
 829   9                                                                              {
 830  10                                                                                      HTTPtemp.OldPassWordLen = strlen(HTTPtemp.Buf[0]);
 831  10                                                                                      strncpy(HTTPtemp.OldPassWord, HTTPtemp.Buf[0], HTTPtemp.OldPassWordLen + 1);//Include '\0' char
 832  10                                                                              }
 833   9                                                                              else if (RECORD_TEXT_new_psw == x) // set new password
 834   9                                                                              {
 835  10                                                                                      HTTPtemp.NewPassWordLen = strlen(HTTPtemp.Buf[0]);
 836  10                                                                                      strncpy(HTTPtemp.NewPassWord, HTTPtemp.Buf[0], HTTPtemp.NewPassWordLen + 1);
 837  10                                                                              }
 838   9                                                                              else if (RECORD_TEXT_cfm_psw == x) // set confirm password
 839   9                                                                              {
 840  10                                                                                      HTTPtemp.CfmPassWordLen = strlen(HTTPtemp.Buf[0]);
 841  10                                                                                      strncpy(HTTPtemp.CfmPassWord, HTTPtemp.Buf[0], HTTPtemp.CfmPassWordLen + 1);
 842  10      
 843  10                                                                              }
 844   9                                                                              else if (RECORD_TEXT_new_usn == x) // set new username
 845   9                                                                              {
 846  10                                                                                      HTTPtemp.NewUserNameLen = strlen(HTTPtemp.Buf[0]);
 847  10                                                                                      strncpy(HTTPtemp.NewUserName, HTTPtemp.Buf[0], HTTPtemp.NewUserNameLen + 1);
 848  10                                                                              }
 849   9                                                                              else
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 15  

 850   9                                                                              {
 851  10                                                                                      return HTTP_POST_FAILURE;
 852  10                                                                              }
 853   9                                                                      }
 854   8                                                                      else                                                                    
 855   8      //------------------- Add for set new username & password function end -------------------------------
 856   8                                                                      {
 857   9                                                                              return HTTP_POST_FAILURE;
 858   9                                                                      }
 859   8                                                              }
 860   7                                                              else
 861   7                                                              {
 862   8                                                                              strncpy(pText->UserValue, HTTPtemp.Buf[0], strlen(HTTPtemp.Buf[0]) + 1);//copy post data to user 
             -value include '\0' character.
 863   8                                                                              pText->UserLength = strlen(HTTPtemp.Buf[0]);//set user length not include '\0' character.
 864   8      /*====== for nrmsetting.htm web page, start ====== */
 865   8      //                                                                      if ((x == RECORD_TEXT_static_ip) ||
 866   8      //                                                                              (x == RECORD_TEXT_tftps_ip) ||                                                                  
 867   8      //                                                                              (x == RECORD_TEXT_dns_ip))
 868   8      
 869   8                                                                              if ((x == RECORD_TEXT_static_ip) ||
 870   8                                                                                      (x == RECORD_TEXT_tftps_ip))                                                                    
 871   8                                                                                                                                                      {
 872   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 873   9                                                                                      if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 874   9                                                                                      if ((IPtemp[0] == 0) || (IPtemp[0] > 223) || (IPtemp[3] == 0) || (IPtemp[3] == 255)) return HTTP
             -_POST_FAILURE;
 875   9                                                                              }
 876   8                                                                              else if (x == RECORD_TEXT_mask)
 877   8                                                                              {
 878   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 879   9                                                                                      if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 880   9                                                                                      if (IPtemp[0] != 255) return HTTP_POST_FAILURE;
 881   9                                                                                      if (IPtemp[0] >= 128)
 882   9                                                                                      {
 883  10                                                                                              if (IPtemp[1] != 255) return HTTP_POST_FAILURE;
 884  10                                                                                      }
 885   9                                                                              }
 886   8                                                                              else if (x == RECORD_TEXT_gateway_ip)
 887   8                                                                              {
 888   9                                                                                      *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);                                                                       
 889   9                                                                                      if (pText->UserLength)
 890   9                                                                                      {
 891  10                                                                                              if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 892  10       //                                                                                     if ((IPtemp[3] == 0) || (IPtemp[3] == 255)) return HTTP_POST_FAILURE;
 893  10                                                                                      }
 894   9                                                                              }
 895   8      //                                                                 else if      ((x == RECORD_TEXT_s_lstport) ||
 896   8      //                                                                                       (x == RECORD_TEXT_c_desport))
 897   8      //                                                                      {
 898   8      //                                                                              Porttemp = HTTP_Str2Short(pText->UserValue, pText->UserLength);
 899   8      //                                                                              if (Porttemp < 1024) return HTTP_POST_FAILURE;
 900   8      //                                                                              
 901   8      //                                                                      }
 902   8      //                                                                      else if ((x == RECORD_TEXT_acc_ip1) ||
 903   8      //                                                                                       (x == RECORD_TEXT_acc_ip2) ||
 904   8      //                                                                                       (x == RECORD_TEXT_acc_ip3) ||
 905   8      //                                                                                       (x == RECORD_TEXT_acc_ip4))
 906   8      //                                                                      {
 907   8      //                                                                              *(U32_T*)IPtemp = HTTP_IpAddr2Ulong(pText->UserValue, pText->UserLength);
 908   8      //                                                                              if (*(U32_T*)IPtemp == 0xffffffff) return HTTP_POST_FAILURE;
 909   8      ////                                                                            if ((IPtemp[3] == 255)) return HTTP_POST_FAILURE;                                                                       
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 16  

 910   8      //                                                              }
 911   8      /*====== for nrmsetting.htm web page, end ====== */
 912   8                                                              }
 913   7                                                              if (strlen(HTTPtemp.Buf[0]) == MAX_POST_VALUE_LEN)
 914   7                                                              {
 915   8                                                                      if ((pData[a] != '&') && (pData[a] != ' '))
 916   8                                                                      {
 917   9                                                                              printd ("TEXT_FALSE\n\r");
 918   9                                                                              status = 1;
 919   9                                                                              pData += a;
 920   9                                                                              i += a;
 921   9      
 922   9                                                                              while ((*pData != '&') && (*pData != 0xa) && (*pData != 0xd))
 923   9                                                                              {
 924  10                                                                                      pData++;
 925  10                                                                                      i++;
 926  10                                                                              }
 927   9      
 928   9                                                                              pData++;
 929   9                                                                              i++;
 930   9      
 931   9                                                                              goto MAPRECORD;
 932   9                                                                      }
 933   8                                                                      else if (pData[a] == ' ') final = 1;
 934   8                                                              }
 935   7                                                              printd ("POST_TEXT: %s\n\r", HTTPtemp.Buf[0]);
 936   7                                                              HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
 937   7                                                              HTTPtemp.PostCnt ++;
 938   7                                                              if (final == 1)
 939   7                                                              {
 940   8                                                                      return (status ? HTTP_POST_FAILURE : HTTP_POST_SUCCESS);                                                                        
 941   8                                                              }
 942   7                                                              pData += (a + 1);
 943   7                                                              i += (a + 1);
 944   7                                                              goto MAPRECORD;
 945   7                                                              break;
 946   7      #if (MAX_POST_BUF_RADIO)
                                                              case POST_TYPE_RADIO:
                                                                      pRadio = POST_Record[x].PValue;
                                                                      for (j = 0; j < pRadio->Count; j++)
                                                                      {
                                                                                      for (a = 0; a < pRadio->Length[j]; a++)
                                                                              {
                                                                                      if (pRadio->Value[j][a] != pData[a]) break;
                                                                              }
                                                                              if (a == pRadio->Length[j])
                                                                              {
                                                                                      pData += (a + 1);
                                                                                      i += (a + 1);
                                                                                      pRadio->UserSet = j;
                                                                                      HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
                                                                                      HTTPtemp.PostCnt ++;
              
                                                                                      printd ("Radio item : %bx\n\r", j);
              
                                                                                      goto MAPRECORD;
                                                                              }
                                                                      }
                                                                      return HTTP_POST_FAILURE;
                                                                      break;
              #endif
 971   7      #if (MAX_POST_BUF_SELECT)
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 17  

 972   7                                                      case POST_TYPE_SELECT:
 973   7                                                              pSelect = POST_Record[x].PValue;
 974   7      
 975   7                                                              pSelect->UserSet = (*pData) - 0x30;
 976   7      
 977   7                                                              if (pSelect->UserSet >= pSelect->Count)
 978   7                                                                      return HTTP_POST_FAILURE;
 979   7      
 980   7                                                              pData++;
 981   7                                                              i++;
 982   7      
 983   7                                                              if (*pData != '&')
 984   7                                                              {
 985   8                                                                      /* support select item > 10 */
 986   8                                                                      if ((*pData >= '0') && (*pData <= '9'))
 987   8                                                                      {
 988   9                                                                              pSelect->UserSet *= 10;
 989   9                                                                              pSelect->UserSet += ((*pData) - 0x30);
 990   9                                                                              if (pSelect->UserSet >= pSelect->Count)
 991   9                                                                                      return HTTP_POST_FAILURE;
 992   9      
 993   9                                                                              pData++;
 994   9                                                                              i++;
 995   9                                                                      }
 996   8      
 997   8                                                                      if (*pData != '&')
 998   8                                                                      {
 999   9                                                                              while ((*pData != '&') && (*pData != 0xa) && (*pData != 0xd))
1000   9                                                                              {
1001  10                                                                                      pData++;
1002  10                                                                                      i++;
1003  10                                                                              }
1004   9      
1005   9                                                                              pData++;
1006   9                                                                              i++;
1007   9      
1008   9                                                                              goto MAPRECORD;
1009   9                                                                      }
1010   8                                                              }
1011   7      
1012   7                                                              pData++;
1013   7                                                              i++;
1014   7                                                              HTTPtemp.PostTable[HTTPtemp.PostCnt] = x;
1015   7                                                              HTTPtemp.PostCnt ++;
1016   7                                                              printd("POST_SELECT: %bu\n\r", pSelect->UserSet);
1017   7                                                              goto MAPRECORD;
1018   7                                                              break;
1019   7      #endif
1020   7                                                      default:
1021   7                                                              break;
1022   7                                                      }
1023   6                                              }
1024   5                                      }
1025   4                              }
1026   3                      }
1027   2              }                       
1028   1              return HTTP_POST_FAILURE;                                                                                                                                                               
1029   1      } /* End of GHTTP_UserPost() */
1030          
1031          /*
1032           * ----------------------------------------------------------------------------
1033           * Function Name: http_PostVal()
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 18  

1034           * Purpose: 
1035           * Params:
1036           * Returns:
1037           * Note:
1038           * ----------------------------------------------------------------------------
1039           */
1040          U8_T http_PostVal(U8_T XDATA* pData, U16_T length,U8_T Continue_Flag )
1041          {
1042   1        U8_T* pTemp;
1043   1        U8_T idx,index;
1044   1        U16_T temp;
1045   1        U8_T tempchar;
1046   1        
1047   1        num_parms=0;
1048   1        pData[length]=0x0;
1049   1      
1050   1        if(!Continue_Flag)
1051   1        {
1052   2              for(temp=0;temp<length;temp++)
1053   2              {
1054   3                      if((pData[temp]=='\r') && (pData[temp+1]=='\n') && (pData[temp+2]=='\r') && (pData[temp+3]=='\n')) break
             -;
1055   3              }
1056   2              if(temp==length) return HTTP_POST_FAILURE;
1057   2              pData+=temp+4;
1058   2        }
1059   1        
1060   1        idx=0;
1061   1        while (*pData != 0x0)
1062   1        {
1063   2          entries[idx].name = pData;
1064   2          pTemp = strchr(pData, '=');
1065   2          if (!pTemp) break;
1066   2          pData=pTemp;
1067   2          *pData++ = 0x0;
1068   2          entries[idx].val = pData;
1069   2                      
1070   2          while (*pData != 0x0)
1071   2          {
1072   3            if (*pData == '\r') *pData++= 0x0;
1073   3            if (*pData == '&')
1074   3            {
1075   4              *pData++ = 0x0;    
1076   4              if (*pData == 0x0d) pData +=2;  //for \r\n
1077   4              break;
1078   4            }
1079   3            pData++;
1080   3          }
1081   2      
1082   2          /* convert  '+' to spaces */
1083   2          pTemp = entries[idx].val;
1084   2          for (; *pTemp != 0x0; pTemp++)
1085   2            if (*pTemp == '+') *pTemp = ' '; 
1086   2                      
1087   2          /* convert  '%XX' */
1088   2          memset(HTTPtemp.Buf[0], 0, sizeof(HTTPtemp.Buf[0]));
1089   2          index=0;
1090   2          for (pTemp = entries[idx].val ; *pTemp != 0x0 ; pTemp++)
1091   2          {
1092   3            HTTPtemp.Buf[0][index] = *pTemp;
1093   3            if (*pTemp == '%')
1094   3            { 
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 19  

1095   4              if (isdigit(*(pTemp+1)))
1096   4                tempchar = (*(pTemp+1) - '0') << 4;
1097   4              else
1098   4                tempchar = ((*(pTemp+1) - 'A') + 10) << 4;
1099   4                                
1100   4              if (isdigit(*(pTemp+2)))
1101   4                tempchar += (*(pTemp+2) - '0');
1102   4              else
1103   4                tempchar += ((*(pTemp+2) - 'A') + 10);
1104   4      
1105   4              HTTPtemp.Buf[0][index] = tempchar;
1106   4              pTemp+=2;                               
1107   4            }
1108   3            index ++;
1109   3          }
1110   2          strncpy(entries[idx].val, HTTPtemp.Buf[0], strlen(HTTPtemp.Buf[0])+1 );
1111   2          idx++;
1112   2        }
1113   1      
1114   1        if(idx==0) return HTTP_POST_CONTINUE; 
1115   1        num_parms=idx;
1116   1        return  0;
1117   1      } /* End of http_PostVal() */
1118          
1119          /*
1120           * ----------------------------------------------------------------------------
1121           * Function Name: HTTP_Receive()
1122           * Purpose: 
1123           * Params:
1124           * Returns:
1125           * Note:
1126           * ----------------------------------------------------------------------------
1127           */
1128          void HTTP_Receive(U8_T XDATA* pData, U16_T length, U8_T conn_id)
1129          {
1130   1              HTTP_SERVER_CONN XDATA* pHttpConn = &HTTP_Connects[conn_id];
1131   1              U8_T XDATA                              str_post[] = {"POST"};
1132   1              U8_T                                    command, status, fileId, index, fileStatus;
1133   1              U8_T XDATA*                             pFName;
1134   1              U8_T XDATA*                             pFNameExt;
1135   1              U8_T CODE*                              pSour;
1136   1              U8_T                                    *pExpanSour;
1137   1              U16_T                                   data_len;
1138   1              U8_T i, j;
1139   1          U16_T num_parms=0;
1140   1              
1141   1              U32_T AccIP;
1142   1                              
1143   1              if (pHttpConn->State < HTTP_STATE_ACTIVE) return;
1144   1              
1145   1              if (pHttpConn->ContinueFlag)
1146   1              {
1147   2                      fileId = pHttpConn->ContinueFileId;
1148   2                      goto POST_START;
1149   2              }
1150   1              
1151   1              if (length < 14) return;
1152   1      
1153   1              if (StringCompare(pData, str_post, 4))
1154   1              {
1155   2                      command = HTTP_CMD_POST;
1156   2                      pData += 5;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 20  

1157   2                      length -= 5;
1158   2              }
1159   1              else
1160   1              {
1161   2                      command = HTTP_CMD_GET;
1162   2                      pData += 4;
1163   2                      length -= 4;
1164   2              }
1165   1      
1166   1              /* skip space */
1167   1              while (*pData == ' ')
1168   1                      pData++;
1169   1      
1170   1              fileId = MAX_STORE_FILE_NUM;
1171   1              fileStatus = GHTTP_GetFile(&pData, &pFName, &pFNameExt, &length);
1172   1              
1173   1              if (fileStatus)
1174   1                      fileId = FSYS_FindFile(pFName);
1175   1      
1176   1      //-----  Add for accessible IP function start ------    
1177   1              if ((HTTPtemp.AccessibleIP_EnableFlag != 0) && (FSYS_Manage[fileId].FType == FILE_TYPE_HTML))
1178   1              {
1179   2                      for (i = 0 ; i < GCONFIG_ACCESSIBLE_IP_NUM ; i ++)
1180   2                      {
1181   3                              GCONFIG_GetAccessibleIP(i, &AccIP);
1182   3                              if (pHttpConn->Ip == AccIP) break;
1183   3                      }
1184   2      
1185   2                      if (i == GCONFIG_ACCESSIBLE_IP_NUM)
1186   2                      {
1187   3                              fileId = FILE_MSGACCERR;
1188   3                              goto HTTP_TX_HEADER;
1189   3                      }
1190   2              }
1191   1      //-----  Add for accessible IP function end ------
1192   1      //--------- Add for user link to not index page directly start ----------------------------------------
1193   1      //      if ((fileId != FILE_INDEX) && (FSYS_Manage[fileId].FType == FILE_TYPE_HTML))
1194   1      //      {
1195   1      //              for (i = 0; i < 4; i++)
1196   1      //              {
1197   1      //                      if (HTTPtemp.AuthenIP[i] == pHttpConn->Ip) break;
1198   1      //              }
1199   1      //              if (i == 4)//not found in table.
1200   1      //              {
1201   1      //              //      fileId = FILE_JMPINDEX;      /* jump */
1202   1      //                      fileId = FILE_BSCSETTING;
1203   1      //
1204   1      //                      goto HTTP_TX_HEADER;                                    
1205   1      //              }
1206   1      //      }
1207   1      //--------- Add for user link to not index page directly end ----------------------------------------   
1208   1              if (fileStatus == 2) /* for GET /XXX.XXX?--- mode */
1209   1                      goto POST_START;
1210   1      
1211   1              if (command == HTTP_CMD_POST)
1212   1              {
1213   2      POST_START:
1214   2                      if (fileId == MAX_STORE_FILE_NUM)
1215   2                      {
1216   3                              printd ("POST error file not found.\n\r");
1217   3                              TCPIP_TcpClose(pHttpConn->TcpSocket); /*RST | ACK*/
1218   3                              pHttpConn->State = HTTP_STATE_FREE;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 21  

1219   3                              return;
1220   3                      }
1221   2                      
1222   2                      if(FSYS_Manage[fileId].CgiRef==0xff)
1223   2                      {
1224   3                              status = http_PostVal(pData, length, pHttpConn->ContinueFlag);
1225   3      
1226   3                              if (status == HTTP_POST_CONTINUE)
1227   3                              {
1228   4                                      printd ("POST continue.\n\r");
1229   4                                      pHttpConn->ContinueFlag = 1;
1230   4                                      pHttpConn->ContinueFileId = fileId;
1231   4                                      return;
1232   4                              }
1233   3      
1234   3                              i=0;
1235   3                              while(i<num_parms)
1236   3                              {
1237   4                                      printd("entry[%02bx]=%s,%s\n",i,entries[i].name,entries[i].val);
1238   4                                      i++;
1239   4                              }  
1240   3                              pHttpConn->ContinueFlag = 0;
1241   3      
1242   3                              if (status == HTTP_POST_FAILURE)
1243   3                              {
1244   4                                      printd ("POST error data0.\n\r");
1245   4      
1246   4                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1247   4                                      pHttpConn->State = HTTP_STATE_FREE;
1248   4                                      return;
1249   4                              }
1250   3                      }       
1251   2                      else
1252   2                      {
1253   3                              /* look for Referer */
1254   3                              status = http_UserPost(pData, length, FSYS_Manage[fileId].CgiRef, pHttpConn->ContinueFlag);
1255   3      
1256   3                              if (status == HTTP_POST_SUCCESS)
1257   3                              {
1258   4                                      pHttpConn->ContinueFlag = 0;
1259   4      
1260   4      /*====== for index.htm web page, start ====== */
1261   4                                      if (fileId == FILE_INDEX)
1262   4                                      {
1263   5                                              status = HTTP_CheckPassWord(pHttpConn);
1264   5                                              if (status == HTTP_POST_FAILURE)
1265   5                                              {
1266   6      #if (INCLUDE_EVENT_DETECT)
1267   6      //                                              GEVENT_SetAuthFailEvent(1);//*** Add for authentication fail detect ***                                 
1268   6      #endif
1269   6                                                      fileId = FILE_MSGAUTHERR;
1270   6                                              }
1271   5                                              else
1272   5                                              {
1273   6                                                      fileId = FILE_MSGAUTHOK;
1274   6                                              }
1275   5                                      }
1276   4      /*====== for index.htm web page, end ====== */
1277   4      /*====== for security.htm web page, start ====== */
1278   4                                      else if (fileId == FILE_SECURITY)
1279   4                                      {
1280   5                                              if ((HTTPtemp.PostTable[0] == RECORD_TEXT_old_psw) &&
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 22  

1281   5                                                      (HTTPtemp.PostTable[1] == RECORD_TEXT_new_psw) &&
1282   5                                                      (HTTPtemp.PostTable[2] == RECORD_TEXT_cfm_psw) && 
1283   5                                                      (HTTPtemp.PostCnt == 4))
1284   5                                              {
1285   6                                                      status = HTTP_CheckNewPassword();
1286   6                                                      fileId = (status == HTTP_POST_FAILURE) ? FILE_MSGSCTERR : FILE_MSGUNPWOK;
1287   6                                              }
1288   5                                              else if ((HTTPtemp.PostTable[0] == RECORD_TEXT_new_usn) &&
1289   5                                                               (HTTPtemp.PostCnt == 2))
1290   5                                              {
1291   6                                                      status = HTTP_CheckNewUsername();
1292   6                                                      fileId = (status == HTTP_POST_FAILURE) ? FILE_MSGSCTERR : FILE_MSGUNPWOK;
1293   6                                              }
1294   5                                              else
1295   5                                                      goto POST_NORM;
1296   5                                      }
1297   4                                      else
1298   4                                      {
1299   5      /*====== for security.htm web page, end ====== */                               
1300   5      POST_NORM:
1301   5                                              status = HTTP_NewConfig();
1302   5      /*====== for msgreboot.htm web page, start ====== */
1303   5                                              if (fileId == FILE_BSCSETTING)
1304   5                                              {
1305   6                                                      if (HTTPtemp.SysRebootFlag)
1306   6                                                      {
1307   7                                                              HTTPtemp.SysRebootFlag = 0;
1308   7                                                              fileId = FILE_MSGREBOOT;
1309   7                                                      }
1310   6                                              }
1311   5      /*====== for msgreboot.htm web page, end ====== */
1312   5      /*====== for advsetting.htm web page, start ====== */
1313   5                                              else if (fileId == FILE_ADVSETTING)
1314   5                                              {
1315   6                                                      for (i = 0; i < HTTPtemp.PostCnt ; i ++)
1316   6                                                      {
1317   7                                                              j = HTTPtemp.PostTable[i];
1318   7                                                              if (!strncmp("upgrade", POST_Record[j].Name, POST_Record[j].NameLen))
1319   7                                                              {
1320   8                                                                      fileId = FILE_MSGUPG;
1321   8                                                                      break;
1322   8                                                              }
1323   7                                                      }
1324   6                                              }
1325   5      /*====== for advsetting.htm web page, end ====== */
1326   5                                      }
1327   4                              }
1328   3                              else if (status == HTTP_POST_CONTINUE)
1329   3                              {
1330   4                                      printd ("POST continue.\n\r");                  
1331   4                                      pHttpConn->ContinueFlag = 1;
1332   4                                      pHttpConn->ContinueFileId = fileId;
1333   4                                      return;
1334   4                              }
1335   3                              else if (status == HTTP_POST_FAILURE)
1336   3                              {
1337   4                                      pHttpConn->ContinueFlag = 0;                            
1338   4                                      printd ("POST error data1.\n\r");
1339   4      
1340   4                                      if (fileId == FILE_ADVSETTING)
1341   4                                              fileId = FILE_MSGADVERR;
1342   4                                      else if (fileId == FILE_BSCSETTING)
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 23  

1343   4                                              fileId = FILE_MSGBSCERR;
1344   4                                      else if (fileId == FILE_SECURITY)
1345   4                                              fileId = FILE_MSGSCTERR;
1346   4                                      else
1347   4                                      {
1348   5                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1349   5                                      pHttpConn->State = HTTP_STATE_FREE;
1350   5                                      return;
1351   5                              }
1352   4                      }
1353   3              }
1354   2              }
1355   1      
1356   1              if (command == HTTP_CMD_GET)
1357   1              {
1358   2      
1359   2                      if (fileStatus)
1360   2                      {
1361   3                              if (fileId == MAX_STORE_FILE_NUM)
1362   3                              {
1363   4                                      /* not find file, send reset */
1364   4                                      TCPIP_TcpClose(pHttpConn->TcpSocket);/* RST | ACK*/
1365   4                                      pHttpConn->State = HTTP_STATE_FREE;
1366   4                                      return;
1367   4                              }
1368   3      //--------- Add for delete validated IP when user logout start ----------------------------------------                 
1369   3                              else if (fileId == FILE_INDEX)
1370   3                              {
1371   4                                      for (i = 0; i < 4; i++)
1372   4                                      {
1373   5                                              if (HTTPtemp.AuthenIP[i] == pHttpConn->Ip)
1374   5                                                      HTTPtemp.AuthenIP[i] = 0;
1375   5                                      }
1376   4                              }
1377   3      //--------- Add for delete validated IP when user logout end ----------------------------------------                                   
             -        
1378   3                      }
1379   2                      else
1380   2                      {
1381   3      //--------- Add for user link to a web page not specify file name start ----------------------------------
             -------
1382   3                              fileId = FILE_JMPINDEX;
1383   3      //--------- Add for user link to a web page not specify file name end ------------------------------------
             -----
1384   3                      }
1385   2              }
1386   1      
1387   1          //call cgi function
1388   1              if(FSYS_Manage[fileId].CgiCall)
1389   1              {
1390   2                      void (*pF)(void);
1391   2                      pF= FSYS_Manage[fileId].CgiCall;
1392   2                      pF();
1393   2              }
1394   1              
1395   1              // update data in some web page
1396   1              {
1397   2                      U8_T i;
1398   2      
1399   2                      for (i = 0; i < MAX_POST_RECORDS; i++)
1400   2                      {
1401   3                              if (fileId == POST_Record[i].FileIndex)
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 24  

1402   3                              {
1403   4                                      if ((POST_Record[i].UpdateSelf == TRUE) && (POST_Record[i].PostType == POST_TYPE_TAG))
1404   4                                      {
1405   5                                              void *pValue = POST_Record[i].PValue;
1406   5                                              void (*f)(void *pWebData);
1407   5                                              f = fun_tbl[i];
1408   5                                              f(pValue);
1409   5                                      }
1410   4                              }
1411   3                      }
1412   2              }
1413   1      HTTP_TX_HEADER: 
1414   1              pHttpConn->FileId = fileId;
1415   1      
1416   1              /* begin send html and jpg header */
1417   1              if (FSYS_Manage[fileId].FType & FILE_TYPE_BIN)
1418   1              {
1419   2                      data_len = (U32_T)FSYS_Manage[fileId].FileSize;
1420   2      
1421   2                      index = 5;
1422   2                      while (index > 0)
1423   2                      {
1424   3                              index--;
1425   3                              ImageHeader[ImageByteCountOffset + index] = (U8_T)((data_len%10) + 0x30);
1426   3                              data_len /= 10;
1427   3                      }
1428   2                      
1429   2                      if (FSYS_Manage[fileId].FType == FILE_TYPE_CSS)
1430   2                      {
1431   3                              data_len = (U32_T)CSSHeaderLen;
1432   3                              pExpanSour = CSSHeader;
1433   3                      }
1434   2                      else
1435   2                      { 
1436   3                              data_len = (U32_T)ImageHeaderLen;
1437   3                              pExpanSour = ImageHeader;
1438   3                      }
1439   2                      TCPIP_TcpSend(pHttpConn->TcpSocket, pExpanSour, data_len, TCPIP_SEND_NOT_FINAL);
1440   2              }
1441   1              else
1442   1              {
1443   2                      if (FSYS_Manage[fileId].FType == FILE_TYPE_JS)
1444   2                      {
1445   3                              data_len = (U32_T)JsHeaderLen;
1446   3                              pSour = JsHeader;
1447   3                      }
1448   2                      else
1449   2                      { 
1450   3                              HTTP_LoadSetting();
1451   3                              data_len = (U32_T)HtmlHeaderLen;
1452   3                              pSour = HtmlHeader;
1453   3                      }
1454   2                      TCPIP_TcpSend(pHttpConn->TcpSocket, pSour, data_len, TCPIP_SEND_NOT_FINAL);
1455   2              }
1456   1      
1457   1              pHttpConn->State = HTTP_STATE_SEND_HEADER;
1458   1      
1459   1      } /* End of HTTP_Receive() */
1460          
1461          /*
1462           * ----------------------------------------------------------------------------
1463           * Function Name: HTTP_DivideHtmlFile()
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 25  

1464           * Purpose: 
1465           * Params:
1466           * Returns:
1467           * Note:
1468           * ----------------------------------------------------------------------------
1469           */
1470          void HTTP_DivideHtmlFile(HTTP_SERVER_CONN XDATA* pHttpConn, U8_T id)
1471          {
1472   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA         *pRadio;
              #endif
1475   1              BUF_TEXT XDATA          *pText;
1476   1      #if (MAX_POST_BUF_SELECT)       
1477   1              BUF_SELECT XDATA        *pSelect;
1478   1      #endif
1479   1              BUF_TAG XDATA           *pTag;
1480   1              U8_T                            tableIndex = 0;
1481   1              U8_T                            i, k;
1482   1      
1483   1              {
1484   2                      for (i = 0; i < MAX_POST_RECORDS; i++)
1485   2                      {
1486   3                              if (id != POST_Record[i].FileIndex)
1487   3                                      continue;
1488   3      //--------------- Ignore process for non-data structure item start -----------------------
1489   3                              if ((i == RECORD_TEXT_old_psw) || 
1490   3                                      (i == RECORD_TEXT_new_psw) || 
1491   3                                      (i == RECORD_TEXT_cfm_psw) || 
1492   3                                      (i == RECORD_TEXT_username) ||
1493   3                                      (i == RECORD_TEXT_password) ||
1494   3                                      (i == RECORD_TEXT_new_usn))
1495   3                                      continue;
1496   3      //--------------- Ignore process for non-data structure item end -------------------------
1497   3                              if (POST_Record[i].PostType == POST_TYPE_TEXT)
1498   3                              {
1499   4                                      U8_T    *pData;
1500   4      
1501   4                                              pText = POST_Record[i].PValue;
1502   4                                              if ((!pText) || (pText->DefaultLength == 0) || (pText->CurrLength == 0) ||
1503   4                                                      ((pText->CurrLength == 1) && (pText->DefaultLength == 1))) continue;
1504   4      
1505   4                                              pData = FSYS_Manage[id].PBuf + pText->Offset;
1506   4                                              if (pText->CurrLength == pText->DefaultLength)
1507   4                                              {
1508   5                                                      for (k = 0; k < pText->CurrLength; k++)
1509   5                                                      {
1510   6                                                              if (pData[k] != pText->CurrValue[k]) break;
1511   6                                                      }
1512   5                                                      if (k == pText->CurrLength)     continue;
1513   5                                              }
1514   4                                                                      
1515   4                                              pHttpConn->Divide.Offset[tableIndex] = pText->Offset;
1516   4                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1517   4                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_TEXT;
1518   4      
1519   4                                      tableIndex++;
1520   4                              }
1521   3                              else if (POST_Record[i].PostType == POST_TYPE_TAG)
1522   3                              {
1523   4                                      
1524   4                                      pTag = POST_Record[i].PValue;
1525   4                                      if (pTag->DefaultLength == 0)
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 26  

1526   4                                              continue;
1527   4                                      pHttpConn->Divide.Offset[tableIndex] = pTag->Offset;
1528   4                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1529   4                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_TAG;
1530   4      
1531   4                                      tableIndex++;
1532   4                              }
1533   3      #if (MAX_POST_BUF_RADIO)        
                                      else if (POST_Record[i].PostType == POST_TYPE_RADIO)
                                      {
                                              pRadio = POST_Record[i].PValue;
                                              if (pRadio->DefaultSet == pRadio->CurrentSet)
                                                      continue;
                                      
                                              for (k = 0; k < pRadio->Count; k++)
                                              {
                                                      pHttpConn->Divide.Offset[tableIndex] = pRadio->Offset[k];
                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_RADIO;
                                                      if (pRadio->CurrentSet == k)
                                                      {
                                                              pHttpConn->Divide.SetFlag[tableIndex] = 1;
                                                              tableIndex++;
                                                      }
                                                      else if (pRadio->DefaultSet == k)
                                                      {
                                                              pHttpConn->Divide.SetFlag[tableIndex] = 2;
                                                              tableIndex++;
                                                      }
                                              }
                                      }
              #endif
1558   3      #if (MAX_POST_BUF_SELECT)
1559   3                              else if (POST_Record[i].PostType == POST_TYPE_SELECT)
1560   3                              {
1561   4                                      pSelect = POST_Record[i].PValue;
1562   4                                      if ((pSelect->DefaultSet == pSelect->CurrentSet) ||
1563   4                                                      (pSelect->CurrentSet >= pSelect->Count))
1564   4                                      {
1565   5                                              continue;
1566   5                                      }
1567   4                                      for (k = 0; k < pSelect->Count; k++)
1568   4                                      {
1569   5                                              if (pSelect->DefaultSet == k)
1570   5                                              {
1571   6                                                      pHttpConn->Divide.Offset[tableIndex] = pSelect->Offset[k];
1572   6                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1573   6                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_SELECT;
1574   6                                                      pHttpConn->Divide.SetFlag[tableIndex] = 2;
1575   6                                                      tableIndex++;
1576   6                                              }
1577   5                                              else if (pSelect->CurrentSet == k)
1578   5                                              {
1579   6                                                      pHttpConn->Divide.Offset[tableIndex] = pSelect->Offset[k];
1580   6                                                      pHttpConn->Divide.RecordIndex[tableIndex] = i;
1581   6                                                      pHttpConn->Divide.PostType[tableIndex] = POST_TYPE_SELECT;
1582   6                                                      pHttpConn->Divide.SetFlag[tableIndex] = 1;
1583   6                                                      tableIndex++;
1584   6                                              }
1585   5                                      }                       
1586   4                              }
1587   3      #endif                  
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 27  

1588   3                              else
1589   3                                      continue;
1590   3                      }
1591   2              }
1592   1              pHttpConn->Divide.Fragment = tableIndex;        
1593   1      
1594   1      } /* End of HTTP_DivideHtmlFile() */
1595          
1596          /*
1597           * ----------------------------------------------------------------------------
1598           * Function Name: HTTP_NewConfig()
1599           * Purpose: 
1600           * Params:
1601           * Returns:
1602           * Note:
1603           * ----------------------------------------------------------------------------
1604           */
1605          U8_T HTTP_NewConfig(void)
1606          {
1607   1      #if (MAX_POST_BUF_RADIO)
                      BUF_RADIO XDATA         *pRadio;
              #endif
1610   1              BUF_TEXT XDATA          *pText;
1611   1      #if (MAX_POST_BUF_SELECT)
1612   1              BUF_SELECT XDATA        *pSelect;
1613   1      #endif  
1614   1              U8_T                            i;
1615   1              U8_T                            change;
1616   1              void                            (*f)(void *pWebData);
1617   1      
1618   1              HTTPtemp.SaveCfgFlag = 0;
1619   1              HTTPtemp.SysRebootFlag = 0;     
1620   1      
1621   1              for (i = 0; i < HTTPtemp.PostCnt; i++)
1622   1              {
1623   2                      if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_TEXT)
1624   2                      {
1625   3                              change = 0;
1626   3                              pText = POST_Record[HTTPtemp.PostTable[i]].PValue;
1627   3                              
1628   3                              if (pText == NULL) continue; // it may be password
1629   3                              {
1630   4                                      if ((pText->CurrLength - 1) == pText->UserLength)
1631   4                                      {
1632   5                                              if (memcmp(pText->CurrValue, pText->UserValue, pText->CurrLength - 1))  change = 1;
1633   5                                      }
1634   4                                      else change = 1;
1635   4      
1636   4                                      if (!change) continue;
1637   4      
1638   4                                      memcpy(pText->CurrValue, pText->UserValue, pText->UserLength);
1639   4                                      pText->CurrValue[pText->UserLength] = '"';
1640   4                                      pText->CurrLength = pText->UserLength + 1;
1641   4                                      pText->UserLength ++;
1642   4      
1643   4                                      f = fun_tbl[HTTPtemp.PostTable[i]];
1644   4                                      f(pText);
1645   4                              }
1646   3                      }
1647   2      #if (MAX_POST_BUF_RADIO)                
                              else if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_RADIO)
                              {
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 28  

                                      change = 0;
                                      pRadio = POST_Record[HTTPtemp.PostTable[i]].PValue;     
                                      if (pRadio->UserSet != pRadio->CurrentSet)
                                      {
                                              pRadio->CurrentSet = pRadio->UserSet;
                                              change = 1;
                                      }
              
                                      if (!change) continue;
              
                                      f = fun_tbl[HTTPtemp.PostTable[i]];
                                      f(&pRadio->CurrentSet);
                              }
              #endif
1664   2      #if (MAX_POST_BUF_SELECT)
1665   2                      else if (POST_Record[HTTPtemp.PostTable[i]].PostType == POST_TYPE_SELECT)
1666   2                      {
1667   3                              change = 0;
1668   3                              pSelect = POST_Record[HTTPtemp.PostTable[i]].PValue;
1669   3                              {
1670   4                                      if (pSelect->UserSet != pSelect->CurrentSet)
1671   4                                      {
1672   5                                              pSelect->CurrentSet = pSelect->UserSet;
1673   5                                              change = 1;
1674   5                                      }
1675   4                                      if (!change) continue;
1676   4      
1677   4                                      f = fun_tbl[HTTPtemp.PostTable[i]];
1678   4                                      f(&pSelect->CurrentSet);
1679   4                              }
1680   3                      }
1681   2      #endif
1682   2                      else continue;
1683   2              }
1684   1      
1685   1              if (HTTPtemp.SaveCfgFlag)
1686   1              {
1687   2                      printd("Change Setting\n\r");
1688   2                      GCONFIG_WriteConfigData();              
1689   2              }
1690   1              
1691   1              return HTTP_POST_SUCCESS;
1692   1      
1693   1      } /* End of HTTP_NewConfig() */
1694          
1695          
1696          /*
1697           * ----------------------------------------------------------------------------
1698           * Function Name: HTTP_Ulong2IpAddr()
1699           * Purpose: Transfer a ulong number to ip address string. exp: 192.168.0.3
1700           * Params:
1701           * Returns:
1702           * Note:
1703           * ----------------------------------------------------------------------------
1704           */
1705          U8_T HTTP_Ulong2IpAddr(U32_T ip, U8_T* pbuf)
1706          {
1707   1              U8_T*   point = (U8_T*)&ip;
1708   1              U8_T    i = sizeof (U32_T);
1709   1              U8_T    temp, value[3];
1710   1              U8_T    j, len = 0;
1711   1      
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 29  

1712   1              while (i--)
1713   1              {
1714   2                      temp = *point++;
1715   2                      if (temp == 0)
1716   2                      {
1717   3                              *pbuf++ = 0x30;
1718   3                              len++;
1719   3                      }
1720   2                      else
1721   2                      {
1722   3                              j = 3;
1723   3                              while (j--)
1724   3                              {
1725   4                                      value[j] = (temp % 10) + 0x30;
1726   4                                      temp /= 10;
1727   4                              }
1728   3      
1729   3                              if (value[0] != '0')
1730   3                              {
1731   4                                      *pbuf++ = value[0];
1732   4                                      *pbuf++ = value[1];
1733   4                                      *pbuf++ = value[2];
1734   4                                      len += 3;
1735   4                              }
1736   3                              else if (value[1] != '0')
1737   3                              {
1738   4                                      *pbuf++ = value[1];
1739   4                                      *pbuf++ = value[2];
1740   4                                      len += 2;
1741   4                              }
1742   3                              else
1743   3                              {
1744   4                                      *pbuf++ = value[2];
1745   4                                      len++;
1746   4                              }
1747   3                      }
1748   2      
1749   2                      if (i)
1750   2                      {
1751   3                              *pbuf++ = '.';
1752   3                              len++;
1753   3                      }
1754   2              }
1755   1      
1756   1              return len;
1757   1                              
1758   1      } /* End of HTTP_Ulong2IpAddr() */
1759          
1760          /*====== for index.htm web page, start ====== */
1761          /*
1762           * ----------------------------------------------------------------------------
1763           * Function Name: HTTP_CheckPassWord()
1764           * Purpose: 
1765           * Params:
1766           * Returns:
1767           * Note:
1768           * ----------------------------------------------------------------------------
1769           */
1770          U8_T HTTP_CheckPassWord(HTTP_SERVER_CONN XDATA* pHttpConn)
1771          {
1772   1              U8_T    Index, LvlTemp;
1773   1      
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 30  

1774   1              return HTTP_POST_SUCCESS;  /* jump */
1775   1      
1776   1              if ((HTTPtemp.PostCnt != 3) ||
1777   1                      (HTTPtemp.PostTable[0] != RECORD_TEXT_username) || 
1778   1                      (HTTPtemp.PostTable[1] != RECORD_TEXT_password))
1779   1              {
1780   2                      printd ("Login: Lost username or password data!\n\r");  
1781   2                      return HTTP_POST_FAILURE;
1782   2              }
1783   1      
1784   1              if ((HTTPtemp.UserNameLen == 0) || 
1785   1                      (HTTPtemp.PassWordLen == 0) || 
1786   1                      (HTTPtemp.UserNameLen > MAX_AUTH_POST_VALUE_LEN) || 
1787   1                      (HTTPtemp.PassWordLen > MAX_AUTH_POST_VALUE_LEN))
1788   1              {
1789   2                      printd ("Login: username or password length error!\n\r");
1790   2                      return HTTP_POST_FAILURE;       
1791   2              }
1792   1              
1793   1              for (Index = 0; Index < MAX_USER_COUNT; Index ++)
1794   1              {
1795   2                      GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &LvlTemp);   //Get username and password.    
1796   2                      if ((HTTPtemp.UserNameLen == strlen(HTTPtemp.Buf[0])) &&                //Check length and content, not include '\0' 
             -char.
1797   2                              (HTTPtemp.PassWordLen == strlen(HTTPtemp.Buf[1])) &&            
1798   2                              (memcmp(HTTPtemp.UserName, HTTPtemp.Buf[0], HTTPtemp.UserNameLen) == 0) &&                      
1799   2                              (memcmp(HTTPtemp.PassWord, HTTPtemp.Buf[1], HTTPtemp.PassWordLen) == 0))
1800   2                              break;
1801   2              }
1802   1              
1803   1              if (Index == MAX_USER_COUNT)
1804   1              {
1805   2                      printd ("Login: username or password not metch!\n\r");  
1806   2                      return HTTP_POST_FAILURE;
1807   2              }
1808   1              
1809   1              for (Index = 0 ; Index < MAX_HTTP_CONNECT ; Index ++)           //Fine a empty space for save authenticationed IP.
1810   1              {
1811   2                      if (HTTPtemp.AuthenIP[Index] == 0)
1812   2                      {
1813   3                              HTTPtemp.AuthenIP[Index] = pHttpConn->Ip;
1814   3                              break;
1815   3                      }
1816   2              }
1817   1      
1818   1              if (Index == MAX_HTTP_CONNECT)          //Force this IP to save.
1819   1                      HTTPtemp.AuthenIP[0] = pHttpConn->Ip;
1820   1              
1821   1              printd ("Login: username and password check ok!\n\r");  
1822   1              return HTTP_POST_SUCCESS;                                               
1823   1      
1824   1      } /* End of HTTP_CheckPassWord() */
1825          /*====== for index.htm web page, end ======*/
1826          /*====== for system.htm web page, start ====== */
1827          /*
1828           * ----------------------------------------------------------------------------
1829           * Function Name: HTTP_CheckNewPassword()
1830           * Purpose: 
1831           * Params:
1832           * Returns:
1833           * Note:
1834           * ----------------------------------------------------------------------------
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 31  

1835           */
1836          U8_T HTTP_CheckNewPassword(void)
1837          {
1838   1              U8_T Index, LvlTemp;
1839   1              
1840   1              if ((HTTPtemp.PostCnt != 4) ||
1841   1                      (HTTPtemp.PostTable[0] != RECORD_TEXT_old_psw) || 
1842   1                      (HTTPtemp.PostTable[1] != RECORD_TEXT_new_psw) || 
1843   1                      (HTTPtemp.PostTable[2] != RECORD_TEXT_cfm_psw))
1844   1              {
1845   2                      printd ("Change PassWord: Lost password data!\n\r");    
1846   2                      return HTTP_POST_FAILURE;
1847   2              }
1848   1      
1849   1              if ((HTTPtemp.NewPassWordLen == 0) || 
1850   1                      (HTTPtemp.CfmPassWordLen == 0) || 
1851   1                      (HTTPtemp.NewPassWordLen > MAX_AUTH_POST_VALUE_LEN) || 
1852   1                      (HTTPtemp.CfmPassWordLen > MAX_AUTH_POST_VALUE_LEN))
1853   1              {
1854   2                      printd ("Change PassWord: New password or confirm password length error!\n\r");
1855   2                      return HTTP_POST_FAILURE;       
1856   2              }
1857   1      
1858   1              for (Index = 0; Index < MAX_USER_COUNT; Index ++)//Find the Old password.
1859   1              {
1860   2                      GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &LvlTemp);
1861   2                      if ((HTTPtemp.OldPassWordLen == strlen(HTTPtemp.Buf[1])) &&
1862   2                              (memcmp(HTTPtemp.Buf[1], HTTPtemp.OldPassWord, HTTPtemp.OldPassWordLen) == 0))
1863   2                              break;
1864   2              }
1865   1      
1866   1              if (Index == MAX_USER_COUNT) 
1867   1              {
1868   2                      printd ("Change PassWord: Old password not found!\n\r");                
1869   2                      return HTTP_POST_FAILURE;
1870   2              }
1871   1      
1872   1              if (HTTPtemp.NewPassWordLen != HTTPtemp.CfmPassWordLen)
1873   1              {
1874   2                      printd ("Change PassWord: New password and confirm password length not equal!\n\r");    
1875   2                      return HTTP_POST_FAILURE;
1876   2              }
1877   1      
1878   1              if (memcmp(HTTPtemp.NewPassWord, HTTPtemp.CfmPassWord, HTTPtemp.NewPassWordLen))
1879   1              {
1880   2                      printd ("Change PassWord: Data not equal in %s to %s\n\r",HTTPtemp.OldPassWord , HTTPtemp.NewPassWord);
1881   2                      return HTTP_POST_FAILURE;
1882   2              }
1883   1      
1884   1      //      if (Index == 0)
1885   1              {
1886   2                      GCONFIG_SetAdmin(HTTPtemp.Buf[0], HTTPtemp.NewPassWord);
1887   2                      printd ("Change PassWord: change ok! from: %s to %s\n\r", HTTPtemp.Buf[1], HTTPtemp.NewPassWord);
1888   2              GCONFIG_WriteConfigData();
1889   2              }
1890   1              return HTTP_POST_SUCCESS;
1891   1      
1892   1      } /* End of HTTP_CheckNewPassword() */
1893          
1894          /*
1895           * ----------------------------------------------------------------------------
1896           * Function Name: HTTP_CheckNewUsername()
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 32  

1897           * Purpose: 
1898           * Params:
1899           * Returns:
1900           * Note:
1901           * ----------------------------------------------------------------------------
1902           */
1903          U8_T HTTP_CheckNewUsername(void)
1904          {
1905   1              U8_T Temp;
1906   1              
1907   1              if (HTTPtemp.PostCnt != 2) return HTTP_POST_FAILURE;
1908   1              
1909   1              if ((!HTTPtemp.NewUserNameLen) || (HTTPtemp.NewUserNameLen > MAX_AUTH_POST_VALUE_LEN))
1910   1              {
1911   2                      printd ("Change UserName: New username length error!\n\r");
1912   2                      return HTTP_POST_FAILURE;
1913   2              }
1914   1              
1915   1              GCONFIG_GetAdmin(HTTPtemp.Buf[0], HTTPtemp.Buf[1], &Temp);
1916   1              GCONFIG_SetAdmin(HTTPtemp.NewUserName, HTTPtemp.Buf[1]);
1917   1              printd ("Change UserName: change ok! from: %s to %s\n\r", HTTPtemp.Buf[0], HTTPtemp.NewUserName);
1918   1          GCONFIG_WriteConfigData();          
1919   1              
1920   1              return HTTP_POST_SUCCESS;
1921   1      } /* End of HTTP_CheckNewUsername() */
1922          
1923          /*
1924           * ----------------------------------------------------------------------------
1925           * Function Name: HTTP_IpAddr2Ulong()
1926           * Purpose: Transfer a ip address string to ulong number. exp: 0xc0a80003
1927           * Params:
1928           * Returns:
1929           * Note:
1930           * ----------------------------------------------------------------------------
1931           */
1932          U32_T HTTP_IpAddr2Ulong(U8_T* pBuf, U8_T len)
1933          {
1934   1              U32_T   ip = 0;
1935   1              U8_T*   point = (U8_T*)&ip;
1936   1              U8_T    count = 0;
1937   1              U8_T    count2 = 0;
1938   1      
1939   1              while (1)
1940   1              {
1941   2                      count2 = 0;
1942   2                      while ((*pBuf != '.') && len)
1943   2                      {
1944   3                              count2++;
1945   3                              if (count2 > 3) return 0xffffffff;
1946   3      
1947   3                              *point *= 10;
1948   3        
1949   3                              if ((*pBuf < 0x3a) && (*pBuf > 0x2f))
1950   3                                      *point += (*pBuf - 0x30);
1951   3                              else
1952   3                                      return 0xffffffff;
1953   3      
1954   3                              pBuf++;
1955   3                              len--;
1956   3                      }
1957   2        
1958   2                      if (len == 0) break;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 33  

1959   2      
1960   2                      pBuf++;
1961   2                      len--;
1962   2                      count++;
1963   2                      point++;
1964   2      
1965   2                      if (count > 3) return 0xffffffff;
1966   2              }
1967   1      
1968   1              if (count != 3) return 0xffffffff;
1969   1      
1970   1              return ip;
1971   1      } /* End of HTTP_IpAddr2Ulong() */
1972          
1973          /*
1974           * ----------------------------------------------------------------------------
1975           * Function Name: HTTP_Str2Short()
1976           * Purpose: Transfer a string to ushort number.
1977           * Params:
1978           * Returns:
1979           * Note:
1980           * ----------------------------------------------------------------------------
1981           */
1982          U16_T HTTP_Str2Short(U8_T* pBuf, U8_T len)
1983          {
1984   1              U32_T   value = 0;
1985   1      
1986   1              while (len--)
1987   1              {
1988   2                      value *= 10;
1989   2       
1990   2                      if ((*pBuf < 0x3a) && (*pBuf > 0x2f))
1991   2                              value += (*pBuf - 0x30);
1992   2                      else
1993   2                              return 0xffff;
1994   2      
1995   2                      pBuf++;
1996   2              }
1997   1              if (value & 0xFFFF0000) return 0xFFFF;
1998   1              return (U16_T)(value & 0xFFFF);
1999   1      
2000   1      } /* End of HTTP_Str2Short() */
2001          
2002          /*
2003           * ----------------------------------------------------------------------------
2004           * Function Name: HTTP_Short2Str()
2005           * Purpose: Transfer a string to ushort number.
2006           * Params:
2007           * Returns:
2008           * Note:
2009           * ----------------------------------------------------------------------------
2010           */
2011          U8_T HTTP_Short2Str(U16_T port, U8_T* pBuf)
2012          {
2013   1              U8_T*   point = (U8_T*)&port;
2014   1              U8_T    i, j, k, len = 0;
2015   1              U16_T   tmp;
2016   1      
2017   1              if (port > 9999)
2018   1                      len = 5;
2019   1              else if (port > 999)
2020   1                      len = 4;
C51 COMPILER V9.06   HTTPD                                                                 05/24/2013 13:18:43 PAGE 34  

2021   1              else if (port > 99)
2022   1                      len = 3;
2023   1              else if (port > 9)
2024   1                      len = 2;
2025   1              else
2026   1                      len = 1;
2027   1      
2028   1              pBuf[len - 1] = (port % 10) + 0x30;
2029   1              for (i = 0; i < len - 1 ; i++)
2030   1              {
2031   2                      j = (len - 1) - i;
2032   2                      tmp = 1;
2033   2                      for (k = 0; k < j; k++)
2034   2                      {
2035   3                              tmp = tmp * 10;
2036   3                      }
2037   2                      pBuf[i] = (port / tmp) + 0x30;
2038   2                      port = port - ((pBuf[i] - 0x30) * tmp);
2039   2              }
2040   1      
2041   1              return len;
2042   1      
2043   1      } /* End of HTTP_Short2Str() */
2044           
2045          
2046          /* End of httpd.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14626    ----
   CONSTANT SIZE    =   1079    ----
   XDATA SIZE       =   1125     184
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
