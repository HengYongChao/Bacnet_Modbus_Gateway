C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE ADAPTER
OBJECT MODULE PLACED IN .\adapter.obj
COMPILER INVOKED BY: E:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\adapter\adapter.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X602
                    -0) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur
                    -\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SR
                    -C\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\
                    -;..\Src\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version;..\src\modbusTCP
                    -;..\src\gs2e;..\src\adpter1;..\src\scan;..\src\gsm;..\src\dyndns) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\adapter.
                    -lst) OBJECT(.\adapter.obj)

line level    source

   1          /*
   2           ******************************************************************************
   3           *     Copyright (c) 2006       ASIX Electronic Corporation      All rights reserved.
   4           *
   5           *     This is unpublished proprietary source code of ASIX Electronic Corporation
   6           *
   7           *     The copyright notice above does not evidence any actual or intended
   8           *     publication of such source code.
   9           ******************************************************************************
  10           */
  11           /*============================================================================
  12           * Module Name: adapter.c
  13           * Purpose:
  14           * Author:
  15           * Date:
  16           * Notes:
  17           * $Log: adapter.c,v $
  18           *=============================================================================
  19           */
  20          
  21          /* INCLUDE FILE DECLARATIONS */
  22          #include "adapter.h"
  23          #include "stoe.h"
  24          #include "dma.h"
  25          #include "tcpip.h"
  26          #include "pppoe.h"
  27          #if (!STOE_TRANSPARENT)
  28          #include "mstimer.h"
  29          #endif
  30          
  31          
  32          /* NAMING CONSTANT DECLARATIONS */
  33          #define ETH_HEADER_LEN          14
  34          #define ETH_NON_TRANSPARENT     0
  35          #define ETH_TRANSPARENT         1
  36          #if (!STOE_TRANSPARENT)
  37          #define ETH_ARP_SEND_INTERVAL_TIME      300
  38          #endif
  39          
  40          /* GLOBAL VARIABLES DECLARATIONS */
  41          U8_T ETH_IsPppoe = 0;
  42          U8_T ETH_DoDhcp = 0;
  43          U8_T ETH_PppoeHeaderLen = 0;
  44          
  45          
  46          /* LOCAL VARIABLES DECLARATIONS */
  47          static U8_T eth_EthHeadLen = 0;
  48          static U16_T eth_PayLoadOffset = 0;
  49          #if (!STOE_TRANSPARENT)
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 2   

  50          static BOOL eth_GatewayArpStaticFlag = FALSE;
  51          static U32_T eth_ArpSendIntervalTime = 5;
  52          static U32_T eth_ArpSendTime = 0;
  53          #endif
  54          
  55          
  56          /* LOCAL SUBPROGRAM DECLARATIONS */
  57          static void eth_RcvHandle(U8_T XDATA*, U16_T, U8_T);
  58          #if (!STOE_TRANSPARENT)
  59          static BOOL eth_CheckGatewayIp(U8_T XDATA* pBuf);
  60          #endif
  61          
  62          /*
  63           * ----------------------------------------------------------------------------
  64           * Function Name: ETH_Init
  65           * Purpose:
  66           * Params:
  67           * Returns:
  68           * Note:
  69           * ----------------------------------------------------------------------------
  70           */
  71          void ETH_Init(void)
  72          {
  73   1              U8_T*           point;
  74   1      
  75   1              /* ethernet initiation */
  76   1              STOE_Init(ETH_PHY_SENSE_TYPE);
  77   1              STOE_RcvCallback = eth_RcvHandle;
  78   1      
  79   1      #if (STOE_TRANSPARENT)
                      /* Initialise TCP/UDP up-layer interfaces */
                      TCPIP_Init(ETH_TRANSPARENT);
                      eth_EthHeadLen = ETH_HEADER_LEN;
              #else
  84   1              TCPIP_Init(ETH_NON_TRANSPARENT);
  85   1              eth_EthHeadLen = 0;
  86   1      #endif
  87   1          /* Initialise the ARP cache. */
  88   1              point = MAC_GetMacAddr();
  89   1              TCPIP_SetMacAddr(point);
  90   1      
  91   1              TCPIP_AssignLowlayerXmitFunc(ETH_Send);
  92   1      
  93   1              /* PPPoE initiation */
  94   1              PPPOE_Init();
  95   1      
  96   1      } /* End of ETH_Init */
  97          
  98          /*
  99           * ----------------------------------------------------------------------------
 100           * Function Name: ETH_Start
 101           * Purpose:
 102           * Params:
 103           * Returns:
 104           * Note:
 105           * ----------------------------------------------------------------------------
 106           */
 107          void ETH_Start(void)
 108          {
 109   1              STOE_Start();
 110   1      
 111   1      } /* End of ETH_Start */
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 3   

 112          
 113          /*
 114           * ----------------------------------------------------------------------------
 115           * Function Name: eth_RcvHandle
 116           * Purpose:
 117           * Params:
 118           * Returns:
 119           * Note:
 120           * ----------------------------------------------------------------------------
 121           */
 122          void eth_RcvHandle(U8_T XDATA* pbuf, U16_T length, U8_T protocol)
 123          {
 124   1              /* copy packet into uIP buffer */
 125   1              DMA_GrantXdata(TCPIP_GetRcvBuffer(), pbuf, length);
 126   1      
 127   1              TCPIP_SetRcvLength(length);
 128   1      
 129   1      #if (STOE_TRANSPARENT == STOE_NON_TRANSPARENT_MODE)
 130   1              if (protocol == 0xff)
 131   1              {
 132   2                      if ((*pbuf > 0x44) && (*pbuf < 0x50))
 133   2                      {
 134   3                              protocol = *(pbuf + 9);
 135   3                              PBDP->STOE_RxInform.Protocol = protocol;
 136   3                      }
 137   2              }
 138   1      #endif
 139   1      
 140   1              switch (protocol)
 141   1              {
 142   2              default:
 143   2                      break;
 144   2              case 1:
 145   2              case 2:
 146   2              case 6:
 147   2              case 17:
 148   2      #if STOE_TRANSPARENT
                              if (ETH_IsPppoe)
                              {
                                      if (!PPPOE_Receive(TCPIP_GetRcvBuffer(), length))
                                              return;
                              }
                              else if (ETH_DoDhcp == 0)
                                      uip_arp_ipin();
              #endif
 157   2                      TCPIP_Receive();
 158   2                      if(TCPIP_GetXmitLength() > 0)
 159   2                      {
 160   3      #if STOE_TRANSPARENT
                                      if (!ETH_IsPppoe)
                                              uip_arp_out();
              #endif
 164   3                              ETH_Send(0);
 165   3                      }
 166   2                      break;
 167   2              case 0xff:
 168   2      #if STOE_TRANSPARENT
                              if (ETH_IsPppoe)
                              {
                                      if (!PPPOE_Receive(TCPIP_GetRcvBuffer(), length))
                                              return;
                              }
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 4   

                              else
                              {
                                      if(pbuf[12] == 0x08 && pbuf[13] == 0x06)
                                      {
                                              uip_arp_arpin();
                                  if(TCPIP_GetXmitLength() > 0)
                                                      ETH_Send(0);
                                      }
                              }
              #else
 184   2                      // receive a arp reply packet, check the ip.
 185   2                      // If this ip is the gateway's ip, update the hardware arp table,
 186   2                      // and set it static
 187   2                      if(pbuf[12] == 0x08 && pbuf[13] == 0x06 && pbuf[21] == 0x02)
 188   2                      {
 189   3                              if (eth_CheckGatewayIp(pbuf))
 190   3                              {
 191   4                                      if (STOE_AddArpTable(&pbuf[6], *(U32_T *)&pbuf[28], 1))
 192   4                                      {
 193   5                                              eth_GatewayArpStaticFlag = TRUE;
 194   5                                              eth_ArpSendIntervalTime = ETH_ARP_SEND_INTERVAL_TIME;
 195   5                                      }
 196   4                              }
 197   3                      }
 198   2      #endif
 199   2                      break;
 200   2              }  /* End of switch */
 201   1      
 202   1      } /* End of eth_RcvHandle */
 203          
 204          /*
 205          * -----------------------------------------------------------------------------
 206           * Function Name: ETH_Send
 207           * Purpose: Copy Data to Mac ram and send to Ethernet.
 208           * Params: 
 209           * Returns: none
 210           * Note:
 211           * ----------------------------------------------------------------------------
 212           */
 213          void ETH_Send(U16_T     payloadOffset)
 214          {
 215   1              U16_T   length = TCPIP_GetXmitLength();
 216   1      
 217   1              eth_PayLoadOffset = payloadOffset;
 218   1      
 219   1      #if STOE_TRANSPARENT
                      if (ETH_IsPppoe)
                      {
                              length += (eth_EthHeadLen + ETH_PppoeHeaderLen);
                              if (!PPPOE_GetState())
                                      return;
              
                              PPPOE_Send (TCPIP_GetXmitBuffer(), length);
                      }
              #endif
 229   1      
 230   1              ETH_SendPkt(TCPIP_GetXmitBuffer(), length);
 231   1                      
 232   1      } /* End of ETH_Send() */
 233          
 234          /*
 235          * -----------------------------------------------------------------------------
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 5   

 236           * Function Name: ETH_SendPkt
 237           * Purpose: Copy Data to Mac ram and send to Ethernet.
 238           * Params: none
 239           * Returns: none
 240           * Note:
 241           * ----------------------------------------------------------------------------
 242           */
 243          void ETH_SendPkt(U8_T XDATA* psour, U16_T length)
 244          {
 245   1              U8_T XDATA* pBuf;
 246   1              U8_T XDATA* point;
 247   1              U16_T           len;
 248   1              U16_T           addr;
 249   1              U8_T            isPppoeIp = 0;
 250   1              U16_T           totalLen = length;
 251   1      
 252   1              if (!PBDP->MacInfo.LinkSpeed)
 253   1                      return;
 254   1              pBuf = STOE_AssignSendBuf(length + MAC_TX_RX_HEADER);
 255   1              if (!pBuf)
 256   1                      return;
 257   1              point = pBuf + MAC_TX_RX_HEADER;
 258   1      
 259   1      #if STOE_TRANSPARENT
                      if (ETH_IsPppoe)
                      {
                              if ((*(psour + 12) == 0x88) && (*(psour + 13) == 0x64) && (*(psour + 20) == 0) && (*(psour + 21) == 0x21
             -))
                              {
                                      isPppoeIp = 1;
                                      PBDP->STOE_TxInform.Protocol = *(psour + 31);
                              }
                              else
                              {
                                      eth_PayLoadOffset = length;
                                      PBDP->STOE_TxInform.Protocol = 0xff;
                              }
                      }
                      else
              #endif
 275   1              {
 276   2      #if STOE_TRANSPARENT
                              if ((*(psour + 12) == 8) && (*(psour + 13) == 0))
                                      PBDP->STOE_TxInform.Protocol = *(psour + 23);
                              else
                                      PBDP->STOE_TxInform.Protocol = 0xff;
              #else
 282   2                      if (*psour == 0x45)
 283   2                              PBDP->STOE_TxInform.Protocol = *(psour + 9);
 284   2                      else
 285   2                              PBDP->STOE_TxInform.Protocol = 0xff;
 286   2      #endif
 287   2              }
 288   1      
 289   1              if (pBuf)
 290   1              {
 291   2                      if (eth_PayLoadOffset)
 292   2                              len = eth_PayLoadOffset;
 293   2                      else
 294   2                      {
 295   3      #if STOE_TRANSPARENT
                                      if (ETH_IsPppoe)
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 6   

                                              len = 48 + eth_EthHeadLen;
                                      else
              #endif
 300   3                                      len = 40 + eth_EthHeadLen;
 301   3                      }
 302   2      
 303   2                      if (length > len)
 304   2                      {
 305   3                              /* Do software DMA */
 306   3                              DMA_GrantXdata(point, TCPIP_GetXmitBuffer(), len);
 307   3      
 308   3                              point += len;
 309   3                              length -= len;
 310   3      
 311   3                              addr = (U32_T)(TCPIP_GetPayloadBuffer()) >> 8;
 312   3      
 313   3                              if(addr > 0x8000)       /*if(flag_dataincode)*/
 314   3                                      STOE_CopyCode2TPBR(point, TCPIP_GetPayloadBuffer(), length);
 315   3                              else if (addr >= 0x100)
 316   3                                      DMA_Grant(point, TCPIP_GetPayloadBuffer(), length);
 317   3                              else
 318   3                                      DMA_GrantXdata(point, TCPIP_GetPayloadBuffer(), length);
 319   3                      }
 320   2                      else
 321   2                      {
 322   3                              /* Do software DMA */
 323   3                              DMA_GrantXdata(point, TCPIP_GetXmitBuffer(), len);
 324   3      
 325   3                      } /* End of if (length > len) */
 326   2      
 327   2                      if (isPppoeIp)
 328   2                              pBuf[5] = 0x80;
 329   2                      else
 330   2                              pBuf[5] = 0;
 331   2                      STOE_Send(pBuf, totalLen, PBDP->STOE_TxInform.Protocol);
 332   2              }
 333   1      
 334   1              eth_PayLoadOffset = 0; /* clear offset flag */
 335   1      
 336   1      } /* End of ETH_SendPkt() */
 337          
 338          #if (!STOE_TRANSPARENT)
 339          /*
 340          * -----------------------------------------------------------------------------
 341           * Function Name: eth_CheckGatewayIp
 342           * Purpose: Copy Data to Mac ram and send to Ethernet.
 343           * Params: none
 344           * Returns: none
 345           * Note:
 346           * ----------------------------------------------------------------------------
 347           */
 348          BOOL eth_CheckGatewayIp(U8_T XDATA* pBuf)
 349          {
 350   1              U32_T   gatewayIp, receiveIp;
 351   1      
 352   1              gatewayIp = STOE_GetGateway();
 353   1              if (!gatewayIp)
 354   1              {
 355   2                      return FALSE;
 356   2              }
 357   1      
 358   1              receiveIp = *(U32_T *)&pBuf[28];
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 7   

 359   1              if (gatewayIp != receiveIp)
 360   1              {
 361   2                      return FALSE;
 362   2              }
 363   1      
 364   1              return TRUE;
 365   1      }
 366          
 367          /*
 368          * -----------------------------------------------------------------------------
 369           * Function Name: ETH_SendArpToGateway
 370           * Purpose: send arp request to gateway
 371           * Params: none
 372           * Returns: none
 373           * Note:
 374           * ----------------------------------------------------------------------------
 375           */
 376          void ETH_SendArpToGateway(BOOL StopSendAfterRcvReply)
 377          {
 378   1              U32_T   gateway, ip, TempTime;
 379   1              U8_T    *buf = uip_buf;
 380   1              U8_T*   point;
 381   1      
 382   1              if (StopSendAfterRcvReply)
 383   1              {
 384   2                      if (eth_GatewayArpStaticFlag)
 385   2                              return;
 386   2              }
 387   1      
 388   1              // first check stoe gateway setting
 389   1              gateway = STOE_GetGateway();
 390   1              if (!gateway)
 391   1                      return;
 392   1      
 393   1              // check stoe source ip setting
 394   1              ip = STOE_GetIPAddr();
 395   1              if (!ip)
 396   1                      return;
 397   1      
 398   1              // check is it time to send arp request
 399   1              TempTime = SWTIMER_Tick();
 400   1              if ((TempTime - eth_ArpSendTime) < (eth_ArpSendIntervalTime * SWTIMER_COUNT_SECOND))
 401   1                      return;
 402   1      
 403   1              // update time
 404   1              eth_ArpSendTime = TempTime;
 405   1      
 406   1              switch(eth_ArpSendIntervalTime)
 407   1              {
 408   2                      case 5:
 409   2                              eth_ArpSendIntervalTime = 10;
 410   2                              break;
 411   2                      case 10:
 412   2                              eth_ArpSendIntervalTime = 15;
 413   2                              break;
 414   2                      case 15:
 415   2                              eth_ArpSendIntervalTime = 30;
 416   2                              break;
 417   2                      case 30:
 418   2                              eth_ArpSendIntervalTime = 60;
 419   2                              break;
 420   2                      case 60:
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 8   

 421   2                              eth_ArpSendIntervalTime = 120;
 422   2                              break;
 423   2                      case 120:
 424   2                              eth_ArpSendIntervalTime = 180;
 425   2                              break;
 426   2                      case 180:
 427   2                      case 300:
 428   2                      default:
 429   2                              eth_ArpSendIntervalTime = ETH_ARP_SEND_INTERVAL_TIME;
 430   2                              break;
 431   2              }
 432   1      
 433   1              // send arp request to gateway,
 434   1              // in order to get gateway MAC address.
 435   1              point = MAC_GetMacAddr();
 436   1              uip_len = 42;
 437   1      
 438   1              buf[0] = 0xFF;
 439   1              buf[1] = 0xFF;
 440   1              buf[2] = 0xFF;
 441   1              buf[3] = 0xFF;
 442   1              buf[4] = 0xFF;
 443   1              buf[5] = 0xFF;
 444   1              buf[6] = *(point);
 445   1              buf[7] = *(point + 1);
 446   1              buf[8] = *(point + 2);
 447   1              buf[9] = *(point + 3);
 448   1              buf[10] = *(point + 4);
 449   1              buf[11] = *(point + 5);
 450   1              buf[12] = 0x08; 
 451   1              buf[13] = 0x06;
 452   1      
 453   1              buf[14] = 0x00;
 454   1              buf[15] = 0x01;
 455   1              buf[16] = 0x08;
 456   1              buf[17] = 0x00;
 457   1              buf[18] = 0x06;
 458   1              buf[19] = 0x04;
 459   1              buf[20] = 0x00;
 460   1              buf[21] = 0x01;
 461   1      
 462   1              buf[22] = *(point);
 463   1              buf[23] = *(point + 1);
 464   1              buf[24] = *(point + 2);
 465   1              buf[25] = *(point + 3);
 466   1              buf[26] = *(point + 4);
 467   1              buf[27] = *(point + 5);
 468   1              *(U32_T *)&buf[28] = STOE_GetIPAddr();
 469   1              
 470   1              buf[32] = 0x00;
 471   1              buf[33] = 0x00;
 472   1              buf[34] = 0x00;
 473   1              buf[35] = 0x00;
 474   1              buf[36] = 0x00;
 475   1              buf[37] = 0x00;
 476   1              *(U32_T *)&buf[38] = gateway;
 477   1      
 478   1              ETH_Send(0);
 479   1      
 480   1              return;
 481   1      }
 482          
C51 COMPILER V9.06   ADAPTER                                                               05/28/2013 10:15:29 PAGE 9   

 483          /*
 484          * -----------------------------------------------------------------------------
 485           * Function Name: ETH_RestartSendArpToGateway
 486           * Purpose: Restart sending arp request to gateway
 487           * Params: none
 488           * Returns: none
 489           * Note:
 490           * ----------------------------------------------------------------------------
 491           */
 492          void ETH_RestartSendArpToGateway(void)
 493          {
 494   1              eth_GatewayArpStaticFlag = FALSE;
 495   1              eth_ArpSendIntervalTime = 5;
 496   1      }
 497          #endif
 498          
 499          /* End of adapter.c */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2785    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
