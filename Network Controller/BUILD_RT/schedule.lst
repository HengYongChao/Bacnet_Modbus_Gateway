C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE SCHEDULE
OBJECT MODULE PLACED IN .\schedule.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\schedule\schedule.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6
                    -020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hs
                    -ur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\
                    -SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX1100
                    -0\;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\schedule.lst) OBJECT(.
                    -\schedule.obj)

line level    source

   1          #include "types.h"
   2          #include "schedule.h"
   3          #include "8563.h"
   4          #include "main.h"
   5          
   6          //////////LHN ADD////////////////
   7          #include "delay.h"
   8          #include "uart.h"
   9          #include "hsuart.h"
  10          U8_T far Ort_Table[256] = {0};
  11          //////////LHN ADD////////////////
  12          
  13          STR_WR far WR_Roution[MAX_WR];
  14          STR_AR far AR_Roution[MAX_AR];
  15          UN_ID far ID_Config[MAX_ID];
  16          
  17          bit BIT_FLAG;  // 0 -- run schedule 
  18          unsigned char idata current_hour;
  19          unsigned char idata current_minute;
  20          unsigned char idata dayofweek;
  21          unsigned char idata previous_dayofweek = 10;
  22          unsigned int  idata dayofyear;
  23          
  24          unsigned char far ar_state_index[2] = {0};
  25          unsigned char far wr_state_index[3] = {0};
  26          unsigned char far holiday1_state_index[3] = {0};
  27          unsigned char far holiday2_state_index[3] = {0};
  28          
  29          unsigned char far output_state_index[32] = {0};
  30          unsigned char far schedual1_state_index[32] = {0};
  31          unsigned char far schedual2_state_index[32] = {0};
  32          unsigned char far first_time_schedual[32] = {0};
  33          
  34          unsigned char far send_schedual[8] = {0};
  35          bit received_schedual_data;
  36          bit success_write_schedual;
  37          bit receiving_schedual_byte;
  38          struct time_per_day
  39          {
  40                  unsigned char hours;
  41                  unsigned char minutes;
  42          };
  43           
  44          unsigned char bdata REFRESH_STATUS = 0;
  45          sbit WEEKLY_CHANGED = REFRESH_STATUS^0;
  46          sbit ANNUAL_CHANGED = REFRESH_STATUS^1;
  47          sbit ID_CHANGED = REFRESH_STATUS^2;
  48          
  49          extern unsigned char T;
  50          unsigned char far daylight_enable;
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 2   

  51          unsigned char far daylight_flag;
  52          bit calibrated_time = 0;
  53          bit cycle_minutes_timeout;
  54          
  55                
  56          unsigned char bdata WR_FLAG = 0;
  57          sbit WR_A_M = WR_FLAG^7; 
  58          sbit WR_VALUE = WR_FLAG^6;  
  59          sbit WR_STATE1 = WR_FLAG^5;
  60          sbit WR_STATE2 = WR_FLAG^4;
  61          
  62          unsigned char bdata AR_FLAG = 0;
  63          sbit AR_A_M = AR_FLAG^7; 
  64          sbit AR_VALUE = AR_FLAG^6;  
  65           
  66          unsigned char bdata ID_FLAG = 0;
  67          sbit ID_A_M = ID_FLAG^7; 
  68          sbit ID_OUTPUT = ID_FLAG^6;  
  69          sbit ID_STATE1 = ID_FLAG^5;
  70          sbit ID_STATE2 = ID_FLAG^4;
  71          
  72          unsigned char far schedule_flag = 0;
  73          unsigned char far schedule_id;
  74          
  75          extern unsigned int CRC16(unsigned char *puchMsg, unsigned char usDataLen);
  76          
  77          void SetBit(unsigned char bit_number,unsigned char *byte)
  78          {
  79   1              unsigned char mask; 
  80   1              mask = 0x01;
  81   1              mask = mask << bit_number;
  82   1              *byte = *byte | mask;
  83   1      }
  84          
  85          void ClearBit(unsigned char bit_number,unsigned char *byte)
  86          {
  87   1              unsigned char mask; 
  88   1              mask = 0x01;
  89   1              mask = mask << bit_number;
  90   1              mask = ~mask;
  91   1              *byte = *byte & mask;
  92   1      }
  93          
  94          bit GetBit(unsigned char bit_number,unsigned char *value)
  95          {
  96   1              unsigned char mask;
  97   1              unsigned char octet_index;
  98   1              mask = 0x01;
  99   1              octet_index = bit_number >> 3;
 100   1              mask = mask << (bit_number & 0x07);
 101   1              return (bit)(*(value + octet_index) & mask);
 102   1      }
 103          
 104          U8_T Read_ORT(U8_T id)
 105          {
 106   1              U8_T send_data[8], tstat_id, i;
 107   1              union
 108   1              {
 109   1                      unsigned int word;
 110   1                      unsigned char byte[2];
 111   1              }crc_16;
 112   1      
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 3   

 113   1              tstat_id = id;
 114   1              send_data[0] = tstat_id;
 115   1              send_data[1] = 0x03;
 116   1              send_data[2] = 0;
 117   1              send_data[3] = 211; // unoccupied override time
 118   1              send_data[4] = 0;
 119   1              send_data[5] = 1;
 120   1              crc_16.word = CRC16(send_schedual, 0x06);
 121   1              send_data[6] = crc_16.byte[0];
 122   1              send_data[7] = crc_16.byte[1];
 123   1              Tx_To_Tstat(send_data, 8);                                      
 124   1              DELAY_Ms(60);
 125   1          i = 0;
 126   1              if(hsurRxCount > 0)
 127   1              {
 128   2                      while(hsurRxCount)
 129   2                              send_data[i++] = HSUR_GetCharNb();
 130   2              }
 131   1              else if(uart1_RxCount > 0)
 132   1              {
 133   2                      for(i = 0; i < uart1_RxCount; i++)
 134   2                              send_data[i] = uart1_RxBuf[i];
 135   2                      uart1_RxCount = 0;
 136   2              }
 137   1      
 138   1              if(i > 0)
 139   1                      return(send_data[4]);
 140   1      
 141   1              return 0;
 142   1      }
 143          
 144          void Write_ORT(U8_T id, U8_T ort)
 145          {
 146   1              U8_T send_data[8];
 147   1              union
 148   1              {
 149   1                      unsigned int word;
 150   1                      unsigned char byte[2];
 151   1              }crc_16;
 152   1      
 153   1              send_data[0] = id;
 154   1              send_data[1] = 0x06;
 155   1              send_data[2] = 0;
 156   1              send_data[3] = 211; // unoccupied override time
 157   1              send_data[4] = 0;
 158   1              send_data[5] = ort;
 159   1              crc_16.word = CRC16(send_data, 0x06);
 160   1              send_data[6] = crc_16.byte[0];
 161   1              send_data[7] = crc_16.byte[1];
 162   1      
 163   1              Tx_To_Tstat(send_data, 8);
 164   1      }
 165          
 166          /////LHN ADD///////////////////
 167          void SendSchedualData(unsigned char id_index, bit output)
 168          {
 169   1              union
 170   1              {
 171   1                      unsigned int word;
 172   1                      unsigned char byte[2];
 173   1              }crc;
 174   1              
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 4   

 175   1      //      unsigned char output_value;
 176   1      //      unsigned char ort_num = 0;
 177   1      
 178   1              unsigned char retry_times = 3;
 179   1              schedule_id = id_index + 1;
 180   1      
 181   1      //      if(output)
 182   1      //      {
 183   1      //              output_value = 1;
 184   1      //              /////LHN ADD///////////////////
 185   1      //              /*ort_num = Read_ORT(number);
 186   1      //              if(ort_num)
 187   1      //              {
 188   1      //                      Ort_Table[number] = ort_num;
 189   1      //                      Write_ORT(number, 0);
 190   1      //              }*/
 191   1      //      }
 192   1      //      else
 193   1      //      {       
 194   1      //              output_value = 0;
 195   1      //              /////LHN ADD///////////////////
 196   1      //              /*ort_num = Read_ORT(number);
 197   1      //              if(!ort_num)
 198   1      //              {
 199   1      //                      ort_num = Ort_Table[number];
 200   1      //                      Write_ORT(number, ort_num);
 201   1      //              }*/
 202   1      //      }                
 203   1              
 204   1              send_schedual[0] = schedule_id;
 205   1              send_schedual[1] = 0x06;
 206   1              send_schedual[2] = 0;
 207   1              send_schedual[3] = 184;
 208   1              send_schedual[4] = 0;
 209   1              send_schedual[5] = 0;
 210   1              send_schedual[5] = output;
 211   1              crc.word = CRC16(send_schedual, 0x06);
 212   1              send_schedual[6] = crc.byte[0];
 213   1              send_schedual[7] = crc.byte[1];
 214   1      
 215   1              while(retry_times)
 216   1              {
 217   2                      Sever_Order = SERVER_SCHEDULE;
 218   2                      Tx_To_Tstat(send_schedual, 8);                                            
 219   2                      OSDelay(5);
 220   2                      if(schedule_flag == 1)
 221   2                      {
 222   3                              schedule_flag = 0;
 223   3                              break;
 224   3                      }
 225   2                      else
 226   2                      {
 227   3                              retry_times--;
 228   3                      }               
 229   2              }
 230   1      
 231   1      //      if(retry_times)
 232   1      //      {
 233   1                      if(output) 
 234   1                      {
 235   2                              if(GetBit(id_index, output_state_index) == 0)
 236   2                              {
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 5   

 237   3                                      SetBit(id_index & 0x07, &output_state_index[id_index >> 3]);
 238   3                                      ID_CHANGED = 0;
 239   3                              }
 240   2                      }
 241   1                      else 
 242   1                      {
 243   2                              if(GetBit(id_index, output_state_index) == 1)
 244   2                              {
 245   3                                      ClearBit(id_index & 0x07, &output_state_index[id_index >> 3]);
 246   3                                      ID_CHANGED = 0;
 247   3                              }
 248   2                      }
 249   1      //      }
 250   1      }
 251           
 252          /* Execute per 500ms */
 253          void CaculateTime(void)
 254          {
 255   1              unsigned int temp_year;
 256   1              unsigned char temp_month;
 257   1              unsigned char temp_day;
 258   1      
 259   1              current_minute = Time.UN.Current.min;
 260   1              current_hour = Time.UN.Current.hour;
 261   1              temp_day = Time.UN.Current.day;
 262   1              dayofweek = Time.UN.Current.dayofweek - 1;
 263   1              temp_month = Time.UN.Current.month;
 264   1              temp_year =     Time.UN.Current.year;
 265   1              
 266   1              if(temp_month & 0x80)
 267   1                      temp_year = 1900 + temp_day;
 268   1              else
 269   1                      temp_year = 2000 + temp_day;
 270   1      
 271   1              temp_month &= 0x1f;
 272   1              
 273   1              if(daylight_flag == 1)
 274   1              {
 275   2                      if(current_hour >= 2)
 276   2                      {
 277   3                              current_hour++;
 278   3                              Set_Clock(PCF_HOUR, current_hour);
 279   3                              daylight_flag = 0; 
 280   3      //                      write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 281   3                      }
 282   2              }
 283   1              else if(daylight_flag == 2)
 284   1              {
 285   2                      if(current_hour >= 2)
 286   2                      {
 287   3                              current_hour--;
 288   3      //                      SetPCF8563(0x04,HexToBcd(current_hour));        //hour]
 289   3                              Set_Clock(PCF_HOUR, current_hour);
 290   3                              daylight_flag = 0; 
 291   3      //                      write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 292   3                      }
 293   2              }
 294   1      
 295   1              if(dayofweek != previous_dayofweek || calibrated_time == 1)
 296   1              {
 297   2                      previous_dayofweek = dayofweek;
 298   2                      calibrated_time = 0;             
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 6   

 299   2                      switch(temp_month)
 300   2                      {
 301   3                              case 1:
 302   3                                      dayofyear = temp_day;
 303   3                                      break;
 304   3                              case 2:
 305   3                                      dayofyear = 0x1f + temp_day;
 306   3                                      break;
 307   3                              case 3:
 308   3                                      if((temp_year & 0x03) == 0x0)
 309   3                                              dayofyear = 0x3c + temp_day;
 310   3                                      else
 311   3                                              dayofyear = 0x3b + temp_day;
 312   3      
 313   3                                      if(daylight_enable == 1 && temp_year >= 2007)
 314   3                                      {
 315   4                                              if(temp_day >= 8 && temp_day <= 14 && dayofweek == 6)   
 316   4                                              {
 317   5                                                      daylight_flag = 1; 
 318   5      //                                              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 319   5                                              }
 320   4                                      }                               
 321   3                                      break;
 322   3                              case 4:
 323   3                                      if((temp_year & 0x03) == 0x00)
 324   3                                              dayofyear = 0x5b + temp_day;
 325   3                                      else
 326   3                                              dayofyear = 0x5a + temp_day;
 327   3                                                      
 328   3                                      if(daylight_enable == 1 && temp_year < 2007)
 329   3                                      {
 330   4                                              if(temp_day <= 7 && dayofweek == 6)     
 331   4                                              {
 332   5                                                      daylight_flag = 1; 
 333   5      //                                              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 334   5                                              }
 335   4                                      }       
 336   3                                      break;
 337   3                              case 5:
 338   3                                      if((temp_year & 0x03) == 0x00)
 339   3                                              dayofyear = 0x79 + temp_day;
 340   3                                      else
 341   3                                              dayofyear = 0x78 + temp_day;
 342   3                                      break;
 343   3                              case 6:
 344   3                                      if((temp_year & 0x03) == 0x00)
 345   3                                              dayofyear = 0x98 + temp_day;
 346   3                                      else
 347   3                                              dayofyear = 0x97 + temp_day;                    
 348   3                                      break;
 349   3                              case 7:
 350   3                                      if((temp_year & 0x03) == 0x00)
 351   3                                              dayofyear = 0xb6 + temp_day;
 352   3                                      else
 353   3                                              dayofyear = 0xb5 + temp_day;                    
 354   3                                      break;
 355   3                              case 8:
 356   3                                      if((temp_year & 0x03) == 0x00)
 357   3                                              dayofyear=0xd5 + temp_day;
 358   3                                      else
 359   3                                              dayofyear=0xd4 + temp_day;                      
 360   3                                      break;
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 7   

 361   3                              case 9:
 362   3                                      if((temp_year & 0x03) == 0x00)
 363   3                                              dayofyear = 0xf4 + temp_day;
 364   3                                      else
 365   3                                              dayofyear = 0xf3 + temp_day;                    
 366   3                                      break;
 367   3                              case 10:
 368   3                                      if((temp_year & 0x03) == 0x00)
 369   3                                              dayofyear = 0x112 + temp_day;
 370   3                                      else
 371   3                                              dayofyear = 0x111 + temp_day;
 372   3                                      if(daylight_enable == 1 && temp_year < 2007)
 373   3                                      {
 374   4                                              if((31 - temp_day <= 6) && dayofweek == 6)      
 375   4                                              {
 376   5                                                      daylight_flag = 2; 
 377   5      //                                              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);               
 378   5                                              }
 379   4                                      }       
 380   3                                      break;
 381   3                              case 11:
 382   3                                      if((temp_year & 0x03) == 0x0)
 383   3                                              dayofyear = 0x131 + temp_day;
 384   3                                      else
 385   3                                              dayofyear = 0x130 + temp_day;   
 386   3                                      if(daylight_enable == 1 && temp_year >= 2007)
 387   3                                      {
 388   4                                              if(temp_day <= 7 && dayofweek == 6)     
 389   4                                              {
 390   5                                                      daylight_flag = 2; 
 391   5      //                                              write_eeprom(EEP_DAYLIGHT_STATUS, daylight_flag);                       
 392   5                                              }
 393   4                                      }                       
 394   3                                      break;
 395   3                              case 12:
 396   3                                      if((temp_year & 0x03) == 0x00)
 397   3                                              dayofyear = 0x14f + temp_day;
 398   3                                      else
 399   3                                              dayofyear = 0x14e + temp_day;                   
 400   3                                      break;
 401   3                              default:
 402   3                                      break;
 403   3                      }
 404   2                      
 405   2                      dayofyear -= 1;
 406   2              }
 407   1      }
 408          
 409          void CheckAnnualRoutines(void)
 410          {
 411   1              unsigned char i;
 412   1              unsigned char mask;
 413   1      //      unsigned char mask_r;
 414   1              unsigned char octet_index;
 415   1      //      unsigned char code *base_address;
 416   1              for(i = 0; i < MAX_AR; i++)
 417   1              {
 418   2                      AR_FLAG = AR_Roution[i].UN.Desc.flag;
 419   2                      if(!AR_A_M)  //auto 
 420   2                       {
 421   3                              mask = 0x01;
 422   3                              /* Assume bit0 from octet0 = Jan 1st */
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 8   

 423   3                              /* octet_index = ora_current.day_of_year / 8;*/
 424   3                              octet_index = dayofyear >> 3;
 425   3                              /* bit_index = ora_current.day_of_year % 8;*/
 426   3                              /* bit_index = ora_current.day_of_year & 0x07;*/
 427   3                              mask = mask << (dayofyear & 0x07);
 428   3                              
 429   3      //                      base_address = AR_Roution[i].Time; // ttt[i];
 430   3                      if(AR_Roution[i].Time[11] != 0xff && AR_Roution[i].Time[38] != 0xff)
 431   3                              { 
 432   4                                      if(AR_Roution[i].Time[octet_index] & mask)
 433   4                                      {
 434   5                                              if(GetBit(i, ar_state_index) == 0)
 435   5                                              {                                
 436   6                                                      SetBit(i & 0x07, &ar_state_index[i >> 3]);
 437   6                                                      ANNUAL_CHANGED = 0;
 438   6                                              }
 439   5                                      }       
 440   4                                      else
 441   4                                      {
 442   5                                              if(GetBit(i, ar_state_index) == 1)
 443   5                                              {                                       
 444   6                                                      ClearBit(i & 0x07, &ar_state_index[i >> 3]); 
 445   6                                                      ANNUAL_CHANGED = 0;
 446   6                                              }
 447   5                                      }
 448   4                              }
 449   3                              else
 450   3                              {                                        
 451   4                                      ClearBit(i & 0x07, &ar_state_index[i >> 3]); 
 452   4                              }
 453   3                      }
 454   2                      else  // mannual
 455   2                      {
 456   3      //                      if(*base_address != 0xff && *(base_address+1) != 0xff)
 457   3                              if(AR_FLAG != 0xff)
 458   3                              {
 459   4                                      if(AR_VALUE)
 460   4                                      {
 461   5                                              if(GetBit(i, ar_state_index) == 0)
 462   5                                              {                                
 463   6                                                      SetBit(i & 0x07, &ar_state_index[i >> 3]);
 464   6                                                      ANNUAL_CHANGED = 0;
 465   6                                              }                                
 466   5                                      }
 467   4                                      else
 468   4                                      {
 469   5                                              if(GetBit(i, ar_state_index) == 1)
 470   5                                              {                                
 471   6                                                      ClearBit(i & 0x07, &ar_state_index[i >> 3]);
 472   6                                                      ANNUAL_CHANGED = 0;
 473   6                                              }                                       
 474   5                                      }
 475   4                              }
 476   3                      }
 477   2              }
 478   1      }
 479          
 480          void CheckWeeklyRoutines(void)
 481          { 
 482   1              unsigned char w, i;
 483   1              signed char j, timeout = 0;
 484   1              unsigned char mask;
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 9   

 485   1      //      unsigned char mask_r;
 486   1              for(i = 0; i < MAX_WR; i++)
 487   1              {
 488   2                      w = dayofweek;
 489   2                      if(w < 0) w = 6;
 490   2                      
 491   2                      WR_FLAG = WR_Roution[i].UN.Desc.flag;
 492   2                      j = WR_Roution[i].UN.Desc.holiday2;     
 493   2                      if((j > 0) && (j <= MAX_AR))
 494   2                      {
 495   3                              WR_FLAG |= 0x10;
 496   3                              j -= 1;
 497   3                              mask = 0x01;
 498   3                              mask = mask << (j & 0x07);               
 499   3                              if(ar_state_index[j >> 3] & mask)
 500   3                              {
 501   4                                      if(GetBit(i, holiday2_state_index) == 0)
 502   4                                      {                        
 503   5                                              SetBit(i & 0x07, &holiday2_state_index[i >> 3]);
 504   5                                              WEEKLY_CHANGED = 0;
 505   5                                      }
 506   4                                      w = 8; 
 507   4                              }
 508   3                      else
 509   3                              {       
 510   4                                      if(GetBit(i, holiday2_state_index) == 1)
 511   4                                      {                        
 512   5                                              ClearBit(i & 0x07, &holiday2_state_index[i >> 3]);
 513   5                                              WEEKLY_CHANGED = 0;
 514   5                                      }
 515   4                              }
 516   3                      }
 517   2                      else
 518   2                              ClearBit(i & 0x07, &holiday2_state_index[i >> 3]);
 519   2      
 520   2                      j = WR_Roution[i].UN.Desc.holiday1;
 521   2                      if((j > 0) && (j <= MAX_AR))
 522   2                      {
 523   3                              j -= 1;
 524   3                              mask = 0x01;
 525   3                              mask = mask << (j & 0x07);
 526   3                              WR_FLAG |= 0x20;                 
 527   3                              if(ar_state_index[j >> 3] & mask)
 528   3                              { 
 529   4                                      if(GetBit(i, holiday1_state_index) == 0)
 530   4                                      {
 531   5                                              SetBit(i & 0x07, &holiday1_state_index[i >> 3]);
 532   5                                              WEEKLY_CHANGED = 0;
 533   5                                      }
 534   4                                      w = 7;
 535   4                              }
 536   3                      else
 537   3                              {
 538   4                                      if(GetBit(i, holiday1_state_index) == 1)
 539   4                                      {
 540   5                                              ClearBit(i & 0x07, &holiday1_state_index[i >> 3]);
 541   5                                              WEEKLY_CHANGED = 0;
 542   5                                      }
 543   4                              }
 544   3                      }
 545   2                      else
 546   2                              ClearBit(i & 0x07, &holiday1_state_index[i >> 3]);
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 10  

 547   2      
 548   2                      if(!WR_A_M) // auto 
 549   2                      {
 550   3                              for(j = 7; j >= 0; j--)
 551   3                              {
 552   4                                      if(j % 2 == 0)  // check ontime j = 0,2,4,6
 553   4                                      {
 554   5                                              if(WR_Roution[i].OnTime[w * 8 + j] || WR_Roution[i].OnTime[w * 8 + j + 1])
 555   5                                              {
 556   6                                                      if(current_hour > WR_Roution[i].OnTime[w * 8 + j])
 557   6                                                              break;
 558   6      
 559   6                                                      if(current_hour == WR_Roution[i].OnTime[w * 8 + j])                                             
 560   6                                                              if(current_minute >= WR_Roution[i].OnTime[w * 8 + j + 1])                                               
 561   6                                                                      break;
 562   6                                              }       
 563   5                                      }
 564   4                                      else // check offtime j = 1,3,5,7
 565   4                                      {
 566   5                                              if(WR_Roution[i].OffTime[w * 8 + j - 1] || WR_Roution[i].OffTime[w * 8 + j])
 567   5                                              {
 568   6                                                      if(current_hour > WR_Roution[i].OffTime[w * 8 + j - 1])
 569   6                                                              break;
 570   6                                                      if(current_hour == WR_Roution[i].OffTime[w * 8 + j - 1])
 571   6                                                              if(current_minute >= WR_Roution[i].OffTime[w * 8 + j])          
 572   6                                                                      break;
 573   6                                              }               
 574   5                                      }                                                       
 575   4                              }
 576   3      
 577   3                              if(j < 0) //if(j == 0) current time is not in Ontime or Offtime
 578   3                              {
 579   4                                      if(GetBit(i, wr_state_index) == 1)
 580   4                                      {        
 581   5                                              ClearBit(i & 0x07, &wr_state_index[i >> 3]);
 582   5                                              WEEKLY_CHANGED = 0;                                                                     
 583   5                                      }
 584   4                              }
 585   3                              else
 586   3                              {
 587   4                                      if(j % 2) /* current time is  off time*/
 588   4                                      {
 589   5                                              if(GetBit(i, wr_state_index) == 1)
 590   5                                              {                
 591   6                                                      ClearBit(i & 0x07, &wr_state_index[i >> 3]);
 592   6                                                      WEEKLY_CHANGED = 0;
 593   6                                              } 
 594   5                                      }
 595   4                                               
 596   4                                      else /* current time is on time*/
 597   4                                      {
 598   5                                              if(GetBit(i, wr_state_index) == 0)
 599   5                                              {                
 600   6                                                      SetBit(i & 0x07, &wr_state_index[i >> 3]);
 601   6                                                      WEEKLY_CHANGED = 0;
 602   6                                              }
 603   5                                      }
 604   4                              }
 605   3                      }
 606   2                      else // manual
 607   2                      {
 608   3                              if(WR_FLAG != 0xff)
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 11  

 609   3                              {
 610   4                                      if(WR_VALUE)
 611   4                                      {
 612   5                                              if(GetBit(i, wr_state_index) == 0)
 613   5                                              {        
 614   6                                                      SetBit(i & 0x07, &wr_state_index[i >> 3]);
 615   6                                                      WEEKLY_CHANGED = 0;
 616   6                                              }
 617   5                                      }
 618   4                                      else
 619   4                                      {
 620   5                                              if(GetBit(i, wr_state_index) == 1)
 621   5                                              {        
 622   6                                                      ClearBit(i & 0x07, &wr_state_index[i >> 3]);
 623   6                                                      WEEKLY_CHANGED = 0;
 624   6                                              }
 625   5                                      }
 626   4                              }
 627   3                      }
 628   2              }       
 629   1      }
 630          
 631          void CheckIdRoutines(void)
 632          {
 633   1              unsigned char i;
 634   1      //      unsigned char code *base_address;
 635   1          bit wr1_value = 0;
 636   1          bit wr2_value = 0;
 637   1              bit output_value = 0;
 638   1              bit temp_bit;
 639   1              bit wr1_valid;
 640   1              bit wr2_valid;
 641   1              for(i = 0; i < MAX_ID; i++)
 642   1              {
 643   2                      if(ID_Config[i].all != NO_DEFINE_ADDRESS)
 644   2                      {
 645   3                              ID_FLAG = ID_Config[i].Str.flag;
 646   3                              wr1_valid = 0;
 647   3                              wr2_valid = 0;
 648   3      //                      test0 = ID_Config[i].Str.schedule1;
 649   3                              if(ID_Config[i].Str.schedule1 > 0 && ID_Config[i].Str.schedule1 <= MAX_WR)
 650   3                              {
 651   4                                      if(GetBit(ID_Config[i].Str.schedule1 - 1, wr_state_index))
 652   4                                      { 
 653   5                                              wr1_value = 1;
 654   5                                              if(GetBit(i, schedual1_state_index) == 0)
 655   5                                              {
 656   6                                                      SetBit(i & 0x07, &schedual1_state_index[i >> 3]);
 657   6                                                      ID_CHANGED = 0;
 658   6                                              }
 659   5                                      }
 660   4                                      else
 661   4                                      {
 662   5                                              wr1_value = 0;
 663   5                                              if(GetBit(i, schedual1_state_index) == 1)
 664   5                                              {
 665   6                                                      ClearBit(i & 0x07, &schedual1_state_index[i >> 3]);
 666   6                                                      ID_CHANGED = 0;
 667   6                                              }
 668   5                                      }
 669   4                                      wr1_valid = 1;
 670   4                              }
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 12  

 671   3                              else
 672   3                                      ClearBit(i & 0x07, &schedual1_state_index[i >> 3]);
 673   3      
 674   3                              if(ID_Config[i].Str.schedule2 > 0 && ID_Config[i].Str.schedule2 <= MAX_WR)
 675   3                              {
 676   4                                      if(GetBit(ID_Config[i].Str.schedule2 - 1, wr_state_index))
 677   4                                      { 
 678   5                                              wr2_value = 1;
 679   5                                              if(GetBit(i, schedual2_state_index) == 0)
 680   5                                              {
 681   6                                                      SetBit(i & 0x07, &schedual2_state_index[i >> 3]);
 682   6                                                      ID_CHANGED = 0;
 683   6                                              }
 684   5                                      }
 685   4                                      else
 686   4                                      {
 687   5                                              wr2_value = 0;
 688   5                                              if(GetBit(i, schedual2_state_index) == 1)
 689   5                                              {
 690   6                                                      ClearBit(i & 0x07, &schedual2_state_index[i >> 3]);
 691   6                                                      ID_CHANGED = 0;
 692   6                                              }
 693   5                                      }
 694   4                                      wr2_valid = 1;
 695   4                              }
 696   3                              else
 697   3                                      ClearBit(i & 0x07, &schedual2_state_index[i >> 3]);
 698   3      
 699   3                              if(!ID_A_M)  // AUTO
 700   3                              {
 701   4                                      if(wr1_valid || wr2_valid)
 702   4                                      {
 703   5      //                                      test0 = 5;
 704   5      //                                      SendSchedualData(i,wr1_value | wr2_value);  
 705   5                              #if 1
 706   5                                              output_value = GetBit(i, output_state_index); 
 707   5                                              temp_bit = GetBit(i, first_time_schedual);
 708   5                                              if(output_value != (wr1_value | wr2_value) || temp_bit == 0)
 709   5                                              { 
 710   6                                                      if(temp_bit == 0)
 711   6                                                              SetBit(i & 0x07, &first_time_schedual[i >> 3]);
 712   6                                                                                                       
 713   6                                                      SendSchedualData(i, wr1_value | wr2_value);  
 714   6                                              }
 715   5                                              else if(cycle_minutes_timeout == 1)
 716   5                                              {
 717   6                                                      SendSchedualData(i, wr1_value | wr2_value);
 718   6                                                        
 719   6                                                      if(i == MAX_ID - 1)
 720   6                                                              cycle_minutes_timeout = 0;
 721   6                                              }
 722   5                              #endif
 723   5                                      }
 724   4                              }
 725   3                              else // MAN
 726   3                              {
 727   4                                      if(ID_FLAG != 0xff)
 728   4                                      {
 729   5      //                                      SendSchedualData(i, ID_OUTPUT);  
 730   5      //                                      test0 = 7;
 731   5                                      #if 1
 732   5                                              temp_bit = GetBit(i, first_time_schedual);
C51 COMPILER V9.06   SCHEDULE                                                              03/13/2013 09:32:28 PAGE 13  

 733   5                                              if(ID_OUTPUT != GetBit(i,output_state_index) || temp_bit == 0)
 734   5                                              { 
 735   6      //                                              test0 = 8;
 736   6                                                      if(temp_bit == 0)
 737   6                                                              SetBit(i & 0x07, &first_time_schedual[i >> 3]);
 738   6                                                                                                       
 739   6                                                      SendSchedualData(i, ID_OUTPUT);
 740   6                                              }
 741   5                                              else if(cycle_minutes_timeout == 1)
 742   5                                              {
 743   6      //                                              test0 = 9;
 744   6                                                      SendSchedualData(i, ID_OUTPUT);
 745   6      
 746   6                                                      if(i == (MAX_ID - 1))
 747   6                                                              cycle_minutes_timeout = 0;
 748   6                                              }
 749   5                                      #endif
 750   5                                      }
 751   4                              }
 752   3                      } // check if the correspond ID has been used
 753   2              } // for 
 754   1      } // main function


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3789    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =      6    ----
   BIT SIZE         =      6       7
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   5869    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
