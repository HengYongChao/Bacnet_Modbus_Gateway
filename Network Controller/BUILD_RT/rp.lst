C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE RP
OBJECT MODULE PLACED IN .\rp.obj
COMPILER INVOKED BY: d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\bacnet\rp.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INC
                    -DIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\S
                    -RC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buff
                    -er\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Sr
                    -c\FreeRTOSSource\include\;..\Src\schedule\;..\src\bacnet;..\src\include;..\src\LCD;..\src\version) DEFINE(KEIL_AX11000) 
                    -VARBANKING DEBUG PRINT(.\rp.lst) OBJECT(.\rp.obj)

line level    source

   1          /*####COPYRIGHTBEGIN####
   2           -------------------------------------------
   3           Copyright (C) 2005 Steve Karg
   4          
   5           This program is free software; you can redistribute it and/or
   6           modify it under the terms of the GNU General Public License
   7           as published by the Free Software Foundation; either version 2
   8           of the License, or (at your option) any later version.
   9          
  10           This program is distributed in the hope that it will be useful,
  11           but WITHOUT ANY WARRANTY; without even the implied warranty of
  12           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  13           GNU General Public License for more details.
  14          
  15           You should have received a copy of the GNU General Public License
  16           along with this program; if not, write to:
  17           The Free Software Foundation, Inc.
  18           59 Temple Place - Suite 330
  19           Boston, MA  02111-1307, USA.
  20          
  21           As a special exception, if other files instantiate templates or
  22           use macros or inline functions from this file, or you compile
  23           this file and link it with other works to produce a work based
  24           on this file, this file does not by itself cause the resulting
  25           work to be covered by the GNU General Public License. However
  26           the source code for this file must still be made available in
  27           accordance with section (3) of the GNU General Public License.
  28          
  29           This exception does not invalidate any other reasons why a work
  30           based on this file might be covered by the GNU General Public
  31           License.
  32           -------------------------------------------
  33          ####COPYRIGHTEND####*/
  34          #include <stdint.h>
  35          #include "../include/bacenum.h"
  36          #include "../include/bacdcode.h"
  37          #include "../include/bacdef.h"
  38          #include "../include/rp.h"
  39          
  40          /** @file rp.c  Encode/Decode Read Property and RP ACKs */
  41          
  42          #if BACNET_SVC_RP_A
  43          /* encode service */
  44          int rp_encode_apdu(
  45              uint8_t * apdu,
  46              uint8_t invoke_id,
  47              BACNET_READ_PROPERTY_DATA * rpdata)
  48          {
  49   1          int len = 0;        /* length of each encoding */
  50   1          int apdu_len = 0;   /* total length of the apdu, return value */
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 2   

  51   1      
  52   1          if (apdu) {
  53   2              apdu[0] = PDU_TYPE_CONFIRMED_SERVICE_REQUEST;
  54   2              apdu[1] = encode_max_segs_max_apdu(0, MAX_APDU);
  55   2              apdu[2] = invoke_id;
  56   2              apdu[3] = SERVICE_CONFIRMED_READ_PROPERTY;      /* service choice */
  57   2              apdu_len = 4;
  58   2              len =
  59   2                  encode_context_object_id(&apdu[apdu_len], 0, rpdata->object_type,
  60   2                  rpdata->object_instance);
  61   2              apdu_len += len;
  62   2              len =
  63   2                  encode_context_enumerated(&apdu[apdu_len], 1,
  64   2                  rpdata->object_property);
  65   2              apdu_len += len;
  66   2              /* optional array index */
  67   2              if (rpdata->array_index != BACNET_ARRAY_ALL) {
  68   3                  len =
  69   3                      encode_context_unsigned(&apdu[apdu_len], 2,
  70   3                      rpdata->array_index);
  71   3                  apdu_len += len;
  72   3              }
  73   2          }
  74   1      
  75   1          return apdu_len;
  76   1      }
  77          #endif
  78          
  79          /* decode the service request only */
  80          int rp_decode_service_request(
  81              uint8_t * apdu,
  82              unsigned apdu_len,
  83              BACNET_READ_PROPERTY_DATA * rpdata)
  84          {
  85   1          unsigned len = 0;
  86   1          uint8_t tag_number = 0;
  87   1          uint32_t len_value_type = 0;
  88   1          uint16_t type = 0;  /* for decoding */
  89   1          uint32_t property = 0;      /* for decoding */
  90   1          uint32_t array_value = 0;   /* for decoding */
  91   1      
  92   1          /* check for value pointers */
  93   1          if (rpdata != NULL) {
  94   2              /* Must have at least 2 tags, an object id and a property identifier
  95   2               * of at least 1 byte in length to have any chance of parsing */
  96   2              if (apdu_len < 7) {
  97   3                  rpdata->error_code = ERROR_CODE_REJECT_MISSING_REQUIRED_PARAMETER;
  98   3                  return BACNET_STATUS_REJECT;
  99   3              }
 100   2      
 101   2              /* Tag 0: Object ID          */
 102   2              if (!decode_is_context_tag(&apdu[len++], 0)) {
 103   3                  rpdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 104   3                  return BACNET_STATUS_REJECT;
 105   3              }
 106   2              len += decode_object_id(&apdu[len], &type, &rpdata->object_instance);
 107   2              rpdata->object_type = (BACNET_OBJECT_TYPE) type;
 108   2              /* Tag 1: Property ID */
 109   2              len +=
 110   2                  decode_tag_number_and_value(&apdu[len], &tag_number,
 111   2                  &len_value_type);
 112   2              if (tag_number != 1) {
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 3   

 113   3                  rpdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 114   3                  return BACNET_STATUS_REJECT;
 115   3              }
 116   2              len += decode_enumerated(&apdu[len], len_value_type, &property);
 117   2              rpdata->object_property = (BACNET_PROPERTY_ID) property;
 118   2              /* Tag 2: Optional Array Index */
 119   2              if (len < apdu_len) {
 120   3                  len +=
 121   3                      decode_tag_number_and_value(&apdu[len], &tag_number,
 122   3                      &len_value_type);
 123   3                  if ((tag_number == 2) && (len < apdu_len)) {
 124   4                      len +=
 125   4                          decode_unsigned(&apdu[len], len_value_type, &array_value);
 126   4                      rpdata->array_index = array_value;
 127   4                  } else {
 128   4                      rpdata->error_code = ERROR_CODE_REJECT_INVALID_TAG;
 129   4                      return BACNET_STATUS_REJECT;
 130   4                  }
 131   3              } else
 132   2                  rpdata->array_index = BACNET_ARRAY_ALL;
 133   2          }
 134   1      
 135   1          if (len < apdu_len) {
 136   2              /* If something left over now, we have an invalid request */
 137   2              rpdata->error_code = ERROR_CODE_REJECT_TOO_MANY_ARGUMENTS;
 138   2              return BACNET_STATUS_REJECT;
 139   2          }
 140   1      
 141   1          return (int) len;
 142   1      }
 143          
 144          /* alternate method to encode the ack without extra buffer */
 145          int rp_ack_encode_apdu_init(
 146              uint8_t * apdu,
 147              uint8_t invoke_id,
 148              BACNET_READ_PROPERTY_DATA * rpdata)
 149          {
 150   1          int len = 0;        /* length of each encoding */
 151   1          int apdu_len = 0;   /* total length of the apdu, return value */
 152   1      
 153   1          if (apdu) {
 154   2              apdu[0] = PDU_TYPE_COMPLEX_ACK; /* complex ACK service */
 155   2              apdu[1] = invoke_id;    /* original invoke id from request */
 156   2              apdu[2] = SERVICE_CONFIRMED_READ_PROPERTY;      /* service choice */
 157   2              apdu_len = 3;
 158   2      
 159   2              /* service ack follows */
 160   2              len =
 161   2                  encode_context_object_id(&apdu[apdu_len], 0, rpdata->object_type,
 162   2                  rpdata->object_instance);
 163   2              apdu_len += len;
 164   2              len =
 165   2                  encode_context_enumerated(&apdu[apdu_len], 1,
 166   2                  rpdata->object_property);
 167   2              apdu_len += len;
 168   2              /* context 2 array index is optional */
 169   2              if (rpdata->array_index != BACNET_ARRAY_ALL) {
 170   3                  len =
 171   3                      encode_context_unsigned(&apdu[apdu_len], 2,
 172   3                      rpdata->array_index);
 173   3                  apdu_len += len;
 174   3              }
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 4   

 175   2              len = encode_opening_tag(&apdu[apdu_len], 3);
 176   2              apdu_len += len;
 177   2          }
 178   1      
 179   1          return apdu_len;
 180   1      }
 181          
 182          /* note: encode the application tagged data yourself */
 183          int rp_ack_encode_apdu_object_property_end(
 184              uint8_t * apdu)
 185          {
 186   1          int apdu_len = 0;   /* total length of the apdu, return value */
 187   1      
 188   1          if (apdu) {
 189   2              apdu_len = encode_closing_tag(&apdu[0], 3);
 190   2          }
 191   1      
 192   1          return apdu_len;
 193   1      }
 194          
 195          int rp_ack_encode_apdu(
 196              uint8_t * apdu,
 197              uint8_t invoke_id,
 198              BACNET_READ_PROPERTY_DATA * rpdata)
 199          {
 200   1          int len = 0;        /* length of each encoding */
 201   1          int apdu_len = 0;   /* total length of the apdu, return value */
 202   1      
 203   1          if (apdu) {
 204   2              /* Do the initial encoding */
 205   2              apdu_len = rp_ack_encode_apdu_init(apdu, invoke_id, rpdata);
 206   2              /* propertyValue */
 207   2              for (len = 0; len < rpdata->application_data_len; len++) {
 208   3                  apdu[apdu_len++] = rpdata->application_data[len];
 209   3              }
 210   2              apdu_len += encode_closing_tag(&apdu[apdu_len], 3);
 211   2          }
 212   1      
 213   1          return apdu_len;
 214   1      }
 215          
 216          
 217          #if BACNET_SVC_RP_A
 218          /** Decode the ReadProperty reply and store the result for one Property in a
 219           *  BACNET_READ_PROPERTY_DATA structure.
 220           *  This leaves the value(s) in the application_data buffer to be decoded later;
 221           *  the application_data field points into the apdu buffer (is not allocated).
 222           *
 223           * @param apdu [in] The apdu portion of the ACK reply.
 224           * @param apdu_len [in] The total length of the apdu.
 225           * @param rpdata [out] The structure holding the partially decoded result.
 226           * @return Number of decoded bytes (could be less than apdu_len),
 227           *                      or -1 on decoding error.
 228           */
 229          int rp_ack_decode_service_request(
 230              uint8_t * apdu,
 231              int apdu_len,       /* total length of the apdu */
 232              BACNET_READ_PROPERTY_DATA * rpdata)
 233          {
 234   1          uint8_t tag_number = 0;
 235   1          uint32_t len_value_type = 0;
 236   1          int tag_len = 0;    /* length of tag decode */
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 5   

 237   1          int len = 0;        /* total length of decodes */
 238   1          uint16_t object = 0;        /* object type */
 239   1          uint32_t property = 0;      /* for decoding */
 240   1          uint32_t array_value = 0;   /* for decoding */
 241   1      
 242   1          /* FIXME: check apdu_len against the len during decode   */
 243   1          /* Tag 0: Object ID */
 244   1          if (!decode_is_context_tag(&apdu[0], 0))
 245   1              return -1;
 246   1          len = 1;
 247   1          len += decode_object_id(&apdu[len], &object, &rpdata->object_instance);
 248   1          rpdata->object_type = (BACNET_OBJECT_TYPE) object;
 249   1          /* Tag 1: Property ID */
 250   1          len +=
 251   1              decode_tag_number_and_value(&apdu[len], &tag_number, &len_value_type);
 252   1          if (tag_number != 1)
 253   1              return -1;
 254   1          len += decode_enumerated(&apdu[len], len_value_type, &property);
 255   1          rpdata->object_property = (BACNET_PROPERTY_ID) property;
 256   1          /* Tag 2: Optional Array Index */
 257   1          tag_len =
 258   1              decode_tag_number_and_value(&apdu[len], &tag_number, &len_value_type);
 259   1          if (tag_number == 2) {
 260   2              len += tag_len;
 261   2              len += decode_unsigned(&apdu[len], len_value_type, &array_value);
 262   2              rpdata->array_index = array_value;
 263   2          } else
 264   1              rpdata->array_index = BACNET_ARRAY_ALL;
 265   1          /* Tag 3: opening context tag */
 266   1          if (decode_is_opening_tag_number(&apdu[len], 3)) {
 267   2              /* a tag number of 3 is not extended so only one octet */
 268   2              len++;
 269   2              /* don't decode the application tag number or its data here */
 270   2              rpdata->application_data = &apdu[len];
 271   2              rpdata->application_data_len = apdu_len - len - 1 /*closing tag */ ;
 272   2              /* len includes the data and the closing tag */
 273   2              len = apdu_len;
 274   2          } else {
 275   2              return -1;
 276   2          }
 277   1      
 278   1          return len;
 279   1      }
 280          #endif
 281          
 282          #ifdef TEST
              #include <assert.h>
              #include <string.h>
              #include "ctest.h"
              
              int rp_decode_apdu(
                  uint8_t * apdu,
                  unsigned apdu_len,
                  uint8_t * invoke_id,
                  BACNET_READ_PROPERTY_DATA * rpdata)
              {
                  int len = 0;
                  unsigned offset = 0;
              
                  if (!apdu)
                      return -1;
                  /* optional checking - most likely was already done prior to this call */
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 6   

                  if (apdu[0] != PDU_TYPE_CONFIRMED_SERVICE_REQUEST)
                      return -1;
                  /*  apdu[1] = encode_max_segs_max_apdu(0, MAX_APDU); */
                  *invoke_id = apdu[2];       /* invoke id - filled in by net layer */
                  if (apdu[3] != SERVICE_CONFIRMED_READ_PROPERTY)
                      return -1;
                  offset = 4;
              
                  if (apdu_len > offset) {
                      len =
                          rp_decode_service_request(&apdu[offset], apdu_len - offset,
                          rpdata);
                  }
              
                  return len;
              }
              
              int rp_ack_decode_apdu(
                  uint8_t * apdu,
                  int apdu_len,       /* total length of the apdu */
                  uint8_t * invoke_id,
                  BACNET_READ_PROPERTY_DATA * rpdata)
              {
                  int len = 0;
                  int offset = 0;
              
                  if (!apdu)
                      return -1;
                  /* optional checking - most likely was already done prior to this call */
                  if (apdu[0] != PDU_TYPE_COMPLEX_ACK)
                      return -1;
                  *invoke_id = apdu[1];
                  if (apdu[2] != SERVICE_CONFIRMED_READ_PROPERTY)
                      return -1;
                  offset = 3;
                  if (apdu_len > offset) {
                      len =
                          rp_ack_decode_service_request(&apdu[offset], apdu_len - offset,
                          rpdata);
                  }
              
                  return len;
              }
              
              void testReadPropertyAck(
                  Test * pTest)
              {
                  uint8_t apdu[480] = { 0 };
                  uint8_t apdu2[480] = { 0 };
                  int len = 0;
                  int apdu_len = 0;
                  uint8_t invoke_id = 1;
                  uint8_t test_invoke_id = 0;
                  BACNET_READ_PROPERTY_DATA rpdata;
                  BACNET_READ_PROPERTY_DATA test_data;
                  BACNET_OBJECT_TYPE object_type = OBJECT_DEVICE;
                  uint32_t object_instance = 0;
                  uint16_t object = 0;
              
                  rpdata.object_type = OBJECT_DEVICE;
                  rpdata.object_instance = 1;
                  rpdata.object_property = PROP_OBJECT_IDENTIFIER;
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 7   

                  rpdata.array_index = BACNET_ARRAY_ALL;
              
                  rpdata.application_data_len =
                      encode_bacnet_object_id(&apdu2[0], rpdata.object_type,
                      rpdata.object_instance);
                  rpdata.application_data = &apdu2[0];
              
                  len = rp_ack_encode_apdu(&apdu[0], invoke_id, &rpdata);
                  ct_test(pTest, len != 0);
                  ct_test(pTest, len != -1);
                  apdu_len = len;
                  len = rp_ack_decode_apdu(&apdu[0], apdu_len,        /* total length of the apdu */
                      &test_invoke_id, &test_data);
                  ct_test(pTest, len != -1);
                  ct_test(pTest, test_invoke_id == invoke_id);
              
                  ct_test(pTest, test_data.object_type == rpdata.object_type);
                  ct_test(pTest, test_data.object_instance == rpdata.object_instance);
                  ct_test(pTest, test_data.object_property == rpdata.object_property);
                  ct_test(pTest, test_data.array_index == rpdata.array_index);
                  ct_test(pTest,
                      test_data.application_data_len == rpdata.application_data_len);
              
                  /* since object property == object_id, decode the application data using
                     the appropriate decode function */
                  len =
                      decode_object_id(test_data.application_data, &object,
                      &object_instance);
                  object_type = object;
                  ct_test(pTest, object_type == rpdata.object_type);
                  ct_test(pTest, object_instance == rpdata.object_instance);
              }
              
              void testReadProperty(
                  Test * pTest)
              {
                  uint8_t apdu[480] = { 0 };
                  int len = 0;
                  int apdu_len = 0;
                  uint8_t invoke_id = 128;
                  uint8_t test_invoke_id = 0;
                  BACNET_READ_PROPERTY_DATA rpdata;
                  BACNET_READ_PROPERTY_DATA test_data;
              
                  rpdata.object_type = OBJECT_DEVICE;
                  rpdata.object_instance = 1;
                  rpdata.object_property = PROP_OBJECT_IDENTIFIER;
                  rpdata.array_index = BACNET_ARRAY_ALL;
                  len = rp_encode_apdu(&apdu[0], invoke_id, &rpdata);
                  ct_test(pTest, len != 0);
                  apdu_len = len;
              
                  len = rp_decode_apdu(&apdu[0], apdu_len, &test_invoke_id, &test_data);
                  ct_test(pTest, len != -1);
                  ct_test(pTest, test_data.object_type == rpdata.object_type);
                  ct_test(pTest, test_data.object_instance == rpdata.object_instance);
                  ct_test(pTest, test_data.object_property == rpdata.object_property);
                  ct_test(pTest, test_data.array_index == rpdata.array_index);
              
                  return;
              }
              
C51 COMPILER V9.06   RP                                                                    03/29/2013 16:57:08 PAGE 8   

              #ifdef TEST_READ_PROPERTY
              int main(
                  void)
              {
                  Test *pTest;
                  bool rc;
              
                  pTest = ct_create("BACnet ReadProperty", NULL);
                  /* individual tests */
                  rc = ct_addTestFunction(pTest, testReadProperty);
                  assert(rc);
                  rc = ct_addTestFunction(pTest, testReadPropertyAck);
                  assert(rc);
              
                  ct_setStream(pTest, stdout);
                  ct_run(pTest);
                  (void) ct_report(pTest);
                  ct_destroy(pTest);
              
                  return 0;
              }
              #endif /* TEST_READ_PROPERTY */
              #endif /* TEST */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2946    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      85
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
