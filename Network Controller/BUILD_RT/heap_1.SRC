; .\heap_1.SRC generated from: ..\src\FreeRtossource\portable\MemMang\heap_1.c
; COMPILER INVOKED BY:
;        d:\Keil_4_9.06\C51\BIN\C51.EXE ..\src\FreeRtossource\portable\MemMang\heap_1.c LARGE OMF2 ROM(D16M) BROWSE INTVECTOR(0X6020) INCDIR(..\SRC\cpu\;..\SRC\ethernet\;..\SRC\swdma\;..\SRC\mstimer\;..\SRC\uart\;..\SRC\main\;..\SRC\tcpip\;..\SRC\hsur\;..\SRC\debug\;..\SRC\dhcp\;..\SRC\dns\;..\SRC\adapter\;..\SRC\pppoe\;..\SRC\management;..\SRC\i2c\;..\SRC\flash\;..\SRC\buffer\;..\SRC\onewire\;..\SRC\http\;..\SRC\web\;..\SRC\AX110xx_SNTP_v100;..\Src\FreeRTOSSource\portable\Keil\AX11000\;..\Src\FreeRTOSSource\include\;..\Src\schedule\) DEFINE(KEIL_AX11000) VARBANKING DEBUG PRINT(.\heap_1.lst) SRC(.\heap_1.SRC)

$MOD_CONT
$NOMOD51

NAME	HEAP_1

TB08	BIT	098H.3
TB18	BIT	0C0H.3
P0	DATA	080H
SM00	BIT	098H.7
P1	DATA	090H
SM10	BIT	0C0H.7
SM01	BIT	098H.6
P2	DATA	0A0H
SM11	BIT	0C0H.6
SM02	BIT	098H.5
P3	DATA	0B0H
AC	BIT	0D0H.6
SM12	BIT	0C0H.5
T0	BIT	0B0H.4
SPIDR	DATA	0CFH
T1	BIT	0B0H.5
EA	BIT	0A8H.7
OWCIR	DATA	0D6H
CH	DATA	0C5H
DPH0	DATA	083H
IE	DATA	0A8H
DPH1	DATA	085H
CL	DATA	0C4H
P0_0	BIT	080H.0
P1_0	BIT	090H.0
P0_1	BIT	080H.1
CCAPH0	DATA	0B9H
DPL0	DATA	082H
P2_0	BIT	0A0H.0
P1_1	BIT	090H.1
P0_2	BIT	080H.2
CCAPH1	DATA	0BAH
DPL1	DATA	084H
P3_0	BIT	0B0H.0
P2_1	BIT	0A0H.1
P1_2	BIT	090H.2
P0_3	BIT	080H.3
UR2_DLH	DATA	0E2H
CCAPH2	DATA	0BBH
XMRHR	DATA	0A7H
P3_1	BIT	0B0H.1
P2_2	BIT	0A0H.2
P1_3	BIT	090H.3
P0_4	BIT	080H.4
CCAPH3	DATA	0BCH
P3_2	BIT	0B0H.2
P2_3	BIT	0A0H.3
P1_4	BIT	090H.4
P0_5	BIT	080H.5
TA	DATA	0EBH
CCAPH4	DATA	0BDH
CCAPL0	DATA	0B1H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P3_3	BIT	0B0H.3
P2_4	BIT	0A0H.4
REN0	BIT	098H.4
P1_5	BIT	090H.5
P0_6	BIT	080H.6
UR2_FCR	DATA	0E3H
CCAPM0	DATA	0D1H
T2IF	DATA	0C9H
CCAPL1	DATA	0B2H
REN1	BIT	0C0H.4
P3_4	BIT	0B0H.4
P2_5	BIT	0A0H.5
P1_6	BIT	090H.6
P0_7	BIT	080H.7
UR2_DLL	DATA	0E1H
CCAPM1	DATA	0D2H
CCAPL2	DATA	0B3H
XMRLR	DATA	0A6H
P3_5	BIT	0B0H.5
P2_6	BIT	0A0H.6
P1_7	BIT	090H.7
CCAPM2	DATA	0D3H
CCAPL3	DATA	0B4H
XMWHR	DATA	0A5H
P3_6	BIT	0B0H.6
P2_7	BIT	0A0H.7
CCAPM3	DATA	0D4H
IP	DATA	0B8H
CCAPL4	DATA	0B5H
P3_7	BIT	0B0H.7
CCAPM4	DATA	0D5H
DBAR	DATA	09AH
UR2_IER	DATA	0E2H
CY	BIT	0D0H.7
INT0	BIT	0B0H.2
UR2_LCR	DATA	0E4H
XMWLR	DATA	0A4H
INT1	BIT	0B0H.3
UR2_MCR	DATA	0E5H
DPX0	DATA	093H
I2CCIR	DATA	096H
DPX1	DATA	095H
UR2_IIR	DATA	0E3H
UR2_RBR	DATA	0E1H
ACON	DATA	09DH
DCIR	DATA	09BH
SP	DATA	081H
CCON	DATA	0C3H
CMOD	DATA	0C2H
OV	BIT	0D0H.2
WR	BIT	0B0H.6
UR2_THR	DATA	0E1H
EWDI	BIT	0E8H.5
WDIF	BIT	0D8H.3
RLDH	DATA	0CBH
EPCR	DATA	0BEH
LDHR	DATA	0AAH
UR2_LSR	DATA	0E6H
EPDR	DATA	0BFH
MCIR	DATA	0B6H
RCLK	BIT	0C8H.5
UR2_MSR	DATA	0E7H
TCLK	BIT	0C8H.4
RLDL	DATA	0CAH
LDLR	DATA	0A9H
PCON	DATA	087H
CANCIR	DATA	0DEH
TCIR	DATA	0AEH
PWDI	BIT	0F8H.5
LSCR	DATA	0A2H
TMOD	DATA	089H
TCON	DATA	088H
OWDR	DATA	0D7H
IE0	BIT	088H.1
IE1	BIT	088H.3
MXAX	DATA	0EAH
LMSR	DATA	0A1H
MD0	DATA	0F9H
B	DATA	0F0H
MD1	DATA	0FAH
LSAIER	DATA	0A1H
MD2	DATA	0FBH
WTRF	BIT	0D8H.2
MD3	DATA	0FCH
PISSR1	DATA	09EH
MD4	DATA	0FDH
LSSR	DATA	0A3H
PISSR2	DATA	09FH
MD5	DATA	0FEH
ACC	DATA	0E0H
ES0	BIT	0A8H.4
CT2	BIT	0C8H.1
ES1	BIT	0A8H.6
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
RI0	BIT	098H.0
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RI1	BIT	0C0H.0
SPICIR	DATA	0CEH
TH0	DATA	08CH
EX0	BIT	0A8H.0
TI0	BIT	098H.1
IT0	BIT	088H.0
TH1	DATA	08DH
TI1	BIT	0C0H.1
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
TL0	DATA	08AH
CSREPR	DATA	08FH
TL1	DATA	08BH
TL2	DATA	0CCH
PS0	BIT	0B8H.4
EIE	DATA	0E8H
WTST	DATA	092H
PS1	BIT	0B8H.6
PT0	BIT	0B8H.1
EIF	DATA	091H
RS0	BIT	0D0H.3
PT1	BIT	0B8H.3
I2CDR	DATA	097H
RS1	BIT	0D0H.4
PT2	BIT	0B8H.5
TR0	BIT	088H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DDR	DATA	09CH
DPH	DATA	083H
EIP	DATA	0F8H
DPL	DATA	082H
LCR	DATA	0A2H
SBUF0	DATA	099H
SBUF1	DATA	0C1H
EINT2	BIT	0E8H.0
EXEN2	BIT	0C8H.3
MDR	DATA	0B7H
EINT3	BIT	0E8H.1
CPRL2	BIT	0C8H.0
SCON0	DATA	098H
EINT4	BIT	0E8H.2
SCON1	DATA	0C0H
SDSTSR	DATA	094H
EINT5	BIT	0E8H.3
STATUS	DATA	0E9H
EINT6	BIT	0E8H.4
T2CON	DATA	0C8H
DPS	DATA	086H
CANDR	DATA	0DFH
TDR	DATA	0AFH
LDAHR	DATA	0A5H
DPX	DATA	093H
DMAHR	DATA	0ADH
PINT2	BIT	0F8H.0
RXD	BIT	0B0H.0
PINT3	BIT	0F8H.1
CKCON	DATA	08EH
PINT4	BIT	0F8H.2
EWT	BIT	0D8H.1
TXD	BIT	0B0H.1
LDALR	DATA	0A4H
PINT5	BIT	0F8H.3
DMALR	DATA	0ABH
LSR	DATA	0A3H
PINT6	BIT	0F8H.4
DMAMR	DATA	0ACH
ARCON	DATA	0FFH
F0	BIT	0D0H.5
F1	BIT	0D0H.1
LDCSR	DATA	0A6H
PSW	DATA	0D0H
RB08	BIT	098H.2
WDCON	DATA	0D8H
RWT	BIT	0D8H.0
RB18	BIT	0C0H.2
?PR?_?pvPortMalloc?HEAP_1                SEGMENT ECODE INSEG 
?PR?_?vPortFree?HEAP_1                   SEGMENT ECODE INSEG 
?PR?_?vPortInitialiseBlocks?HEAP_1       SEGMENT ECODE INSEG 
?C_INITSEG           SEGMENT CODE 
?XD?HEAP_1           SEGMENT XDATA 
	EXTRN	CODE (_?cTaskResumeAll)
	EXTRN	CODE (_?vTaskSuspendAll)
	EXTRN	CODE (?C?ADDXBP)
	EXTRN	DATA (?C_XBP)
	EXTRN	NUMBER (?C?XDATASEG)
	EXTRN	CODE (?C?XBPOFF)
	PUBLIC	_?vPortInitialiseBlocks
	PUBLIC	_?vPortFree
	PUBLIC	_?pvPortMalloc

	RSEG  ?XD?HEAP_1
 usNextFreeByte:   DS   2
          xHeap:   DS   15364

	RSEG  ?C_INITSEG
	DB	042H
	DW	usNextFreeByte
	DW	00000H

; /*
; 	FreeRTOS V2.6.0 - Copyright (C) 2003 - 2005 Richard Barry.
; 
; 	This file is part of the FreeRTOS distribution.
; 
; 	FreeRTOS is free software; you can redistribute it and/or modify
; 	it under the terms of the GNU General Public License as published by
; 	the Free Software Foundation; either version 2 of the License, or
; 	(at your option) any later version.
; 
; 	FreeRTOS is distributed in the hope that it will be useful,
; 	but WITHOUT ANY WARRANTY; without even the implied warranty of
; 	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; 	GNU General Public License for more details.
; 
; 	You should have received a copy of the GNU General Public License
; 	along with FreeRTOS; if not, write to the Free Software
; 	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
; 
; 	A special exception to the GPL can be applied should you wish to distribute
; 	a combined work that includes FreeRTOS, without being obliged to provide
; 	the source code for any proprietary components.  See the licensing section 
; 	of http://www.FreeRTOS.org for full details of how and when the exception
; 	can be applied.
; 
; 	***************************************************************************
; 	See http://www.FreeRTOS.org for documentation, latest information, license 
; 	and contact details.  Please ensure to read the configuration and relevant 
; 	port sections of the online documentation.
; 	***************************************************************************
; */
; 
; /* 
; 
; Changes between V2.5.1 and V2.5.1
; 
; 	+ The memory pool has been defined within a struct to ensure correct memory
; 	  alignment on 32bit systems.
; */
; 
; 
; /*
;  * The simplest possible implementation of pvPortMalloc().  Note that this
;  * implementation does NOT allow allocated memory to be freed again.
;  *
;  * See heap_2.c and heap_3.c for alternative implementations, and the memory
;  * management pages of http://www.FreeRTOS.org for more information.
;  */
; #include <stdlib.h>
; #include "projdefs.h"
; #include "portable.h"
; #include "task.h"
; 
; /* Setup the correct byte alignment mask for the defined byte alignment. */
; #if portBYTE_ALIGNMENT == 4
; 	#define heapBYTE_ALIGNMENT_MASK	( ( unsigned portSHORT ) 0x0003 )
; #endif
; 
; #if portBYTE_ALIGNMENT == 2
; 	#define heapBYTE_ALIGNMENT_MASK	( ( unsigned portSHORT ) 0x0001 )
; #endif
; 
; #if portBYTE_ALIGNMENT == 1 
; 	#define heapBYTE_ALIGNMENT_MASK	( ( unsigned portSHORT ) 0x0000 )
; #endif
; 
; #ifndef heapBYTE_ALIGNMENT_MASK
; 	#error "Invalid portBYTE_ALIGNMENT definition"
; #endif
; 
; /* Allocate the memory for the heap.  The struct is used to force byte
; alignment without using any non-portable code. */
; static struct xRTOS_HEAP
; {
; 	unsigned portLONG ulDummy;
; 	unsigned portCHAR ucHeap[ portTOTAL_HEAP_SIZE ];
; } xHeap;
; 
; static unsigned portSHORT usNextFreeByte = ( unsigned portSHORT ) 0;
; /*-----------------------------------------------------------*/
; 
; void *pvPortMalloc( unsigned portSHORT usWantedSize ) reentrant

	RSEG  ?PR?_?pvPortMalloc?HEAP_1
_?pvPortMalloc:
	USING	0
			; SOURCE LINE # 82
	MOV  	DPTR,#0FFFEH
	LCALL	?C?ADDXBP
	MOV  	A,R6
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
; {
; void *pvReturn = NULL;
			; SOURCE LINE # 84
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	CLR  	A
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 
; 	/* Ensure that blocks are always aligned to the required number of bytes. */
; 	if( usWantedSize & heapBYTE_ALIGNMENT_MASK )
			; SOURCE LINE # 87
; 	{
			; SOURCE LINE # 88
; 		/* Byte alignment required. */
; 		usWantedSize += ( portBYTE_ALIGNMENT - ( usWantedSize & heapBYTE_ALIGNMENT_MASK ) );
			; SOURCE LINE # 90
; 	}
			; SOURCE LINE # 91
?C0001:
; 
; 	vTaskSuspendAll();
			; SOURCE LINE # 93
	LCALL	_?vTaskSuspendAll
; 	{
			; SOURCE LINE # 94
; 		/* Check there is enough room left for the allocation. */
; 		if( ( usNextFreeByte + usWantedSize ) < portTOTAL_HEAP_SIZE )
			; SOURCE LINE # 96
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#usNextFreeByte
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	ADD  	A,R7
	MOV  	A,R4
	ADDC 	A,R6
	CLR  	C
	SUBB 	A,#03CH
	JNC  	?C0002
; 		{
			; SOURCE LINE # 97
; 			/* Return the next free byte then increment the index past this
; 			block. */
; 			pvReturn = &( xHeap.ucHeap[ usNextFreeByte ] );
			; SOURCE LINE # 100
	MOV  	A,#LOW (xHeap+04H)
	ADD  	A,R5
	MOV  	R1,A
	MOV  	A,#HIGH (xHeap+04H)
	ADDC 	A,R4
	MOV  	R2,A
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOV  	A,#MBYTE (xHeap)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; 			usNextFreeByte += usWantedSize;			
			; SOURCE LINE # 101
	MOV  	DPTR,#03H
	LCALL	?C?XBPOFF
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#usNextFreeByte+01H
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOVX 	@DPTR,A
	MOV  	DPTR,#usNextFreeByte
	MOVX 	A,@DPTR
	ADDC 	A,R6
	MOVX 	@DPTR,A
; 		}	
			; SOURCE LINE # 102
?C0002:
; 	}
			; SOURCE LINE # 103
; 	cTaskResumeAll();
			; SOURCE LINE # 104
	LCALL	_?cTaskResumeAll
; 
; 	return pvReturn;
			; SOURCE LINE # 106
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R3,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R1,A
; }
			; SOURCE LINE # 107
?C0003:
	MOV  	DPTR,#05H
	LJMP 	?C?ADDXBP
; END OF _?pvPortMalloc

; /*-----------------------------------------------------------*/
; 
; void vPortFree( void *pv ) reentrant

	RSEG  ?PR?_?vPortFree?HEAP_1
_?vPortFree:
	USING	0
			; SOURCE LINE # 110
	MOV  	DPTR,#0FFFDH
	LCALL	?C?ADDXBP
	MOV  	A,R3
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; {
; 	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
; 	for alternative implementations, and the memory management pages of 
; 	http://www.FreeRTOS.org for more information. */
; 	pv = pv;
			; SOURCE LINE # 115
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	MOVX 	A,@DPTR
	MOV  	R1,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R2,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPH,?C_XBP
	MOV  	DPL,?C_XBP+01H
	MOV  	DPX,#?C?XDATASEG
	XCH  	A,R1
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R2
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R1
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 116
	MOV  	DPTR,#03H
	LJMP 	?C?ADDXBP
; END OF _?vPortFree

; /*-----------------------------------------------------------*/
; 
; void vPortInitialiseBlocks( void ) reentrant

	RSEG  ?PR?_?vPortInitialiseBlocks?HEAP_1
_?vPortInitialiseBlocks:
	USING	0
			; SOURCE LINE # 119
; {
; 	/* Only required when static memory is not cleared. */
; 	usNextFreeByte = ( unsigned portSHORT ) 0;
			; SOURCE LINE # 122
	CLR  	A
	MOV  	DPTR,#usNextFreeByte
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 123
	RET  	
; END OF _?vPortInitialiseBlocks

	END
